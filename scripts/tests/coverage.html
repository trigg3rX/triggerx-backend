
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/trigg3rX/triggerx-backend/cli/actions/associate_operator.go (0.0%)</option>
				
				<option value="file1">github.com/trigg3rX/triggerx-backend/cli/actions/delegate_tokens.go (0.0%)</option>
				
				<option value="file2">github.com/trigg3rX/triggerx-backend/cli/actions/deposit_tokens.go (0.0%)</option>
				
				<option value="file3">github.com/trigg3rX/triggerx-backend/cli/actions/fund_imua_account.go (0.0%)</option>
				
				<option value="file4">github.com/trigg3rX/triggerx-backend/cli/actions/generate_keys.go (0.0%)</option>
				
				<option value="file5">github.com/trigg3rX/triggerx-backend/cli/actions/get_imeth_tokens.go (0.0%)</option>
				
				<option value="file6">github.com/trigg3rX/triggerx-backend/cli/actions/opt_in_to_avs.go (0.0%)</option>
				
				<option value="file7">github.com/trigg3rX/triggerx-backend/cli/actions/register_bls_key.go (0.0%)</option>
				
				<option value="file8">github.com/trigg3rX/triggerx-backend/cli/actions/register_imua_operator.go (0.0%)</option>
				
				<option value="file9">github.com/trigg3rX/triggerx-backend/cli/actions/setup_imua_keys.go (0.0%)</option>
				
				<option value="file10">github.com/trigg3rX/triggerx-backend/cli/core/chainio/avs_reader.go (0.0%)</option>
				
				<option value="file11">github.com/trigg3rX/triggerx-backend/cli/core/chainio/avs_subscriber.go (0.0%)</option>
				
				<option value="file12">github.com/trigg3rX/triggerx-backend/cli/core/chainio/avs_writer.go (0.0%)</option>
				
				<option value="file13">github.com/trigg3rX/triggerx-backend/cli/core/chainio/bindings.go (0.0%)</option>
				
				<option value="file14">github.com/trigg3rX/triggerx-backend/cli/core/chainio/builder.go (0.0%)</option>
				
				<option value="file15">github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth/client.go (0.0%)</option>
				
				<option value="file16">github.com/trigg3rX/triggerx-backend/cli/core/config/config.go (0.0%)</option>
				
				<option value="file17">github.com/trigg3rX/triggerx-backend/cli/core/keystore.go (0.0%)</option>
				
				<option value="file18">github.com/trigg3rX/triggerx-backend/cli/core/utils.go (0.0%)</option>
				
				<option value="file19">github.com/trigg3rX/triggerx-backend/cli/main.go (0.0%)</option>
				
				<option value="file20">github.com/trigg3rX/triggerx-backend/cmd/aggregator/main.go (0.0%)</option>
				
				<option value="file21">github.com/trigg3rX/triggerx-backend/cmd/health/main.go (0.0%)</option>
				
				<option value="file22">github.com/trigg3rX/triggerx-backend/cmd/imua-keeper/main.go (0.0%)</option>
				
				<option value="file23">github.com/trigg3rX/triggerx-backend/cmd/keeper/main.go (0.0%)</option>
				
				<option value="file24">github.com/trigg3rX/triggerx-backend/cmd/registrar/main.go (0.0%)</option>
				
				<option value="file25">github.com/trigg3rX/triggerx-backend/cmd/schedulers/condition/main.go (0.0%)</option>
				
				<option value="file26">github.com/trigg3rX/triggerx-backend/cmd/schedulers/time/main.go (0.0%)</option>
				
				<option value="file27">github.com/trigg3rX/triggerx-backend/cmd/taskdispatcher/main.go (0.0%)</option>
				
				<option value="file28">github.com/trigg3rX/triggerx-backend/cmd/taskmonitor/main.go (0.0%)</option>
				
				<option value="file29">github.com/trigg3rX/triggerx-backend/internal/aggregator/aggregator.go (0.0%)</option>
				
				<option value="file30">github.com/trigg3rX/triggerx-backend/internal/aggregator/api/middleware.go (0.0%)</option>
				
				<option value="file31">github.com/trigg3rX/triggerx-backend/internal/aggregator/api/server.go (0.0%)</option>
				
				<option value="file32">github.com/trigg3rX/triggerx-backend/internal/aggregator/config/config.go (0.0%)</option>
				
				<option value="file33">github.com/trigg3rX/triggerx-backend/internal/aggregator/rpc/server.go (0.0%)</option>
				
				<option value="file34">github.com/trigg3rX/triggerx-backend/internal/dbserver/config/config.go (0.0%)</option>
				
				<option value="file35">github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics/collector.go (0.0%)</option>
				
				<option value="file36">github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics/connection_metrics.go (0.0%)</option>
				
				<option value="file37">github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics/db_metrics.go (0.0%)</option>
				
				<option value="file38">github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics/prometheus.go (0.0%)</option>
				
				<option value="file39">github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics/system_metrics.go (0.0%)</option>
				
				<option value="file40">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/apikeyauth.go (0.0%)</option>
				
				<option value="file41">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/metrics.go (0.0%)</option>
				
				<option value="file42">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/ratelimiter.go (0.0%)</option>
				
				<option value="file43">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/recovery.go (0.0%)</option>
				
				<option value="file44">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/retry.go (0.0%)</option>
				
				<option value="file45">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/timeout.go (0.0%)</option>
				
				<option value="file46">github.com/trigg3rX/triggerx-backend/internal/dbserver/middleware/validator.go (0.0%)</option>
				
				<option value="file47">github.com/trigg3rX/triggerx-backend/internal/dbserver/redis/client.go (0.0%)</option>
				
				<option value="file48">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/apikey_repository.go (0.0%)</option>
				
				<option value="file49">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/condition_job_repository.go (0.0%)</option>
				
				<option value="file50">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/event_job_repository.go (0.0%)</option>
				
				<option value="file51">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/job_repository.go (0.0%)</option>
				
				<option value="file52">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/keeper_repository.go (0.0%)</option>
				
				<option value="file53">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/task_repository.go (0.0%)</option>
				
				<option value="file54">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/time_job_repository.go (0.0%)</option>
				
				<option value="file55">github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/user_repository.go (0.0%)</option>
				
				<option value="file56">github.com/trigg3rX/triggerx-backend/internal/dbserver/types/bigint_string.go (0.0%)</option>
				
				<option value="file57">github.com/trigg3rX/triggerx-backend/internal/dbserver/types/job_types.go (0.0%)</option>
				
				<option value="file58">github.com/trigg3rX/triggerx-backend/internal/health/client/database.go (0.0%)</option>
				
				<option value="file59">github.com/trigg3rX/triggerx-backend/internal/health/config/config.go (0.0%)</option>
				
				<option value="file60">github.com/trigg3rX/triggerx-backend/internal/health/keeper/cleanup.go (0.0%)</option>
				
				<option value="file61">github.com/trigg3rX/triggerx-backend/internal/health/keeper/persistence.go (0.0%)</option>
				
				<option value="file62">github.com/trigg3rX/triggerx-backend/internal/health/keeper/state_manager.go (0.0%)</option>
				
				<option value="file63">github.com/trigg3rX/triggerx-backend/internal/health/keeper/update.go (0.0%)</option>
				
				<option value="file64">github.com/trigg3rX/triggerx-backend/internal/health/metrics/collector.go (0.0%)</option>
				
				<option value="file65">github.com/trigg3rX/triggerx-backend/internal/health/metrics/prometheus.go (0.0%)</option>
				
				<option value="file66">github.com/trigg3rX/triggerx-backend/internal/health/telegram/bot.go (0.0%)</option>
				
				<option value="file67">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers/execute.go (0.0%)</option>
				
				<option value="file68">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers/handler.go (0.0%)</option>
				
				<option value="file69">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers/metrics.go (0.0%)</option>
				
				<option value="file70">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers/validate.go (0.0%)</option>
				
				<option value="file71">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/middleware.go (0.0%)</option>
				
				<option value="file72">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/server.go (0.0%)</option>
				
				<option value="file73">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio/avs_reader.go (0.0%)</option>
				
				<option value="file74">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio/avs_subscriber.go (0.0%)</option>
				
				<option value="file75">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio/avs_writer.go (0.0%)</option>
				
				<option value="file76">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio/bindings.go (0.0%)</option>
				
				<option value="file77">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/client/health/health.go (0.0%)</option>
				
				<option value="file78">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config/config.go (0.0%)</option>
				
				<option value="file79">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution/action.go (0.0%)</option>
				
				<option value="file80">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution/arguments.go (0.0%)</option>
				
				<option value="file81">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution/executor.go (0.0%)</option>
				
				<option value="file82">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution/nonce_manager.go (0.0%)</option>
				
				<option value="file83">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution/utils.go (0.0%)</option>
				
				<option value="file84">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/action.go (0.0%)</option>
				
				<option value="file85">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/proof.go (0.0%)</option>
				
				<option value="file86">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/signatures.go (0.0%)</option>
				
				<option value="file87">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/trigger.go (0.0%)</option>
				
				<option value="file88">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/utils.go (0.0%)</option>
				
				<option value="file89">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation/validator.go (0.0%)</option>
				
				<option value="file90">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/keeper.go (0.0%)</option>
				
				<option value="file91">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics/collector.go (0.0%)</option>
				
				<option value="file92">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics/prometheus.go (0.0%)</option>
				
				<option value="file93">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils.go (0.0%)</option>
				
				<option value="file94">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils/chainids.go (0.0%)</option>
				
				<option value="file95">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils/fetch.go (0.0%)</option>
				
				<option value="file96">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils/imua.go (0.0%)</option>
				
				<option value="file97">github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils/ipfs.go (0.0%)</option>
				
				<option value="file98">github.com/trigg3rX/triggerx-backend/internal/keeper/api/handlers/execute.go (0.0%)</option>
				
				<option value="file99">github.com/trigg3rX/triggerx-backend/internal/keeper/api/handlers/handler.go (0.0%)</option>
				
				<option value="file100">github.com/trigg3rX/triggerx-backend/internal/keeper/api/handlers/metrics.go (0.0%)</option>
				
				<option value="file101">github.com/trigg3rX/triggerx-backend/internal/keeper/api/handlers/validate.go (0.0%)</option>
				
				<option value="file102">github.com/trigg3rX/triggerx-backend/internal/keeper/api/middleware.go (0.0%)</option>
				
				<option value="file103">github.com/trigg3rX/triggerx-backend/internal/keeper/api/server.go (0.0%)</option>
				
				<option value="file104">github.com/trigg3rX/triggerx-backend/internal/keeper/client/ethClient/client.go (0.0%)</option>
				
				<option value="file105">github.com/trigg3rX/triggerx-backend/internal/keeper/client/health/health.go (13.8%)</option>
				
				<option value="file106">github.com/trigg3rX/triggerx-backend/internal/keeper/config/config.go (0.0%)</option>
				
				<option value="file107">github.com/trigg3rX/triggerx-backend/internal/keeper/config/registered.go (0.0%)</option>
				
				<option value="file108">github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution/action.go (0.0%)</option>
				
				<option value="file109">github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution/arguments.go (0.0%)</option>
				
				<option value="file110">github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution/executor.go (0.0%)</option>
				
				<option value="file111">github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution/nonce_manager.go (0.0%)</option>
				
				<option value="file112">github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution/utils.go (0.0%)</option>
				
				<option value="file113">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/action.go (0.0%)</option>
				
				<option value="file114">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/proof.go (0.0%)</option>
				
				<option value="file115">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/signatures.go (0.0%)</option>
				
				<option value="file116">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/trigger.go (0.0%)</option>
				
				<option value="file117">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/utils.go (0.0%)</option>
				
				<option value="file118">github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation/validator.go (0.0%)</option>
				
				<option value="file119">github.com/trigg3rX/triggerx-backend/internal/keeper/metrics/collector.go (0.0%)</option>
				
				<option value="file120">github.com/trigg3rX/triggerx-backend/internal/keeper/metrics/prometheus.go (0.0%)</option>
				
				<option value="file121">github.com/trigg3rX/triggerx-backend/internal/keeper/utils/chainids.go (100.0%)</option>
				
				<option value="file122">github.com/trigg3rX/triggerx-backend/internal/keeper/utils/fetch.go (80.0%)</option>
				
				<option value="file123">github.com/trigg3rX/triggerx-backend/internal/registrar/api/handlers/handler.go (0.0%)</option>
				
				<option value="file124">github.com/trigg3rX/triggerx-backend/internal/registrar/api/handlers/metrics.go (0.0%)</option>
				
				<option value="file125">github.com/trigg3rX/triggerx-backend/internal/registrar/api/handlers/status.go (0.0%)</option>
				
				<option value="file126">github.com/trigg3rX/triggerx-backend/internal/registrar/api/middleware.go (0.0%)</option>
				
				<option value="file127">github.com/trigg3rX/triggerx-backend/internal/registrar/api/server.go (0.0%)</option>
				
				<option value="file128">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/database.go (0.0%)</option>
				
				<option value="file129">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/registration.go (0.0%)</option>
				
				<option value="file130">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/rewards.go (0.0%)</option>
				
				<option value="file131">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/task.go (0.0%)</option>
				
				<option value="file132">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/taskmanager/client.go (0.0%)</option>
				
				<option value="file133">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket/client.go (0.0%)</option>
				
				<option value="file134">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket/reconnect.go (0.0%)</option>
				
				<option value="file135">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket/subscription.go (0.0%)</option>
				
				<option value="file136">github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket/utils.go (0.0%)</option>
				
				<option value="file137">github.com/trigg3rX/triggerx-backend/internal/registrar/config/config.go (0.0%)</option>
				
				<option value="file138">github.com/trigg3rX/triggerx-backend/internal/registrar/events/listener.go (0.0%)</option>
				
				<option value="file139">github.com/trigg3rX/triggerx-backend/internal/registrar/events/operator.go (0.0%)</option>
				
				<option value="file140">github.com/trigg3rX/triggerx-backend/internal/registrar/events/task.go (0.0%)</option>
				
				<option value="file141">github.com/trigg3rX/triggerx-backend/internal/registrar/metrics/collector.go (0.0%)</option>
				
				<option value="file142">github.com/trigg3rX/triggerx-backend/internal/registrar/metrics/prometheus.go (0.0%)</option>
				
				<option value="file143">github.com/trigg3rX/triggerx-backend/internal/registrar/registrar.go (0.0%)</option>
				
				<option value="file144">github.com/trigg3rX/triggerx-backend/internal/registrar/rewards/rewards.go (0.0%)</option>
				
				<option value="file145">github.com/trigg3rX/triggerx-backend/internal/registrar/sync/state.go (0.0%)</option>
				
				<option value="file146">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/handlers/metrics.go (0.0%)</option>
				
				<option value="file147">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/handlers/scheduler.go (0.0%)</option>
				
				<option value="file148">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/handlers/status.go (0.0%)</option>
				
				<option value="file149">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/middleware.go (0.0%)</option>
				
				<option value="file150">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/server.go (0.0%)</option>
				
				<option value="file151">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/config/config.go (0.0%)</option>
				
				<option value="file152">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics/collect_metrics.go (0.0%)</option>
				
				<option value="file153">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics/collector.go (0.0%)</option>
				
				<option value="file154">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics/prometheus.go (0.0%)</option>
				
				<option value="file155">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/init.go (0.0%)</option>
				
				<option value="file156">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/notification.go (0.0%)</option>
				
				<option value="file157">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/schedule.go (0.0%)</option>
				
				<option value="file158">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/stats.go (0.0%)</option>
				
				<option value="file159">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/utils.go (0.0%)</option>
				
				<option value="file160">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker/init_condition.go (0.0%)</option>
				
				<option value="file161">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker/init_event.go (0.0%)</option>
				
				<option value="file162">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker/monitor_condition.go (0.0%)</option>
				
				<option value="file163">github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker/monitor_event.go (0.0%)</option>
				
				<option value="file164">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/handlers/metrics.go (0.0%)</option>
				
				<option value="file165">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/handlers/scheduler.go (0.0%)</option>
				
				<option value="file166">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/handlers/status.go (0.0%)</option>
				
				<option value="file167">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/middleware.go (0.0%)</option>
				
				<option value="file168">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/server.go (0.0%)</option>
				
				<option value="file169">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/config/config.go (0.0%)</option>
				
				<option value="file170">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics/collect_metrics.go (0.0%)</option>
				
				<option value="file171">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics/collector.go (0.0%)</option>
				
				<option value="file172">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics/prometheus.go (0.0%)</option>
				
				<option value="file173">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler/init.go (0.0%)</option>
				
				<option value="file174">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler/schedule.go (0.0%)</option>
				
				<option value="file175">github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler/stats.go (0.0%)</option>
				
				<option value="file176">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/config/config.go (0.0%)</option>
				
				<option value="file177">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/health_client.go (0.0%)</option>
				
				<option value="file178">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics/collector.go (0.0%)</option>
				
				<option value="file179">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics/prometheus.go (0.0%)</option>
				
				<option value="file180">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/rpc/client.go (0.0%)</option>
				
				<option value="file181">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/rpc/handler.go (47.8%)</option>
				
				<option value="file182">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/rpc/server.go (0.0%)</option>
				
				<option value="file183">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/taskdispatcher.go (0.0%)</option>
				
				<option value="file184">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/tasks/manager.go (0.0%)</option>
				
				<option value="file185">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/tasks/task_add.go (0.0%)</option>
				
				<option value="file186">github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/tasks/task_read.go (0.0%)</option>
				
				<option value="file187">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database/database.go (0.0%)</option>
				
				<option value="file188">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database/task.go (0.0%)</option>
				
				<option value="file189">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket/client.go (0.0%)</option>
				
				<option value="file190">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket/reconnect.go (0.0%)</option>
				
				<option value="file191">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket/subscription.go (0.0%)</option>
				
				<option value="file192">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket/utils.go (0.0%)</option>
				
				<option value="file193">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config/config.go (0.0%)</option>
				
				<option value="file194">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/events/listener.go (0.0%)</option>
				
				<option value="file195">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/events/task.go (0.0%)</option>
				
				<option value="file196">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics/collector.go (0.0%)</option>
				
				<option value="file197">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics/prometheus.go (0.0%)</option>
				
				<option value="file198">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/taskmonitor.go (8.0%)</option>
				
				<option value="file199">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks/manager.go (0.0%)</option>
				
				<option value="file200">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks/task_add.go (0.0%)</option>
				
				<option value="file201">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks/task_read.go (0.0%)</option>
				
				<option value="file202">github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks/workers.go (0.0%)</option>
				
				<option value="file203">github.com/trigg3rX/triggerx-backend/pkg/client/aggregator/aggregator.go (91.7%)</option>
				
				<option value="file204">github.com/trigg3rX/triggerx-backend/pkg/client/aggregator/custom.go (100.0%)</option>
				
				<option value="file205">github.com/trigg3rX/triggerx-backend/pkg/client/aggregator/mocks.go (67.4%)</option>
				
				<option value="file206">github.com/trigg3rX/triggerx-backend/pkg/client/aggregator/task.go (76.7%)</option>
				
				<option value="file207">github.com/trigg3rX/triggerx-backend/pkg/client/dbserver/condition.go (0.0%)</option>
				
				<option value="file208">github.com/trigg3rX/triggerx-backend/pkg/client/dbserver/dbserver.go (0.0%)</option>
				
				<option value="file209">github.com/trigg3rX/triggerx-backend/pkg/client/dbserver/redis.go (0.0%)</option>
				
				<option value="file210">github.com/trigg3rX/triggerx-backend/pkg/client/dbserver/time.go (0.0%)</option>
				
				<option value="file211">github.com/trigg3rX/triggerx-backend/pkg/client/redis/client.go (86.4%)</option>
				
				<option value="file212">github.com/trigg3rX/triggerx-backend/pkg/client/redis/health.go (0.0%)</option>
				
				<option value="file213">github.com/trigg3rX/triggerx-backend/pkg/client/redis/lock.go (82.4%)</option>
				
				<option value="file214">github.com/trigg3rX/triggerx-backend/pkg/client/redis/monitoring.go (83.7%)</option>
				
				<option value="file215">github.com/trigg3rX/triggerx-backend/pkg/client/redis/recovery.go (4.6%)</option>
				
				<option value="file216">github.com/trigg3rX/triggerx-backend/pkg/client/redis/retry.go (89.4%)</option>
				
				<option value="file217">github.com/trigg3rX/triggerx-backend/pkg/client/redis/scan.go (89.7%)</option>
				
				<option value="file218">github.com/trigg3rX/triggerx-backend/pkg/client/redis/sorted_set_methods.go (0.0%)</option>
				
				<option value="file219">github.com/trigg3rX/triggerx-backend/pkg/client/redis/stream.go (76.9%)</option>
				
				<option value="file220">github.com/trigg3rX/triggerx-backend/pkg/client/redis/stream_methods.go (88.4%)</option>
				
				<option value="file221">github.com/trigg3rX/triggerx-backend/pkg/client/redis/ttl.go (88.9%)</option>
				
				<option value="file222">github.com/trigg3rX/triggerx-backend/pkg/client/redis/types.go (100.0%)</option>
				
				<option value="file223">github.com/trigg3rX/triggerx-backend/pkg/cryptography/ecdsa.go (89.5%)</option>
				
				<option value="file224">github.com/trigg3rX/triggerx-backend/pkg/cryptography/encrypt.go (96.4%)</option>
				
				<option value="file225">github.com/trigg3rX/triggerx-backend/pkg/database/config.go (0.0%)</option>
				
				<option value="file226">github.com/trigg3rX/triggerx-backend/pkg/database/connection.go (0.0%)</option>
				
				<option value="file227">github.com/trigg3rX/triggerx-backend/pkg/database/database_mocks.go (60.9%)</option>
				
				<option value="file228">github.com/trigg3rX/triggerx-backend/pkg/database/retry.go (4.0%)</option>
				
				<option value="file229">github.com/trigg3rX/triggerx-backend/pkg/database/retry_codes.go (45.0%)</option>
				
				<option value="file230">github.com/trigg3rX/triggerx-backend/pkg/docker/config/defaults.go (100.0%)</option>
				
				<option value="file231">github.com/trigg3rX/triggerx-backend/pkg/docker/container/lifecycle.go (0.0%)</option>
				
				<option value="file232">github.com/trigg3rX/triggerx-backend/pkg/docker/container/manager.go (0.0%)</option>
				
				<option value="file233">github.com/trigg3rX/triggerx-backend/pkg/docker/container/pool.go (0.0%)</option>
				
				<option value="file234">github.com/trigg3rX/triggerx-backend/pkg/docker/docker.go (0.0%)</option>
				
				<option value="file235">github.com/trigg3rX/triggerx-backend/pkg/docker/execution/executor.go (0.0%)</option>
				
				<option value="file236">github.com/trigg3rX/triggerx-backend/pkg/docker/execution/monitor.go (0.0%)</option>
				
				<option value="file237">github.com/trigg3rX/triggerx-backend/pkg/docker/execution/pipeline.go (0.0%)</option>
				
				<option value="file238">github.com/trigg3rX/triggerx-backend/pkg/docker/file/cache.go (0.0%)</option>
				
				<option value="file239">github.com/trigg3rX/triggerx-backend/pkg/docker/file/downloader.go (0.0%)</option>
				
				<option value="file240">github.com/trigg3rX/triggerx-backend/pkg/docker/file/manager.go (0.0%)</option>
				
				<option value="file241">github.com/trigg3rX/triggerx-backend/pkg/docker/file/validator.go (0.0%)</option>
				
				<option value="file242">github.com/trigg3rX/triggerx-backend/pkg/docker/scripts/scripts.go (0.0%)</option>
				
				<option value="file243">github.com/trigg3rX/triggerx-backend/pkg/docker/types/container.go (100.0%)</option>
				
				<option value="file244">github.com/trigg3rX/triggerx-backend/pkg/env/env.go (100.0%)</option>
				
				<option value="file245">github.com/trigg3rX/triggerx-backend/pkg/env/validator.go (100.0%)</option>
				
				<option value="file246">github.com/trigg3rX/triggerx-backend/pkg/http/http.go (90.4%)</option>
				
				<option value="file247">github.com/trigg3rX/triggerx-backend/pkg/http/mocks.go (81.4%)</option>
				
				<option value="file248">github.com/trigg3rX/triggerx-backend/pkg/ipfs/client.go (87.5%)</option>
				
				<option value="file249">github.com/trigg3rX/triggerx-backend/pkg/ipfs/config.go (100.0%)</option>
				
				<option value="file250">github.com/trigg3rX/triggerx-backend/pkg/logging/config.go (92.3%)</option>
				
				<option value="file251">github.com/trigg3rX/triggerx-backend/pkg/logging/mocks.go (96.2%)</option>
				
				<option value="file252">github.com/trigg3rX/triggerx-backend/pkg/logging/rotator.go (90.0%)</option>
				
				<option value="file253">github.com/trigg3rX/triggerx-backend/pkg/logging/zap_logger.go (95.5%)</option>
				
				<option value="file254">github.com/trigg3rX/triggerx-backend/pkg/parser/time.go (100.0%)</option>
				
				<option value="file255">github.com/trigg3rX/triggerx-backend/pkg/proof/proof.go (94.4%)</option>
				
				<option value="file256">github.com/trigg3rX/triggerx-backend/pkg/retry/retry.go (96.2%)</option>
				
				<option value="file257">github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/config/auth.go (0.0%)</option>
				
				<option value="file258">github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/jwt/claims.go (0.0%)</option>
				
				<option value="file259">github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/jwt/interceptor.go (0.0%)</option>
				
				<option value="file260">github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/jwt/validator.go (0.0%)</option>
				
				<option value="file261">github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/middleware/auth.go (0.0%)</option>
				
				<option value="file262">github.com/trigg3rX/triggerx-backend/pkg/rpc/client/client.go (0.0%)</option>
				
				<option value="file263">github.com/trigg3rX/triggerx-backend/pkg/rpc/client/pool.go (0.0%)</option>
				
				<option value="file264">github.com/trigg3rX/triggerx-backend/pkg/rpc/client/retry.go (0.0%)</option>
				
				<option value="file265">github.com/trigg3rX/triggerx-backend/pkg/rpc/discovery/redis_registry.go (0.0%)</option>
				
				<option value="file266">github.com/trigg3rX/triggerx-backend/pkg/rpc/metrics/metrics.go (0.0%)</option>
				
				<option value="file267">github.com/trigg3rX/triggerx-backend/pkg/rpc/proto/service.pb.go (0.0%)</option>
				
				<option value="file268">github.com/trigg3rX/triggerx-backend/pkg/rpc/proto/service_grpc.pb.go (0.0%)</option>
				
				<option value="file269">github.com/trigg3rX/triggerx-backend/pkg/rpc/server/generic_service.go (0.0%)</option>
				
				<option value="file270">github.com/trigg3rX/triggerx-backend/pkg/rpc/server/health.go (0.0%)</option>
				
				<option value="file271">github.com/trigg3rX/triggerx-backend/pkg/rpc/server/middleware.go (0.0%)</option>
				
				<option value="file272">github.com/trigg3rX/triggerx-backend/pkg/rpc/server/server.go (0.0%)</option>
				
				<option value="file273">github.com/trigg3rX/triggerx-backend/pkg/rpc/tracing/interceptor.go (0.0%)</option>
				
				<option value="file274">github.com/trigg3rX/triggerx-backend/pkg/rpc/tracing/propagation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
<span>Total Test Coverage: 8.4% | Generated on Mon Aug 11 05:16:26 PM IST 2025</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "log"
        "math/big"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

type AssociationResponse struct {
        Operator string `json:"operator"`
}

func AssociateOperator(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("🚀 Starting operator association process (Post-Bootstrap Phase)")
        log.Println("⏳ This may take a few moments...")

        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration initialization failed: %v", err)
        }</span>

        // Validate environment variables
        <span class="cov0" title="0">ethPrivateKey := os.Getenv("OPERATOR_PRIVATE_KEY")
        if ethPrivateKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OPERATOR_PRIVATE_KEY must be set in .env file")
        }</span>

        <span class="cov0" title="0">imuaPrivateKey := os.Getenv("IMUA_PRIVATE_KEY")
        if imuaPrivateKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_PRIVATE_KEY must be set in .env file\n" +
                        "Get it by running: 'imuad keys unsafe-export-eth-key YOUR_ACCOUNT_NAME'")
        }</span>

        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                imuaHomeDir = filepath.Join(os.Getenv("HOME"), ".imuad")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME must be set in .env file")
        }</span>

        // Set default URLs if not provided
        <span class="cov0" title="0">imuaEthRPCURL := os.Getenv("IMUA_ETH_RPC_URL")
        if imuaEthRPCURL == "" </span><span class="cov0" title="0">{
                imuaEthRPCURL = "https://api-eth.exocore-restaking.com"
        }</span>

        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                imuaCosGrpcURL = "https://api-cosmos-grpc.exocore-restaking.com:443"
        }</span>

        // Constants
        <span class="cov0" title="0">const (
                ethLZID         = 40161 // Sepolia LayerZero ID
                imuaGatewayAddr = "0xdDf5218Dbff297ADdF17fB7977E2469D774545ED"
        )

        // Get Ethereum address from private key
        ethAddress := config.GetOperatorAddress().Hex()
        log.Printf("🔑 Ethereum Address: %s", ethAddress)

        // 1. Check balance
        log.Println("\n🔍 Step 1: Checking Ethereum address balance...")
        balance, err := getBalance(ethAddress, imuaEthRPCURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check balance: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("💰 Current Balance: %s hua", balance.String())

        // Calculate required transfer amount (0.5 IMUA in wei)
        transferAmount := new(big.Int).Mul(big.NewInt(5), big.NewInt(1e17)) // 0.5 * 10^18

        // 2. Transfer funds if needed
        if balance.Cmp(transferAmount) &lt; 0 </span><span class="cov0" title="0">{
                log.Printf("\n🔄 Step 2: Transferring 0.5 IMUA to %s...", ethAddress)

                if err := transferFunds(imuaEthRPCURL, ethAddress, transferAmount.String(), imuaPrivateKey); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("funds transfer failed: %v", err)
                }</span>

                // Wait for transfer to complete
                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        } else<span class="cov0" title="0"> {
                log.Println("✅ Sufficient balance detected")
        }</span>

        // 3. Get Imua operator address
        <span class="cov0" title="0">log.Println("\n📝 Step 3: Retrieving Imua operator address...")
        imOperatorAddr, err := getImuaOperatorAddress(imuaHomeDir, imuaAccountKeyName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get operator address: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("🏷️ Operator Address: %s", imOperatorAddr)

        // 4. Check existing association
        log.Println("\n🔎 Step 4: Checking for existing association...")
        stakerID := fmt.Sprintf("%s_0x%x", strings.ToLower(ethAddress), ethLZID)

        if existingOp, err := checkExistingAssociation(stakerID, imuaCosGrpcURL); err == nil &amp;&amp; existingOp != "" </span><span class="cov0" title="0">{
                if existingOp == imOperatorAddr </span><span class="cov0" title="0">{
                        log.Println("✅ Association already exists!")
                        printSuccess(ethAddress, imOperatorAddr, stakerID)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("existing association with different operator: %s", existingOp)</span>
        }

        // 5. Create association
        <span class="cov0" title="0">log.Println("\n⚡ Step 5: Creating operator association...")
        if err := createAssociation(imuaEthRPCURL, imuaGatewayAddr, ethLZID, imOperatorAddr, ethPrivateKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("association failed: %v", err)
        }</span>

        // 6. Verify association
        <span class="cov0" title="0">log.Println("\n🔍 Step 6: Verifying association...")
        time.Sleep(3 * time.Second) // Wait for state update

        if verifiedOp, err := checkExistingAssociation(stakerID, imuaCosGrpcURL); err != nil </span><span class="cov0" title="0">{
                log.Printf("⚠️ Verification failed (check later with): imuad query delegation associated-operator-by-staker %s --node %s",
                        stakerID, imuaCosGrpcURL)
        }</span> else<span class="cov0" title="0"> if verifiedOp == imOperatorAddr </span><span class="cov0" title="0">{
                log.Println("✅ Association verified!")
                printSuccess(ethAddress, imOperatorAddr, stakerID)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("verification failed - expected %s got %s", imOperatorAddr, verifiedOp)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions

func getBalance(address, rpcURL string) (*big.Int, error) <span class="cov0" title="0">{
        cmd := exec.Command("cast", "balance", address, "--rpc-url", rpcURL)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("balance check failed: %v", err)
        }</span>
        <span class="cov0" title="0">balanceStr := strings.TrimSpace(string(output))
        balance, ok := new(big.Int).SetString(balanceStr, 10)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse balance: %s", balanceStr)
        }</span>
        <span class="cov0" title="0">return balance, nil</span>
}

func transferFunds(rpcURL, toAddress, amount, privateKey string) error <span class="cov0" title="0">{
        cmd := exec.Command("cast", "send",
                "--rpc-url", rpcURL,
                toAddress,
                "--value", amount,
                "--private-key", privateKey,
        )
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transfer failed: %v\nOutput: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">log.Printf("💸 Transfer successful: %s", string(output))
        return nil</span>
}

func getImuaOperatorAddress(homeDir, accountName string) (string, error) <span class="cov0" title="0">{
        keyringPassword := os.Getenv("KEYRING_PASSWORD")
        if keyringPassword == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("KEYRING_PASSWORD environment variable not set")
        }</span>
        <span class="cov0" title="0">getAddrCmd := exec.Command("imuad",
                "--home", homeDir,
                "keys", "show", "-a", accountName,
        )

        // Provide password for address query
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get validator address: %v", err)
        }</span>

        <span class="cov0" title="0">validatorAddr := strings.TrimSpace(string(addrOutput))
        return validatorAddr, nil</span>
}

func checkExistingAssociation(stakerID, grpcURL string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("imuad", "query", "delegation", "associated-operator-by-staker",
                stakerID,
                "--node", grpcURL,
                "--output", "json",
        )
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("query failed: %v", err)
        }</span>

        <span class="cov0" title="0">var resp AssociationResponse
        if err := json.Unmarshal(output, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %v", err)
        }</span>
        <span class="cov0" title="0">return resp.Operator, nil</span>
}

func createAssociation(rpcURL, gatewayAddr string, lzID uint32, operatorAddr, privateKey string) error <span class="cov0" title="0">{
        cmd := exec.Command("cast", "send",
                "--rpc-url", rpcURL,
                gatewayAddr,
                "associateOperatorWithEVMStaker(uint32,string)",
                fmt.Sprintf("%d", lzID),
                operatorAddr,
                "--private-key", privateKey,
        )
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction failed: %v\nOutput: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">log.Printf("📝 Transaction successful: %s", string(output))
        return nil</span>
}

func printSuccess(ethAddr, imuaAddr, stakerID string) <span class="cov0" title="0">{
        log.Println("\n🎉 Successfully Associated Operator!")
        log.Printf("├─ Ethereum Address: %s", ethAddr)
        log.Printf("├─ Imua Operator:    %s", imuaAddr)
        log.Printf("└─ Staker ID:        %s", stakerID)

        log.Println("\n💡 Next Steps:")
        log.Println("- Ensure you have at least 1,000 USD in self-delegation")
        log.Println("- Validator will be eligible at next epoch (within 1 hour)")
        log.Println("- Top 50 validators by stake will be active")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strconv"
        "strings"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func DelegateTokens(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("🤝 Starting token delegation process...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">ethPrivateKey := os.Getenv("OPERATOR_PRIVATE_KEY")
        if ethPrivateKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OPERATOR_PRIVATE_KEY environment variable not set")
        }</span>

        // Add 0x prefix if not present
        <span class="cov0" title="0">if !strings.HasPrefix(ethPrivateKey, "0x") </span><span class="cov0" title="0">{
                ethPrivateKey = "0x" + ethPrivateKey
        }</span>

        <span class="cov0" title="0">ethAddress := config.GetOperatorAddress().Hex()
        log.Printf("Using Ethereum address: %s", ethAddress)

        // Configuration with official contract addresses
        const (
                // Official contract addresses on Ethereum Sepolia
                IM_ETH_ADDR      = "0xF79F563571f7D8122611D0219A0d5449B5304F79"
                WST_ETH_ADDR     = "0xB82381A3fBD3FaFA77B3a7bE693342618240067b"
                GATEWAY_ADDR     = "0x64B5B5A618072C1E4D137f91Af780e3B17A81f3f"
                ETHEREUM_RPC_URL = "https://eth-sepolia.g.alchemy.com/v2/U67yWPtGvZIz8FwnTcFEfERypsxYzfdR"
        )

        // User configuration
        tokenAddr := IM_ETH_ADDR // Default to exoETH
        if tokenOverride := os.Getenv("TOKEN_ADDRESS"); tokenOverride != "" </span><span class="cov0" title="0">{
                tokenAddr = tokenOverride
        }</span>

        // Get delegation amount from environment or use default
        <span class="cov0" title="0">delegateAmountStr := os.Getenv("DELEGATE_AMOUNT")
        if delegateAmountStr == "" </span><span class="cov0" title="0">{
                delegateAmountStr = os.Getenv("DEPOSIT_AMOUNT") // Use deposit amount if delegate amount not specified
                if delegateAmountStr == "" </span><span class="cov0" title="0">{
                        delegateAmountStr = "25" // Default 25 tokens as per documentation
                }</span>
        }

        <span class="cov0" title="0">delegateAmount, err := strconv.ParseFloat(delegateAmountStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DELEGATE_AMOUNT: %v", err)
        }</span>

        // Imua configuration
        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                imuaCosGrpcURL = "https://api-cosmos-grpc.exocore-restaking.com:443" // Default fallback
        }</span>

        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")

        if imuaHomeDir == "" || imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR and IMUA_ACCOUNT_KEY_NAME environment variables must be set")
        }</span>

        // Get keyring password from environment
        <span class="cov0" title="0">keyringPassword := os.Getenv("KEYRING_PASSWORD")
        if keyringPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("KEYRING_PASSWORD environment variable not set")
        }</span>

        <span class="cov0" title="0">log.Printf("📋 Delegation Configuration:")
        log.Printf("- Token Address: %s", tokenAddr)
        log.Printf("- Delegation Amount: %.2f", delegateAmount)
        log.Printf("- Ethereum RPC: %s", ETHEREUM_RPC_URL)
        log.Printf("- Gateway Address: %s", GATEWAY_ADDR)

        // Step 1: Get Imua operator address for delegation
        log.Println("\n🏠 Step 1: Getting Imua operator address...")
        getAddrCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "keys", "show", "-a", imuaAccountKeyName,
        )

        // Provide password for address query
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get Imua operator address: %v", err)
        }</span>

        <span class="cov0" title="0">imAddress := strings.TrimSpace(string(addrOutput))
        if imAddress == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("empty Imua operator address returned")
        }</span>
        <span class="cov0" title="0">log.Printf("Delegating to Imua address: %s", imAddress)

        // Step 2: Check if gateway is bootstrapped
        log.Println("\n🔍 Step 2: Checking bootstrap status...")
        bootstrapCmd := exec.Command("cast", "call",
                "--rpc-url", ETHEREUM_RPC_URL,
                GATEWAY_ADDR,
                "bootstrapped() returns (bool)",
        )

        bootstrapOutput, err := bootstrapCmd.Output()
        isBootstrapped := false
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check bootstrap status: %v", err)
                log.Println("Assuming network is not bootstrapped...")
        }</span> else<span class="cov0" title="0"> {
                bootstrapResult := strings.TrimSpace(string(bootstrapOutput))
                isBootstrapped = bootstrapResult == "true"
        }</span>
        <span class="cov0" title="0">log.Printf("Bootstrap status: %t", isBootstrapped)

        // Step 3: Calculate delegation LayerZero fees if bootstrapped
        delegateValue := "0"
        if isBootstrapped </span><span class="cov0" title="0">{
                log.Println("\n💸 Step 3: Calculating delegation LayerZero fees...")

                // Convert amount to wei first for proper hex conversion
                amountWeiCmd := exec.Command("cast", "2w", fmt.Sprintf("%.0f", delegateAmount))
                amountWeiOutput, err := amountWeiCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert amount to wei: %v", err)
                }</span>
                <span class="cov0" title="0">amountWei := strings.TrimSpace(string(amountWeiOutput))

                // Convert wei to hex
                amountHexCmd := exec.Command("cast", "2h", amountWei)
                amountHexOutput, err := amountHexCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert amount to hex: %v", err)
                }</span>
                <span class="cov0" title="0">amountHex := strings.TrimSpace(string(amountHexOutput))

                // Remove 0x prefix and pad to 64 characters (32 bytes)
                amountHex = strings.TrimPrefix(amountHex, "0x")
                // Pad with leading zeros to make it 64 characters
                for len(amountHex) &lt; 64 </span><span class="cov0" title="0">{
                        amountHex = "0" + amountHex
                }</span>
                <span class="cov0" title="0">quantityB32 := "0x" + amountHex

                // Generate the LZ message for delegation
                delegatePrefix := "0x08"

                // Convert token address to bytes32
                tokenB32Cmd := exec.Command("cast", "2b", tokenAddr)
                tokenB32Output, err := tokenB32Cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert token address to bytes32: %v", err)
                }</span>
                <span class="cov0" title="0">tokenB32 := strings.TrimSpace(string(tokenB32Output))

                // Convert ETH address to bytes32
                ethAddressB32Cmd := exec.Command("cast", "2b", ethAddress)
                ethAddressB32Output, err := ethAddressB32Cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert ETH address to bytes32: %v", err)
                }</span>
                <span class="cov0" title="0">ethAddressB32 := strings.TrimSpace(string(ethAddressB32Output))

                // Convert Imua address to bytes
                imAddressBytesCmd := exec.Command("cast", "fu", imAddress)
                imAddressBytesOutput, err := imAddressBytesCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert Imua address to bytes: %v", err)
                }</span>
                <span class="cov0" title="0">imAddressBytes := strings.TrimSpace(string(imAddressBytesOutput))

                // Create delegation LZ message
                lzDelegateMessageCmd := exec.Command("cast", "ch",
                        delegatePrefix,
                        tokenB32,
                        ethAddressB32,
                        imAddressBytes,
                        quantityB32,
                )
                lzDelegateMessageOutput, err := lzDelegateMessageCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create delegation LZ message: %v", err)
                }</span>
                <span class="cov0" title="0">lzDelegateMessage := strings.TrimSpace(string(lzDelegateMessageOutput))
                log.Printf("Generated LZ message: %s", lzDelegateMessage)

                // Quote delegation LayerZero fees
                quoteDelegateCmd := exec.Command("cast", "call",
                        "--rpc-url", ETHEREUM_RPC_URL,
                        GATEWAY_ADDR,
                        "quote(bytes)",
                        lzDelegateMessage,
                )

                quoteDelegateOutput, err := quoteDelegateCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to quote delegation LayerZero fees: %v", err)
                        log.Println("This might be due to network issues or incorrect message format.")
                        return fmt.Errorf("LayerZero fee calculation failed for delegation: %v", err)
                }</span>

                <span class="cov0" title="0">delegateValue = strings.TrimSpace(string(quoteDelegateOutput))
                log.Printf("Delegation LayerZero fee calculated: %s", delegateValue)

                // Validate that we got a proper fee value
                if delegateValue == "" || delegateValue == "0x" </span><span class="cov0" title="0">{
                        log.Printf("Warning: Received empty or invalid LayerZero fee: '%s'", delegateValue)
                        log.Println("Proceeding with 0 value, but this might cause transaction failure")
                        delegateValue = "0"
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("\n⚡ Step 3: Network not bootstrapped, no LayerZero fees required")
        }</span>

        <span class="cov0" title="0">log.Printf("Delegation LayerZero value: %s", delegateValue)

        // Step 4: Execute delegation transaction
        log.Println("\n📤 Step 4: Executing delegation transaction...")

        // Convert amount to wei for transaction
        amountWeiCmd := exec.Command("cast", "2w", fmt.Sprintf("%.0f", delegateAmount))
        amountWeiOutput, err := amountWeiCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert amount to wei: %v", err)
        }</span>
        <span class="cov0" title="0">amountWei := strings.TrimSpace(string(amountWeiOutput))

        // Convert delegation value to decimal if needed
        var finalDelegateValue string
        if delegateValue != "0" &amp;&amp; delegateValue != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(delegateValue, "0x") </span><span class="cov0" title="0">{
                        // Convert hex to decimal
                        castDecimalCmd := exec.Command("cast", "2d", delegateValue)
                        castDecimalOutput, err := castDecimalCmd.Output()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Failed to convert LayerZero fee to decimal: %v", err)
                                log.Printf("Using raw value: %s", delegateValue)
                                finalDelegateValue = delegateValue
                        }</span> else<span class="cov0" title="0"> {
                                finalDelegateValue = strings.TrimSpace(string(castDecimalOutput))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Already in decimal format
                        finalDelegateValue = delegateValue
                }</span>
        } else<span class="cov0" title="0"> {
                finalDelegateValue = "0"
        }</span>

        <span class="cov0" title="0">log.Printf("Final delegation value for transaction: %s", finalDelegateValue)

        // Execute the delegation transaction
        delegateCmd := exec.Command("cast", "send",
                "--rpc-url", ETHEREUM_RPC_URL,
                GATEWAY_ADDR,
                "delegateTo(string,address,uint256)",
                imAddress,
                tokenAddr,
                amountWei,
                "--private-key", ethPrivateKey,
                "--value", finalDelegateValue,
        )

        log.Printf("Executing delegation command: %s", strings.Join(delegateCmd.Args, " "))
        delegateOutput, err := delegateCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Delegation command output: %s", string(delegateOutput))
                return fmt.Errorf("failed to execute delegation transaction: %v\nOutput: %s", err, string(delegateOutput))
        }</span>

        <span class="cov0" title="0">transactionOutput := strings.TrimSpace(string(delegateOutput))
        log.Printf("✅ Delegation transaction successful!")
        log.Printf("Transaction details: %s", transactionOutput)

        // Extract transaction hash if available
        var txHash string
        lines := strings.Split(transactionOutput, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "transactionHash") || strings.Contains(line, "blockHash") </span><span class="cov0" title="0">{
                        log.Printf("📝 %s", line)
                }</span>
                // Try to extract transaction hash
                <span class="cov0" title="0">if strings.HasPrefix(strings.TrimSpace(line), "0x") &amp;&amp; len(strings.TrimSpace(line)) == 66 </span><span class="cov0" title="0">{
                        txHash = strings.TrimSpace(line)
                }</span>
        }

        // Step 5: Provide verification instructions
        <span class="cov0" title="0">log.Println("\n🎉 Token delegation completed successfully!")
        log.Printf("📊 Summary:")
        log.Printf("  - Token: %s", tokenAddr)
        log.Printf("  - Amount: %.2f tokens (%s wei)", delegateAmount, amountWei)
        log.Printf("  - Delegated from: %s", ethAddress)
        log.Printf("  - Delegated to: %s", imAddress)
        log.Printf("  - Network: %s", "Ethereum Sepolia -&gt; Imuachain")
        log.Printf("  - LayerZero Fee: %s", finalDelegateValue)

        if isBootstrapped </span><span class="cov0" title="0">{
                log.Println("\n📋 Verification Instructions:")
                log.Println("1. 🔍 Monitor LayerZero message processing:")
                log.Println("   - Visit: https://testnet.layerzeroscan.com/")
                if txHash != "" </span><span class="cov0" title="0">{
                        log.Printf("   - Search for transaction hash: %s", txHash)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("   - Search for your transaction hash from the output above")
                }</span>

                <span class="cov0" title="0">ethLZID := 40161 // Sepolia LayerZero ID
                stakerID := strings.ToLower(ethAddress) + "_" + fmt.Sprintf("0x%x", ethLZID)
                log.Println("\n2. 📊 Verify your delegation on Imua:")
                log.Printf("   Staker ID: %s", stakerID)
                log.Printf("   Query command:")
                log.Printf("   imuad query assets staker-assets %s --node %s --output json | jq", stakerID, imuaCosGrpcURL)

                log.Println("\n3. 🤝 Expected result should show:")
                log.Printf("   - total_deposit_amount: (unchanged)")
                log.Printf("   - withdrawable_amount: (reduced by %s)", amountWei)
                log.Printf("   - pending_undelegation_amount: 0")

                log.Println("\n⏱️  Note: LayerZero message processing may take a few minutes")
                log.Println("   Please wait before checking the delegation status on Imua")</span>
        } else<span class="cov0" title="0"> {
                log.Println("\n💡 Note: Network is in bootstrap mode")
                log.Println("- Your delegation will be processed when the network becomes active")
                log.Println("- No LayerZero fees were charged")
                log.Println("- The delegation is immediately effective in bootstrap mode")
        }</span>

        <span class="cov0" title="0">log.Println("\n📋 Next Steps:")
        log.Println("1. 🔗 Associate operator for post-bootstrap phase:")
        log.Println("   ./triggerx associate-operator")
        log.Println("2. 🚀 Proceed with AVS opt-in:")
        log.Println("   ./triggerx opt-in-to-avs")
        log.Println("3. ⚡ Complete TriggerX registration:")
        log.Println("   ./triggerx complete-registration")

        log.Println("\n💡 Important Notes:")
        log.Println("- Ensure you have at least 1,000 USD in self-delegated tokens")
        log.Println("- Validator inclusion happens at the beginning of the next epoch (max 1 hour)")
        log.Println("- Only top 50 validators by total stake are included in the active set")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strconv"
        "strings"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func DepositTokens(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("💰 Starting token deposit process on Ethereum Sepolia...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">ethPrivateKey := os.Getenv("OPERATOR_PRIVATE_KEY")
        if ethPrivateKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OPERATOR_PRIVATE_KEY environment variable not set")
        }</span>

        // Add 0x prefix if not present
        <span class="cov0" title="0">if !strings.HasPrefix(ethPrivateKey, "0x") </span><span class="cov0" title="0">{
                ethPrivateKey = "0x" + ethPrivateKey
        }</span>

        <span class="cov0" title="0">ethAddress := config.GetOperatorAddress().Hex()
        log.Printf("Using Ethereum address: %s", ethAddress)

        // Configuration with official contract addresses
        const (
                // Official contract addresses on Ethereum Sepolia
                IM_ETH_ADDR      = "0xF79F563571f7D8122611D0219A0d5449B5304F79"      
                WST_ETH_ADDR     = "0xB82381A3fBD3FaFA77B3a7bE693342618240067b"
                GATEWAY_ADDR     = "0x64B5B5A618072C1E4D137f91Af780e3B17A81f3f"
                ETHEREUM_RPC_URL = "https://eth-sepolia.g.alchemy.com/v2/U67yWPtGvZIz8FwnTcFEfERypsxYzfdR"
        )

        // User configuration
        tokenAddr := IM_ETH_ADDR // Default to imETH
        if tokenOverride := os.Getenv("TOKEN_ADDRESS"); tokenOverride != "" </span><span class="cov0" title="0">{
                tokenAddr = tokenOverride
        }</span>

        // Get deposit amount from environment or use default
        <span class="cov0" title="0">depositAmountStr := os.Getenv("DEPOSIT_AMOUNT")
        if depositAmountStr == "" </span><span class="cov0" title="0">{
                depositAmountStr = "25" // Default 25 tokens as per documentation
        }</span>

        <span class="cov0" title="0">depositAmount, err := strconv.ParseFloat(depositAmountStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid DEPOSIT_AMOUNT: %v", err)
        }</span>

        // Imua configuration for verification
        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                imuaCosGrpcURL = "https://api-cosmos-grpc.exocore-restaking.com:443"
        }</span>

        <span class="cov0" title="0">log.Printf("📋 Deposit Configuration:")
        log.Printf("- Token Address: %s", tokenAddr)
        log.Printf("- Deposit Amount: %.2f", depositAmount)
        log.Printf("- Ethereum RPC: %s", ETHEREUM_RPC_URL)
        log.Printf("- Gateway Address: %s", GATEWAY_ADDR)

        // Step 1: Get vault address for the token
        log.Println("\n💰 Step 1: Getting vault address for token...")
        vaultCmd := exec.Command("cast", "call",
                "--rpc-url", ETHEREUM_RPC_URL,
                GATEWAY_ADDR,
                "tokenToVault(address) returns (address)",
                tokenAddr,
        )

        vaultOutput, err := vaultCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get vault address: %v", err)
        }</span>

        <span class="cov0" title="0">vaultAddr := strings.TrimSpace(string(vaultOutput))
        log.Printf("Vault address: %s", vaultAddr)

        // Step 2: Approve token spending by vault
        log.Println("\n✅ Step 2: Approving token spending by vault...")

        // First get the maximum uint256 value
        maxUintCmd := exec.Command("cast", "maxu")
        maxUintOutput, err := maxUintCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get max uint256: %v", err)
        }</span>
        <span class="cov0" title="0">maxUint := strings.TrimSpace(string(maxUintOutput))

        approveCmd := exec.Command("cast", "send",
                "--rpc-url", ETHEREUM_RPC_URL,
                tokenAddr,
                "approve(address,uint256)",
                vaultAddr,
                maxUint,
                "--private-key", ethPrivateKey,
        )

        approveOutput, err := approveCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Approve command output: %s", string(approveOutput))
                return fmt.Errorf("failed to approve token: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Token approval successful: %s", string(approveOutput))

        // Step 3: Check if gateway is bootstrapped
        log.Println("\n🔍 Step 3: Checking bootstrap status...")
        bootstrapCmd := exec.Command("cast", "call",
                "--rpc-url", ETHEREUM_RPC_URL,
                GATEWAY_ADDR,
                "bootstrapped() returns (bool)",
        )

        bootstrapOutput, err := bootstrapCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check bootstrap status: %v", err)
                bootstrapOutput = []byte("false")
        }</span>

        <span class="cov0" title="0">isBootstrapped := strings.TrimSpace(string(bootstrapOutput)) == "true"
        log.Printf("Bootstrap status: %t", isBootstrapped)

        // Step 4: Calculate LayerZero fees if bootstrapped
        depositValue := "0"
        if isBootstrapped </span><span class="cov0" title="0">{
                log.Println("\n💸 Step 4: Calculating LayerZero fees...")

                // Generate the LZ message to calculate the fees
                depositPrefix := "0x02"

                // Convert token address to bytes32
                tokenB32Cmd := exec.Command("cast", "2b", tokenAddr)
                tokenB32Output, err := tokenB32Cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert token address: %v", err)
                }</span>
                <span class="cov0" title="0">tokenB32 := strings.TrimSpace(string(tokenB32Output))

                // Convert ETH address to bytes32
                ethAddressB32Cmd := exec.Command("cast", "2b", ethAddress)
                ethAddressB32Output, err := ethAddressB32Cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert ETH address: %v", err)
                }</span>
                <span class="cov0" title="0">ethAddressB32 := strings.TrimSpace(string(ethAddressB32Output))

                // Convert amount to wei and then to hex
                amountWeiCmd := exec.Command("cast", "2w", fmt.Sprintf("%.0f", depositAmount))
                amountWeiOutput, err := amountWeiCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert amount to wei: %v", err)
                }</span>

                <span class="cov0" title="0">amountHexCmd := exec.Command("cast", "2h", strings.TrimSpace(string(amountWeiOutput)))
                amountHexOutput, err := amountHexCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert amount to hex: %v", err)
                }</span>

                // Pad the amount to 64 characters (32 bytes)
                <span class="cov0" title="0">amountHexStr := strings.TrimSpace(string(amountHexOutput))
                amountHexStr = strings.TrimPrefix(amountHexStr, "0x")
                quantityB32 := fmt.Sprintf("%064s", amountHexStr)
                quantityB32 = strings.ReplaceAll(quantityB32, " ", "0")

                // Concatenate the LZ message
                lzMessageCmd := exec.Command("cast", "ch", depositPrefix, tokenB32, ethAddressB32, quantityB32)
                lzMessageOutput, err := lzMessageCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create LZ message: %v", err)
                }</span>
                <span class="cov0" title="0">lzMessage := strings.TrimSpace(string(lzMessageOutput))

                // Quote the LayerZero fees
                quoteCmd := exec.Command("cast", "call",
                        "--rpc-url", ETHEREUM_RPC_URL,
                        GATEWAY_ADDR,
                        "quote(bytes)",
                        lzMessage,
                )

                quoteOutput, err := quoteCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to quote LayerZero fees: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        depositValue = strings.TrimSpace(string(quoteOutput))
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("\n⚡ Step 4: Network not bootstrapped, no LayerZero fees required")
        }</span>

        <span class="cov0" title="0">log.Printf("LayerZero value: %s", depositValue)

        // Step 5: Execute deposit transaction
        log.Println("\n📤 Step 5: Executing deposit transaction...")

        // Convert amount to wei for transaction
        amountWeiCmd := exec.Command("cast", "2w", fmt.Sprintf("%.0f", depositAmount))
        amountWeiOutput, err := amountWeiCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert amount to wei: %v", err)
        }</span>
        <span class="cov0" title="0">amountWei := strings.TrimSpace(string(amountWeiOutput))

        // Convert value to decimal if needed
        var finalValue string
        if depositValue != "0" </span><span class="cov0" title="0">{
                castDecimalCmd := exec.Command("cast", "2d", depositValue)
                castDecimalOutput, err := castDecimalCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        finalValue = depositValue // Use as is if conversion fails
                }</span> else<span class="cov0" title="0"> {
                        finalValue = strings.TrimSpace(string(castDecimalOutput))
                }</span>
        } else<span class="cov0" title="0"> {
                finalValue = "0"
        }</span>

        <span class="cov0" title="0">depositCmd := exec.Command("cast", "send",
                "--rpc-url", ETHEREUM_RPC_URL,
                GATEWAY_ADDR,
                "deposit(address,uint256)",
                tokenAddr,
                amountWei,
                "--private-key", ethPrivateKey,
                "--value", finalValue,
        )

        depositOutput, err := depositCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Deposit command output: %s", string(depositOutput))
                return fmt.Errorf("failed to execute deposit: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✅ Deposit successful: %s", string(depositOutput))

        // Step 6: Provide verification instructions
        log.Println("\n🎉 Token deposit completed successfully!")
        log.Printf("📊 Summary:")
        log.Printf("  - Token: %s", tokenAddr)
        log.Printf("  - Amount: %.2f tokens", depositAmount)
        log.Printf("  - Deposited from: %s", ethAddress)
        log.Printf("  - Network: %s", "Ethereum Sepolia -&gt; Imuachain")

        if isBootstrapped </span><span class="cov0" title="0">{
                log.Println("\n📋 Verification Instructions:")
                log.Println("1. 🔍 Monitor LayerZero message processing:")
                log.Println("   - Visit: https://testnet.layerzeroscan.com/")
                log.Println("   - Search for your transaction hash above")

                ethLZID := 40161 // Sepolia LayerZero ID
                stakerID := strings.ToLower(ethAddress) + "_" + fmt.Sprintf("0x%x", ethLZID)
                log.Println("2. 📊 Verify your deposit on Imua:")
                log.Printf("   Staker ID: %s", stakerID)
                log.Printf("   Query: imuad query assets staker-assets %s --node %s --output json | jq", stakerID, imuaCosGrpcURL)

                log.Println("3. 💰 Expected result should show:")
                log.Printf("   - total_deposit_amount: %s (%.2f tokens in wei)", amountWei, depositAmount)
                log.Printf("   - withdrawable_amount: %s (all deposited tokens)", amountWei)
        }</span> else<span class="cov0" title="0"> {
                log.Println("\n💡 Note: Network is in bootstrap mode")
                log.Println("- Your deposit will be processed when the network becomes active")
                log.Println("- No LayerZero fees were charged")
        }</span>

        <span class="cov0" title="0">log.Println("\n📋 Next Steps:")
        log.Println("1. 🤝 Delegate tokens to your validator:")
        log.Println("   ./triggerx delegate-tokens")
        log.Println("2. 🚀 Or run complete process:")
        log.Println("   ./triggerx deposit-and-delegate")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package actions

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

type FaucetRequest struct {
        Address string `json:"address"`
}

type FaucetResponse struct {
        TxHash string `json:"txHash"`
        Error  string `json:"error,omitempty"`
}

func FundImuaAccount(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("💰 Starting IMUA token funding process...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_COS_GRPC_URL environment variable not set")
        }</span>

        // Get keyring password from environment
        <span class="cov0" title="0">keyringPassword := os.Getenv("KEYRING_PASSWORD")
        if keyringPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("KEYRING_PASSWORD environment variable not set")
        }</span>

        // Faucet URL
        <span class="cov0" title="0">faucetURL := os.Getenv("IMUA_FAUCET_URL")
        if faucetURL == "" </span><span class="cov0" title="0">{
                faucetURL = "https://241009-faucet.exocore-restaking.com/"
        }</span>

        <span class="cov0" title="0">log.Printf("Funding configuration:")
        log.Printf("- Home Directory: %s", imuaHomeDir)
        log.Printf("- Account Key Name: %s", imuaAccountKeyName)
        log.Printf("- Faucet URL: %s", faucetURL)

        // Step 1: Get the validator address
        log.Println("\n🔍 Step 1: Getting validator address...")
        getAddrCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "keys", "show", "-a", imuaAccountKeyName,
        )

        // Provide password for address query
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get validator address: %v", err)
        }</span>

        <span class="cov0" title="0">validatorAddr := strings.TrimSpace(string(addrOutput))
        log.Printf("Validator address: %s", validatorAddr)

        // Step 2: Check current balance
        log.Println("\n💰 Step 2: Checking current balance...")
        err = checkImuaBalance(validatorAddr, imuaCosGrpcURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check balance: %v", err)
        }</span>

        // Step 3: Request tokens from faucet
        <span class="cov0" title="0">log.Println("\n🚰 Step 3: Requesting IMUA tokens from faucet...")
        txHash, err := requestFaucetTokens(faucetURL, validatorAddr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to request tokens from faucet: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✅ Faucet request successful!")
        log.Printf("Transaction Hash: %s", txHash)

        // Step 4: Wait and check balance again
        log.Println("\n⏳ Step 4: Waiting for transaction to be processed...")
        log.Println("Waiting 30 seconds for the transaction to be confirmed...")
        time.Sleep(30 * time.Second)

        log.Println("\n🔍 Step 5: Checking updated balance...")
        err = checkImuaBalance(validatorAddr, imuaCosGrpcURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check updated balance: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("\n🎉 IMUA token funding completed successfully!")
        log.Printf("Validator Address: %s", validatorAddr)
        log.Printf("Transaction Hash: %s", txHash)

        // log.Println("\n📋 Next Steps:")
        // log.Println("1. 🏗️  Register as operator: ./triggerx register-imua-operator")
        // log.Println("2. 🚀 Complete registration: ./triggerx complete-imua-registration")

        return nil</span>
}

func CheckImuaBalance(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("🔍 Checking IMUA account balance...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_COS_GRPC_URL environment variable not set")
        }</span>

        // Get keyring password from environment
        <span class="cov0" title="0">keyringPassword := os.Getenv("KEYRING_PASSWORD")
        if keyringPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("KEYRING_PASSWORD environment variable not set")
        }</span>

        // Get the validator address
        <span class="cov0" title="0">log.Println("Getting validator address...")
        getAddrCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "keys", "show", "-a", imuaAccountKeyName,
        )

        // Provide password for address query
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get validator address: %v", err)
        }</span>

        <span class="cov0" title="0">validatorAddr := strings.TrimSpace(string(addrOutput))
        log.Printf("Validator address: %s", validatorAddr)

        // Check balance
        return checkImuaBalance(validatorAddr, imuaCosGrpcURL)</span>
}

func checkImuaBalance(address, grpcURL string) error <span class="cov0" title="0">{
        log.Printf("Checking balance for address: %s", address)

        balanceCmd := exec.Command("imuad",
                "query", "bank", "balances", address,
                "--node", grpcURL,
                "--output", "json",
        )

        balanceOutput, err := balanceCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query balance: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Balance query result: %s", string(balanceOutput))

        // Parse JSON to extract balance information
        var balanceData struct {
                Balances []struct {
                        Denom  string `json:"denom"`
                        Amount string `json:"amount"`
                } `json:"balances"`
        }

        err = json.Unmarshal(balanceOutput, &amp;balanceData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not parse balance JSON: %v", err)
                log.Printf("Raw balance output: %s", string(balanceOutput))
                return nil
        }</span>

        <span class="cov0" title="0">if len(balanceData.Balances) == 0 </span><span class="cov0" title="0">{
                log.Println("❌ Account has no balance (0 IMUA tokens)")
                log.Println("💡 Run './triggerx fund-imua-account' to get IMUA tokens from the faucet")
                return nil
        }</span>

        <span class="cov0" title="0">log.Println("💰 Account Balances:")
        for _, balance := range balanceData.Balances </span><span class="cov0" title="0">{
                log.Printf("  - %s %s", balance.Amount, balance.Denom)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func requestFaucetTokens(faucetURL, address string) (string, error) <span class="cov0" title="0">{
        // Prepare request body
        requestBody := FaucetRequest{
                Address: address,
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Sending faucet request to: %s", faucetURL)
        log.Printf("Request body: %s", string(jsonData))

        // Make HTTP request
        resp, err := http.Post(faucetURL, "application/json", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make faucet request: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to close response body: %v", cerr)
                }</span>
        }()

        // Read response
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Faucet response status: %d", resp.StatusCode)
        log.Printf("Faucet response body: %s", string(body))

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("faucet request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // Parse response
        <span class="cov0" title="0">var faucetResp FaucetResponse
        err = json.Unmarshal(body, &amp;faucetResp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse faucet response: %v", err)
        }</span>

        <span class="cov0" title="0">if faucetResp.Error != "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("faucet error: %s", faucetResp.Error)
        }</span>

        <span class="cov0" title="0">if faucetResp.TxHash == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no transaction hash received from faucet")
        }</span>

        <span class="cov0" title="0">return faucetResp.TxHash, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "path/filepath"

        "github.com/trigg3rX/triggerx-backend/cli/core"
        "github.com/urfave/cli"
)

func GenerateKeys(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("Generating operator keys...")

        // Create keys directory
        keysDir := "keys"
        if err := os.MkdirAll(keysDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create keys directory: %v", err)
        }</span>

        // Generate ECDSA keystore
        <span class="cov0" title="0">log.Println("Generating ECDSA keystore...")
        ecdsaKeyPath := filepath.Join(keysDir, "ecdsa.json")
        if err := core.GenerateECDSAKeystore(ecdsaKeyPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate ECDSA keystore: %v", err)
        }</span>

        // Generate BLS keystore
        <span class="cov0" title="0">log.Println("Generating BLS keystore...")
        blsKeyPath := filepath.Join(keysDir, "bls.json")
        blsPrivateKeyHex, err := core.GenerateBLSKeystore(blsKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate BLS keystore: %v", err)
        }</span>

        // Update .env file with keystore paths
        <span class="cov0" title="0">envPath := ".env"
        if err := core.UpdateEnvFile(envPath, ecdsaKeyPath, blsKeyPath, blsPrivateKeyHex); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update .env file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Key generation completed successfully!")
        log.Printf("ECDSA keystore: %s", ecdsaKeyPath)
        log.Printf("BLS keystore: %s", blsKeyPath)
        log.Printf("Updated .env file with keystore paths")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func GetImethTokens(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("💧 Starting imETH faucet request...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">ethPrivateKey := os.Getenv("OPERATOR_PRIVATE_KEY")
        if ethPrivateKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OPERATOR_PRIVATE_KEY environment variable not set")
        }</span>

        // Add 0x prefix if not present
        <span class="cov0" title="0">if !strings.HasPrefix(ethPrivateKey, "0x") </span><span class="cov0" title="0">{
                ethPrivateKey = "0x" + ethPrivateKey
        }</span>

        <span class="cov0" title="0">ethAddress := config.GetOperatorAddress().Hex()
        log.Printf("Using Ethereum address: %s", ethAddress)

        // Configuration
        const (
                IM_ETH_FAUCET_ADDR = "0xfCf79695f63FB9e540a1887A19dA94e10ADF13eB"
                IM_ETH_ADDR        = "0xF79F563571f7D8122611D0219A0d5449B5304F79"
                ETHEREUM_RPC_URL   = "https://eth-sepolia.g.alchemy.com/v2/U67yWPtGvZIz8FwnTcFEfERypsxYzfdR"
        )

        log.Printf("📋 Faucet Configuration:")
        log.Printf("- Faucet Address: %s", IM_ETH_FAUCET_ADDR)
        log.Printf("- imETH Token Address: %s", IM_ETH_ADDR)
        log.Printf("- Ethereum RPC: %s", ETHEREUM_RPC_URL)
        log.Printf("- Requesting address: %s", ethAddress)

        // Step 1: Check current imETH balance
        log.Println("\n💰 Step 1: Checking current imETH balance...")
        balanceCmd := exec.Command("cast", "call",
                "--rpc-url", ETHEREUM_RPC_URL,
                IM_ETH_ADDR,
                "balanceOf(address) returns (uint256)",
                ethAddress,
        )

        balanceOutput, err := balanceCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check balance: %v", err)
        }</span> else<span class="cov0" title="0"> {
                currentBalance := strings.TrimSpace(string(balanceOutput))
                log.Printf("Current imETH balance: %s wei", currentBalance)

                // Convert to decimal for readability
                if decimalCmd := exec.Command("cast", "2d", currentBalance); decimalCmd != nil </span><span class="cov0" title="0">{
                        if decimalOutput, err := decimalCmd.Output(); err == nil </span><span class="cov0" title="0">{
                                decimalBalance := strings.TrimSpace(string(decimalOutput))
                                log.Printf("Current imETH balance: %s tokens", decimalBalance)
                        }</span>
                }
        }

        // Step 2: Request tokens from faucet
        <span class="cov0" title="0">log.Println("\n🚰 Step 2: Requesting 25 imETH tokens from faucet...")
        log.Println("Note: This faucet gives out 25 imETH every 24 hours per requesting address.")

        faucetCmd := exec.Command("cast", "send",
                "--rpc-url", ETHEREUM_RPC_URL,
                IM_ETH_FAUCET_ADDR,
                "requestTokens()",
                "--private-key", ethPrivateKey,
        )

        faucetOutput, err := faucetCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Faucet command output: %s", string(faucetOutput))
                return fmt.Errorf("failed to request tokens from faucet: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✅ Faucet request successful: %s", string(faucetOutput))

        // Step 3: Check new balance
        log.Println("\n🔄 Step 3: Checking updated imETH balance...")
        newBalanceCmd := exec.Command("cast", "call",
                "--rpc-url", ETHEREUM_RPC_URL,
                IM_ETH_ADDR,
                "balanceOf(address) returns (uint256)",
                ethAddress,
        )

        newBalanceOutput, err := newBalanceCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check new balance: %v", err)
        }</span> else<span class="cov0" title="0"> {
                newBalance := strings.TrimSpace(string(newBalanceOutput))
                log.Printf("New imETH balance: %s wei", newBalance)

                // Convert to decimal for readability
                if decimalCmd := exec.Command("cast", "2d", newBalance); decimalCmd != nil </span><span class="cov0" title="0">{
                        if decimalOutput, err := decimalCmd.Output(); err == nil </span><span class="cov0" title="0">{
                                decimalBalance := strings.TrimSpace(string(decimalOutput))
                                log.Printf("New imETH balance: %s tokens", decimalBalance)
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Println("\n🎉 imETH tokens successfully acquired!")
        log.Println("📋 Next Steps:")
        log.Println("1. 💰 You can now deposit tokens:")
        log.Println("   ./triggerx deposit-tokens")
        log.Println("2. 🚀 Or run the complete process:")
        log.Println("   ./triggerx deposit-and-delegate")
        log.Println("")
        log.Println("💡 Note: The faucet has a 24-hour cooldown period per address.")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

// OptInToAVS handles the AVS opt-in process using cast send
func OptInToAVS(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("Starting AVS opt-in process...")

        // Initialize config from environment variables
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Validate required environment variables
        <span class="cov0" title="0">requiredVars := map[string]string{
                "AVS_ADDRESS":       os.Getenv("AVS_ADDRESS"),
                "IMUA_PRIVATE_KEY":  os.Getenv("IMUA_PRIVATE_KEY"),
                "RPC_URL":          os.Getenv("RPC_URL"),
        }

        // Set default values if not provided
        if requiredVars["AVS_ADDRESS"] == "" </span><span class="cov0" title="0">{
                requiredVars["AVS_ADDRESS"] = "0x72A5016ECb9EB01d7d54ae48bFFB62CA0B8e57a5"
        }</span>
        <span class="cov0" title="0">if requiredVars["RPC_URL"] == "" </span><span class="cov0" title="0">{
                requiredVars["RPC_URL"] = "https://api-eth.exocore-restaking.com"
        }</span>

        // Check required variables
        <span class="cov0" title="0">for name, value := range requiredVars </span><span class="cov0" title="0">{
                if value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s environment variable not set", name)
                }</span>
        }

        // Log configuration (redact private key)
        <span class="cov0" title="0">log.Printf("AVS opt-in configuration:")
        for name, value := range requiredVars </span><span class="cov0" title="0">{
                if name != "IMUA_PRIVATE_KEY" </span><span class="cov0" title="0">{
                        log.Printf("- %s: %s", name, value)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("- %s: [redacted]", name)
                }</span>
        }

        // Check if cast is available
        <span class="cov0" title="0">if err := checkCastAvailable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cast command not available: %v", err)
        }</span>

        // Execute the cast send command
        <span class="cov0" title="0">log.Println("\n🚀 Executing registerOperatorToAVS transaction...")
        
        castCmd := exec.Command("cast", "send",
                requiredVars["AVS_ADDRESS"],
                "registerOperatorToAVS()",
                "--rpc-url", requiredVars["RPC_URL"],
                "--private-key", requiredVars["IMUA_PRIVATE_KEY"],
                "--gas-limit", "1000000",
        )

        // Execute the command and capture output
        castOutput, err := castCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ Cast send command output: %s", string(castOutput))
                
                // Handle specific error cases
                if strings.Contains(string(castOutput), "insufficient funds") </span><span class="cov0" title="0">{
                        return fmt.Errorf("insufficient ETH balance for gas fees")
                }</span>
                <span class="cov0" title="0">if strings.Contains(string(castOutput), "execution reverted") </span><span class="cov0" title="0">{
                        return fmt.Errorf("transaction reverted - check if already registered or meet requirements")
                }</span>
                <span class="cov0" title="0">if strings.Contains(string(castOutput), "invalid private key") </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid private key format")
                }</span>
                
                <span class="cov0" title="0">return fmt.Errorf("failed to execute registerOperatorToAVS: %v", err)</span>
        }

        <span class="cov0" title="0">log.Printf("✅ Transaction submitted: %s", string(castOutput))

        // Extract transaction hash from output
        var txHash string
        outputStr := string(castOutput)
        
        // Cast typically outputs just the transaction hash
        lines := strings.Split(strings.TrimSpace(outputStr), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                // Look for a hex string that looks like a transaction hash (0x followed by 64 hex chars)
                if strings.HasPrefix(line, "0x") &amp;&amp; len(line) == 66 </span><span class="cov0" title="0">{
                        txHash = line
                        break</span>
                }
        }

        <span class="cov0" title="0">if txHash != "" </span><span class="cov0" title="0">{
                log.Printf("\n🔍 Transaction hash: %s", txHash)
                log.Println("Waiting for transaction confirmation...")
                time.Sleep(10 * time.Second) // Wait for block confirmation

                // Verify transaction status using cast
                if err := verifyTransaction(txHash, requiredVars["RPC_URL"]); err != nil </span><span class="cov0" title="0">{
                        log.Printf("⚠️ Could not verify transaction status: %v", err)
                        log.Println("Transaction was submitted but confirmation failed. Check block explorer.")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("⚠️ Could not extract transaction hash from output")
                log.Println("Transaction may have been submitted. Check your wallet or block explorer.")
        }</span>

        <span class="cov0" title="0">log.Println("\n✨ AVS opt-in process completed!")
        log.Println("Next steps:")
        log.Println("- Check transaction on block explorer")
        log.Println("- Monitor your operator status on AVS dashboard")
        log.Printf("- Transaction hash: %s", txHash)

        return nil</span>
}

// checkCastAvailable verifies that the cast command is available
func checkCastAvailable() error <span class="cov0" title="0">{
        cmd := exec.Command("cast", "--help")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cast command not found. Please install Foundry toolkit: https://getfoundry.sh/")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// verifyTransaction checks if the transaction was successful
func verifyTransaction(txHash, rpcURL string) error <span class="cov0" title="0">{
        log.Println("🔍 Verifying transaction status...")
        
        // Use cast to get transaction receipt
        receiptCmd := exec.Command("cast", "receipt", txHash, "--rpc-url", rpcURL)
        receiptOutput, err := receiptCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get transaction receipt: %v", err)
        }</span>

        <span class="cov0" title="0">receiptStr := string(receiptOutput)
        
        // Check if transaction was successful (status: 0x1 means success)
        if strings.Contains(receiptStr, "status") &amp;&amp; strings.Contains(receiptStr, "0x1") </span><span class="cov0" title="0">{
                log.Println("🎉 Transaction confirmed successfully!")
                return nil
        }</span> else<span class="cov0" title="0"> if strings.Contains(receiptStr, "status") &amp;&amp; strings.Contains(receiptStr, "0x0") </span><span class="cov0" title="0">{
                log.Println("❌ Transaction failed!")
                log.Printf("Receipt: %s", receiptStr)
                return fmt.Errorf("transaction failed with status 0x0")
        }</span>
        
        <span class="cov0" title="0">log.Println("⚠️ Transaction status unclear")
        log.Printf("Receipt: %s", receiptStr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package actions

import (
        "bufio"
        "encoding/hex"
        "fmt"
        "math/big"
        "os"
        "os/exec"
        "strings"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/imua-xyz/imua-avs-sdk/logging"
        "github.com/prysmaticlabs/prysm/v5/crypto/bls"
        "github.com/trigg3rX/triggerx-backend/pkg/env"
        "github.com/urfave/cli"
)

// BLS12-381 curve order
const BLS12381_CURVE_ORDER = "52435875175126190479447740508185965837690552500527637822603658699938581184513"

func RegisterBLSPublicKey(c *cli.Context) error <span class="cov0" title="0">{
        logger := logging.NewSlogLogger(logging.Development)
        logger.Info("Starting BLS Public Key Registration...")

        // Load environment variables
        requiredEnvVars := map[string]string{
                "AVS_ADDRESS":      env.GetEnvString("AVS_ADDRESS", ""),
                "BLS_PRIVATE_KEY":  env.GetEnvString("BLS_PRIVATE_KEY", ""),
                "IMUA_BECH32_KEY":  env.GetEnvString("IMUA_BECH32_KEY", ""),
                "IMUA_CHAIN_ID":    env.GetEnvString("IMUA_CHAIN_ID", ""),
                "IMUA_HEX_KEY":     env.GetEnvString("IMUA_HEX_KEY", ""),
                "IMUA_PRIVATE_KEY": env.GetEnvString("IMUA_PRIVATE_KEY", ""),
                "ETH_HTTP_RPC_URL": env.GetEnvString("ETH_HTTP_RPC_URL", ""),
                "ENV_FILE_PATH":    env.GetEnvString("ENV_FILE_PATH", ".env"),
        }

        // Validate required environment variables
        for key, value := range requiredEnvVars </span><span class="cov0" title="0">{
                if value == "" </span><span class="cov0" title="0">{
                        logger.Error("Required environment variable not set", "variable", key)
                        return fmt.Errorf("required environment variable %s is not set", key)
                }</span>
        }

        // Load and validate BLS private key
        <span class="cov0" title="0">blsPrivateKeyHex := requiredEnvVars["BLS_PRIVATE_KEY"]
        validatedKey, err := validateAndFixBLSKey(blsPrivateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("BLS key validation failed", "error", err)
                return fmt.Errorf("BLS key validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">blsPrivateKey, err := parseBLSPrivateKey(validatedKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse BLS private key", "error", err)
                return fmt.Errorf("failed to parse BLS private key: %w", err)
        }</span>

        // Get BLS public key
        <span class="cov0" title="0">blsPublicKey := blsPrivateKey.PublicKey()
        blsPublicKeyBytes := blsPublicKey.Marshal()
        blsPublicKeyHex := "0x" + hex.EncodeToString(blsPublicKeyBytes)

        // Create message to sign for BLS registration
        chainID := requiredEnvVars["IMUA_CHAIN_ID"]
        operatorBech32 := requiredEnvVars["IMUA_BECH32_KEY"]
        chainIDWithoutRevision := formatChainIDWithoutRevision(chainID)

        messageToSign := fmt.Sprintf("BLS12-381 Signed Message\nChainIDWithoutRevision: %s\nAccAddressBech32: %s",
                chainIDWithoutRevision, operatorBech32)

        // Hash the message using Keccak256
        messageHash := crypto.Keccak256Hash([]byte(messageToSign))

        // Sign the message hash with BLS private key
        signature := blsPrivateKey.Sign(messageHash[:])
        signatureBytes := signature.Marshal()
        signatureHex := "0x" + hex.EncodeToString(signatureBytes)

        envFilePath := requiredEnvVars["ENV_FILE_PATH"]
        err = storeSignatureInEnvFile(envFilePath, signatureHex)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to store BLS signature in .env file", "error", err)
                return fmt.Errorf("failed to store BLS signature in .env file: %w", err)
        }</span>

        // Prepare the cast command
        <span class="cov0" title="0">avsAddress := requiredEnvVars["AVS_ADDRESS"]
        operatorAddress := requiredEnvVars["IMUA_HEX_KEY"]
        privateKey := requiredEnvVars["IMUA_PRIVATE_KEY"]
        rpcUrl := requiredEnvVars["ETH_HTTP_RPC_URL"]

        castCommand := fmt.Sprintf(
                "cast send %s \"registerBLSPublicKey(address,bytes,bytes)\" %s %s %s --rpc-url %s --private-key %s --gas-limit 1000000",
                avsAddress,
                avsAddress,
                blsPublicKeyHex,
                signatureHex,
                rpcUrl,
                privateKey,
        )

        // Print the command being executed
        fmt.Println("🚀 Executing cast command:")
        fmt.Println(castCommand)
        fmt.Println("")

        // Execute the cast command
        cmd := exec.Command("bash", "-c", castCommand)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ Error executing cast command:")
                fmt.Println(string(output))
                return fmt.Errorf("failed to execute cast command: %w", err)
        }</span>

        // Print the output
        <span class="cov0" title="0">fmt.Println("✅ BLS Public Key registration successful!")
        fmt.Println("📋 Command output:")
        fmt.Println(string(output))
        fmt.Println("\n📋 Details:")
        fmt.Printf("🔑 BLS Public Key: %s\n", blsPublicKeyHex)
        fmt.Printf("🏢 Operator Address: %s\n", operatorAddress)
        fmt.Printf("📝 Message Signed: %s\n", messageToSign)
        fmt.Printf("🔐 Signature: %s\n", signatureHex)
        fmt.Printf("🌐 RPC URL: %s\n", rpcUrl)

        return nil</span>
}

func parseBLSPrivateKey(hexKey string) (bls.SecretKey, error) <span class="cov0" title="0">{
        hexKey = strings.TrimPrefix(hexKey, "0x")

        keyBytes := common.FromHex(hexKey)
        if len(keyBytes) != 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BLS private key must be 32 bytes, got %d", len(keyBytes))
        }</span>

        <span class="cov0" title="0">curveOrder := new(big.Int)
        curveOrder.SetString(BLS12381_CURVE_ORDER, 10)

        keyInt := new(big.Int).SetBytes(keyBytes)
        if keyInt.Cmp(curveOrder) &gt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key is too large for BLS12-381 curve")
        }</span>

        <span class="cov0" title="0">if keyInt.Sign() == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key cannot be zero")
        }</span>

        <span class="cov0" title="0">return bls.SecretKeyFromBytes(keyBytes)</span>
}

func validateAndFixBLSKey(currentKey string) (string, error) <span class="cov0" title="0">{
        currentKey = strings.TrimPrefix(currentKey, "0x")

        if len(currentKey) != 64 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("BLS key must be 64 hex characters, got %d", len(currentKey))
        }</span>

        <span class="cov0" title="0">keyBytes := common.FromHex(currentKey)
        if len(keyBytes) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid hex encoding")
        }</span>

        <span class="cov0" title="0">curveOrder := new(big.Int)
        curveOrder.SetString(BLS12381_CURVE_ORDER, 10)

        keyInt := new(big.Int).SetBytes(keyBytes)

        if keyInt.Cmp(curveOrder) &gt;= 0 </span><span class="cov0" title="0">{
                reducedKey := new(big.Int).Mod(keyInt, curveOrder)
                if reducedKey.Sign() == 0 </span><span class="cov0" title="0">{
                        reducedKey.SetInt64(1)
                }</span>

                <span class="cov0" title="0">reducedBytes := make([]byte, 32)
                reducedKeyBytes := reducedKey.Bytes()
                copy(reducedBytes[32-len(reducedKeyBytes):], reducedKeyBytes)

                return hex.EncodeToString(reducedBytes), nil</span>
        }

        <span class="cov0" title="0">return currentKey, nil</span>
}

func formatChainIDWithoutRevision(chainID string) string <span class="cov0" title="0">{
        lastDash := strings.LastIndex(chainID, "-")
        if lastDash == -1 </span><span class="cov0" title="0">{
                return chainID
        }</span>

        <span class="cov0" title="0">revision := chainID[lastDash+1:]
        if len(revision) &gt; 0 </span><span class="cov0" title="0">{
                for _, r := range revision </span><span class="cov0" title="0">{
                        if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                                return chainID
                        }</span>
                }
                <span class="cov0" title="0">return chainID[:lastDash]</span>
        }

        <span class="cov0" title="0">return chainID</span>
}
func storeSignatureInEnvFile(filePath, signature string) error <span class="cov0" title="0">{
        // Open the file in append mode, create if it doesn't exist
        file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open .env file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := file.Close(); cerr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close .env file: %v\n", cerr)
                }</span>
        }()

        // Check if BLS_SIGNATURE already exists in the file
        <span class="cov0" title="0">var hasSignature bool
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "BLS_SIGNATURE=") </span><span class="cov0" title="0">{
                        hasSignature = true
                        break</span>
                }
        }

        // If we found an existing signature, we should update it rather than append
        <span class="cov0" title="0">if hasSignature </span><span class="cov0" title="0">{
                // Read the entire file
                if _, err := file.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to seek to beginning of .env file: %w", err)
                }</span>
                <span class="cov0" title="0">var lines []string
                scanner = bufio.NewScanner(file)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := scanner.Text()
                        if strings.HasPrefix(line, "BLS_SIGNATURE=") </span><span class="cov0" title="0">{
                                line = "BLS_SIGNATURE=" + signature
                        }</span>
                        <span class="cov0" title="0">lines = append(lines, line)</span>
                }

                // Truncate the file and rewrite all lines
                <span class="cov0" title="0">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close .env file: %w", err)
                }</span>
                <span class="cov0" title="0">file, err = os.OpenFile(filePath, os.O_TRUNC|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to truncate .env file: %w", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if cerr := file.Close(); cerr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to close .env file: %v\n", cerr)
                        }</span>
                }()

                <span class="cov0" title="0">writer := bufio.NewWriter(file)
                for _, line := range lines </span><span class="cov0" title="0">{
                        _, err := writer.WriteString(line + "\n")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write to .env file: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">return writer.Flush()</span>
        }

        // If no existing signature, just append it
        <span class="cov0" title="0">writer := bufio.NewWriter(file)
        _, err = writer.WriteString("BLS_SIGNATURE=" + signature + "\n")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to .env file: %w", err)
        }</span>
        <span class="cov0" title="0">return writer.Flush()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func RegisterImuaOperator(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("Starting Imuachain operator registration...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Step 0: Ensure validator key exists
        <span class="cov0" title="0">log.Println("🔑 Checking validator key setup...")
        if err := EnsureValidatorKeyExists(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validator key setup failed: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("✅ Validator key is ready")

        // Check required environment variables for Imua registration
        operatorName := os.Getenv("OPERATOR_NAME")
        if operatorName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("OPERATOR_NAME environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaChainID := os.Getenv("IMUA_CHAIN_ID")
        if imuaChainID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_CHAIN_ID environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaCosGrpcURL := os.Getenv("IMUA_COS_GRPC_URL")
        if imuaCosGrpcURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_COS_GRPC_URL environment variable not set")
        }</span>

        // Get keyring password from environment
        <span class="cov0" title="0">keyringPassword := os.Getenv("KEYRING_PASSWORD")
        if keyringPassword == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("KEYRING_PASSWORD environment variable not set")
        }</span>

        <span class="cov0" title="0">log.Printf("Registering operator with the following configuration:")
        log.Printf("- Operator Name: %s", operatorName)
        log.Printf("- Home Directory: %s", imuaHomeDir)
        log.Printf("- Account Key Name: %s", imuaAccountKeyName)
        log.Printf("- Chain ID: %s", imuaChainID)
        log.Printf("- GRPC URL: %s", imuaCosGrpcURL)

        // Step 1.5: Check account balance before attempting registration
        log.Println("💰 Checking account balance before registration...")
        hasBalance, err := checkAccountHasBalance(imuaHomeDir, imuaAccountKeyName, imuaCosGrpcURL, keyringPassword)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not check account balance: %v", err)
        }</span> else<span class="cov0" title="0"> if !hasBalance </span><span class="cov0" title="0">{
                log.Println("❌ Account has insufficient IMUA tokens for gas fees")
                log.Println("")
                log.Println("🚰 To fund your account, run:")
                log.Println("   ./triggerx fund-imua-account")
                log.Println("")
                log.Println("💡 Or check your current balance:")
                log.Println("   ./triggerx check-imua-balance")
                log.Println("")
                return fmt.Errorf("account not funded with IMUA tokens - registration requires gas fees")
        }</span>
        <span class="cov0" title="0">log.Println("✅ Account has sufficient balance for registration")

        // Step 2: Register the operator
        log.Println("Step 1: Registering operator on Imuachain...")
        cmd := exec.Command("imuad",
                "tx", "operator", "register-operator",
                "--from", imuaAccountKeyName,
                "--chain-id", imuaChainID,
                "--node", imuaCosGrpcURL,
                "--gas", "150000",
                "--gas-prices", "7hua",
                "--meta-info", operatorName,
                "--commission-rate", "0.10",
                "--commission-max-rate", "0.20",
                "--commission-max-change-rate", "0.01",
                "-y", // Non-interactive flag
        )

        // Set up stdin to provide the password
        cmd.Stdin = strings.NewReader(keyringPassword + "\n")

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Operator registration command output: %s", string(output))

                // Check if it's a funding issue and provide helpful message
                if strings.Contains(string(output), "account") &amp;&amp; strings.Contains(string(output), "not found") </span><span class="cov0" title="0">{
                        log.Println("")
                        log.Println("💡 This error usually means your account is not funded with IMUA tokens.")
                        log.Println("🚰 To fund your account, run:")
                        log.Println("   ./triggerx fund-imua-account")
                        log.Println("")
                        return fmt.Errorf("account funding issue - please fund your account with IMUA tokens")
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to register operator: %v", err)</span>
        }

        <span class="cov0" title="0">log.Printf("Operator registration successful: %s", string(output))

        // Step 3: Wait a moment for the transaction to be processed
        log.Println("Waiting for transaction to be processed...")

        // Step 4: Verify operator registration
        log.Println("Step 2: Verifying operator registration...")

        // Get the operator address
        getAddrCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "keys", "show", "-a", imuaAccountKeyName,
        )

        // Provide password for address query too
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get operator address: %v", err)
        }</span>

        <span class="cov0" title="0">operatorAddr := string(addrOutput)
        operatorAddr = strings.TrimSpace(operatorAddr) // Remove trailing newline

        log.Printf("Operator address: %s", operatorAddr)

        // Query operator info
        queryCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "query", "operator", "get-operator-info",
                operatorAddr,
                "--node", imuaCosGrpcURL,
                "--output", "json",
        )

        queryOutput, err := queryCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Query output: %s", string(queryOutput))
                log.Printf("Warning: Could not verify operator registration immediately: %v", err)
                log.Println("This is often normal as transactions may take a moment to be processed and indexed.")
                log.Println("You can manually verify using:")
                log.Printf("  imuad query operator get-operator-info %s --node %s --output json", operatorAddr, imuaCosGrpcURL)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Operator registration verified: %s", string(queryOutput))
        }</span>

        <span class="cov0" title="0">log.Println("\n✅ Imuachain operator registration completed successfully!")
        log.Printf("Operator Name: %s", operatorName)
        log.Printf("Operator Address: %s", operatorAddr)

        return nil</span>
}

func checkAccountHasBalance(homeDir, keyName, grpcURL, keyringPassword string) (bool, error) <span class="cov0" title="0">{
        // Get the validator address
        getAddrCmd := exec.Command("imuad",
                "--home", homeDir,
                "keys", "show", "-a", keyName,
        )

        // Provide password for address query
        getAddrCmd.Stdin = strings.NewReader(keyringPassword + "\n")

        addrOutput, err := getAddrCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get validator address: %v", err)
        }</span>

        <span class="cov0" title="0">validatorAddr := strings.TrimSpace(string(addrOutput))

        // Check balance (balance queries don't require password)
        balanceCmd := exec.Command("imuad",
                "query", "bank", "balances", validatorAddr,
                "--node", grpcURL,
                "--output", "json",
        )

        balanceOutput, err := balanceCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to query balance: %v", err)
        }</span>

        // Parse JSON to check if there are any balances
        <span class="cov0" title="0">var balanceData struct {
                Balances []struct {
                        Denom  string `json:"denom"`
                        Amount string `json:"amount"`
                } `json:"balances"`
        }

        err = json.Unmarshal(balanceOutput, &amp;balanceData)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse balance JSON: %v", err)
        }</span>

        // Return true if there are any balances (specifically looking for IMUA or hua tokens)
        <span class="cov0" title="0">return len(balanceData.Balances) &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package actions

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"

        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func SetupImuaKeys(ctx *cli.Context) error <span class="cov0" title="0">{
        log.Println("🔑 Setting up Imuachain keys...")

        // Initialize config from environment variables
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize config: %v", err)
        }</span>

        // Check required environment variables
        <span class="cov0" title="0">imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME environment variable not set")
        }</span>

        <span class="cov0" title="0">log.Printf("Setup configuration:")
        log.Printf("- Home Directory: %s", imuaHomeDir)
        log.Printf("- Account Key Name: %s", imuaAccountKeyName)

        // Step 1: Check if imuad is available
        log.Println("\n🔍 Step 1: Checking if imuad is available...")
        _, err = exec.LookPath("imuad")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imuad binary not found in PATH. Please install imuad first")
        }</span>
        <span class="cov0" title="0">log.Println("✅ imuad binary found")

        // Step 2: Ensure home directory exists
        log.Println("\n📁 Step 2: Ensuring home directory exists...")
        if err := ensureImuaHomeDir(imuaHomeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup home directory: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("✅ Home directory ready: %s", imuaHomeDir)

        // Step 3: Check if validator key exists
        log.Println("\n🔑 Step 3: Checking if validator key exists...")
        keyExists, err := checkValidatorKeyExists(imuaHomeDir, imuaAccountKeyName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if validator key exists: %v", err)
        }</span>

        <span class="cov0" title="0">if keyExists </span><span class="cov0" title="0">{
                log.Printf("✅ Validator key '%s' already exists", imuaAccountKeyName)

                // Show the address
                getAddrCmd := exec.Command("imuad",
                        "--home", imuaHomeDir,
                        "keys", "show", "-a", imuaAccountKeyName,
                        "--keyring-backend", "test",
                )

                addrOutput, err := getAddrCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("⚠️ Could not retrieve address: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        address := strings.TrimSpace(string(addrOutput))
                        log.Printf("   Address: %s", address)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // Step 4: Create validator key
        // log.Printf("\n🚀 Step 4: Creating validator key '%s'...", imuaAccountKeyName)
        // if err := createValidatorKey(imuaHomeDir, imuaAccountKeyName); err != nil {
        //         return fmt.Errorf("failed to create validator key: %v", err)
        // }

        // log.Println("\n🎉 Imuachain key setup completed successfully!")
        // log.Println("\n📋 Summary:")
        // log.Printf("   ✅ Validator key '%s' created", imuaAccountKeyName)
        // log.Printf("   ✅ Home directory: %s", imuaHomeDir)
        // log.Println("\n💡 Next Steps:")
        // log.Println("   1. Fund your validator address with IMUA tokens from the testnet faucet")
        // log.Println("   2. Run 'triggerx register-imua-operator' to register as an operator")
        // log.Println("   3. Run 'triggerx complete-imua-registration' for full setup")

        <span class="cov0" title="0">return nil</span>
}

// ensureImuaHomeDir creates the imua home directory if it doesn't exist
func ensureImuaHomeDir(imuaHomeDir string) error <span class="cov0" title="0">{
        // Check if directory exists
        if _, err := os.Stat(imuaHomeDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Creating home directory: %s", imuaHomeDir)

                // Initialize imuad configuration
                initCmd := exec.Command("imuad", "init", "validator", "--home", imuaHomeDir)
                output, err := initCmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Init command output: %s", string(output))
                        return fmt.Errorf("failed to initialize imuad home directory: %v", err)
                }</span>

                <span class="cov0" title="0">log.Printf("Initialized imuad home directory")</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check home directory: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkValidatorKeyExists checks if the validator key already exists
func checkValidatorKeyExists(imuaHomeDir, keyName string) (bool, error) <span class="cov0" title="0">{
        listCmd := exec.Command("imuad",
                "--home", imuaHomeDir,
                "keys", "list",
                "--output", "json",
                "--keyring-backend", "test",
        )

        output, err := listCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to list keys: %v", err)
        }</span>

        <span class="cov0" title="0">outputStr := string(output)
        // Simple check - look for the key name in the JSON output
        // In production, you'd want proper JSON parsing
        return strings.Contains(outputStr, fmt.Sprintf(`"name":"%s"`, keyName)), nil</span>
}

// createValidatorKey creates a new validator key
// func createValidatorKey(imuaHomeDir, keyName string) error {
//         createCmd := exec.Command("imuad",
//                 "--home", imuaHomeDir,
//                 "keys", "add", keyName, "--keyring-backend", "test",
//         )

//         output, err := createCmd.CombinedOutput()
//         if err != nil {
//                 log.Printf("Create key command output: %s", string(output))
//                 return fmt.Errorf("failed to create validator key: %v", err)
//         }

//         log.Printf("Validator key created successfully:")
//         log.Printf("%s", string(output))

//         return nil
// }

// EnsureValidatorKeyExists is a helper function that can be called by other commands
// to ensure the validator key exists before proceeding
func EnsureValidatorKeyExists() error <span class="cov0" title="0">{
        imuaHomeDir := os.Getenv("IMUA_HOME_DIR")
        if imuaHomeDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_HOME_DIR environment variable not set")
        }</span>

        <span class="cov0" title="0">imuaAccountKeyName := os.Getenv("IMUA_ACCOUNT_KEY_NAME")
        if imuaAccountKeyName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("IMUA_ACCOUNT_KEY_NAME environment variable not set")
        }</span>

        // Check if imuad is available
        <span class="cov0" title="0">_, err := exec.LookPath("imuad")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("imuad binary not found in PATH. Please install imuad first")
        }</span>

        // Ensure home directory exists
        <span class="cov0" title="0">if err := ensureImuaHomeDir(imuaHomeDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup home directory: %v", err)
        }</span>

        // Check if key exists
        <span class="cov0" title="0">keyExists, err := checkValidatorKeyExists(imuaHomeDir, imuaAccountKeyName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check if validator key exists: %v", err)
        }</span>

        <span class="cov0" title="0">if !keyExists </span><span class="cov0" title="0">{
                log.Printf("⚠️ Validator key '%s' not found", imuaAccountKeyName)
                // log.Println("Creating validator key automatically...")

                // if err := createValidatorKey(imuaHomeDir, imuaAccountKeyName); err != nil {
                //         return fmt.Errorf("failed to create validator key: %v", err)
                // }

                // log.Printf("✅ Validator key '%s' created successfully", imuaAccountKeyName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package chainio

import (
        "cosmossdk.io/math"
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        gethcommon "github.com/ethereum/go-ethereum/common"
        "github.com/imua-xyz/imua-avs-sdk/logging"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts/TriggerXAvs"
        "github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth"
)

type AvsReader interface {
        GetOptInOperators(
                opts *bind.CallOpts,
                avsAddress string,
        ) ([]gethcommon.Address, error)

        GetRegisteredPubkey(
                opts *bind.CallOpts,
                operator string,
                avsAddress string,
        ) ([]byte, error)
        GtAVSUSDValue(
                opts *bind.CallOpts,
                avsAddress string,
        ) (math.LegacyDec, error)

        GetOperatorOptedUSDValue(
                opts *bind.CallOpts,
                avsAddress string,
                operatorAddr string,
        ) (math.LegacyDec, error)
        GetAVSEpochIdentifier(
                opts *bind.CallOpts,
                avsAddress string,
        ) (string, error)
        GetTaskInfo(
                opts *bind.CallOpts,
                avsAddress string,
                taskID uint64,
        ) (avs.TaskInfo, error)
        IsOperator(
                opts *bind.CallOpts,
                operator string,
        ) (bool, error)

        GetCurrentEpoch(
                opts *bind.CallOpts,
                epochIdentifier string,
        ) (int64, error)
        GetChallengeInfo(
                opts *bind.CallOpts,
                taskAddress string,
                taskID uint64,
        ) (gethcommon.Address, error)
        GetOperatorTaskResponse(
                opts *bind.CallOpts,
                taskAddress string,
                operatorAddress string,
                taskID uint64,
        ) (avs.TaskResultInfo, error)
        GetOperatorTaskResponseList(
                opts *bind.CallOpts,
                taskAddress string,
                taskID uint64,
        ) ([]avs.OperatorResInfo, error)
}

type ChainReader struct {
        logger     logging.Logger
        avsManager avs.TriggerXAvs
        ethClient  eth.EthClient
}

// forces EthReader to implement the chainio.Reader interface
var _ AvsReader = (*ChainReader)(nil)

func NewChainReader(
        avsManager avs.TriggerXAvs,
        logger logging.Logger,
        ethClient eth.EthClient,
) *ChainReader <span class="cov0" title="0">{
        return &amp;ChainReader{
                avsManager: avsManager,
                logger:     logger,
                ethClient:  ethClient,
        }
}</span>

func BuildChainReader(
        avsAddr gethcommon.Address,
        ethClient eth.EthClient,
        logger logging.Logger,
) (*ChainReader, error) <span class="cov0" title="0">{
        contractBindings, err := NewContractBindings(
                avsAddr,
                ethClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewChainReader(
                *contractBindings.AVSManager,
                logger,
                ethClient,
        ), nil</span>
}

func (r *ChainReader) GetOptInOperators(
        opts *bind.CallOpts,
        avsAddress string,
) ([]gethcommon.Address, error) <span class="cov0" title="0">{
        operators, err := r.avsManager.GetOptInOperators(
                opts,
                gethcommon.HexToAddress(avsAddress))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetOptInOperators ", "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return operators, nil</span>
}

func (r *ChainReader) GetRegisteredPubkey(opts *bind.CallOpts, operator string, avsAddress string) ([]byte, error) <span class="cov0" title="0">{
        pukKey, err := r.avsManager.GetRegisteredPubkey(
                opts,
                gethcommon.HexToAddress(operator), gethcommon.HexToAddress(avsAddress))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetRegisteredPubkey ", "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return pukKey, nil</span>
}

func (r *ChainReader) GtAVSUSDValue(opts *bind.CallOpts, avsAddress string) (math.LegacyDec, error) <span class="cov0" title="0">{
        amount, err := r.avsManager.GetAVSUSDValue(
                opts,
                gethcommon.HexToAddress(avsAddress))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GtAVSUSDValue ", "err", err)
                return math.LegacyDec{}, err
        }</span>
        <span class="cov0" title="0">return math.LegacyNewDecFromBigInt(amount), nil</span>
}

func (r *ChainReader) GetOperatorOptedUSDValue(opts *bind.CallOpts, avsAddress string, operatorAddr string) (math.LegacyDec, error) <span class="cov0" title="0">{
        amount, err := r.avsManager.GetOperatorOptedUSDValue(
                opts,
                gethcommon.HexToAddress(avsAddress), gethcommon.HexToAddress(operatorAddr))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetOperatorOptedUSDValue ", "err", err)
                return math.LegacyDec{}, err
        }</span>
        <span class="cov0" title="0">return math.LegacyNewDecFromBigInt(amount), nil</span>
}

func (r *ChainReader) GetAVSEpochIdentifier(opts *bind.CallOpts, avsAddress string) (string, error) <span class="cov0" title="0">{
        epochIdentifier, err := r.avsManager.GetAVSEpochIdentifier(
                opts,
                gethcommon.HexToAddress(avsAddress))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetAVSEpochIdentifier ", "err", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return epochIdentifier, nil</span>
}
func (r *ChainReader) GetTaskInfo(opts *bind.CallOpts, avsAddress string, taskID uint64) (avs.TaskInfo, error) <span class="cov0" title="0">{
        info, err := r.avsManager.GetTaskInfo(
                opts,
                gethcommon.HexToAddress(avsAddress), taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetTaskInfo ", "err", err)
                return avs.TaskInfo{}, err
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

func (r *ChainReader) IsOperator(opts *bind.CallOpts, operator string) (bool, error) <span class="cov0" title="0">{
        flag, err := r.avsManager.IsOperator(
                opts,
                gethcommon.HexToAddress(operator))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return flag, nil</span>
}
func (r *ChainReader) GetCurrentEpoch(opts *bind.CallOpts, epochIdentifier string) (int64, error) <span class="cov0" title="0">{
        currentEpoch, err := r.avsManager.GetCurrentEpoch(
                opts,
                epochIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return currentEpoch, nil</span>
}
func (r *ChainReader) GetChallengeInfo(opts *bind.CallOpts, taskAddress string, taskID uint64) (gethcommon.Address, error) <span class="cov0" title="0">{
        address, err := r.avsManager.GetChallengeInfo(
                opts,
                gethcommon.HexToAddress(taskAddress),
                taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return gethcommon.Address{}, err
        }</span>
        <span class="cov0" title="0">return address, nil</span>
}

func (r *ChainReader) GetOperatorTaskResponse(opts *bind.CallOpts, taskAddress string, operatorAddress string, taskID uint64) (avs.TaskResultInfo, error) <span class="cov0" title="0">{
        res, err := r.avsManager.GetOperatorTaskResponse(
                opts,
                gethcommon.HexToAddress(taskAddress),
                gethcommon.HexToAddress(operatorAddress),
                taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return avs.TaskResultInfo{}, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func (r *ChainReader) GetOperatorTaskResponseList(opts *bind.CallOpts, taskAddress string, taskID uint64) ([]avs.OperatorResInfo, error) <span class="cov0" title="0">{
        res, err := r.avsManager.GetOperatorTaskResponseList(
                opts,
                gethcommon.HexToAddress(taskAddress),
                taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return []avs.OperatorResInfo{}, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package chainio

import (
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/event"

        "github.com/imua-xyz/imua-avs-sdk/logging"
        avssub "github.com/trigg3rX/imua-contracts/bindings/contracts/TriggerXAvs"
        "github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth"
)

type AvsRegistrySubscriber interface {
        SubscribeToNewTasks(newTaskCreatedChan chan *avssub.TriggerXAvsTaskCreated) event.Subscription
}

type AvsRegistryChainSubscriber struct {
        logger logging.Logger
        avssub avssub.TriggerXAvs
}

// forces EthSubscriber to implement the chainio.Subscriber interface
var _ AvsRegistrySubscriber = (*AvsRegistryChainSubscriber)(nil)

func NewAvsRegistryChainSubscriber(
        avssub avssub.TriggerXAvs,
        logger logging.Logger,
) (*AvsRegistryChainSubscriber, error) <span class="cov0" title="0">{
        return &amp;AvsRegistryChainSubscriber{
                logger: logger,
                avssub: avssub,
        }, nil
}</span>

func BuildAvsRegistryChainSubscriber(
        avssubAddr common.Address,
        ethWsClient eth.EthClient,
        logger logging.Logger,
) (*AvsRegistryChainSubscriber, error) <span class="cov0" title="0">{
        avssub, err := avssub.NewTriggerXAvs(avssubAddr, ethWsClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create BLSApkRegistry contract", "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewAvsRegistryChainSubscriber(*avssub, logger)</span>
}

func (s *AvsRegistryChainSubscriber) SubscribeToNewTasks(newTaskCreatedChan chan *avssub.TriggerXAvsTaskCreated) event.Subscription <span class="cov0" title="0">{
        sub, err := s.avssub.WatchTaskCreated(
                &amp;bind.WatchOpts{}, newTaskCreatedChan, []uint64{},
        )
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to subscribe to new  tasks", "err", err)
        }</span>
        <span class="cov0" title="0">s.logger.Infof("Subscribed to new TaskManager tasks")
        return sub</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package chainio

import (
        "context"
        "errors"

        gethcommon "github.com/ethereum/go-ethereum/common"
        gethtypes "github.com/ethereum/go-ethereum/core/types"
        "github.com/imua-xyz/imua-avs-sdk/client/txmgr"
        "github.com/imua-xyz/imua-avs-sdk/logging"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts/TriggerXAvs"
        "github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth"
)

type AvsWriter interface {
        RegisterAVSToChain(
                ctx context.Context,
                params avs.AVSParams,
        ) (*gethtypes.Receipt, error)

        RegisterBLSPublicKey(
                ctx context.Context,
                avsAddr string,
                pubKey []byte,
                pubKeyRegistrationSignature []byte,
        ) (*gethtypes.Receipt, error)

        CreateNewTask(
                ctx context.Context,
                name string,
                numberToBeSquared uint8,
                taskResponsePeriod uint64,
                taskChallengePeriod uint64,
                thresholdPercentage uint8,
                taskStatisticalPeriod uint64,
        ) (*gethtypes.Receipt, error)

        OperatorSubmitTask(
                ctx context.Context,
                taskID uint64,
                taskResponse []byte,
                blsSignature []byte,
                taskContractAddress string,
                phase uint8,
        ) (*gethtypes.Receipt, error)

        // Challenge(
        //         ctx context.Context,
        //         req avs.AvsServiceContractChallengeReq,
        // ) (*gethtypes.Receipt, error)

        RegisterOperatorToAVS(
                ctx context.Context,
        ) (*gethtypes.Receipt, error)
}

type ChainWriter struct {
        avsManager  avs.TriggerXAvs
        chainReader AvsReader
        ethClient   eth.EthClient
        logger      logging.Logger
        txMgr       txmgr.TxManager
}

var _ AvsWriter = (*ChainWriter)(nil)

func NewChainWriter(
        avsManager avs.TriggerXAvs,
        chainReader AvsReader,
        ethClient eth.EthClient,
        logger logging.Logger,
        txMgr txmgr.TxManager,
) *ChainWriter <span class="cov0" title="0">{
        return &amp;ChainWriter{
                avsManager:  avsManager,
                chainReader: chainReader,
                logger:      logger,
                ethClient:   ethClient,
                txMgr:       txMgr,
        }
}</span>

func BuildChainWriter(
        avsAddr gethcommon.Address,
        ethClient eth.EthClient,
        logger logging.Logger,
        txMgr txmgr.TxManager,
) (*ChainWriter, error) <span class="cov0" title="0">{
        contractBindings, err := NewContractBindings(
                avsAddr,
                ethClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">chainReader := NewChainReader(
                *contractBindings.AVSManager,
                logger,
                ethClient,
        )
        return NewChainWriter(
                *contractBindings.AVSManager,
                chainReader,
                ethClient,
                logger,
                txMgr,
        ), nil</span>
}

func (w *ChainWriter) RegisterAVSToChain(
        ctx context.Context,
        params avs.AVSParams,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{

        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.RegisterAVS(
                noSendTxOpts,
                params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}
func (w *ChainWriter) RegisterBLSPublicKey(
        ctx context.Context,
        avsAddr string,
        pubKey []byte,
        pubKeyRegistrationSignature []byte,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.RegisterBLSPublicKey(
                noSendTxOpts,
                gethcommon.HexToAddress(avsAddr),
                pubKey,
                pubKeyRegistrationSignature)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}
func (w *ChainWriter) CreateNewTask(
        ctx context.Context,
        name string,
        numberToBeSquared uint8,
        taskResponsePeriod uint64,
        taskChallengePeriod uint64,
        thresholdPercentage uint8,
        taskStatisticalPeriod uint64,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.CreateTask(
                noSendTxOpts,
                name,
                numberToBeSquared,
                taskResponsePeriod,
                taskChallengePeriod,
                thresholdPercentage,
                taskStatisticalPeriod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}

func (w *ChainWriter) OperatorSubmitTask(
        ctx context.Context,
        taskID uint64,
        taskResponse []byte,
        blsSignature []byte,
        taskContractAddress string,
        phase uint8,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.OperatorSubmitTask(
                noSendTxOpts,
                taskID,
                taskResponse,
                blsSignature,
                gethcommon.HexToAddress(taskContractAddress),
                phase)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}

// func (w *ChainWriter) Challenge(ctx context.Context, req avs.AvsServiceContractChallengeReq) (*gethtypes.Receipt, error) {
//         noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
//         if err != nil {
//                 return nil, err
//         }
//         tx, err := w.avsManager.RaiseAndResolveChallenge(
//                 noSendTxOpts,
//                 req)
//         if err != nil {
//                 return nil, err
//         }
//         receipt, err := w.txMgr.Send(ctx, tx)
//         if err != nil {
//                 return nil, errors.New("failed to send tx with err: " + err.Error())
//         }
//         w.logger.Infof("tx hash: %s", tx.Hash().String())

//         return receipt, nil
// }

func (w *ChainWriter) RegisterOperatorToAVS(
        ctx context.Context,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.RegisterOperatorToAVS(
                noSendTxOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}

// func DeployAVS(
//         ethClient eth.EthClient,
//         logger logging.Logger,
//         key ecdsa.PrivateKey,
//         chainID *big.Int,
// ) (gethcommon.Address, string, error) {
//         auth, err := bind.NewKeyedTransactorWithChainID(&amp;key, chainID)
//         if err != nil {
//                 logger.Fatalf("Failed to make transactor: %v", err)
//         }

//         address, tx, _, err := avs.DeployContracttriggerX(auth, ethClient)
//         if err != nil {
//                 logger.Infof("deploy err: %s", err.Error())
//                 return gethcommon.Address{}, "", errors.New("failed to deploy contract with err: " + err.Error())
//         }
//         logger.Infof("tx hash: %s", tx.Hash().String())
//         logger.Infof("contract address: %s", address.String())

//         return address, tx.Hash().String(), nil
// }
</pre>
		
		<pre class="file" id="file13" style="display: none">package chainio

import (
        gethcommon "github.com/ethereum/go-ethereum/common"
        "github.com/imua-xyz/imua-avs-sdk/logging"

        avs "github.com/trigg3rX/imua-contracts/bindings/contracts/TriggerXAvs"
        "github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth"
)

type ContractBindings struct {
        AvsAddr    gethcommon.Address
        AVSManager *avs.TriggerXAvs
}

func NewContractBindings(
        avsAddr gethcommon.Address,
        ethclient eth.EthClient,
        logger logging.Logger,
) (*ContractBindings, error) <span class="cov0" title="0">{
        contractAvsManager, err := avs.NewTriggerXAvs(avsAddr, ethclient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to fetch Avs contract", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ContractBindings{
                AvsAddr:    avsAddr,
                AVSManager: contractAvsManager,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package chainio

import (
        gethcommon "github.com/ethereum/go-ethereum/common"
        "github.com/imua-xyz/imua-avs-sdk/client/txmgr"
        "github.com/imua-xyz/imua-avs-sdk/logging"
        "github.com/imua-xyz/imua-avs-sdk/signer"
        "github.com/trigg3rX/triggerx-backend/cli/core/chainio/eth"
)

type BuildAllConfig struct {
        EthHttpUrl string
        EthWsUrl   string
        AvsAddr    string
        AvsName    string
}

type Clients struct {
        AvsRegistryChainSubscriber *AvsRegistryChainSubscriber
        ChainReader                *ChainReader
        ChainWriter                *ChainWriter
        EthHttpClient              *eth.Client
        EthWsClient                *eth.Client
}

func BuildAll(
        config BuildAllConfig,
        signerAddr gethcommon.Address,
        signerFn signer.SignerFn,
        logger logging.Logger,
) (*Clients, error) <span class="cov0" title="0">{
        config.validate(logger)

        // creating two types of Eth clients: HTTP and WS
        ethHttpClient, err := eth.NewClient(config.EthHttpUrl)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create Eth Http client", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">ethWsClient, err := eth.NewClient(config.EthWsUrl)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create Eth WS client", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">txMgr := txmgr.NewSimpleTxManager(ethHttpClient, logger, signerFn, signerAddr)
        // creating  clients: Reader, Writer and Subscriber
        chainReader, chainWriter, avsRegistrySubscriber, err := config.buildClients(
                ethHttpClient,
                txMgr,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create Reader, Writer and Subscriber", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Clients{
                ChainReader:                chainReader,
                ChainWriter:                chainWriter,
                AvsRegistryChainSubscriber: avsRegistrySubscriber,
                EthHttpClient:              ethHttpClient,
                EthWsClient:                ethWsClient,
        }, nil</span>

}

func (config *BuildAllConfig) buildClients(
        ethHttpClient eth.EthClient,
        txMgr txmgr.TxManager,
        logger logging.Logger,
) (*ChainReader, *ChainWriter, *AvsRegistryChainSubscriber, error) <span class="cov0" title="0">{
        contractBindings, err := NewContractBindings(
                gethcommon.HexToAddress(config.AvsAddr),
                ethHttpClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ContractBindings", "err", err)
                return nil, nil, nil, err
        }</span>

        // get the Reader for the chain contracts
        <span class="cov0" title="0">chainReader := NewChainReader(
                *contractBindings.AVSManager,
                logger,
                ethHttpClient,
        )

        chainWriter := NewChainWriter(
                *contractBindings.AVSManager,
                chainReader,
                ethHttpClient,
                logger,
                txMgr,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ChainWriter", "err", err)
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">avsRegistrySubscriber, err := BuildAvsRegistryChainSubscriber(
                contractBindings.AvsAddr,
                ethHttpClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create ChainSubscriber", "err", err)
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">return chainReader, chainWriter, avsRegistrySubscriber, err</span>
}

// Very basic validation that makes sure all fields are nonempty
// we might eventually want more sophisticated validation, based on regexp,
// or use something like https://json-schema.org/ (?)
func (config *BuildAllConfig) validate(logger logging.Logger) <span class="cov0" title="0">{
        if config.EthHttpUrl == "" </span><span class="cov0" title="0">{
                logger.Fatalf("BuildAllConfig.validate: Missing eth http url")
        }</span>
        <span class="cov0" title="0">if config.EthWsUrl == "" </span><span class="cov0" title="0">{
                logger.Fatalf("BuildAllConfig.validate: Missing eth ws url")
        }</span>
        <span class="cov0" title="0">if config.AvsAddr == "" </span><span class="cov0" title="0">{
                logger.Fatalf("BuildAllConfig.validate: Missing bls registry coordinator address")
        }</span>
        <span class="cov0" title="0">if config.AvsName == "" </span><span class="cov0" title="0">{
                logger.Fatalf("BuildAllConfig.validate: Missing avs name")
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package eth

import (
        "context"
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
)

type gethClient interface {
        ChainID(ctx context.Context) (*big.Int, error)
        BalanceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error)
        BlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error)
        BlockByNumber(ctx context.Context, number *big.Int) (*types.Block, error)
        BlockNumber(ctx context.Context) (uint64, error)
        CallContract(ctx context.Context, msg ethereum.CallMsg, blockNumber *big.Int) ([]byte, error)
        CallContractAtHash(ctx context.Context, msg ethereum.CallMsg, blockHash common.Hash) ([]byte, error)
        CodeAt(ctx context.Context, account common.Address, blockNumber *big.Int) ([]byte, error)
        EstimateGas(ctx context.Context, msg ethereum.CallMsg) (uint64, error)
        FeeHistory(
                ctx context.Context,
                blockCount uint64,
                lastBlock *big.Int,
                rewardPercentiles []float64,
        ) (*ethereum.FeeHistory, error)
        FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error)
        HeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error)
        HeaderByNumber(ctx context.Context, number *big.Int) (*types.Header, error)
        NetworkID(ctx context.Context) (*big.Int, error)
        NonceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (uint64, error)
        PeerCount(ctx context.Context) (uint64, error)
        PendingBalanceAt(ctx context.Context, account common.Address) (*big.Int, error)
        PendingCallContract(ctx context.Context, msg ethereum.CallMsg) ([]byte, error)
        PendingCodeAt(ctx context.Context, account common.Address) ([]byte, error)
        PendingNonceAt(ctx context.Context, account common.Address) (uint64, error)
        PendingStorageAt(ctx context.Context, account common.Address, key common.Hash) ([]byte, error)
        PendingTransactionCount(ctx context.Context) (uint, error)
        SendTransaction(ctx context.Context, tx *types.Transaction) error
        StorageAt(ctx context.Context, account common.Address, key common.Hash, blockNumber *big.Int) ([]byte, error)
        SubscribeFilterLogs(ctx context.Context, q ethereum.FilterQuery, ch chan&lt;- types.Log) (ethereum.Subscription, error)
        SubscribeNewHead(ctx context.Context, ch chan&lt;- *types.Header) (ethereum.Subscription, error)
        SuggestGasPrice(ctx context.Context) (*big.Int, error)
        SuggestGasTipCap(ctx context.Context) (*big.Int, error)
        SyncProgress(ctx context.Context) (*ethereum.SyncProgress, error)
        TransactionByHash(ctx context.Context, hash common.Hash) (tx *types.Transaction, isPending bool, err error)
        TransactionCount(ctx context.Context, blockHash common.Hash) (uint, error)
        TransactionInBlock(ctx context.Context, blockHash common.Hash, index uint) (*types.Transaction, error)
        TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error)
        TransactionSender(ctx context.Context, tx *types.Transaction, block common.Hash, index uint) (common.Address, error)
}

// EthClient is modified interface with additional custom methods
type EthClient interface {
        gethClient

        WaitForTransactionReceipt(
                ctx context.Context,
                txHash common.Hash,
        ) *types.Receipt
}

// Client is a wrapper around geth's ethclient.Client struct, that adds a WaitForTransactionReceipt convenience method.
type Client struct {
        *ethclient.Client
}

var _ EthClient = (*Client)(nil)

func NewClient(rpcAddress string) (*Client, error) <span class="cov0" title="0">{
        client, err := ethclient.Dial(rpcAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{client}, nil</span>
}

func (e *Client) WaitForTransactionReceipt(
        ctx context.Context,
        txHash common.Hash,
) *types.Receipt <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                // verifying transaction receipt
                receipt, err := e.TransactionReceipt(ctx, txHash)
                if err != nil </span><span class="cov0" title="0">{
                        time.Sleep(2 * time.Second)
                }</span> else<span class="cov0" title="0"> {
                        return receipt
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "crypto/ecdsa"
        "fmt"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/joho/godotenv"
        "github.com/trigg3rX/triggerx-backend/pkg/env"

        blscommon "github.com/prysmaticlabs/prysm/v5/crypto/bls/common"
)

type Config struct {
        // Private Keys
        ecdsaPrivateKey          *ecdsa.PrivateKey
        blsPrivateKey            *blscommon.SecretKey
        ecdsaPrivateKeyStorePath string
        blsPrivateKeyStorePath   string

        // RPC URLs
        ethHttpRpcUrl string
        ethWsRpcUrl   string

        // Operator and AVS Configuration
        operatorAddress common.Address
        avsOwnerAddress common.Address
        avsAddress      common.Address

        // API Configuration
        nodeApiIpPortAddress string
        enableNodeApi        bool

        // Other Configuration
        production bool
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>

        // ECDSA Private Key
        <span class="cov0" title="0">ecdsaPrivateKeyStr := env.GetEnvString("OPERATOR_PRIVATE_KEY", "")
        ecdsaPrivateKey, err := crypto.HexToECDSA(ecdsaPrivateKeyStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error converting private key to ECDSA: %w", err)
        }</span>

        // BLS Private Key - check if environment variable exists but don't load it here
        // The operator will handle BLS key loading using the appropriate library
        <span class="cov0" title="0">blsPrivateKeyStr := env.GetEnvString("BLS_PRIVATE_KEY", "")
        var blsPrivateKey *blscommon.SecretKey
        // Note: BLS key loading is handled in the operator using the imua-avs-sdk library
        // We just track whether the environment variable is available
        if blsPrivateKeyStr != "" </span><span class="cov0" title="0">{
                // BLS private key is available in environment, operator will load it
                blsPrivateKey = nil
        }</span>

        // ECDSA Private Key Store Path
        <span class="cov0" title="0">ecdsaPrivateKeyStorePath := env.GetEnvString("ECDSA_PRIVATE_KEY_STORE_PATH", "")

        // BLS Private Key Store Path
        blsPrivateKeyStorePath := env.GetEnvString("BLS_PRIVATE_KEY_STORE_PATH", "")

        // RPC URLs
        ethHttpRpcUrl := env.GetEnvString("ETH_HTTP_RPC_URL", "")
        ethWsRpcUrl := env.GetEnvString("ETH_WS_RPC_URL", "")

        // Operator and AVS Configuration
        operatorAddressStr := env.GetEnvString("OPERATOR_ADDRESS", "")
        var operatorAddress common.Address
        if operatorAddressStr != "" </span><span class="cov0" title="0">{
                operatorAddress = common.HexToAddress(operatorAddressStr)
        }</span> else<span class="cov0" title="0"> {
                // Derive from private key if not provided
                operatorAddress = crypto.PubkeyToAddress(ecdsaPrivateKey.PublicKey)
        }</span>

        <span class="cov0" title="0">avsOwnerAddressStr := env.GetEnvString("AVS_OWNER_ADDRESS", "")
        var avsOwnerAddress common.Address
        if avsOwnerAddressStr != "" </span><span class="cov0" title="0">{
                avsOwnerAddress = common.HexToAddress(avsOwnerAddressStr)
        }</span>

        <span class="cov0" title="0">avsAddressStr := env.GetEnvString("AVS_ADDRESS", "")
        var avsAddress common.Address
        if avsAddressStr != "" </span><span class="cov0" title="0">{
                avsAddress = common.HexToAddress(avsAddressStr)
        }</span>

        // API Configuration
        <span class="cov0" title="0">nodeApiIpPortAddress := env.GetEnvString("NODE_API_IP_PORT_ADDRESS", "")
        enableNodeApi := env.GetEnvString("ENABLE_NODE_API", "false") == "true"

        // Other Configuration
        production := env.GetEnvString("PRODUCTION", "false") == "true"

        cfg = Config{
                ecdsaPrivateKey:          ecdsaPrivateKey,
                blsPrivateKey:            blsPrivateKey,
                ecdsaPrivateKeyStorePath: ecdsaPrivateKeyStorePath,
                blsPrivateKeyStorePath:   blsPrivateKeyStorePath,
                ethHttpRpcUrl:            ethHttpRpcUrl,
                ethWsRpcUrl:              ethWsRpcUrl,
                operatorAddress:          operatorAddress,
                avsOwnerAddress:          avsOwnerAddress,
                avsAddress:               avsAddress,
                nodeApiIpPortAddress:     nodeApiIpPortAddress,
                enableNodeApi:            enableNodeApi,
                production:               production,
        }
        return nil</span>
}

func GetEcdsaPrivateKey() *ecdsa.PrivateKey <span class="cov0" title="0">{
        return cfg.ecdsaPrivateKey
}</span>

func GetEcdsaPrivateKeyStorePath() string <span class="cov0" title="0">{
        return cfg.ecdsaPrivateKeyStorePath
}</span>

func GetBlsPrivateKeyStorePath() string <span class="cov0" title="0">{
        return cfg.blsPrivateKeyStorePath
}</span>

func GetEthHttpRpcUrl() string <span class="cov0" title="0">{
        return cfg.ethHttpRpcUrl
}</span>

func GetEthWsRpcUrl() string <span class="cov0" title="0">{
        return cfg.ethWsRpcUrl
}</span>

func GetOperatorAddress() common.Address <span class="cov0" title="0">{
        return cfg.operatorAddress
}</span>

func GetAvsOwnerAddress() common.Address <span class="cov0" title="0">{
        return cfg.avsOwnerAddress
}</span>

func GetAvsAddress() common.Address <span class="cov0" title="0">{
        return cfg.avsAddress
}</span>

func GetNodeApiIpPortAddress() string <span class="cov0" title="0">{
        return cfg.nodeApiIpPortAddress
}</span>

func GetEnableNodeApi() bool <span class="cov0" title="0">{
        return cfg.enableNodeApi
}</span>

func GetProduction() bool <span class="cov0" title="0">{
        return cfg.production
}</span>

func HasBLSPrivateKeyInEnv() bool <span class="cov0" title="0">{
        return env.GetEnvString("BLS_PRIVATE_KEY", "") != ""
}</span>

func GetBLSPrivateKeyHex() string <span class="cov0" title="0">{
        return env.GetEnvString("BLS_PRIVATE_KEY", "")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package core

import (
        "bufio"
        "crypto/aes"
        "crypto/cipher"
        "crypto/ecdsa"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "syscall"

        "github.com/ethereum/go-ethereum/crypto"
        "github.com/google/uuid"
        "github.com/prysmaticlabs/prysm/v5/crypto/bls"
        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/term"
)

// BLS EIP-2335 keystore structure
type BLSCrypto struct {
        Cipher       string                 `json:"cipher"`
        CipherText   string                 `json:"ciphertext"`
        CipherParams map[string]string      `json:"cipherparams"`
        KDF          string                 `json:"kdf"`
        KDFParams    map[string]interface{} `json:"kdfparams"`
        MAC          string                 `json:"mac"`
}

type BLSKeystore struct {
        Crypto  BLSCrypto `json:"crypto"`
        PubKey  string    `json:"pubkey"`
        Path    string    `json:"path"`
        ID      string    `json:"uuid"`
        Version int       `json:"version"`
}

// ECDSA keystore structure
type Crypto struct {
        Cipher       string                 `json:"cipher"`
        CipherText   string                 `json:"ciphertext"`
        CipherParams map[string]string      `json:"cipherparams"`
        KDF          string                 `json:"kdf"`
        KDFParams    map[string]interface{} `json:"kdfparams"`
        MAC          string                 `json:"mac"`
}

type Keystore struct {
        Address string `json:"address,omitempty"`
        Crypto  Crypto `json:"crypto"`
        ID      string `json:"id"`
        Version int    `json:"version"`
}

// getPasswordSecurely prompts for password input without echoing to terminal
func getPasswordSecurely(prompt string) (string, error) <span class="cov0" title="0">{
        fmt.Print(prompt)

        // Get the file descriptor for stdin
        fd := int(syscall.Stdin)

        // Check if we're running in a terminal
        if term.IsTerminal(fd) </span><span class="cov0" title="0">{
                // Read password without echo
                bytePassword, err := term.ReadPassword(fd)
                fmt.Println() // Add newline after password input
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(string(bytePassword)), nil</span>
        } else<span class="cov0" title="0"> {
                // Fallback for non-terminal input (testing, etc.)
                reader := bufio.NewReader(os.Stdin)
                password, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read password: %w", err)
                }</span>
                <span class="cov0" title="0">return strings.TrimSpace(password), nil</span>
        }
}

// confirmPassword prompts for password confirmation
func confirmPassword(password string) error <span class="cov0" title="0">{
        confirmPassword, err := getPasswordSecurely("Confirm password: ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if password != confirmPassword </span><span class="cov0" title="0">{
                return fmt.Errorf("passwords do not match")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// encryptBLS implements EIP-2335 encryption for BLS keystores
func encryptBLS(privateKeyBytes []byte, password string) (BLSKeystore, error) <span class="cov0" title="0">{
        // Generate random salt and IV
        salt := make([]byte, 32)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return BLSKeystore{}, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">iv := make([]byte, 16)
        _, err = rand.Read(iv)
        if err != nil </span><span class="cov0" title="0">{
                return BLSKeystore{}, fmt.Errorf("failed to generate IV: %w", err)
        }</span>

        // Derive encryption key using PBKDF2
        <span class="cov0" title="0">dkLen := 32
        iterations := 262144
        key := pbkdf2.Key([]byte(password), salt, iterations, dkLen, sha256.New)

        // Split key into encryption key and MAC key
        encryptionKey := key[:16] // AES-128
        macKey := key[16:]

        // Encrypt private key using AES-128-CTR
        block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return BLSKeystore{}, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">stream := cipher.NewCTR(block, iv)
        ciphertext := make([]byte, len(privateKeyBytes))
        stream.XORKeyStream(ciphertext, privateKeyBytes)

        // Calculate MAC
        macData := append(macKey, ciphertext...)
        mac := hmac.New(sha256.New, macKey)
        mac.Write(macData)
        macSum := mac.Sum(nil)

        // Generate public key
        secretKey, err := bls.SecretKeyFromBytes(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return BLSKeystore{}, fmt.Errorf("failed to create secret key: %w", err)
        }</span>
        <span class="cov0" title="0">publicKey := secretKey.PublicKey().Marshal()

        // Create keystore structure
        keystore := BLSKeystore{
                Crypto: BLSCrypto{
                        Cipher:     "aes-128-ctr",
                        CipherText: hex.EncodeToString(ciphertext),
                        CipherParams: map[string]string{
                                "iv": hex.EncodeToString(iv),
                        },
                        KDF: "pbkdf2",
                        KDFParams: map[string]interface{}{
                                "dklen": dkLen,
                                "c":     iterations,
                                "prf":   "hmac-sha256",
                                "salt":  hex.EncodeToString(salt),
                        },
                        MAC: hex.EncodeToString(macSum),
                },
                PubKey:  hex.EncodeToString(publicKey),
                Path:    "m/12381/3600/0/0",
                ID:      uuid.New().String(),
                Version: 4,
        }

        return keystore, nil</span>
}

// decryptBLS implements EIP-2335 decryption for BLS keystores
func decryptBLS(keystore BLSKeystore, password string) ([]byte, error) <span class="cov0" title="0">{
        // Parse parameters
        salt, err := hex.DecodeString(keystore.Crypto.KDFParams["salt"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode salt: %w", err)
        }</span>

        <span class="cov0" title="0">iv, err := hex.DecodeString(keystore.Crypto.CipherParams["iv"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode IV: %w", err)
        }</span>

        <span class="cov0" title="0">ciphertext, err := hex.DecodeString(keystore.Crypto.CipherText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode ciphertext: %w", err)
        }</span>

        <span class="cov0" title="0">expectedMAC, err := hex.DecodeString(keystore.Crypto.MAC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode MAC: %w", err)
        }</span>

        // Derive key using same parameters
        <span class="cov0" title="0">dkLen := int(keystore.Crypto.KDFParams["dklen"].(float64))
        iterations := int(keystore.Crypto.KDFParams["c"].(float64))
        key := pbkdf2.Key([]byte(password), salt, iterations, dkLen, sha256.New)

        // Split key
        encryptionKey := key[:16]
        macKey := key[16:]

        // Verify MAC
        macData := append(macKey, ciphertext...)
        mac := hmac.New(sha256.New, macKey)
        mac.Write(macData)
        calculatedMAC := mac.Sum(nil)

        if !hmac.Equal(expectedMAC, calculatedMAC) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid password or corrupted keystore")
        }</span>

        // Decrypt
        <span class="cov0" title="0">block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">stream := cipher.NewCTR(block, iv)
        plaintext := make([]byte, len(ciphertext))
        stream.XORKeyStream(plaintext, ciphertext)

        return plaintext, nil</span>
}

// GenerateBLSKeystore creates an encrypted BLS keystore in EIP-2335 format
func GenerateBLSKeystore(keystorePath string) (string, error) <span class="cov0" title="0">{
        // Generate random 32 bytes for the private key scalar
        privateKeyBytes := make([]byte, 32)
        _, err := rand.Read(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Get password for encryption
        <span class="cov0" title="0">password, err := getPasswordSecurely("Enter password for BLS keystore: ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get password: %w", err)
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("password must be at least 8 characters long")
        }</span>

        // Confirm password
        <span class="cov0" title="0">if err := confirmPassword(password); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create encrypted keystore
        <span class="cov0" title="0">keystore, err := encryptBLS(privateKeyBytes, password)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt keystore: %w", err)
        }</span>

        // Write keystore to file
        <span class="cov0" title="0">keystoreJSON, err := json.MarshalIndent(keystore, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal keystore: %w", err)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(keystorePath, keystoreJSON, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write keystore file: %w", err)
        }</span>

        // Return the private key hex for reference
        <span class="cov0" title="0">return hex.EncodeToString(privateKeyBytes), nil</span>
}

// GenerateBLSKeystoreFromExistingKey creates an encrypted BLS keystore from an existing private key
func GenerateBLSKeystoreFromExistingKey(keystorePath, privateKeyHex string) error <span class="cov0" title="0">{
        // Remove 0x prefix if present
        if len(privateKeyHex) &gt;= 2 &amp;&amp; privateKeyHex[:2] == "0x" </span><span class="cov0" title="0">{
                privateKeyHex = privateKeyHex[2:]
        }</span>

        // Decode private key bytes
        <span class="cov0" title="0">privateKeyBytes, err := hex.DecodeString(privateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode private key hex: %w", err)
        }</span>

        // Get password for encryption
        <span class="cov0" title="0">password, err := getPasswordSecurely("Enter password for BLS keystore: ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get password: %w", err)
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        // Confirm password
        <span class="cov0" title="0">if err := confirmPassword(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create encrypted keystore
        <span class="cov0" title="0">keystore, err := encryptBLS(privateKeyBytes, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt keystore: %w", err)
        }</span>

        // Write keystore to file
        <span class="cov0" title="0">keystoreJSON, err := json.MarshalIndent(keystore, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal keystore: %w", err)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(keystorePath, keystoreJSON, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write keystore file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadBLSKeystore loads and decrypts a BLS keystore
// LoadBLSKeystore loads and decrypts a BLS keystore
func LoadBLSKeystore(keystorePath string, password string) (bls.SecretKey, error) <span class="cov0" title="0">{
        // Read keystore file
        keystoreData, err := os.ReadFile(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read keystore file: %w", err)
        }</span>

        // Parse keystore JSON
        <span class="cov0" title="0">var keystore BLSKeystore
        if err := json.Unmarshal(keystoreData, &amp;keystore); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse keystore: %w", err)
        }</span>

        // Decrypt keystore
        <span class="cov0" title="0">secretKeyBytes, err := decryptBLS(keystore, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt keystore: %w", err)
        }</span>

        // Create BLS secret key from decrypted bytes
        <span class="cov0" title="0">secretKey, err := bls.SecretKeyFromBytes(secretKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create BLS secret key: %w", err)
        }</span>

        <span class="cov0" title="0">return secretKey, nil</span>
}

// decryptECDSAKey decrypts an ECDSA keystore
func decryptECDSAKey(crypto Crypto, password string) ([]byte, error) <span class="cov0" title="0">{
        // Parse parameters
        salt, err := hex.DecodeString(crypto.KDFParams["salt"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode salt: %w", err)
        }</span>

        <span class="cov0" title="0">iv, err := hex.DecodeString(crypto.CipherParams["iv"])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode IV: %w", err)
        }</span>

        <span class="cov0" title="0">ciphertext, err := hex.DecodeString(crypto.CipherText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode ciphertext: %w", err)
        }</span>

        <span class="cov0" title="0">expectedMAC, err := hex.DecodeString(crypto.MAC)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode MAC: %w", err)
        }</span>

        // Derive key using same parameters
        <span class="cov0" title="0">dkLen := int(crypto.KDFParams["dklen"].(float64))
        iterations := int(crypto.KDFParams["c"].(float64))
        key := pbkdf2.Key([]byte(password), salt, iterations, dkLen, sha256.New)

        // Split key
        encryptionKey := key[:16]
        macKey := key[16:]

        // Verify MAC
        macData := append(macKey, ciphertext...)
        mac := hmac.New(sha256.New, macKey)
        mac.Write(macData)
        calculatedMAC := mac.Sum(nil)

        if !hmac.Equal(expectedMAC, calculatedMAC) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid password or corrupted keystore")
        }</span>

        // Decrypt
        <span class="cov0" title="0">block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">stream := cipher.NewCTR(block, iv)
        plaintext := make([]byte, len(ciphertext))
        stream.XORKeyStream(plaintext, ciphertext)

        return plaintext, nil</span>
}

// LoadECDSAKeystore loads and decrypts an ECDSA keystore
// LoadECDSAKeystore loads and decrypts an ECDSA keystore
func LoadECDSAKeystore(keystorePath string, password string) (*ecdsa.PrivateKey, error) <span class="cov0" title="0">{
        // Read keystore file
        keystoreData, err := os.ReadFile(keystorePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read keystore file: %w", err)
        }</span>

        // Parse keystore JSON
        <span class="cov0" title="0">var keystore Keystore
        if err := json.Unmarshal(keystoreData, &amp;keystore); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse keystore: %w", err)
        }</span>

        // Decrypt keystore
        <span class="cov0" title="0">privateKeyBytes, err := decryptECDSAKey(keystore.Crypto, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt keystore: %w", err)
        }</span>

        // Create ECDSA private key from decrypted bytes
        <span class="cov0" title="0">privateKey, err := crypto.ToECDSA(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ECDSA private key: %w", err)
        }</span>

        <span class="cov0" title="0">return privateKey, nil</span>
}

// Simple PBKDF2-based encryption for ECDSA keystores
func encryptECDSAKey(privateKeyBytes []byte, password string) (Crypto, error) <span class="cov0" title="0">{
        // Generate random salt and IV
        salt := make([]byte, 32)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return Crypto{}, fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        <span class="cov0" title="0">iv := make([]byte, 16)
        _, err = rand.Read(iv)
        if err != nil </span><span class="cov0" title="0">{
                return Crypto{}, fmt.Errorf("failed to generate IV: %w", err)
        }</span>

        // Derive encryption key using PBKDF2
        <span class="cov0" title="0">dkLen := 32
        iterations := 262144
        key := pbkdf2.Key([]byte(password), salt, iterations, dkLen, sha256.New)

        // Split key into encryption key and MAC key
        encryptionKey := key[:16] // AES-128
        macKey := key[16:]

        // Encrypt private key using AES-128-CTR
        block, err := aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return Crypto{}, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">stream := cipher.NewCTR(block, iv)
        ciphertext := make([]byte, len(privateKeyBytes))
        stream.XORKeyStream(ciphertext, privateKeyBytes)

        // Calculate MAC
        macData := append(macKey, ciphertext...)
        mac := hmac.New(sha256.New, macKey)
        mac.Write(macData)
        macSum := mac.Sum(nil)

        cryptoData := Crypto{
                Cipher:     "aes-128-ctr",
                CipherText: hex.EncodeToString(ciphertext),
                CipherParams: map[string]string{
                        "iv": hex.EncodeToString(iv),
                },
                KDF: "pbkdf2",
                KDFParams: map[string]interface{}{
                        "dklen": dkLen,
                        "c":     iterations,
                        "prf":   "hmac-sha256",
                        "salt":  hex.EncodeToString(salt),
                },
                MAC: hex.EncodeToString(macSum),
        }

        return cryptoData, nil</span>
}

// GenerateECDSAKeystore creates an encrypted ECDSA keystore file
func GenerateECDSAKeystore(keystorePath string) error <span class="cov0" title="0">{
        // Generate new ECDSA private key
        privateKey, err := crypto.GenerateKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Get address from public key
        <span class="cov0" title="0">address := crypto.PubkeyToAddress(privateKey.PublicKey)

        // Convert private key to bytes
        privateKeyBytes := crypto.FromECDSA(privateKey)

        // Get password for encryption
        password, err := getPasswordSecurely("Enter password for ECDSA keystore: ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get password: %w", err)
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        // Confirm password
        <span class="cov0" title="0">if err := confirmPassword(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Encrypt the private key
        <span class="cov0" title="0">cryptoData, err := encryptECDSAKey(privateKeyBytes, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt private key: %w", err)
        }</span>

        // Create keystore structure
        <span class="cov0" title="0">keystore := Keystore{
                Address: address.Hex()[2:], // Remove 0x prefix
                Crypto:  cryptoData,
                ID:      uuid.New().String(),
                Version: 3,
        }

        // Write keystore to file
        keystoreJSON, err := json.MarshalIndent(keystore, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal keystore: %w", err)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(keystorePath, keystoreJSON, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write keystore file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("ECDSA keystore created successfully at: %s\n", keystorePath)
        fmt.Printf("Address: 0x%s\n", keystore.Address)

        return nil</span>
}

// GenerateECDSAKeystoreFromExistingKey creates an encrypted ECDSA keystore from the private key in config
func GenerateECDSAKeystoreFromExistingKey(keystorePath string) error <span class="cov0" title="0">{
        // Get the ECDSA private key from config
        privateKey := config.GetEcdsaPrivateKey()
        if privateKey == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ECDSA private key not available from config")
        }</span>

        // Get address from public key
        <span class="cov0" title="0">address := config.GetOperatorAddress()

        // Convert private key to bytes
        privateKeyBytes := crypto.FromECDSA(privateKey)

        // Get password for encryption
        password, err := getPasswordSecurely("Enter password for ECDSA keystore: ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get password: %w", err)
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return fmt.Errorf("password must be at least 8 characters long")
        }</span>

        // Confirm password
        <span class="cov0" title="0">if err := confirmPassword(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Encrypt the private key
        <span class="cov0" title="0">cryptoData, err := encryptECDSAKey(privateKeyBytes, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt private key: %w", err)
        }</span>

        // Create keystore structure
        <span class="cov0" title="0">keystore := map[string]interface{}{
                "address": address.Hex()[2:], // Remove 0x prefix
                "crypto":  cryptoData,
                "id":      uuid.New().String(),
                "version": 3,
        }

        // Write keystore to file
        keystoreJSON, err := json.MarshalIndent(keystore, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal keystore: %w", err)
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(keystorePath, keystoreJSON, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write keystore file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GenerateBLSPublicKey generates a BLS public key from private key
func GenerateBLSPublicKey(privateKeyBytes []byte) []byte <span class="cov0" title="0">{
        secretKey, err := bls.SecretKeyFromBytes(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                // Handle error (maybe return zero bytes or panic)
                return make([]byte, 48)
        }</span>
        <span class="cov0" title="0">return secretKey.PublicKey().Marshal()</span>
}

// UpdateEnvFile updates the .env file with keystore paths
func UpdateEnvFile(envPath, ecdsaKeyPath, blsKeyPath, blsPrivateKeyHex string) error <span class="cov0" title="0">{
        // Read existing .env file
        content, err := os.ReadFile(envPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read .env file: %w", err)
        }</span>

        // Add keystore paths
        <span class="cov0" title="0">newContent := string(content)
        newContent += "\n# Keystore paths (generated by generate-keys command)\n"
        newContent += fmt.Sprintf("ECDSA_PRIVATE_KEY_STORE_PATH=%s\n", ecdsaKeyPath)
        newContent += fmt.Sprintf("BLS_PRIVATE_KEY_STORE_PATH=%s\n", blsKeyPath)
        // Note: Don't store the private key in plaintext in .env for encrypted keystores
        newContent += "# BLS_PRIVATE_KEY is encrypted in keystore - use keystore password to decrypt\n"

        // Write back to file
        err = os.WriteFile(envPath, []byte(newContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write .env file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateEnvFileWithPathsAndAddress updates the .env file with keystore paths and operator address
func UpdateEnvFileWithPathsAndAddress(ecdsaKeyPath, blsKeyPath, operatorAddress string) error <span class="cov0" title="0">{
        envPath := ".env"

        // Read existing .env file
        content, err := os.ReadFile(envPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read .env file: %w", err)
        }</span>

        <span class="cov0" title="0">lines := splitLines(string(content))
        var newLines []string
        var addedECDSAPath, addedBLSPath, addedOperatorAddr bool

        // Process existing lines and update if they exist
        for _, line := range lines </span><span class="cov0" title="0">{
                trimmedLine := strings.TrimSpace(line)
                if strings.HasPrefix(trimmedLine, "ECDSA_PRIVATE_KEY_STORE_PATH=") </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("ECDSA_PRIVATE_KEY_STORE_PATH=%s", ecdsaKeyPath))
                        addedECDSAPath = true
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(trimmedLine, "BLS_PRIVATE_KEY_STORE_PATH=") </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("BLS_PRIVATE_KEY_STORE_PATH=%s", blsKeyPath))
                        addedBLSPath = true
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(trimmedLine, "OPERATOR_ADDRESS=") </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("OPERATOR_ADDRESS=%s", operatorAddress))
                        addedOperatorAddr = true
                }</span> else<span class="cov0" title="0"> {
                        newLines = append(newLines, line)
                }</span>
        }

        // Add missing variables at the end
        <span class="cov0" title="0">if !addedECDSAPath || !addedBLSPath || !addedOperatorAddr </span><span class="cov0" title="0">{
                newLines = append(newLines, "\n# Keystore paths and operator address (generated by complete-registration command)")
                if !addedECDSAPath </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("ECDSA_PRIVATE_KEY_STORE_PATH=%s", ecdsaKeyPath))
                }</span>
                <span class="cov0" title="0">if !addedBLSPath </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("BLS_PRIVATE_KEY_STORE_PATH=%s", blsKeyPath))
                }</span>
                <span class="cov0" title="0">if !addedOperatorAddr </span><span class="cov0" title="0">{
                        newLines = append(newLines, fmt.Sprintf("OPERATOR_ADDRESS=%s", operatorAddress))
                }</span>
        }

        // Write back to file
        <span class="cov0" title="0">envContent := strings.Join(newLines, "\n")
        err = os.WriteFile(envPath, []byte(envContent), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write .env file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func splitLines(s string) []string <span class="cov0" title="0">{
        var lines []string
        start := 0
        for i, c := range s </span><span class="cov0" title="0">{
                if c == '\n' </span><span class="cov0" title="0">{
                        lines = append(lines, s[start:i])
                        start = i + 1
                }</span>
        }
        <span class="cov0" title="0">if start &lt; len(s) </span><span class="cov0" title="0">{
                lines = append(lines, s[start:])
        }</span>
        <span class="cov0" title="0">return lines</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package core

import (
        "encoding/hex"
        "fmt"
        "regexp"
        "strings"

        "github.com/cosmos/btcutil/bech32"
        "github.com/ethereum/go-ethereum/common"
        "github.com/prysmaticlabs/prysm/v5/crypto/bls"
)

const BLSMessageToSign = "BLS12-381 Signed Message\nChainIDWithoutRevision: %s\nAccAddressBech32: %s"

func ValidateBLSPrivateKey(privateKeyHex string) error <span class="cov0" title="0">{
        // Remove 0x prefix if present
        privateKeyHex = strings.TrimPrefix(privateKeyHex, "0x")
        
        // Check length (BLS private key should be 32 bytes = 64 hex characters)
        if len(privateKeyHex) != 64 </span><span class="cov0" title="0">{
                return fmt.Errorf("BLS private key should be 64 hex characters, got %d", len(privateKeyHex))
        }</span>
        <span class="cov0" title="0">privateKeyBytes := common.FromHex(privateKeyHex)
        _, err := bls.SecretKeyFromBytes(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid BLS private key format: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func GetBLSPublicKeyFromPrivateKey(privateKeyHex string) ([]byte, error) <span class="cov0" title="0">{
        privateKeyHex = strings.TrimPrefix(privateKeyHex, "0x")
        privateKeyBytes := common.FromHex(privateKeyHex)
        
        privateKey, err := bls.SecretKeyFromBytes(privateKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse BLS private key: %w", err)
        }</span>
        
        <span class="cov0" title="0">publicKey := privateKey.PublicKey()
        return publicKey.Marshal(), nil</span>
}

func FormatChainIDWithoutRevision(chainID string) string <span class="cov0" title="0">{
        // Find the last dash and check if it's followed by a number (revision)
        lastDash := strings.LastIndex(chainID, "-")
        if lastDash == -1 </span><span class="cov0" title="0">{
                return chainID
        }</span>
        
        // Check if what follows the dash is a number
        <span class="cov0" title="0">revision := chainID[lastDash+1:]
        if len(revision) &gt; 0 </span><span class="cov0" title="0">{
                // If it looks like a revision number, remove it
                for _, r := range revision </span><span class="cov0" title="0">{
                        if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                                // Not a number, return original
                                return chainID
                        }</span>
                }
                // All characters after dash are numbers, so it's a revision
                <span class="cov0" title="0">return chainID[:lastDash]</span>
        }
        
        <span class="cov0" title="0">return chainID</span>
}

func SwitchEthAddressToImAddress(ethAddress string) (string, error) <span class="cov0" title="0">{
        b, err := hex.DecodeString(ethAddress[2:])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode eth address: %w", err)
        }</span>

        // Generate im address
        <span class="cov0" title="0">bech32Prefix := "im"
        imAddress, err := bech32.EncodeFromBase256(bech32Prefix, b)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode bech32 address: %w", err)
        }</span>

        <span class="cov0" title="0">return imAddress, nil</span>
}

// ChainIDWithoutRevision returns the chainID without the revision number.
// For example, "imuachaintestnet_233-1" returns "imuachaintestnet_233".
func ChainIDWithoutRevision(chainID string) string <span class="cov0" title="0">{
        if !IsRevisionFormat(chainID) </span><span class="cov0" title="0">{
                return chainID
        }</span>
        <span class="cov0" title="0">splitStr := strings.Split(chainID, "-")
        return splitStr[0]</span>
}

var IsRevisionFormat = regexp.MustCompile(`^.*[^\n-]-{1}[1-9][0-9]*$`).MatchString
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "log"
        "os"

        "github.com/trigg3rX/triggerx-backend/cli/actions"
        "github.com/trigg3rX/triggerx-backend/cli/core/config"
        "github.com/urfave/cli"
)

func main() <span class="cov0" title="0">{
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">app := cli.NewApp()
        app.Name = "triggerx"
        app.Usage = "TriggerX Operator CLI"

        app.Commands = []cli.Command{
                {
                        Name:   "generate-keys",
                        Usage:  "Generate BLS and ECDSA keystore files",
                        Action: actions.GenerateKeys,
                },
                // Imuachain Integration
                {
                        Name:   "setup-imua-keys",
                        Usage:  "Setup and create required Imuachain validator keys",
                        Action: actions.SetupImuaKeys,
                },
                {
                        Name:   "fund-imua-account",
                        Usage:  "Fund Imuachain validator account with IMUA tokens from faucet",
                        Action: actions.FundImuaAccount,
                },
                {
                        Name:   "check-imua-balance",
                        Usage:  "Check IMUA token balance of validator account",
                        Action: actions.CheckImuaBalance,
                },
                {
                        Name:   "register-imua-operator",
                        Usage:  "Register operator on Imuachain",
                        Action: actions.RegisterImuaOperator,
                },
                // Token Management Commands
                {
                        Name:   "get-imeth-tokens",
                        Usage:  "Get imETH tokens from faucet (required before depositing)",
                        Action: actions.GetImethTokens,
                },
                {
                        Name:   "deposit-tokens",
                        Usage:  "Deposit tokens from Ethereum Sepolia to Imuachain",
                        Action: actions.DepositTokens,
                },
                {
                        Name:   "delegate-tokens",
                        Usage:  "Delegate deposited tokens to your Imua validator",
                        Action: actions.DelegateTokens,
                },
                // AVS Management
                {
                        Name:   "opt-in-to-avs",
                        Usage:  "Opt-in to AVS on Imuachain as a validator",
                        Action: actions.OptInToAVS,
                },
                {
                        Name:   "associate-operator",
                        Usage:  "Associate operator with EVM staker (post-bootstrap phase)",
                        Action: actions.AssociateOperator,
                },
                // BLS Key Management
                {
                        Name:   "register-bls-key",
                        Usage:  "Register BLS public key for AVS operator",
                        Action: actions.RegisterBLSPublicKey,
                },
        }

        err = app.Run(os.Args)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"

        "github.com/trigg3rX/triggerx-backend/internal/aggregator"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/api"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/config"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/rpc"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 30 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.AggregatorProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting aggregator service...")

        // Initialize aggregator configuration
        aggregatorConfig := &amp;types.AggregatorConfig{
                MaxConcurrentTasks: 100,
                DefaultTimeout:     5 * time.Minute,
                MinOperators:       1,
                MaxOperators:       100,
        }

        // Create aggregator instance
        aggregatorInstance := aggregator.NewAggregator(logger, aggregatorConfig)

        // Start aggregator service
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        if err := aggregatorInstance.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start aggregator service", "error", err)
                panic(fmt.Sprintf("Failed to start aggregator service: %v", err))</span>
        }

        // Initialize server components
        <span class="cov0" title="0">var wg sync.WaitGroup
        serverErrors := make(chan error, 3)
        ready := make(chan struct{})

        // Setup HTTP server
        httpServer := setupHTTPServer(aggregatorInstance, logger)

        // Setup RPC server
        rpcServerAddr := fmt.Sprintf(":%s", config.GetAggregatorP2PPort())
        rpcServer := rpc.NewRPCServer(aggregatorInstance, logger, rpcServerAddr)

        // Start HTTP server
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                logger.Info("Starting HTTP API server...")
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErrors &lt;- fmt.Errorf("HTTP server error: %v", err)
                }</span>
        }()

        // Start RPC server
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                logger.Info("Starting RPC server...")
                if err := rpcServer.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        serverErrors &lt;- fmt.Errorf("RPC server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">close(ready)
        logger.Infof("Aggregator service is ready")
        logger.Infof("HTTP API server running on port %s", config.GetAggregatorRPCPort())
        logger.Infof("RPC server running on port %s", config.GetAggregatorP2PPort())

        // Handle graceful shutdown
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                logger.Error("Server error received", "error", err)</span>
        case sig := &lt;-shutdown:<span class="cov0" title="0">
                logger.Info("Received shutdown signal", "signal", sig.String())</span>
        }

        <span class="cov0" title="0">performGracefulShutdown(httpServer, rpcServer, aggregatorInstance, &amp;wg, logger, cancel)</span>
}

func setupHTTPServer(aggregatorInstance *aggregator.Aggregator, logger logging.Logger) *http.Server <span class="cov0" title="0">{
        if !config.IsDevMode() </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov0" title="0">router := gin.New()
        router.Use(gin.Recovery())
        router.Use(api.LoggerMiddleware(logger))

        // Register routes with aggregator instance
        api.RegisterRoutesWithAggregator(router, aggregatorInstance, logger)

        return &amp;http.Server{
                Addr:         fmt.Sprintf(":%s", config.GetAggregatorRPCPort()),
                Handler:      router,
                ReadTimeout:  30 * time.Second,
                WriteTimeout: 30 * time.Second,
                IdleTimeout:  60 * time.Second,
        }</span>
}

func performGracefulShutdown(
        httpServer *http.Server,
        rpcServer *rpc.RPCServer,
        aggregatorInstance *aggregator.Aggregator,
        wg *sync.WaitGroup,
        logger logging.Logger,
        cancel context.CancelFunc,
) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        // Create shutdown context
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer shutdownCancel()

        // Cancel main context to stop aggregator workers
        cancel()

        // Shutdown RPC server
        if rpcServer != nil </span><span class="cov0" title="0">{
                logger.Info("Shutting down RPC server...")
                if err := rpcServer.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("RPC server shutdown error", "error", err)
                }</span>
        }

        // Shutdown HTTP server
        <span class="cov0" title="0">if httpServer != nil </span><span class="cov0" title="0">{
                logger.Info("Shutting down HTTP server...")
                if err := httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("HTTP server shutdown error", "error", err)
                        if err := httpServer.Close(); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Forced HTTP server close error", "error", err)
                        }</span>
                }
        }

        // Stop aggregator service
        <span class="cov0" title="0">if aggregatorInstance != nil </span><span class="cov0" title="0">{
                logger.Info("Stopping aggregator service...")
                if err := aggregatorInstance.Stop(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Aggregator shutdown error", "error", err)
                }</span>
        }

        // Wait for all goroutines to finish
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                logger.Info("All servers stopped gracefully")</span>
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                logger.Warn("Shutdown timeout exceeded, forcing exit")</span>
        }

        <span class="cov0" title="0">logger.Info("Shutdown complete")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gocql/gocql"

        "github.com/trigg3rX/triggerx-backend/internal/health"
        "github.com/trigg3rX/triggerx-backend/internal/health/client"
        "github.com/trigg3rX/triggerx-backend/internal/health/config"
        "github.com/trigg3rX/triggerx-backend/internal/health/keeper"
        "github.com/trigg3rX/triggerx-backend/internal/health/telegram"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 30 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.HealthProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting health service...")

        // Initialize server components
        var wg sync.WaitGroup
        serverErrors := make(chan error, 3)
        ready := make(chan struct{})

        // Initialize database connection
        dbConfig := &amp;database.Config{
                Hosts:        []string{config.GetDatabaseHostAddress() + ":" + config.GetDatabaseHostPort()},
                Keyspace:     "triggerx",
                Consistency:  gocql.Quorum,
                Timeout:      time.Second * 30,
                Retries:      5,
                ConnectWait:  time.Second * 10,
                ProtoVersion: 4,
        }
        dbConn, err := database.NewConnection(dbConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize database connection: %v", err))</span>
        }

        // Initialize Telegram bot
        <span class="cov0" title="0">telegramBot, err := telegram.NewBot(config.GetBotToken(), logger, dbConn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to initialize Telegram bot: %v", err)
        }</span>

        // Initialize database manager
        <span class="cov0" title="0">client.InitDatabaseManager(logger, dbConn, telegramBot)
        logger.Info("Database manager initialized")

        // Initialize state manager
        stateManager := keeper.InitializeStateManager(logger)
        logger.Info("Keeper state manager initialized")

        // Load verified keepers from database
        if err := stateManager.LoadVerifiedKeepers(); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to load verified keepers from database", "error", err)
                // Continue anyway, as we can still operate with an empty state
        }</span>

        // Setup HTTP server
        <span class="cov0" title="0">srv := setupHTTPServer(logger)

        // Start server
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                logger.Info("Starting HTTP server...")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErrors &lt;- fmt.Errorf("HTTP server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">close(ready)
        logger.Infof("Health service is ready on port %s", config.GetHealthRPCPort())

        // Handle graceful shutdown
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                logger.Error("Server error received", "error", err)</span>
        case sig := &lt;-shutdown:<span class="cov0" title="0">
                logger.Info("Received shutdown signal", "signal", sig.String())</span>
        }

        <span class="cov0" title="0">performGracefulShutdown(srv, &amp;wg, logger)</span>
}

func setupHTTPServer(logger logging.Logger) *http.Server <span class="cov0" title="0">{
        if !config.IsDevMode() </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov0" title="0">router := gin.New()
        router.Use(gin.Recovery())
        router.Use(health.LoggerMiddleware(logger))

        // Register routes
        health.RegisterRoutes(router, logger)

        return &amp;http.Server{
                Addr:    fmt.Sprintf(":%s", config.GetHealthRPCPort()),
                Handler: router,
        }</span>
}

func performGracefulShutdown(srv *http.Server, wg *sync.WaitGroup, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        // Update all keepers to inactive in database
        stateManager := keeper.GetStateManager()
        if err := stateManager.DumpState(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to dump keeper state", "error", err)
        }</span>

        <span class="cov0" title="0">if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("HTTP server shutdown error", "error", err)
                if err := srv.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Forced HTTP server close error", "error", err)
                }</span>
        }

        <span class="cov0" title="0">wg.Wait()
        logger.Info("Shutdown complete")</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "context"
        "encoding/hex"
        "errors"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/imua-xyz/imua-avs-sdk/client/txmgr"
        "github.com/imua-xyz/imua-avs-sdk/signer"
        keeper "github.com/trigg3rX/triggerx-backend/internal/imua-keeper"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/client/health"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/docker"
        dockerconfig "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 10 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize configuration: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.KeeperProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting keeper node ...",
                "keeper_address", config.GetKeeperAddress(),
                "consensus_address", config.GetConsensusKeyPair().PublicKey().Marshal(),
                "version", config.GetVersion(),
        )

        collector := metrics.NewCollector()
        logger.Info("[1/5] Dependency: Metrics collector Initialised")

        // Initialize Ethereum client and AVS writer
        ethClient, err := ethclient.Dial(config.GetEthRPCUrl())
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to Ethereum", "error", err)
        }</span>

        <span class="cov0" title="0">chainId, err := ethClient.ChainID(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Cannot get chainId", "error", err)
        }</span>

        // Setup signer and transaction manager
        <span class="cov0" title="0">signer, _, err := signer.SignerFromConfig(signer.Config{
                PrivateKey: config.GetPrivateKeyOwner(),
        }, chainId)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create signer", "error", err)
        }</span>

        <span class="cov0" title="0">txMgr := txmgr.NewSimpleTxManager(ethClient, logger, signer, common.HexToAddress(config.GetOwnerAddress()))

        // Initialize AVS writer
        avsWriter, err := chainio.BuildChainWriter(
                common.HexToAddress(config.GetAvsGovernanceAddress()),
                ethClient,
                logger,
                txMgr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize AVS writer", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/5] Dependency: AVS writer Initialised")

        // Initialize clients: ECDSA
        // aggregatorCfg := aggregator.AggregatorClientConfig{
        //         AggregatorRPCUrl: config.GetAggregatorRPCUrl(),
        //         SenderPrivateKey: string(config.GetPrivateKeyController().D.Bytes()),
        //         SenderAddress:    config.GetKeeperAddress(),
        // }
        // Initialize clients: BLS
        // aggregatorCfg := aggregator.AggregatorClientConfig{
        //         AggregatorRPCUrl: config.GetAggregatorRPCUrl(),
        //         SenderPrivateKey: config.GetPrivateKeyConsensus(),
        //         SenderAddress:    config.GetKeeperAddress(),
        // }
        // aggregatorClient, err := aggregator.NewAggregatorClient(logger, aggregatorCfg)
        // if err != nil {
        //         logger.Fatal("Failed to initialize aggregator client", "error", err)
        // }
        // logger.Info("[2/5] Dependency: Aggregator client Initialised")

        healthCfg := health.Config{
                HealthServiceURL: config.GetHealthRPCUrl(),
                PrivateKey:       hex.EncodeToString(config.GetPrivateKeyController().D.Bytes()),
                KeeperAddress:    config.GetKeeperAddress(),
                PeerID:           config.GetPeerID(),
                Version:          config.GetVersion(),
                RequestTimeout:   10 * time.Second,
        }
        healthClient, err := health.NewClient(logger, healthCfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize health client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[3/5] Dependency: Health client Initialised")

        dockerCfg := dockerconfig.DefaultConfig("go")
        supportedLanguages := []types.Language{
                types.LanguageGo,
                // types.LanguagePy,
                // types.LanguageJS,
                // types.LanguageTS,
                // types.LanguageNode,
        }

        dockerManager, err := docker.NewDockerManager(dockerCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize code executor", "error", err)
        }</span>

        // Initialize the Docker manager with language-specific pools
        <span class="cov0" title="0">ctx := context.Background()
        if err := dockerManager.Initialize(ctx, supportedLanguages); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize Docker manager", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Infof("[4/5] Dependency: Code executor Initialised with %d language pools", len(supportedLanguages))

        // Initialize task executor and validator
        validator := validation.NewTaskValidator(config.GetAlchemyAPIKey(), config.GetEtherscanAPIKey(), dockerManager, logger)
        executor := execution.NewTaskExecutor(config.GetAlchemyAPIKey(), validator, nil, avsWriter, logger)

        // Initialize API server
        serverCfg := api.Config{
                Port:           config.GetOperatorRPCPort(),
                ReadTimeout:    10 * time.Second,
                WriteTimeout:   10 * time.Second,
                MaxHeaderBytes: 1 &lt;&lt; 20,
        }

        deps := &amp;api.Dependencies{
                Logger:    logger,
                Executor:  executor,
                Validator: validator,
        }

        server := api.NewServer(serverCfg, deps)
        logger.Info("[5/5] Dependency: API server Initialised")

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        keeper := keeper.NewKeeper(logger)
        defer keeper.Close()
        go func() </span><span class="cov0" title="0">{
                err = keeper.Start(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start keeper", "error", err)
                }</span>
        }()
        <span class="cov0" title="0">logger.Info("[1/4] Process: Keeper Started")

        // Start health check routine
        go startHealthCheckRoutine(ctx, healthClient, dockerManager, logger, server, keeper)
        logger.Debug("Note: Only first health-check will be logged, subsequent health-checks will not be logged.")
        logger.Info("[2/4] Process: Health check routine Started")

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", "error", err)
                }</span>
        }()
        <span class="cov0" title="0">logger.Info("[3/4] Process: API server Started")

        // Start metrics collector in a goroutine
        go func() </span><span class="cov0" title="0">{
                collector.Start()
        }</span>()
        <span class="cov0" title="0">logger.Info("[4/4] Process: Metrics collector Started")

        // Wait for interrupt signal
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

        // Block until signal is received
        &lt;-shutdown

        // Perform graceful shutdown
        performGracefulShutdown(ctx, healthClient, dockerManager, server, keeper, logger)</span>
}

// startHealthCheckRoutine starts a goroutine that sends periodic health check-ins
func startHealthCheckRoutine(ctx context.Context, healthClient *health.Client, dockerManager *docker.DockerManager, logger logging.Logger, server *api.Server, keeper *keeper.Keeper) <span class="cov0" title="0">{
        ticker := time.NewTicker(60 * time.Second)
        defer ticker.Stop()

        // Initial check-in
        response, err := healthClient.CheckIn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, health.ErrKeeperNotVerified) </span><span class="cov0" title="0">{
                        logger.Error("Keeper is not verified. Shutting down...", "error", err)
                        performGracefulShutdown(ctx, healthClient, dockerManager, server, keeper, logger)
                        return
                }</span>
                <span class="cov0" title="0">logger.Error("Failed initial health check-in", "error", response.Data)</span>
        }

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        response, err := healthClient.CheckIn(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed health check-in", "error", response.Data)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Stopping health check routine")
                        return</span>
                }
        }
}

func performGracefulShutdown(ctx context.Context, healthClient *health.Client, dockerManager *docker.DockerManager, server *api.Server, keeper *keeper.Keeper, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(ctx, shutdownTimeout)
        defer cancel()

        // Close health client
        healthClient.Close()
        logger.Info("[1/4] Process: Health client Closed")

        // Close code executor
        if err := dockerManager.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error closing code executor", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/4] Process: Code executor Closed")

        // Shutdown server gracefully
        if err := server.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[3/4] Process: API server Stopped")

        // Close keeper
        keeper.Close()
        logger.Info("[4/4] Process: Keeper Closed")

        logger.Info("Shutdown complete")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/keeper/api"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/client/health"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
        "github.com/trigg3rX/triggerx-backend/pkg/docker"
        dockerconfig "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 10 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        err := config.Init()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize configuration: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.KeeperProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting keeper node ...",
                "keeper_address", config.GetKeeperAddress(),
                "consensus_address", config.GetConsensusAddress(),
                "version", config.GetVersion(),
        )

        collector := metrics.NewCollector()
        logger.Info("[1/6] Dependency: Metrics collector Initialised")

        // Initialize health client first
        healthCfg := health.Config{
                HealthServiceURL: config.GetHealthRPCUrl(),
                PrivateKey:       config.GetPrivateKeyConsensus(),
                KeeperAddress:    config.GetKeeperAddress(),
                PeerID:           config.GetPeerID(),
                Version:          config.GetVersion(),
                RequestTimeout:   10 * time.Second,
        }
        healthClient, err := health.NewClient(logger, healthCfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize health client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/6] Dependency: Health client Initialised")

        // Perform initial health check-in to get configuration
        logger.Info("Performing initial health check-in to get configuration...")
        ctx := context.Background()
        response, err := healthClient.CheckIn(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, health.ErrKeeperNotVerified) </span><span class="cov0" title="0">{
                        logger.Fatal("Keeper is not verified. Shutting down...", "error", err)
                }</span>
                <span class="cov0" title="0">logger.Fatal("Failed initial health check-in", "error", response.Data)</span>
        }
        <span class="cov0" title="0">logger.Info("Initial health check-in successful, configuration received")

        // Initialize clients: ECDSA
        aggregatorCfg := aggregator.AggregatorClientConfig{
                AggregatorRPCUrl: config.GetAggregatorRPCUrl(),
                SenderPrivateKey: config.GetPrivateKeyController(),
                SenderAddress:    config.GetKeeperAddress(),
        }
        aggregatorClient, err := aggregator.NewAggregatorClient(logger, aggregatorCfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize aggregator client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[3/6] Dependency: Aggregator client Initialised")

        dockerCfg := dockerconfig.DefaultConfig("go")
        supportedLanguages := []types.Language{
                types.LanguageGo,
                // types.LanguagePy,
                // types.LanguageJS,
                // types.LanguageTS,
                // types.LanguageNode,
        }

        dockerManager, err := docker.NewDockerManager(dockerCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize code executor", "error", err)
        }</span>

        // Initialize the Docker manager with language-specific pools
        <span class="cov0" title="0">if err := dockerManager.Initialize(ctx, supportedLanguages); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize Docker manager", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Infof("[4/6] Dependency: Code executor Initialised with %d language pools", len(supportedLanguages))

        ipfsCfg := ipfs.NewConfig(config.GetIpfsHost(), config.GetPinataJWT())
        ipfsClient, err := ipfs.NewClient(ipfsCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize IPFS client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[5/6] Dependency: IPFS client Initialised")

        // Initialize task executor and validator
        validator := validation.NewTaskValidator(config.GetAlchemyAPIKey(), config.GetEtherscanAPIKey(), dockerManager, aggregatorClient, logger, ipfsClient)
        executor := execution.NewTaskExecutor(config.GetAlchemyAPIKey(), validator, aggregatorClient, logger)

        // Initialize API server
        serverCfg := api.Config{
                Port:           config.GetOperatorRPCPort(),
                ReadTimeout:    10 * time.Second,
                WriteTimeout:   10 * time.Second,
                MaxHeaderBytes: 1 &lt;&lt; 20,
        }

        deps := &amp;api.Dependencies{
                Logger:    logger,
                Executor:  executor,
                Validator: validator,
        }

        server := api.NewServer(serverCfg, deps)
        logger.Info("[6/6] Dependency: API server Initialised")

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start health check routine
        go startHealthCheckRoutine(ctx, healthClient, dockerManager, logger, server)
        logger.Debug("Note: Only first health-check will be logged, subsequent health-checks will not be logged.")
        logger.Info("[1/3] Process: Health check routine Started")

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to start server", "error", err)
                }</span>
        }()
        <span class="cov0" title="0">logger.Info("[2/3] Process: API server Started")

        // Start metrics collector in a goroutine
        go func() </span><span class="cov0" title="0">{
                collector.Start()
        }</span>()
        <span class="cov0" title="0">logger.Info("[3/3] Process: Metrics collector Started")

        // Wait for interrupt signal
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

        // Block until signal is received
        &lt;-shutdown

        // Perform graceful shutdown
        performGracefulShutdown(ctx, healthClient, dockerManager, server, logger)</span>
}

// startHealthCheckRoutine starts a goroutine that sends periodic health check-ins
func startHealthCheckRoutine(ctx context.Context, healthClient *health.Client, dockerManager *docker.DockerManager, logger logging.Logger, server *api.Server) <span class="cov0" title="0">{
        ticker := time.NewTicker(60 * time.Second)
        defer ticker.Stop()

        // Skip initial check-in since we already did it during startup
        logger.Debug("Starting periodic health check routine")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        response, err := healthClient.CheckIn(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, health.ErrKeeperNotVerified) </span><span class="cov0" title="0">{
                                        logger.Error("Keeper is not verified. Shutting down...", "error", err)
                                        performGracefulShutdown(ctx, healthClient, dockerManager, server, logger)
                                        return
                                }</span>
                                <span class="cov0" title="0">logger.Error("Failed health check-in", "error", response.Data)</span>
                        }
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Stopping health check routine")
                        return</span>
                }
        }
}

func performGracefulShutdown(ctx context.Context, healthClient *health.Client, dockerManager *docker.DockerManager, server *api.Server, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(ctx, shutdownTimeout)
        defer cancel()

        // Close health client
        healthClient.Close()
        logger.Info("[1/3] Process: Health client Closed")

        // Close code executor
        if err := dockerManager.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error closing code executor", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/3] Process: Code executor Closed")

        // Shutdown server gracefully
        if err := server.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[3/3] Process: API server Stopped")

        logger.Info("Shutdown complete")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/registrar"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 30 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.RegistrarProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting registrar service...",
                "port", config.GetRegistrarPort(),
                "avs_governance", config.GetAvsGovernanceAddress(),
                "attestation_center", config.GetAttestationCenterAddress(),
        )

        // Initialize and start registrar service
        registrarService, err := registrar.NewRegistrarService(logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize registrar service", "error", err)
        }</span>

        // Start services
        <span class="cov0" title="0">err = registrarService.Start()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start registrar service", "error", err)
        }</span>

        <span class="cov0" title="0">logger.Info("All services started successfully")

        // Handle graceful shutdown
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        sig := &lt;-shutdown
        logger.Infof("Received shutdown signal: %s", sig.String())

        // Perform graceful shutdown
        performGracefulShutdown(registrarService, logger)

        logger.Info("Shutdown complete")</span>
}

func performGracefulShutdown(registrarService *registrar.RegistrarService, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        err := registrarService.Stop()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to stop registrar service", "error", err)
        }</span>

        // Wait for context timeout or manual cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        logger.Info("Shutdown complete")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/config"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/client/dbserver"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 30 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Start metrics collection
        <span class="cov0" title="0">metrics.StartMetricsCollection()

        // Initialize logger
        logConfig := logging.LoggerConfig{
                ProcessName:   logging.ConditionSchedulerProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting Condition-based Scheduler with Redis integration...")

        // Initialize database client
        dbClient, err := dbserver.NewDBServerClient(logger, config.GetDBServerURL())
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize database client", "error", err)
        }</span>

        // Perform initial health check
        <span class="cov0" title="0">logger.Info("Performing initial health check...")
        if err := dbClient.HealthCheck(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Database server health check failed", "error", err)
                logger.Info("Continuing startup - will retry connections during operation")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Database server health check passed")
        }</span>

        // Initialize condition-based scheduler with Redis integration
        <span class="cov0" title="0">managerID := fmt.Sprintf("condition-scheduler-%d", time.Now().Unix())
        conditionScheduler, err := scheduler.NewConditionBasedScheduler(managerID, logger, dbClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize condition-based scheduler", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Condition-based scheduler initialized successfully")

        // Setup HTTP server with scheduler integration
        srv := api.NewServer(api.Config{
                Port: config.GetSchedulerRPCPort(),
        }, api.Dependencies{
                Logger:    logger,
                Scheduler: conditionScheduler,
        })

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start scheduler in background
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting condition monitoring and Redis job creation...")
                conditionScheduler.Start(ctx)
        }</span>()

        // Start HTTP server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                logger.Info("Starting HTTP server for condition job scheduling API...", "port", config.GetSchedulerRPCPort())
                if err := srv.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error("HTTP server error", "error", err)
                }</span>
        }()

        // Log comprehensive service status
        <span class="cov0" title="0">serviceStatus := map[string]interface{}{
                "manager_id":           managerID,
                "api_port":             config.GetSchedulerRPCPort(),
                "max_workers":          config.GetMaxWorkers(),
                "poll_interval":        "1s",
                "supported_conditions": []string{"greater_than", "less_than", "between", "equals", "not_equals", "greater_equal", "less_equal"},
                "supported_sources":    []string{"api", "oracle", "static"},
                "request_timeout":      "10s",
                "value_cache_ttl":      "30s",
                "condition_state_ttl":  "5m",
                "redis_integration":    "enabled",
                "orchestration_mode":   "redis_job_streams",
                "trigger_mechanism":    "condition_monitoring",
                "task_creation":        "automatic_via_redis",
        }

        logger.Info("Condition-based scheduler service ready", "status", serviceStatus)

        // Handle graceful shutdown
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        &lt;-shutdown

        performGracefulShutdown(cancel, srv, conditionScheduler, dbClient, logger)</span>
}

func performGracefulShutdown(cancel context.CancelFunc, srv *api.Server, conditionScheduler *scheduler.ConditionBasedScheduler, dbClient *dbserver.DBServerClient, logger logging.Logger) <span class="cov0" title="0">{
        shutdownStart := time.Now()
        logger.Info("Initiating graceful shutdown...")

        // Cancel context to stop scheduler
        cancel()

        // Create shutdown context with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer shutdownCancel()

        // Stop scheduler gracefully (this will stop all condition workers)
        conditionScheduler.Stop()

        // Close database client
        dbClient.Close()

        // Shutdown server gracefully
        if err := srv.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown", "error", err)
        }</span>

        <span class="cov0" title="0">shutdownDuration := time.Since(shutdownStart)

        logger.Info("Condition-based scheduler shutdown complete",
                "duration", shutdownDuration,
                "redis_integration", "disconnected")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/config"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/client/dbserver"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 30 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error loading configuration: %v\n", err)
                os.Exit(1)
        }</span>

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.TimeSchedulerProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting Time-based Scheduler with Redis integration...")

        // Initialize database client
        dbClient, err := dbserver.NewDBServerClient(logger, config.GetDBServerURL())
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize database client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Database client initialized successfully")

        // Initialize time-based scheduler with Redis integration via HTTP API
        managerID := fmt.Sprintf("time-scheduler-%d", time.Now().Unix())
        timeScheduler, err := scheduler.NewTimeBasedScheduler(managerID, logger, dbClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize time-based scheduler", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Time-based scheduler initialized successfully")

        // Setup HTTP server with scheduler integration
        srv := api.NewServer(api.Config{
                Port: config.GetSchedulerRPCPort(),
        }, api.Dependencies{
                Logger:    logger,
                Scheduler: timeScheduler,
        })

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Start scheduler in background
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting time-based task polling and Redis submission...")
                timeScheduler.Start(ctx)
        }</span>()

        // Start HTTP server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                logger.Info("Starting HTTP server for scheduler management API...", "port", config.GetSchedulerRPCPort())
                if err := srv.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error("HTTP server error", "error", err)
                }</span>
        }()

        // Log comprehensive service status
        <span class="cov0" title="0">serviceStatus := map[string]interface{}{
                "manager_id":            managerID,
                "api_port":              config.GetSchedulerRPCPort(),
                "poll_interval":         config.GetPollingInterval(),
                "look_ahead":            config.GetPollingLookAhead(),
                "batch_size":            config.GetTaskBatchSize(),
                "task_cache_ttl":        config.GetTaskCacheTTL(),
                "duplicate_task_window": config.GetDuplicateTaskWindow(),
                "redis_integration":     "enabled",
                "orchestration_mode":    "redis_streams",
                "performer_assignment":  "automatic_via_redis",
        }

        logger.Info("Time-based scheduler service ready", "status", serviceStatus)

        // Handle graceful shutdown
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)

        &lt;-shutdown

        performGracefulShutdown(cancel, srv, timeScheduler, dbClient, logger)</span>
}

func performGracefulShutdown(cancel context.CancelFunc, srv *api.Server, timeScheduler *scheduler.TimeBasedScheduler, dbClient *dbserver.DBServerClient, logger logging.Logger) <span class="cov0" title="0">{
        shutdownStart := time.Now()
        logger.Info("Initiating graceful shutdown...")

        // Cancel context to stop scheduler
        cancel()

        // Create shutdown context with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer shutdownCancel()

        // Stop scheduler gracefully
        timeScheduler.Stop()

        // Close database client
        dbClient.Close()

        // Shutdown server gracefully
        if err := srv.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server forced to shutdown", "error", err)
        }</span>

        <span class="cov0" title="0">shutdownDuration := time.Since(shutdownStart)

        logger.Info("Time-based scheduler shutdown complete",
                "duration", shutdownDuration,
                "redis_integration", "disconnected")
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/rpc"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/tasks"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
        "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcserver "github.com/trigg3rX/triggerx-backend/pkg/rpc/server"
)

const shutdownTimeout = 10 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.TaskDispatcherProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting Task Dispatcher service ...")

        // Initialize metrics collector
        collector := metrics.NewCollector()
        logger.Info("[1/5] Metrics collector Initialised")
        collector.Start()

        // Create Redis client and verify connection
        redisConfig := config.GetRedisClientConfig()
        redisClient, err := redis.NewRedisClient(logger, redisConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create Redis client", "error", err)
        }</span>
        <span class="cov0" title="0">if err := redisClient.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Redis is not reachable", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/5] Redis client Initialised")

        // Set up monitoring hooks for metrics integration
        monitoringHooks := metrics.CreateRedisMonitoringHooks()
        redisClient.SetMonitoringHooks(monitoringHooks)

        aggCfg := aggregator.AggregatorClientConfig{
                AggregatorRPCUrl: config.GetAggregatorRPCUrl(),
                SenderPrivateKey: config.GetTaskDispatcherSigningKey(),
                SenderAddress:    config.GetTaskDispatcherSigningAddress(),
        }
        aggClient, err := aggregator.NewAggregatorClient(logger, aggCfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create aggregator client", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[3/5] Aggregator client Initialised")

        healthClient := taskdispatcher.NewHealthClient(logger, config.GetHealthRPCUrl())
        logger.Info("[4/5] Health client Initialised")

        // Initialize task stream manager for orchestration
        taskStreamMgr, err := tasks.NewTaskStreamManager(redisClient, aggClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize TaskStreamManager", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[5/5] Task stream manager Initialised")

        // TaskDispatcher is the main orchestrator. It needs all the other components.
        dispatcher, err := taskdispatcher.NewTaskDispatcher(
                logger,
                taskStreamMgr,
                healthClient,
                config.GetTaskDispatcherSigningKey(),
                config.GetTaskDispatcherSigningAddress(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize TaskDispatcher", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Task Dispatcher Initialised")

        // 5. Initialize the delivery mechanism (RPC Server) using the generic approach
        serverConfig := rpcserver.Config{
                Name:    "TaskDispatcher",
                Version: "1.0.0",
                Address: "0.0.0.0",
                Port:    config.GetTaskDispatcherRPCPort(),
        }
        srv := rpcserver.NewServer(serverConfig, logger)
        srv.AddInterceptor(rpcserver.LoggingInterceptor(logger))

        // Create and register the generic RPC handler
        handler := rpc.NewTaskDispatcherHandler(logger, dispatcher)
        srv.RegisterHandler("TaskDispatcher", handler)

        // 6. Start everything
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        if err := srv.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start RPC server", "error", err)
        }</span>

        // Wait for interrupt signal
        <span class="cov0" title="0">shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

        // Block until signal is received
        &lt;-shutdown

        // Perform graceful shutdown
        performGracefulShutdown(ctx, srv, dispatcher, logger)</span>
}

// performGracefulShutdown handles graceful shutdown of the service
func performGracefulShutdown(ctx context.Context, server *rpcserver.Server, dispatcher *taskdispatcher.TaskDispatcher, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(ctx, shutdownTimeout)
        defer cancel()

        // Shutdown server gracefully
        logger.Info("Shutting down RPC server...")
        if err := server.Stop(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("RPC server forced to shutdown", "error", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("RPC server stopped successfully")
        }</span>

        // Close the Dispatcher
        <span class="cov0" title="0">if err := dispatcher.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to close dispatcher", "error", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Dispatcher closed successfully")
        }</span>

        <span class="cov0" title="0">logger.Info("Task Dispatcher service shutdown complete")

        // Ensure we exit cleanly
        select </span>{
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                logger.Error("Shutdown timeout exceeded")
                os.Exit(1)</span>
        default:<span class="cov0" title="0">
                os.Exit(0)</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const shutdownTimeout = 10 * time.Second

func main() <span class="cov0" title="0">{
        // Initialize configuration
        if err := config.Init(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize config: %v", err))</span>
        }

        // Initialize logger
        <span class="cov0" title="0">logConfig := logging.LoggerConfig{
                ProcessName:   logging.TaskMonitorProcess,
                IsDevelopment: config.IsDevMode(),
        }

        logger, err := logging.NewZapLogger(logConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to initialize logger: %v", err))</span>
        }

        <span class="cov0" title="0">logger.Info("Starting Task Monitor service ...")

        // Initialize TaskManager (handles Redis, Database, IPFS, Event Listener, and Task Stream Manager)
        taskManager, err := taskmonitor.NewTaskManager(logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create TaskManager", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[1/5] TaskManager created successfully")

        // Initialize all components
        if err := taskManager.Initialize(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to initialize TaskManager components", "error", err)
        }</span>
        <span class="cov0" title="0">logger.Info("[2/5] TaskManager components initialized successfully")

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Log service status
        logger.Info("Task Monitor service is running")

        // Wait for interrupt signal
        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)

        // Block until signal is received
        &lt;-shutdown

        // Perform graceful shutdown
        performGracefulShutdown(ctx, taskManager, logger)</span>
}

func performGracefulShutdown(ctx context.Context, taskManager *taskmonitor.TaskManager, logger logging.Logger) <span class="cov0" title="0">{
        logger.Info("Initiating graceful shutdown...")

        // Create shutdown context with timeout
        shutdownCtx, cancel := context.WithTimeout(ctx, shutdownTimeout)
        defer cancel()

        // Close TaskManager (handles all components)
        logger.Info("Closing TaskManager...")
        if err := taskManager.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error closing TaskManager", "error", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("TaskManager closed successfully")
        }</span>
        <span class="cov0" title="0">logger.Info("Task Monitor service shutdown complete")

        // Ensure we exit cleanly
        select </span>{
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                logger.Error("Shutdown timeout exceeded")
                os.Exit(1)</span>
        default:<span class="cov0" title="0">
                os.Exit(0)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package aggregator

import (
        "context"
        // "crypto/rand"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/aggregator/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Aggregator manages tasks, operators, and response aggregation
type Aggregator struct {
        logger logging.Logger
        mu     sync.RWMutex

        // Task management
        tasks         map[types.TaskIndex]*types.Task
        taskResponses map[types.TaskIndex][]*types.TaskResponse
        nextTaskIndex types.TaskIndex

        // Operator management
        operators map[string]*types.OperatorInfo

        // Configuration
        config *types.AggregatorConfig

        // Channels for communication
        taskChannel     chan *types.Task
        responseChannel chan *types.TaskResponse
        shutdownChannel chan struct{}

        // Metrics
        stats *types.AggregatorStats
}

// NewAggregator creates a new aggregator instance
func NewAggregator(logger logging.Logger, config *types.AggregatorConfig) *Aggregator <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;types.AggregatorConfig{
                        MaxConcurrentTasks: 100,
                        DefaultTimeout:     5 * time.Minute,
                        MinOperators:       1,
                        MaxOperators:       100,
                }
        }</span>

        <span class="cov0" title="0">return &amp;Aggregator{
                logger:          logger,
                tasks:           make(map[types.TaskIndex]*types.Task),
                taskResponses:   make(map[types.TaskIndex][]*types.TaskResponse),
                operators:       make(map[string]*types.OperatorInfo),
                nextTaskIndex:   1,
                config:          config,
                taskChannel:     make(chan *types.Task, config.MaxConcurrentTasks),
                responseChannel: make(chan *types.TaskResponse, config.MaxConcurrentTasks*10),
                shutdownChannel: make(chan struct{}),
                stats: &amp;types.AggregatorStats{
                        TotalTasks:      0,
                        CompletedTasks:  0,
                        FailedTasks:     0,
                        ActiveOperators: 0,
                        LastTaskCreated: time.Time{},
                },
        }</span>
}

// Start begins the aggregator service
func (a *Aggregator) Start(ctx context.Context) error <span class="cov0" title="0">{
        a.logger.Info("Starting aggregator service...")

        // Start background workers
        go a.taskProcessor(ctx)
        go a.responseProcessor(ctx)
        go a.taskExpiryChecker(ctx)
        go a.statsUpdater(ctx)

        a.logger.Info("Aggregator service started successfully")
        return nil
}</span>

// Stop gracefully shuts down the aggregator
func (a *Aggregator) Stop() error <span class="cov0" title="0">{
        a.logger.Info("Stopping aggregator service...")
        close(a.shutdownChannel)
        return nil
}</span>

// CreateTask creates a new task and adds it to the processing queue
func (a *Aggregator) CreateTask(req *types.NewTaskRequest) (*types.Task, error) <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Check if we've reached the maximum concurrent tasks
        if len(a.tasks) &gt;= a.config.MaxConcurrentTasks </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("maximum concurrent tasks limit reached (%d)", a.config.MaxConcurrentTasks)
        }</span>

        // Set default timeout if not provided
        <span class="cov0" title="0">timeout := req.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = a.config.DefaultTimeout
        }</span>

        // Create new task
        <span class="cov0" title="0">task := &amp;types.Task{
                Index:          a.nextTaskIndex,
                Data:           req.Data,
                CreatedAt:      time.Now(),
                ExpiresAt:      time.Now().Add(timeout),
                Status:         types.TaskStatusPending,
                RequiredQuorum: req.RequiredQuorum,
                SubmitterAddr:  req.SubmitterAddr,
                ResponseCount:  0,
                BlockNumber:    types.BlockNumber(time.Now().Unix()), // Simplified block number
        }

        // Store task
        a.tasks[task.Index] = task
        a.taskResponses[task.Index] = make([]*types.TaskResponse, 0)
        a.nextTaskIndex++

        // Update stats
        a.stats.TotalTasks++
        a.stats.LastTaskCreated = task.CreatedAt

        // Queue task for processing
        select </span>{
        case a.taskChannel &lt;- task:<span class="cov0" title="0">
                a.logger.Infof("Created task %d: %s", task.Index, task.Data)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("task queue is full")</span>
        }

        <span class="cov0" title="0">return task, nil</span>
}

// SubmitTaskResponse processes a response from an operator
func (a *Aggregator) SubmitTaskResponse(response *types.TaskResponse) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Validate task exists
        task, exists := a.tasks[response.TaskIndex]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task %d not found", response.TaskIndex)
        }</span>

        // Check if task is still active
        <span class="cov0" title="0">if task.Status != types.TaskStatusPending &amp;&amp; task.Status != types.TaskStatusProcessing </span><span class="cov0" title="0">{
                return fmt.Errorf("task %d is no longer accepting responses (status: %s)", response.TaskIndex, task.Status)
        }</span>

        // Check if task has expired
        <span class="cov0" title="0">if time.Now().After(task.ExpiresAt) </span><span class="cov0" title="0">{
                task.Status = types.TaskStatusExpired
                return fmt.Errorf("task %d has expired", response.TaskIndex)
        }</span>

        // Validate operator
        <span class="cov0" title="0">operator, exists := a.operators[response.OperatorID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("operator %s not registered", response.OperatorID)
        }</span>

        <span class="cov0" title="0">if !operator.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("operator %s is not active", response.OperatorID)
        }</span>

        // Check for duplicate responses from the same operator
        <span class="cov0" title="0">for _, existingResponse := range a.taskResponses[response.TaskIndex] </span><span class="cov0" title="0">{
                if existingResponse.OperatorID == response.OperatorID </span><span class="cov0" title="0">{
                        return fmt.Errorf("operator %s has already submitted a response for task %d", response.OperatorID, response.TaskIndex)
                }</span>
        }

        // Add response timestamp
        <span class="cov0" title="0">response.SubmittedAt = time.Now()
        response.IsValid = a.validateResponse(task, response)

        // Store response
        a.taskResponses[response.TaskIndex] = append(a.taskResponses[response.TaskIndex], response)
        task.ResponseCount++

        // Update operator activity
        operator.LastActivity = time.Now()

        // Queue response for processing
        select </span>{
        case a.responseChannel &lt;- response:<span class="cov0" title="0">
                a.logger.Infof("Received response from operator %s for task %d", response.OperatorID, response.TaskIndex)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("response queue is full")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RegisterOperator registers a new operator
func (a *Aggregator) RegisterOperator(operator *types.OperatorInfo) error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Check if operator already exists
        if _, exists := a.operators[operator.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("operator %s already registered", operator.ID)
        }</span>

        // Check maximum operators limit
        <span class="cov0" title="0">if len(a.operators) &gt;= a.config.MaxOperators </span><span class="cov0" title="0">{
                return fmt.Errorf("maximum operators limit reached (%d)", a.config.MaxOperators)
        }</span>

        // Set registration time and activate
        <span class="cov0" title="0">operator.RegisteredAt = time.Now()
        operator.LastActivity = time.Now()
        operator.IsActive = true

        // Store operator
        a.operators[operator.ID] = operator
        a.stats.ActiveOperators++

        a.logger.Infof("Registered operator %s at address %s", operator.ID, operator.Address.Hex())
        return nil</span>
}

// GetTask retrieves a task by index
func (a *Aggregator) GetTask(taskIndex types.TaskIndex) (*types.Task, error) <span class="cov0" title="0">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        task, exists := a.tasks[taskIndex]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task %d not found", taskIndex)
        }</span>

        <span class="cov0" title="0">return task, nil</span>
}

// GetTasks retrieves tasks with pagination
func (a *Aggregator) GetTasks(page, pageSize int) (*types.TaskListResponse, error) <span class="cov0" title="0">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        totalCount := len(a.tasks)
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>

        <span class="cov0" title="0">start := (page - 1) * pageSize
        end := start + pageSize

        tasks := make([]*types.Task, 0, len(a.tasks))
        for _, task := range a.tasks </span><span class="cov0" title="0">{
                tasks = append(tasks, task)
        }</span>

        // Sort by creation time (newest first)
        <span class="cov0" title="0">for i := 0; i &lt; len(tasks)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(tasks); j++ </span><span class="cov0" title="0">{
                        if tasks[i].CreatedAt.Before(tasks[j].CreatedAt) </span><span class="cov0" title="0">{
                                tasks[i], tasks[j] = tasks[j], tasks[i]
                        }</span>
                }
        }

        // Apply pagination
        <span class="cov0" title="0">var paginatedTasks []types.Task
        if start &lt; len(tasks) </span><span class="cov0" title="0">{
                if end &gt; len(tasks) </span><span class="cov0" title="0">{
                        end = len(tasks)
                }</span>
                <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                        paginatedTasks = append(paginatedTasks, *tasks[i])
                }</span>
        }

        <span class="cov0" title="0">return &amp;types.TaskListResponse{
                Tasks:      paginatedTasks,
                TotalCount: totalCount,
                Page:       page,
                PageSize:   pageSize,
        }, nil</span>
}

// GetStats returns current aggregator statistics
func (a *Aggregator) GetStats() *types.AggregatorStats <span class="cov0" title="0">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        statsCopy := *a.stats
        return &amp;statsCopy
}</span>

// validateResponse validates a task response (simplified implementation)
func (a *Aggregator) validateResponse(task *types.Task, response *types.TaskResponse) bool <span class="cov0" title="0">{
        // Basic validation - in a real implementation, this would include signature verification
        if response.Response == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Validate operator address matches registered address
        <span class="cov0" title="0">operator, exists := a.operators[response.OperatorID]
        if !exists || operator.Address != response.OperatorAddr </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// taskProcessor handles task processing in the background
func (a *Aggregator) taskProcessor(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.shutdownChannel:<span class="cov0" title="0">
                        return</span>
                case task := &lt;-a.taskChannel:<span class="cov0" title="0">
                        a.processTask(task)</span>
                }
        }
}

// processTask handles individual task processing
func (a *Aggregator) processTask(task *types.Task) <span class="cov0" title="0">{
        a.mu.Lock()
        task.Status = types.TaskStatusProcessing
        a.mu.Unlock()

        a.logger.Infof("Processing task %d", task.Index)

        // Simulate task broadcasting to operators
        // In a real implementation, this would send the task to registered operators

        // For now, we just mark it as processing and wait for responses
}</span>

// responseProcessor handles response processing and aggregation
func (a *Aggregator) responseProcessor(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.shutdownChannel:<span class="cov0" title="0">
                        return</span>
                case response := &lt;-a.responseChannel:<span class="cov0" title="0">
                        a.processResponse(response)</span>
                }
        }
}

// processResponse handles individual response processing
func (a *Aggregator) processResponse(response *types.TaskResponse) <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        task := a.tasks[response.TaskIndex]
        responses := a.taskResponses[response.TaskIndex]

        // Count valid responses
        validResponses := 0
        for _, resp := range responses </span><span class="cov0" title="0">{
                if resp.IsValid </span><span class="cov0" title="0">{
                        validResponses++
                }</span>
        }

        // Check if we have enough responses to meet quorum
        <span class="cov0" title="0">if validResponses &gt;= int(task.RequiredQuorum) </span><span class="cov0" title="0">{
                task.Status = types.TaskStatusCompleted
                a.stats.CompletedTasks++
                a.logger.Infof("Task %d completed with %d valid responses", task.Index, validResponses)
        }</span>
}

// taskExpiryChecker periodically checks for expired tasks
func (a *Aggregator) taskExpiryChecker(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.shutdownChannel:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.checkExpiredTasks()</span>
                }
        }
}

// checkExpiredTasks marks expired tasks as failed
func (a *Aggregator) checkExpiredTasks() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        now := time.Now()
        expiredCount := 0

        for _, task := range a.tasks </span><span class="cov0" title="0">{
                if (task.Status == types.TaskStatusPending || task.Status == types.TaskStatusProcessing) &amp;&amp; now.After(task.ExpiresAt) </span><span class="cov0" title="0">{
                        task.Status = types.TaskStatusExpired
                        a.stats.FailedTasks++
                        expiredCount++
                }</span>
        }

        <span class="cov0" title="0">if expiredCount &gt; 0 </span><span class="cov0" title="0">{
                a.logger.Infof("Marked %d tasks as expired", expiredCount)
        }</span>
}

// statsUpdater periodically updates aggregator statistics
func (a *Aggregator) statsUpdater(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.shutdownChannel:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.updateStats()</span>
                }
        }
}

// updateStats calculates and updates performance statistics
func (a *Aggregator) updateStats() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Update active operator count
        activeCount := 0
        for _, operator := range a.operators </span><span class="cov0" title="0">{
                if operator.IsActive </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }
        <span class="cov0" title="0">a.stats.ActiveOperators = activeCount

        // Calculate average response time (simplified)
        totalResponseTime := time.Duration(0)
        responseCount := 0

        for taskIndex, responses := range a.taskResponses </span><span class="cov0" title="0">{
                task := a.tasks[taskIndex]
                for _, response := range responses </span><span class="cov0" title="0">{
                        if response.IsValid </span><span class="cov0" title="0">{
                                responseTime := response.SubmittedAt.Sub(task.CreatedAt)
                                totalResponseTime += responseTime
                                responseCount++
                        }</span>
                }
        }

        <span class="cov0" title="0">if responseCount &gt; 0 </span><span class="cov0" title="0">{
                a.stats.AverageResponseTime = totalResponseTime / time.Duration(responseCount)
        }</span>
}

// generateTaskID generates a unique task ID (simplified)
// func (a *Aggregator) generateTaskID() string {
//         // Generate a random task ID
//         randomBytes := make([]byte, 8)
//         _, err := rand.Read(randomBytes)
//         if err != nil {
//                 a.logger.Errorf("Failed to generate task ID: %v", err)
//                 return ""
//         }
//         return fmt.Sprintf("task_%x", randomBytes)
// }
</pre>
		
		<pre class="file" id="file30" style="display: none">package api

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

func LoggerMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Set("logger", logger)
                c.Next()
        }</span>
}</pre>
		
		<pre class="file" id="file31" style="display: none">package api

import (
        "net/http"
        "strconv"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/gin-gonic/gin"

        "github.com/trigg3rX/triggerx-backend/internal/aggregator"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// APIHandlers contains the aggregator instance and provides HTTP handlers
type APIHandlers struct {
        aggregator *aggregator.Aggregator
        logger     logging.Logger
}

// NewAPIHandlers creates a new API handlers instance
func NewAPIHandlers(agg *aggregator.Aggregator, logger logging.Logger) *APIHandlers <span class="cov0" title="0">{
        return &amp;APIHandlers{
                aggregator: agg,
                logger:     logger,
        }
}</span>

// RegisterRoutes registers all HTTP routes for the aggregator API
func RegisterRoutes(router *gin.Engine, logger logging.Logger) <span class="cov0" title="0">{
        // This will be updated once we have the aggregator instance
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message":     "Aggregator service is running",
                        "timestamp":   time.Now().Unix(),
                        "server_time": time.Now().Format(time.RFC3339),
                })
        }</span>)
}

// RegisterRoutesWithAggregator registers all HTTP routes with an aggregator instance
func RegisterRoutesWithAggregator(router *gin.Engine, agg *aggregator.Aggregator, logger logging.Logger) <span class="cov0" title="0">{
        handlers := NewAPIHandlers(agg, logger)

        // API version group
        v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Health and status endpoints
                v1.GET("/health", handlers.HealthCheck)
                v1.GET("/stats", handlers.GetStats)

                // Task management endpoints
                tasks := v1.Group("/tasks")
                </span><span class="cov0" title="0">{
                        tasks.POST("/", handlers.CreateTask)
                        tasks.GET("/", handlers.GetTasks)
                        tasks.GET("/:taskIndex", handlers.GetTask)
                }</span>

                // Operator management endpoints
                <span class="cov0" title="0">operators := v1.Group("/operators")
                </span><span class="cov0" title="0">{
                        operators.POST("/register", handlers.RegisterOperator)
                        operators.POST("/response", handlers.SubmitTaskResponse)
                }</span>
        }

        // Legacy endpoints for backward compatibility
        <span class="cov0" title="0">router.GET("/health", handlers.HealthCheck)</span>
}

// ============================================================================
// Health and Status Handlers
// ============================================================================

// HealthCheck returns the health status of the aggregator
func (h *APIHandlers) HealthCheck(c *gin.Context) <span class="cov0" title="0">{
        stats := h.aggregator.GetStats()

        c.JSON(http.StatusOK, gin.H{
                "message":     "Aggregator service is running",
                "timestamp":   time.Now().Unix(),
                "server_time": time.Now().Format(time.RFC3339),
                "stats":       stats,
                "status":      "healthy",
        })
}</span>

// GetStats returns aggregator statistics
func (h *APIHandlers) GetStats(c *gin.Context) <span class="cov0" title="0">{
        stats := h.aggregator.GetStats()

        c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "data":      stats,
                "timestamp": time.Now().Unix(),
        })
}</span>

// ============================================================================
// Task Management Handlers
// ============================================================================

// CreateTaskRequest represents the request body for creating a task
type CreateTaskRequest struct {
        Data           string `json:"data" binding:"required"`
        RequiredQuorum uint8  `json:"required_quorum"`
        Timeout        string `json:"timeout,omitempty"` // Duration string like "5m", "1h"
        SubmitterAddr  string `json:"submitter_address" binding:"required"`
}

// CreateTask handles task creation requests
func (h *APIHandlers) CreateTask(c *gin.Context) <span class="cov0" title="0">{
        var req CreateTaskRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid task creation request", "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Parse submitter address
        <span class="cov0" title="0">submitterAddr := common.HexToAddress(req.SubmitterAddr)
        if submitterAddr == (common.Address{}) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid submitter address",
                })
                return
        }</span>

        // Parse timeout if provided
        <span class="cov0" title="0">var timeout time.Duration
        if req.Timeout != "" </span><span class="cov0" title="0">{
                var err error
                timeout, err = time.ParseDuration(req.Timeout)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "success": false,
                                "error":   "Invalid timeout format",
                                "details": "Use format like '5m', '1h', '30s'",
                        })
                        return
                }</span>
        }

        // Set default quorum if not provided
        <span class="cov0" title="0">requiredQuorum := req.RequiredQuorum
        if requiredQuorum == 0 </span><span class="cov0" title="0">{
                requiredQuorum = 1
        }</span>

        // Create task request
        <span class="cov0" title="0">taskReq := &amp;types.NewTaskRequest{
                Data:           req.Data,
                RequiredQuorum: requiredQuorum,
                Timeout:        timeout,
                SubmitterAddr:  submitterAddr,
        }

        // Create task
        task, err := h.aggregator.CreateTask(taskReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create task", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to create task",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Infof("Task created successfully: %d", task.Index)
        c.JSON(http.StatusCreated, gin.H{
                "success":   true,
                "message":   "Task created successfully",
                "data":      task,
                "timestamp": time.Now().Unix(),
        })</span>
}

// GetTasks handles task listing requests
func (h *APIHandlers) GetTasks(c *gin.Context) <span class="cov0" title="0">{
        // Parse query parameters
        pageStr := c.DefaultQuery("page", "1")
        pageSizeStr := c.DefaultQuery("page_size", "10")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">pageSize, err := strconv.Atoi(pageSizeStr)
        if err != nil || pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>

        // Get tasks
        <span class="cov0" title="0">taskList, err := h.aggregator.GetTasks(page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get tasks", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "success": false,
                        "error":   "Failed to retrieve tasks",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "data":      taskList,
                "timestamp": time.Now().Unix(),
        })</span>
}

// GetTask handles individual task retrieval requests
func (h *APIHandlers) GetTask(c *gin.Context) <span class="cov0" title="0">{
        taskIndexStr := c.Param("taskIndex")

        taskIndex, err := strconv.ParseUint(taskIndexStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid task index",
                        "details": "Task index must be a valid number",
                })
                return
        }</span>

        // Get task
        <span class="cov0" title="0">task, err := h.aggregator.GetTask(types.TaskIndex(taskIndex))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get task", "task_index", taskIndex, "error", err)
                c.JSON(http.StatusNotFound, gin.H{
                        "success": false,
                        "error":   "Task not found",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "data":      task,
                "timestamp": time.Now().Unix(),
        })</span>
}

// ============================================================================
// Operator Management Handlers
// ============================================================================

// RegisterOperatorRequest represents the request body for operator registration
type RegisterOperatorRequest struct {
        OperatorID string `json:"operator_id" binding:"required"`
        Address    string `json:"address" binding:"required"`
        PublicKey  string `json:"public_key" binding:"required"`
        Stake      string `json:"stake"`
        Signature  string `json:"signature"`
}

// RegisterOperator handles operator registration requests
func (h *APIHandlers) RegisterOperator(c *gin.Context) <span class="cov0" title="0">{
        var req RegisterOperatorRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid operator registration request", "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Parse operator address
        <span class="cov0" title="0">operatorAddr := common.HexToAddress(req.Address)
        if operatorAddr == (common.Address{}) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid operator address",
                })
                return
        }</span>

        // Create operator info
        <span class="cov0" title="0">operatorInfo := &amp;types.OperatorInfo{
                ID:        req.OperatorID,
                Address:   operatorAddr,
                PublicKey: req.PublicKey,
                Stake:     req.Stake,
        }

        // Register operator
        err := h.aggregator.RegisterOperator(operatorInfo)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to register operator", "operator_id", req.OperatorID, "error", err)
                c.JSON(http.StatusConflict, gin.H{
                        "success": false,
                        "error":   "Failed to register operator",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Infof("Operator registered successfully: %s", req.OperatorID)
        c.JSON(http.StatusCreated, gin.H{
                "success":     true,
                "message":     "Operator registered successfully",
                "operator_id": req.OperatorID,
                "timestamp":   time.Now().Unix(),
        })</span>
}

// SubmitTaskResponseRequest represents the request body for task response submission
type SubmitTaskResponseRequest struct {
        TaskIndex    uint32 `json:"task_index" binding:"required"`
        OperatorID   string `json:"operator_id" binding:"required"`
        OperatorAddr string `json:"operator_address" binding:"required"`
        Response     string `json:"response" binding:"required"`
        Signature    string `json:"signature" binding:"required"`
}

// SubmitTaskResponse handles task response submissions from operators
func (h *APIHandlers) SubmitTaskResponse(c *gin.Context) <span class="cov0" title="0">{
        var req SubmitTaskResponseRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid task response submission", "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Parse operator address
        <span class="cov0" title="0">operatorAddr := common.HexToAddress(req.OperatorAddr)
        if operatorAddr == (common.Address{}) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "success": false,
                        "error":   "Invalid operator address",
                })
                return
        }</span>

        // Create task response
        <span class="cov0" title="0">taskResponse := &amp;types.TaskResponse{
                TaskIndex:    types.TaskIndex(req.TaskIndex),
                OperatorID:   req.OperatorID,
                OperatorAddr: operatorAddr,
                Response:     req.Response,
                Signature:    req.Signature,
        }

        // Submit response
        err := h.aggregator.SubmitTaskResponse(taskResponse)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to submit task response",
                        "operator_id", req.OperatorID,
                        "task_index", req.TaskIndex,
                        "error", err)

                status := http.StatusInternalServerError
                if err.Error() == "task not found" </span><span class="cov0" title="0">{
                        status = http.StatusNotFound
                }</span> else<span class="cov0" title="0"> if err.Error() == "task has expired" || err.Error() == "operator has already responded" </span><span class="cov0" title="0">{
                        status = http.StatusConflict
                }</span>

                <span class="cov0" title="0">c.JSON(status, gin.H{
                        "success": false,
                        "error":   "Failed to submit task response",
                        "details": err.Error(),
                })
                return</span>
        }

        <span class="cov0" title="0">h.logger.Infof("Task response submitted successfully: operator %s, task %d", req.OperatorID, req.TaskIndex)
        c.JSON(http.StatusOK, gin.H{
                "success":     true,
                "message":     "Task response submitted successfully",
                "task_index":  req.TaskIndex,
                "operator_id": req.OperatorID,
                "timestamp":   time.Now().Unix(),
        })</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Port configuration
        aggregatorRPCPort string
        aggregatorP2PPort string

        // Task management configuration
        maxConcurrentTasks  int
        defaultTaskTimeout  time.Duration
        taskCleanupInterval time.Duration

        // Operator configuration
        minOperators            int
        maxOperators            int
        operatorTimeoutDuration time.Duration

        // Performance and limits
        requestTimeout   time.Duration
        maxRetryAttempts int

        // Blockchain configuration (for future use)
        ethRPCURL string
        chainID   int64

        // Security configuration
        enableSignatureValidation bool
        requireStakedOperators    bool
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>

        // Parse duration values
        <span class="cov0" title="0">defaultTaskTimeout, err := parseDurationWithDefault(env.GetEnvString("AGGREGATOR_DEFAULT_TASK_TIMEOUT", "5m"), 5*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AGGREGATOR_DEFAULT_TASK_TIMEOUT: %w", err)
        }</span>

        <span class="cov0" title="0">taskCleanupInterval, err := parseDurationWithDefault(env.GetEnvString("AGGREGATOR_TASK_CLEANUP_INTERVAL", "1h"), 1*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AGGREGATOR_TASK_CLEANUP_INTERVAL: %w", err)
        }</span>

        <span class="cov0" title="0">operatorTimeoutDuration, err := parseDurationWithDefault(env.GetEnvString("AGGREGATOR_OPERATOR_TIMEOUT", "30s"), 30*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AGGREGATOR_OPERATOR_TIMEOUT: %w", err)
        }</span>

        <span class="cov0" title="0">requestTimeout, err := parseDurationWithDefault(env.GetEnvString("AGGREGATOR_REQUEST_TIMEOUT", "30s"), 30*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AGGREGATOR_REQUEST_TIMEOUT: %w", err)
        }</span>

        <span class="cov0" title="0">cfg = Config{
                devMode:           env.GetEnvBool("DEV_MODE", false),
                aggregatorRPCPort: env.GetEnvString("AGGREGATOR_RPC_PORT", "9007"),
                aggregatorP2PPort: env.GetEnvString("AGGREGATOR_P2P_PORT", "9008"),

                // Task management
                maxConcurrentTasks:  env.GetEnvInt("AGGREGATOR_MAX_CONCURRENT_TASKS", 100),
                defaultTaskTimeout:  defaultTaskTimeout,
                taskCleanupInterval: taskCleanupInterval,

                // Operator configuration
                minOperators:            env.GetEnvInt("AGGREGATOR_MIN_OPERATORS", 1),
                maxOperators:            env.GetEnvInt("AGGREGATOR_MAX_OPERATORS", 100),
                operatorTimeoutDuration: operatorTimeoutDuration,

                // Performance and limits
                requestTimeout:   requestTimeout,
                maxRetryAttempts: env.GetEnvInt("AGGREGATOR_MAX_RETRY_ATTEMPTS", 3),

                // Blockchain configuration
                ethRPCURL: env.GetEnvString("ETH_RPC_URL", ""),
                chainID:   int64(env.GetEnvInt("CHAIN_ID", 1)),

                // Security configuration
                enableSignatureValidation: env.GetEnvBool("AGGREGATOR_ENABLE_SIGNATURE_VALIDATION", false),
                requireStakedOperators:    env.GetEnvBool("AGGREGATOR_REQUIRE_STAKED_OPERATORS", false),
        }

        if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateConfig() error <span class="cov0" title="0">{
        if !env.IsValidPort(cfg.aggregatorRPCPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Aggregator RPC Port: %s", cfg.aggregatorRPCPort)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPort(cfg.aggregatorP2PPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Aggregator P2P Port: %s", cfg.aggregatorP2PPort)
        }</span>

        // Validate task configuration
        <span class="cov0" title="0">if cfg.maxConcurrentTasks &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxConcurrentTasks must be at least 1")
        }</span>
        <span class="cov0" title="0">if cfg.defaultTaskTimeout &lt; time.Second </span><span class="cov0" title="0">{
                return fmt.Errorf("defaultTaskTimeout must be at least 1 second")
        }</span>

        // Validate operator configuration
        <span class="cov0" title="0">if cfg.minOperators &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("minOperators must be at least 1")
        }</span>
        <span class="cov0" title="0">if cfg.maxOperators &lt; cfg.minOperators </span><span class="cov0" title="0">{
                return fmt.Errorf("maxOperators must be greater than or equal to minOperators")
        }</span>

        // Validate performance configuration
        <span class="cov0" title="0">if cfg.maxRetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxRetryAttempts must be non-negative")
        }</span>
        <span class="cov0" title="0">if cfg.requestTimeout &lt; time.Second </span><span class="cov0" title="0">{
                return fmt.Errorf("requestTimeout must be at least 1 second")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// parseDurationWithDefault parses a duration string, returning the default if empty or invalid
func parseDurationWithDefault(durationStr string, defaultDuration time.Duration) (time.Duration, error) <span class="cov0" title="0">{
        if durationStr == "" </span><span class="cov0" title="0">{
                return defaultDuration, nil
        }</span>
        <span class="cov0" title="0">return time.ParseDuration(durationStr)</span>
}

// Basic getters
func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetAggregatorRPCPort() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCPort
}</span>

func GetAggregatorP2PPort() string <span class="cov0" title="0">{
        return cfg.aggregatorP2PPort
}</span>

// Task management getters
func GetMaxConcurrentTasks() int <span class="cov0" title="0">{
        return cfg.maxConcurrentTasks
}</span>

func GetDefaultTaskTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.defaultTaskTimeout
}</span>

func GetTaskCleanupInterval() time.Duration <span class="cov0" title="0">{
        return cfg.taskCleanupInterval
}</span>

// Operator configuration getters
func GetMinOperators() int <span class="cov0" title="0">{
        return cfg.minOperators
}</span>

func GetMaxOperators() int <span class="cov0" title="0">{
        return cfg.maxOperators
}</span>

func GetOperatorTimeoutDuration() time.Duration <span class="cov0" title="0">{
        return cfg.operatorTimeoutDuration
}</span>

// Performance configuration getters
func GetRequestTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.requestTimeout
}</span>

func GetMaxRetryAttempts() int <span class="cov0" title="0">{
        return cfg.maxRetryAttempts
}</span>

// Blockchain configuration getters
func GetEthRPCURL() string <span class="cov0" title="0">{
        return cfg.ethRPCURL
}</span>

func GetChainID() int64 <span class="cov0" title="0">{
        return cfg.chainID
}</span>

// Security configuration getters
func IsSignatureValidationEnabled() bool <span class="cov0" title="0">{
        return cfg.enableSignatureValidation
}</span>

func IsStakedOperatorsRequired() bool <span class="cov0" title="0">{
        return cfg.requireStakedOperators
}</span>

// GetAggregatorConfig returns a complete configuration object for the aggregator
func GetAggregatorConfig() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "dev_mode":                  cfg.devMode,
                "rpc_port":                  cfg.aggregatorRPCPort,
                "p2p_port":                  cfg.aggregatorP2PPort,
                "max_concurrent_tasks":      cfg.maxConcurrentTasks,
                "default_task_timeout":      cfg.defaultTaskTimeout.String(),
                "task_cleanup_interval":     cfg.taskCleanupInterval.String(),
                "min_operators":             cfg.minOperators,
                "max_operators":             cfg.maxOperators,
                "operator_timeout_duration": cfg.operatorTimeoutDuration.String(),
                "request_timeout":           cfg.requestTimeout.String(),
                "max_retry_attempts":        cfg.maxRetryAttempts,
                "eth_rpc_url":               cfg.ethRPCURL,
                "chain_id":                  cfg.chainID,
                "signature_validation":      cfg.enableSignatureValidation,
                "require_staked_operators":  cfg.requireStakedOperators,
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package rpc

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "net/rpc"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator"
        "github.com/trigg3rX/triggerx-backend/internal/aggregator/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Common RPC errors
var (
        ErrTaskNotFound             = errors.New("400. Task not found")
        ErrOperatorNotRegistered    = errors.New("400. Operator not registered")
        ErrInvalidTaskResponse      = errors.New("400. Invalid task response")
        ErrTaskExpired              = errors.New("400. Task has expired")
        ErrOperatorAlreadyResponded = errors.New("400. Operator has already responded to this task")
        ErrQuorumNotMet             = errors.New("400. Required quorum not met")
        ErrInvalidSignature         = errors.New("400. Invalid signature")
        ErrServerShuttingDown       = errors.New("500. Server is shutting down")
)

// RPCServer handles RPC communication with operators
type RPCServer struct {
        aggregator *aggregator.Aggregator
        logger     logging.Logger
        serverAddr string
        httpServer *http.Server
        isShutdown bool
}

// NewRPCServer creates a new RPC server instance
func NewRPCServer(agg *aggregator.Aggregator, logger logging.Logger, serverAddr string) *RPCServer <span class="cov0" title="0">{
        return &amp;RPCServer{
                aggregator: agg,
                logger:     logger,
                serverAddr: serverAddr,
                isShutdown: false,
        }
}</span>

// Start starts the RPC server
func (s *RPCServer) Start(ctx context.Context) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                return ErrServerShuttingDown
        }</span>

        // Register RPC methods
        <span class="cov0" title="0">err := rpc.Register(s)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to register RPC service", "error", err)
                return fmt.Errorf("failed to register RPC service: %w", err)
        }</span>

        // Setup HTTP handler
        <span class="cov0" title="0">rpc.HandleHTTP()

        // Create HTTP server
        s.httpServer = &amp;http.Server{
                Addr:    s.serverAddr,
                Handler: http.DefaultServeMux,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                s.logger.Infof("Starting RPC server on %s", s.serverAddr)
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("RPC server error", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">s.logger.Info("RPC server started successfully")
        return nil</span>
}

// Stop gracefully shuts down the RPC server
func (s *RPCServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.isShutdown = true

        if s.httpServer != nil </span><span class="cov0" title="0">{
                s.logger.Info("Shutting down RPC server...")

                shutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
                defer cancel()

                if err := s.httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error during RPC server shutdown", "error", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("RPC server stopped")
        return nil</span>
}

// ============================================================================
// RPC Method Definitions (these must be exported and follow RPC conventions)
// ============================================================================

// OperatorRegistrationRequest represents an operator registration request
type OperatorRegistrationRequest struct {
        OperatorID string `json:"operator_id"`
        Address    string `json:"address"`
        PublicKey  string `json:"public_key"`
        Stake      string `json:"stake"`
        Signature  string `json:"signature"`
}

// OperatorRegistrationResponse represents the response to operator registration
type OperatorRegistrationResponse struct {
        Success   bool   `json:"success"`
        Message   string `json:"message"`
        Timestamp int64  `json:"timestamp"`
}

// RegisterOperator handles operator registration via RPC
func (s *RPCServer) RegisterOperator(req *OperatorRegistrationRequest, reply *OperatorRegistrationResponse) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                return ErrServerShuttingDown
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Received operator registration request from %s", req.OperatorID)

        // Validate input
        if req.OperatorID == "" || req.Address == "" || req.PublicKey == "" </span><span class="cov0" title="0">{
                reply.Success = false
                reply.Message = "Missing required fields"
                return ErrInvalidTaskResponse
        }</span>

        // Parse operator address
        <span class="cov0" title="0">operatorAddr := common.HexToAddress(req.Address)
        if operatorAddr == (common.Address{}) </span><span class="cov0" title="0">{
                reply.Success = false
                reply.Message = "Invalid operator address"
                return ErrInvalidTaskResponse
        }</span>

        // Create operator info
        <span class="cov0" title="0">operatorInfo := &amp;types.OperatorInfo{
                ID:        req.OperatorID,
                Address:   operatorAddr,
                PublicKey: req.PublicKey,
                Stake:     req.Stake,
        }

        // Register with aggregator
        err := s.aggregator.RegisterOperator(operatorInfo)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to register operator", "operator_id", req.OperatorID, "error", err)
                reply.Success = false
                reply.Message = err.Error()
                return err
        }</span>

        <span class="cov0" title="0">reply.Success = true
        reply.Message = "Operator registered successfully"
        reply.Timestamp = time.Now().Unix()

        s.logger.Infof("Successfully registered operator %s", req.OperatorID)
        return nil</span>
}

// TaskResponseSubmission represents a task response from an operator
type TaskResponseSubmission struct {
        TaskIndex    uint32 `json:"task_index"`
        OperatorID   string `json:"operator_id"`
        OperatorAddr string `json:"operator_address"`
        Response     string `json:"response"`
        Signature    string `json:"signature"`
}

// TaskResponseReply represents the response to a task response submission
type TaskResponseReply struct {
        Success   bool   `json:"success"`
        Message   string `json:"message"`
        TaskIndex uint32 `json:"task_index"`
        Timestamp int64  `json:"timestamp"`
}

// SubmitTaskResponse handles task response submission from operators via RPC
func (s *RPCServer) SubmitTaskResponse(submission *TaskResponseSubmission, reply *TaskResponseReply) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                return ErrServerShuttingDown
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Received task response from operator %s for task %d", submission.OperatorID, submission.TaskIndex)

        // Validate input
        if submission.OperatorID == "" || submission.Response == "" || submission.Signature == "" </span><span class="cov0" title="0">{
                reply.Success = false
                reply.Message = "Missing required fields"
                reply.TaskIndex = submission.TaskIndex
                return ErrInvalidTaskResponse
        }</span>

        // Parse operator address
        <span class="cov0" title="0">operatorAddr := common.HexToAddress(submission.OperatorAddr)
        if operatorAddr == (common.Address{}) </span><span class="cov0" title="0">{
                reply.Success = false
                reply.Message = "Invalid operator address"
                reply.TaskIndex = submission.TaskIndex
                return ErrInvalidTaskResponse
        }</span>

        // Create task response
        <span class="cov0" title="0">taskResponse := &amp;types.TaskResponse{
                TaskIndex:    types.TaskIndex(submission.TaskIndex),
                OperatorID:   submission.OperatorID,
                OperatorAddr: operatorAddr,
                Response:     submission.Response,
                Signature:    submission.Signature,
        }

        // Submit to aggregator
        err := s.aggregator.SubmitTaskResponse(taskResponse)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to submit task response",
                        "operator_id", submission.OperatorID,
                        "task_index", submission.TaskIndex,
                        "error", err)
                reply.Success = false
                reply.Message = err.Error()
                reply.TaskIndex = submission.TaskIndex
                return err
        }</span>

        <span class="cov0" title="0">reply.Success = true
        reply.Message = "Task response submitted successfully"
        reply.TaskIndex = submission.TaskIndex
        reply.Timestamp = time.Now().Unix()

        s.logger.Infof("Successfully processed task response from operator %s for task %d",
                submission.OperatorID, submission.TaskIndex)
        return nil</span>
}

// TaskInfoRequest represents a request for task information
type TaskInfoRequest struct {
        TaskIndex uint32 `json:"task_index"`
}

// TaskInfoResponse represents task information response
type TaskInfoResponse struct {
        Success   bool        `json:"success"`
        Message   string      `json:"message"`
        Task      *types.Task `json:"task,omitempty"`
        Timestamp int64       `json:"timestamp"`
}

// GetTaskInfo retrieves information about a specific task via RPC
func (s *RPCServer) GetTaskInfo(req *TaskInfoRequest, reply *TaskInfoResponse) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                return ErrServerShuttingDown
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Received task info request for task %d", req.TaskIndex)

        // Get task from aggregator
        task, err := s.aggregator.GetTask(types.TaskIndex(req.TaskIndex))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get task info", "task_index", req.TaskIndex, "error", err)
                reply.Success = false
                reply.Message = err.Error()
                reply.Timestamp = time.Now().Unix()
                return ErrTaskNotFound
        }</span>

        <span class="cov0" title="0">reply.Success = true
        reply.Message = "Task information retrieved successfully"
        reply.Task = task
        reply.Timestamp = time.Now().Unix()

        return nil</span>
}

// HealthCheckRequest represents a health check request
type HealthCheckRequest struct {
        OperatorID string `json:"operator_id,omitempty"`
}

// HealthCheckResponse represents a health check response
type HealthCheckResponse struct {
        Success    bool                   `json:"success"`
        Message    string                 `json:"message"`
        Stats      *types.AggregatorStats `json:"stats,omitempty"`
        Timestamp  int64                  `json:"timestamp"`
        ServerTime string                 `json:"server_time"`
}

// HealthCheck provides health status via RPC
func (s *RPCServer) HealthCheck(req *HealthCheckRequest, reply *HealthCheckResponse) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                reply.Success = false
                reply.Message = "Server is shutting down"
                reply.Timestamp = time.Now().Unix()
                reply.ServerTime = time.Now().Format(time.RFC3339)
                return ErrServerShuttingDown
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Received health check request")

        // Get aggregator stats
        stats := s.aggregator.GetStats()

        reply.Success = true
        reply.Message = "Aggregator RPC server is healthy"
        reply.Stats = stats
        reply.Timestamp = time.Now().Unix()
        reply.ServerTime = time.Now().Format(time.RFC3339)

        return nil</span>
}

// TaskListRequest represents a request for task listing
type TaskListRequest struct {
        Page     int `json:"page"`
        PageSize int `json:"page_size"`
}

// GetTasks retrieves a list of tasks via RPC
func (s *RPCServer) GetTasks(req *TaskListRequest, reply *types.TaskListResponse) error <span class="cov0" title="0">{
        if s.isShutdown </span><span class="cov0" title="0">{
                return ErrServerShuttingDown
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Received task list request (page: %d, size: %d)", req.Page, req.PageSize)

        // Set defaults
        page := req.Page
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">pageSize := req.PageSize
        if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>

        // Get tasks from aggregator
        <span class="cov0" title="0">taskList, err := s.aggregator.GetTasks(page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get task list", "error", err)
                return fmt.Errorf("failed to retrieve tasks: %w", err)
        }</span>

        <span class="cov0" title="0">*reply = *taskList
        return nil</span>
}

// ============================================================================
// Helper Methods
// ============================================================================

// GetAddress returns the server address
func (s *RPCServer) GetAddress() string <span class="cov0" title="0">{
        return s.serverAddr
}</span>

// IsRunning returns true if the server is running
func (s *RPCServer) IsRunning() bool <span class="cov0" title="0">{
        return s.httpServer != nil &amp;&amp; !s.isShutdown
}</span>

// GetStats returns server statistics
func (s *RPCServer) GetServerStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "server_address": s.serverAddr,
                "is_running":     s.IsRunning(),
                "is_shutdown":    s.isShutdown,
                "start_time":     time.Now().Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package config

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Scheduler RPC URLs
        timeSchedulerRPCUrl      string
        conditionSchedulerRPCUrl string

        // Database RPC Port
        dbserverRPCPort string

        // ScyllaDB Host and Port
        databaseHostAddress string
        databaseHostPort    string

        // Email User and Password
        emailUser     string
        emailPassword string
        botToken      string

        // API Keys for Alchemy
        alchemyAPIKey string

        // Faucet Private Key and Fund Amount
        faucetPrivateKey string
        faucetFundAmount string

        // Upstash Redis URL and Rest Token
        upstashRedisUrl       string
        upstashRedisRestToken string
        otTempoEndpoint       string

        // Polling Look Ahead
        timeSchedulerPollingLookAhead int
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                timeSchedulerRPCUrl:           env.GetEnvString("TIME_SCHEDULER_RPC_URL", "http://localhost:9005"),
                conditionSchedulerRPCUrl:      env.GetEnvString("CONDITION_SCHEDULER_RPC_URL", "http://localhost:9006"),
                dbserverRPCPort:               env.GetEnvString("DBSERVER_RPC_PORT", "9002"),
                databaseHostAddress:           env.GetEnvString("DATABASE_HOST_ADDRESS", "localhost"),
                databaseHostPort:              env.GetEnvString("DATABASE_HOST_PORT", "9042"),
                emailUser:                     env.GetEnvString("EMAIL_USER", ""),
                emailPassword:                 env.GetEnvString("EMAIL_PASS", ""),
                botToken:                      env.GetEnvString("BOT_TOKEN", ""),
                alchemyAPIKey:                 env.GetEnvString("ALCHEMY_API_KEY", ""),
                faucetPrivateKey:              env.GetEnvString("FAUCET_PRIVATE_KEY", ""),
                faucetFundAmount:              env.GetEnvString("FAUCET_FUND_AMOUNT", "30000000000000000"),
                upstashRedisUrl:               env.GetEnvString("UPSTASH_REDIS_URL", ""),
                upstashRedisRestToken:         env.GetEnvString("UPSTASH_REDIS_REST_TOKEN", ""),
                otTempoEndpoint:               env.GetEnvString("TEMPO_OTLP_ENDPOINT", "localhost:4318"),
                devMode:                       env.GetEnvBool("DEV_MODE", false),
                timeSchedulerPollingLookAhead: env.GetEnvInt("TIME_SCHEDULER_POLLING_LOOKAHEAD", 40),
        }
        if err := validateConfig(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig(cfg Config) error <span class="cov0" title="0">{
        if !env.IsValidURL(cfg.timeSchedulerRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid time scheduler RPC URL: %s", cfg.timeSchedulerRPCUrl)
        }</span>
        <span class="cov0" title="0">if !env.IsValidURL(cfg.conditionSchedulerRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid condition scheduler RPC URL: %s", cfg.conditionSchedulerRPCUrl)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPort(cfg.dbserverRPCPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database RPC port: %s", cfg.dbserverRPCPort)
        }</span>
        <span class="cov0" title="0">if !env.IsValidIPAddress(cfg.databaseHostAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host address: %s", cfg.databaseHostAddress)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPort(cfg.databaseHostPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host port: %s", cfg.databaseHostPort)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.alchemyAPIKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid alchemy api key: %s", cfg.alchemyAPIKey)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPrivateKey(cfg.faucetPrivateKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid faucet private key: %s", cfg.faucetPrivateKey)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.otTempoEndpoint) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tempo otlp endpoint: %s", cfg.otTempoEndpoint)
        }</span>
        // if env.IsEmpty(cfg.upstashRedisUrl) {
        //         return fmt.Errorf("invalid upstash redis url: %s", cfg.upstashRedisUrl)
        // }
        // if env.IsEmpty(cfg.upstashRedisRestToken) {
        //         return fmt.Errorf("invalid upstash redis rest token: %s", cfg.upstashRedisRestToken)
        // }
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                if !env.IsValidEmail(cfg.emailUser) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email user: %s", cfg.emailUser)
                }</span>
                <span class="cov0" title="0">if env.IsEmpty(cfg.emailPassword) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email password: %s", cfg.emailPassword)
                }</span>
                <span class="cov0" title="0">if env.IsEmpty(cfg.botToken) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid bot token: %s", cfg.botToken)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func GetTimeSchedulerRPCUrl() string <span class="cov0" title="0">{
        return cfg.timeSchedulerRPCUrl
}</span>

func GetConditionSchedulerRPCUrl() string <span class="cov0" title="0">{
        return cfg.conditionSchedulerRPCUrl
}</span>

func GetDBServerRPCPort() string <span class="cov0" title="0">{
        return cfg.dbserverRPCPort
}</span>

func GetDatabaseHostAddress() string <span class="cov0" title="0">{
        return cfg.databaseHostAddress
}</span>

func GetDatabaseHostPort() string <span class="cov0" title="0">{
        return cfg.databaseHostPort
}</span>

func GetEmailUser() string <span class="cov0" title="0">{
        return cfg.emailUser
}</span>

func GetEmailPassword() string <span class="cov0" title="0">{
        return cfg.emailPassword
}</span>

func GetBotToken() string <span class="cov0" title="0">{
        return cfg.botToken
}</span>

func GetAlchemyAPIKey() string <span class="cov0" title="0">{
        return cfg.alchemyAPIKey
}</span>

func GetFaucetPrivateKey() string <span class="cov0" title="0">{
        return cfg.faucetPrivateKey
}</span>

func GetFaucetFundAmount() string <span class="cov0" title="0">{
        return cfg.faucetFundAmount
}</span>

func GetUpstashRedisUrl() string <span class="cov0" title="0">{
        return cfg.upstashRedisUrl
}</span>

func GetUpstashRedisRestToken() string <span class="cov0" title="0">{
        return cfg.upstashRedisRestToken
}</span>

func GetOTTempoEndpoint() string <span class="cov0" title="0">{
        return cfg.otTempoEndpoint
}</span>

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetPollingLookAhead() int <span class="cov0" title="0">{
        return cfg.timeSchedulerPollingLookAhead
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package metrics

import (
        "time"
)

// TrackDBConnections tracks active database connections
func TrackDBConnections() <span class="cov0" title="0">{
        // Update connection count every 10 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        // For now, we'll just track if the connection is alive
                        // This can be enhanced later with actual connection counting
                        ActiveConnections.Set(1.0)
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package metrics

import (
        "strings"
        "time"

        "fmt"
        "github.com/gocql/gocql"
)

// TrackDBOperation is a helper function to track database operations
// It tracks operation duration, success/failure, errors, and slow queries
func TrackDBOperation(operation string, table string) func(error) <span class="cov0" title="0">{
        startTime := time.Now()
        return func(err error) </span><span class="cov0" title="0">{
                duration := time.Since(startTime).Seconds()
                status := "success"
                if err != nil </span><span class="cov0" title="0">{
                        status = "error"
                        TrackDBError(err)
                }</span>

                // Record operation metrics
                <span class="cov0" title="0">DatabaseOperationsTotal.WithLabelValues(operation, table, status).Inc()
                DatabaseOperationDuration.WithLabelValues(operation, table).Observe(duration)

                // Track slow queries
                if duration &gt; 1.0 </span><span class="cov0" title="0">{ // Consider queries taking more than 1 second as slow
                        DBSlowQueriesTotal.WithLabelValues("1s").Inc()
                }</span>
        }
}

// TrackDBError is a helper function to track database errors
func TrackDBError(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">errorType := "unknown"
        switch </span>{
        case err == gocql.ErrTimeoutNoResponse:<span class="cov0" title="0">
                errorType = "timeout"</span>
        case err == gocql.ErrConnectionClosed:<span class="cov0" title="0">
                errorType = "connection"</span>
        case strings.Contains(err.Error(), "query"):<span class="cov0" title="0">
                errorType = "query"</span>
        case strings.Contains(err.Error(), "constraint"):<span class="cov0" title="0">
                errorType = "constraint"</span>
        }

        <span class="cov0" title="0">DatabaseErrorsTotal.WithLabelValues(errorType).Inc()</span>
}

// TrackRetry tracks retry mechanism metrics
func TrackRetry(endpoint string, attempt int, success bool) <span class="cov0" title="0">{
        RetryAttemptsTotal.WithLabelValues(endpoint, fmt.Sprint(rune(attempt))).Inc()
        if success </span><span class="cov0" title="0">{
                RetrySuccessesTotal.WithLabelValues(endpoint).Inc()
        }</span> else<span class="cov0" title="0"> {
                RetryFailuresTotal.WithLabelValues(endpoint).Inc()
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the database server uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "uptime_seconds",
                Help:      "The uptime of the database server in seconds",
        })

        // Health check metrics with status
        HealthChecksTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "health_checks_total",
                Help:      "Total health check requests",
        }, []string{"status"})

        // Total HTTP Request metrics
        HTTPRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "http_requests_total",
                Help:      "Total HTTP requests processed",
        }, []string{"method", "endpoint", "status"})

        // HTTP Request duration metrics
        HTTPRequestDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "http_request_duration_seconds",
                Help:      "HTTP request duration in seconds",
                Buckets:   prometheus.DefBuckets,
        }, []string{"method", "endpoint"})

        // Active HTTP requests
        ActiveRequests = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "active_requests",
                Help:      "Currently active HTTP requests",
        }, []string{"endpoint"})

        // Request throughput rate
        RequestsPerSecond = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "requests_per_second",
                Help:      "Request throughput rate",
        }, []string{"endpoint"})

        // Average response time
        AverageResponseTime = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "average_response_time_seconds",
                Help:      "Mean response time",
        }, []string{"endpoint"})

        // Database operation metrics
        DatabaseOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "database_operations_total",
                Help:      "Total database operations performed",
        }, []string{"operation", "table", "status"})

        // Database query duration metrics
        DBQueryDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "db_query_duration_seconds",
                Help:      "Database query execution time",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5},
        }, []string{"query_type"})

        // Database slow queries metrics
        DBSlowQueriesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "db_slow_queries_total",
                Help:      "Queries exceeding time threshold",
        }, []string{"threshold"})

        // Connection metrics
        ActiveConnections = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "active_connections",
                Help:      "Current number of active database connections",
        })
        // Retry mechanism metrics
        RetryAttemptsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "retry_attempts_total",
                Help:      "Retry mechanism attempts",
        }, []string{"endpoint", "attempt_number"})

        // Retry success metrics
        RetrySuccessesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "retry_successes_total",
                Help:      "Successful retries",
        }, []string{"endpoint"})

        // Retry failure metrics
        RetryFailuresTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "retry_failures_total",
                Help:      "Failed retry attempts",
        }, []string{"endpoint"})

        // Error and reliability metrics
        DatabaseErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "database_errors_total",
                Help:      "Database errors (error_type=timeout/connection/query/constraint)",
        }, []string{"error_type"})

        // Panic recovery metrics
        PanicRecoveriesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "panic_recoveries_total",
                Help:      "Panic recovery instances",
        }, []string{"endpoint"})

        // Request timeout metrics
        RequestTimeoutsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "request_timeouts_total",
                Help:      "Request timeout occurrences",
        }, []string{"endpoint"})

        // Memory usage metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        // CPU usage metrics
        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        // Goroutines active metrics
        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        // Garbage collection duration metrics
        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Database operations by entity
        DBOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "db_operations_total",
                Help:      "Total database operations (entity=job/task/user/keeper/apikey, operation=create/read/update/delete)",
        }, []string{"entity", "operation", "status"})

        // Database operation duration metrics
        DatabaseOperationDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "database_operation_duration_seconds",
                Help:      "Database operation duration in seconds",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5},
        }, []string{"operation", "table"})

        // Database operations per second metrics
        DBOperationsPerSecond = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "db_server",
                Name:      "db_operations_per_second",
                Help:      "Database operations throughput rate",
        }, []string{"operation"})
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package metrics

import (
        "runtime"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
)

// StartSystemMetricsCollection starts collecting system metrics
func StartSystemMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()

        // Update memory and CPU usage every 5 seconds
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(5 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        // Memory usage
                        if vmStat, err := mem.VirtualMemory(); err == nil </span><span class="cov0" title="0">{
                                MemoryUsageBytes.Set(float64(vmStat.Used))
                        }</span>

                        // CPU usage
                        <span class="cov0" title="0">if cpuPercent, err := cpu.Percent(time.Second, false); err == nil &amp;&amp; len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                                CPUUsagePercent.Set(cpuPercent[0])
                        }</span>

                        // Goroutines count
                        <span class="cov0" title="0">GoroutinesActive.Set(float64(runtime.NumGoroutine()))</span>
                }
        }()

        // Update GC stats every minute
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Minute)
                defer ticker.Stop()

                var lastGCStats runtime.MemStats
                runtime.ReadMemStats(&amp;lastGCStats)

                for range ticker.C </span><span class="cov0" title="0">{
                        var currentGCStats runtime.MemStats
                        runtime.ReadMemStats(&amp;currentGCStats)

                        // Calculate GC duration
                        gcDuration := float64(currentGCStats.PauseTotalNs-lastGCStats.PauseTotalNs) / float64(time.Second)
                        GCDurationSeconds.Set(gcDuration)

                        lastGCStats = currentGCStats
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type ApiKeyAuth struct {
        db          *database.Connection
        logger      logging.Logger
        rateLimiter *RateLimiter
}

func NewApiKeyAuth(db *database.Connection, rateLimiter *RateLimiter, logger logging.Logger) *ApiKeyAuth <span class="cov0" title="0">{
        return &amp;ApiKeyAuth{
                db:          db,
                logger:      logger,
                rateLimiter: rateLimiter,
        }
}</span>

func (a *ApiKeyAuth) GinMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                apiKeyHeader := c.GetHeader("X-Api-Key")
                if apiKeyHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "API key is required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">apiKey, err := a.getApiKey(apiKeyHeader)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Errorf("Error retrieving API key: %v", err)
                        c.JSON(http.StatusForbidden, gin.H{"error": "Invalid or inactive API key"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !apiKey.IsActive </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "API key is inactive"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">go a.updateLastUsed(apiKeyHeader)

                if a.rateLimiter != nil </span><span class="cov0" title="0">{
                        if err := a.rateLimiter.ApplyGinRateLimit(c, apiKey); err != nil </span><span class="cov0" title="0">{
                                a.logger.Warnf("Rate limit applied: %v", err)
                                c.JSON(http.StatusTooManyRequests, gin.H{
                                        "error":   "Rate limit exceeded",
                                        "message": "You have exceeded the rate limit",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Set("apiKey", apiKey)
                c.Next()</span>
        }
}

func (a *ApiKeyAuth) KeeperMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // First check if the request has a valid API key
                apiKeyHeader := c.GetHeader("X-Api-Key")
                if apiKeyHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "API key is required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">apiKey, err := a.getApiKey(apiKeyHeader)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Errorf("Error retrieving API key: %v", err)
                        c.JSON(http.StatusForbidden, gin.H{"error": "Invalid or inactive API key"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !apiKey.IsActive </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "API key is inactive"})
                        c.Abort()
                        return
                }</span>

                // Check if the API key belongs to a keeper
                <span class="cov0" title="0">isKeeper, err := a.isKeeperApiKey(apiKey.Key)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Errorf("Error checking keeper status: %v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !isKeeper </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Access denied. Keeper authorization required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">go a.updateLastUsed(apiKeyHeader)

                if a.rateLimiter != nil </span><span class="cov0" title="0">{
                        if err := a.rateLimiter.ApplyGinRateLimit(c, apiKey); err != nil </span><span class="cov0" title="0">{
                                a.logger.Warnf("Rate limit applied: %v", err)
                                c.JSON(http.StatusTooManyRequests, gin.H{
                                        "error":   "Rate limit exceeded",
                                        "message": "You have exceeded the rate limit",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.Set("apiKey", apiKey)
                c.Next()</span>
        }
}

func (a *ApiKeyAuth) getApiKey(key string) (*types.ApiKey, error) <span class="cov0" title="0">{
        query := `SELECT key, owner, is_active, rate_limit, last_used, created_at 
                          FROM triggerx.apikeys WHERE key = ? AND is_active = ? ALLOW FILTERING`

        var apiKey types.ApiKey

        err := a.db.Session().Query(query, key, true).Scan(
                &amp;apiKey.Key,
                &amp;apiKey.Owner,
                &amp;apiKey.IsActive,
                &amp;apiKey.RateLimit,
                &amp;apiKey.LastUsed,
                &amp;apiKey.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                a.logger.Errorf("Failed to retrieve API key for key %s: %v", key, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;apiKey, nil</span>
}

func (a *ApiKeyAuth) updateLastUsed(key string) <span class="cov0" title="0">{
        query := `UPDATE triggerx.apikeys SET last_used = ? WHERE key = ?`

        if err := a.db.Session().Query(query, time.Now().UTC(), key).Exec(); err != nil </span><span class="cov0" title="0">{
                a.logger.Errorf("Failed to update last used timestamp: %v", err)
        }</span>
}

func (a *ApiKeyAuth) isKeeperApiKey(key string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT isKeeper FROM triggerx.apikeys WHERE key = ? ALLOW FILTERING`

        var isKeeper bool
        err := a.db.Session().Query(query, key).Scan(&amp;isKeeper)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return isKeeper, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package middleware

import (
        "time"

        "fmt"
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics"
)

// MetricsMiddleware tracks HTTP metrics for all requests
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                startTime := time.Now()
                path := c.FullPath()
                method := c.Request.Method

                // Increment active requests
                metrics.ActiveRequests.WithLabelValues(path).Inc()
                defer metrics.ActiveRequests.WithLabelValues(path).Dec()

                // Process request
                c.Next()

                // Record request duration
                duration := time.Since(startTime).Seconds()
                metrics.HTTPRequestDuration.WithLabelValues(method, path).Observe(duration)

                // Record total requests with status code
                status := c.Writer.Status()
                metrics.HTTPRequestsTotal.WithLabelValues(method, path, fmt.Sprint(rune(status))).Inc()

                // Update average response time
                metrics.AverageResponseTime.WithLabelValues(path).Set(duration)

                // Update requests per second
                metrics.RequestsPerSecond.WithLabelValues(path).Inc()
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package middleware

import (
        "context"
        "fmt"
        "math"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type RateLimitInfo struct {
        Remaining int   `json:"remaining"`
        Limit     int   `json:"limit"`
        Reset     int64 `json:"reset"`
}

type RateLimiter struct {
        redis  *redis.Client
        logger logging.Logger
}

func NewRateLimiterWithClient(redisClient *redis.Client, logger logging.Logger) (*RateLimiter, error) <span class="cov0" title="0">{
        if redisClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis client is nil")
        }</span>

        <span class="cov0" title="0">return &amp;RateLimiter{
                redis:  redisClient,
                logger: logger,
        }, nil</span>
}

const rateLimitScript = `
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])

local current = redis.call("INCR", key)
if current == 1 then
    redis.call("EXPIRE", key, window)
end

local ttl = redis.call("TTL", key)

if current &gt; limit then
    return {current, 0, ttl}
else
    return {current, limit - current, ttl}
end
`

func (rl *RateLimiter) ApplyGinRateLimit(c *gin.Context, apiKey *types.ApiKey) error <span class="cov0" title="0">{
        key := fmt.Sprintf("rate_limit:%s", apiKey.Key)
        window := 60 // 1 minute window
        limit := apiKey.RateLimit

        ctx := context.Background()
        result, err := rl.redis.EvalScript(ctx, rateLimitScript, []string{key}, []interface{}{limit, window})
        if err != nil </span><span class="cov0" title="0">{
                rl.logger.Errorf("Failed to evaluate rate limit script: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">values, ok := result.([]interface{})
        if !ok || len(values) != 3 </span><span class="cov0" title="0">{
                rl.logger.Error("Invalid response from rate limit script")
                return fmt.Errorf("invalid response from rate limit script")
        }</span>

        <span class="cov0" title="0">current := values[0].(int64)
        remaining := values[1].(int64)
        reset := values[2].(int64)

        c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
        c.Header("X-RateLimit-Remaining", strconv.FormatInt(remaining, 10))
        c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Unix()+reset, 10))

        if current &gt; int64(limit) </span><span class="cov0" title="0">{
                return fmt.Errorf("rate limit exceeded")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rl *RateLimiter) ApplyRateLimit(r *http.Request, apiKey *types.ApiKey) (*http.Response, error) <span class="cov0" title="0">{
        ctx := r.Context()
        rateLimitKey := fmt.Sprintf("rate-limit:%s", apiKey.Key)
        windowSeconds := 60
        currentTimestamp := time.Now().UTC().Unix()

        result, err := rl.redis.Eval(ctx, rateLimitScript, []string{rateLimitKey},
                apiKey.RateLimit, windowSeconds)
        if err != nil </span><span class="cov0" title="0">{
                rl.logger.Errorf("Rate limiting error: %v", err)

                if true </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return &amp;http.Response{
                        StatusCode: http.StatusInternalServerError,
                        Body:       nil,
                }, fmt.Errorf("rate limiting service unavailable: %w", err)</span>
        }

        <span class="cov0" title="0">results, ok := result.([]interface{})
        if !ok || len(results) != 3 </span><span class="cov0" title="0">{
                rl.logger.Errorf("Invalid result from Redis: %v", result)
                return nil, fmt.Errorf("invalid response from rate limiter")
        }</span>

        <span class="cov0" title="0">count := int(results[0].(int64))
        remaining := int(results[1].(int64))
        ttl := int(results[2].(int64))
        reset := currentTimestamp + int64(ttl)

        rl.logger.Infof("Rate Limit Debug: API Key: %s, Owner: %s, Rate Limit: %d, Current Count: %d, Remaining: %d, TTL: %d",
                apiKey.Key, apiKey.Owner, apiKey.RateLimit, count, remaining, ttl)

        r.Header.Set("X-RateLimit-Limit", strconv.Itoa(apiKey.RateLimit))
        r.Header.Set("X-RateLimit-Remaining", strconv.Itoa(remaining))
        r.Header.Set("X-RateLimit-Reset", strconv.FormatInt(reset, 10))

        if count &gt; apiKey.RateLimit </span><span class="cov0" title="0">{
                rl.logger.Warnf("Rate limit exceeded: API Key: %s, Owner: %s, Count: %d, Limit: %d",
                        apiKey.Key, apiKey.Owner, count, apiKey.RateLimit)

                resp := &amp;http.Response{
                        StatusCode: http.StatusTooManyRequests,
                        Header:     http.Header{},
                        Body:       nil,
                }

                resp.Header.Set("X-RateLimit-Limit", strconv.Itoa(apiKey.RateLimit))
                resp.Header.Set("X-RateLimit-Remaining", "0")
                resp.Header.Set("X-RateLimit-Reset", strconv.FormatInt(reset, 10))
                resp.Header.Set("Retry-After", strconv.Itoa(ttl))

                return resp, fmt.Errorf("rate limit exceeded")
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

func (rl *RateLimiter) GetRateLimitStatus(ctx context.Context, apiKey *types.ApiKey) (*RateLimitInfo, error) <span class="cov0" title="0">{
        rateLimitKey := fmt.Sprintf("rate-limit:%s", apiKey.Key)
        currentTimestamp := time.Now().UTC().Unix()

        countStr, err := rl.redis.Get(ctx, rateLimitKey)
        count := 0
        if err == nil &amp;&amp; countStr != "" </span><span class="cov0" title="0">{
                count, _ = strconv.Atoi(countStr)
        }</span>

        <span class="cov0" title="0">ttl, err := rl.redis.TTL(ctx, rateLimitKey)
        if err != nil || ttl &lt; 0 </span><span class="cov0" title="0">{
                ttl = 60 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;RateLimitInfo{
                Remaining: int(math.Max(0, float64(apiKey.RateLimit-count))),
                Limit:     apiKey.RateLimit,
                Reset:     currentTimestamp + int64(ttl.Seconds()),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "net/http"
        "runtime/debug"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// RecoveryMiddleware creates a new recovery middleware that collects panic metrics
func RecoveryMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                // Get the endpoint path
                                endpoint := c.FullPath()
                                if endpoint == "" </span><span class="cov0" title="0">{
                                        endpoint = c.Request.URL.Path
                                }</span>

                                // Record panic recovery
                                <span class="cov0" title="0">metrics.PanicRecoveriesTotal.WithLabelValues(endpoint).Inc()

                                // Log the panic
                                logger.Errorf("Panic recovered: %v\nStack trace: %s", err, debug.Stack())

                                // Return 500 Internal Server Error
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error": "Internal server error",
                                })
                                c.Abort()</span>
                        }
                }()

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// RetryConfig holds configuration for API retry operations
type RetryConfig struct {
        MaxRetries      int
        InitialDelay    time.Duration
        MaxDelay        time.Duration
        BackoffFactor   float64
        JitterFactor    float64
        LogRetryAttempt bool
        // Status codes that should trigger a retry
        RetryStatusCodes []int
}

// DefaultRetryConfig returns default configuration for API retry operations
func DefaultRetryConfig() *RetryConfig <span class="cov0" title="0">{
        return &amp;RetryConfig{
                MaxRetries:      3,
                InitialDelay:    time.Second,
                MaxDelay:        10 * time.Second,
                BackoffFactor:   2.0,
                JitterFactor:    0.1,
                LogRetryAttempt: true,
                RetryStatusCodes: []int{
                        http.StatusInternalServerError,
                        http.StatusBadGateway,
                        http.StatusServiceUnavailable,
                        http.StatusGatewayTimeout,
                        http.StatusTooManyRequests,
                        http.StatusRequestTimeout,
                        http.StatusConflict,
                },
        }
}</span>

// RetryMiddleware creates a new retry middleware
func RetryMiddleware(config *RetryConfig, logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRetryConfig()
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip retry for non-idempotent methods
                if c.Request.Method != http.MethodGet &amp;&amp; c.Request.Method != http.MethodHead </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">endpoint := c.FullPath()
                if endpoint == "" </span><span class="cov0" title="0">{
                        endpoint = c.Request.URL.Path
                }</span>

                // Create a copy of the request body if it exists
                <span class="cov0" title="0">var bodyBytes []byte
                if c.Request.Body != nil </span><span class="cov0" title="0">{
                        var err error
                        bodyBytes, err = io.ReadAll(c.Request.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to read request body: %v", err)
                                c.AbortWithStatus(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))</span>
                }

                // Create a response recorder
                <span class="cov0" title="0">origWriter := c.Writer
                w := &amp;responseWriter{
                        ResponseWriter: origWriter,
                        body:           &amp;bytes.Buffer{},
                }
                c.Writer = w

                var lastErr error
                attempts := 0
                var finalStatus int
                var finalBody []byte

                _, err := retry.Retry(context.Background(), func() (interface{}, error) </span><span class="cov0" title="0">{
                        attempts++
                        metrics.RetryAttemptsTotal.WithLabelValues(endpoint, fmt.Sprintf("%d", attempts)).Inc()

                        // Reset the response writer for this attempt
                        w.body.Reset()
                        w.statusCode = 0

                        // Create a new request for this attempt
                        newReq, err := http.NewRequest(c.Request.Method, c.Request.URL.String(), bytes.NewBuffer(bodyBytes))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create new request: %v", err)
                        }</span>

                        // Copy headers from original request
                        <span class="cov0" title="0">for key, values := range c.Request.Header </span><span class="cov0" title="0">{
                                for _, value := range values </span><span class="cov0" title="0">{
                                        newReq.Header.Add(key, value)
                                }</span>
                        }

                        // Create a new context for this attempt
                        <span class="cov0" title="0">newCtx := c.Copy()
                        newCtx.Request = newReq
                        newCtx.Writer = w

                        // Process the request
                        c.Handler()(newCtx)

                        // If the request was aborted, don't retry
                        if newCtx.IsAborted() </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">statusCode := w.statusCode
                        retryable := false
                        for _, retryCode := range config.RetryStatusCodes </span><span class="cov0" title="0">{
                                if statusCode == retryCode </span><span class="cov0" title="0">{
                                        retryable = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !retryable </span><span class="cov0" title="0">{
                                finalStatus = w.statusCode
                                finalBody = w.body.Bytes()
                                metrics.RetrySuccessesTotal.WithLabelValues(endpoint).Inc()
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if config.LogRetryAttempt </span><span class="cov0" title="0">{
                                logger.Warnf("Retry attempt %d for %s %s with status code %d",
                                        attempts, c.Request.Method, c.Request.URL.Path, statusCode)
                        }</span>

                        <span class="cov0" title="0">lastErr = fmt.Errorf("received retryable status code: %d", statusCode)
                        finalStatus = w.statusCode
                        finalBody = w.body.Bytes()
                        return nil, lastErr</span>
                }, &amp;retry.RetryConfig{
                        MaxRetries:      config.MaxRetries,
                        InitialDelay:    config.InitialDelay,
                        MaxDelay:        config.MaxDelay,
                        BackoffFactor:   config.BackoffFactor,
                        JitterFactor:    config.JitterFactor,
                        LogRetryAttempt: config.LogRetryAttempt,
                }, logger)

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error retrying request: %v", err)
                        metrics.RetryFailuresTotal.WithLabelValues(endpoint).Inc()
                        if finalStatus == 0 </span><span class="cov0" title="0">{
                                finalStatus = http.StatusInternalServerError
                                finalBody = []byte("Internal server error during retry operation")
                        }</span>
                }

                // Write the final response only once
                <span class="cov0" title="0">origWriter.WriteHeader(finalStatus)
                if _, err := origWriter.Write(finalBody); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error writing final response: %v", err)
                }</span>

                // Abort the context to prevent further handlers from writing
                <span class="cov0" title="0">c.Abort()</span>
        }
}

// responseWriter is a custom response writer that captures the response
type responseWriter struct {
        gin.ResponseWriter
        body       *bytes.Buffer
        statusCode int
}

func (w *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/metrics"
)

// TimeoutMiddleware creates a new middleware that tracks request timeouts
func TimeoutMiddleware(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Create a context with timeout
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()

                // Create a channel to track request completion
                done := make(chan struct{})

                // Start a goroutine to process the request
                go func() </span><span class="cov0" title="0">{
                        c.Next()
                        close(done)
                }</span>()

                // Wait for either the request to complete or timeout
                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        // Request completed successfully
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Request timed out
                        endpoint := c.FullPath()
                        if endpoint == "" </span><span class="cov0" title="0">{
                                endpoint = c.Request.URL.Path
                        }</span>

                        // Record timeout
                        <span class="cov0" title="0">metrics.RequestTimeoutsTotal.WithLabelValues(endpoint).Inc()

                        // Abort the request
                        c.AbortWithStatusJSON(http.StatusGatewayTimeout, gin.H{
                                "error": "Request timeout",
                        })</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package middleware

import (
        "bytes"
        // "fmt"
        "io"
        "net/http"
        "regexp"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Validator struct {
        validate *validator.Validate
        logger   logging.Logger
}

func NewValidator(logger logging.Logger) *Validator <span class="cov0" title="0">{
        v := validator.New()

        // Register custom validations
        err := v.RegisterValidation("ethereum_address", validateEthereumAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error registering validation: %v", err)
        }</span>
        <span class="cov0" title="0">err = v.RegisterValidation("ipfs_url", validateIPFSURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error registering validation: %v", err)
        }</span>
        <span class="cov0" title="0">err = v.RegisterValidation("chain_id", validateChainID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error registering validation: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Validator{
                validate: v,
                logger:   logger,
        }</span>
}

func (v *Validator) GinMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Read the request body first
                body, err := io.ReadAll(c.Request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        v.logger.Errorf("Error reading request body: %v", err)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Invalid request body",
                                "details": err.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // Log the raw request body
                <span class="cov0" title="0">v.logger.Infof("Raw request body: %s", string(body))

                // Create a new reader with the body and restore it
                c.Request.Body = io.NopCloser(bytes.NewBuffer(body))

                // Validate based on the endpoint
                var validationError error
                switch c.Request.URL.Path </span>{
                case "/api/jobs":<span class="cov0" title="0">
                        var jobDataArray []types.CreateJobData
                        if err := c.ShouldBindJSON(&amp;jobDataArray); err != nil </span><span class="cov0" title="0">{
                                validationError = err
                        }</span> else<span class="cov0" title="0"> {
                                for _, jobData := range jobDataArray </span><span class="cov0" title="0">{
                                        if err := v.validate.Struct(jobData); err != nil </span><span class="cov0" title="0">{
                                                validationError = err
                                                break</span>
                                        }
                                }
                        }

                case "/api/tasks":<span class="cov0" title="0">
                        var taskData types.CreateTaskDataRequest
                        if err := c.ShouldBindJSON(&amp;taskData); err != nil </span><span class="cov0" title="0">{
                                validationError = err
                        }</span> else<span class="cov0" title="0"> {
                                validationError = v.validate.Struct(taskData)
                        }</span>

                case "/api/keepers":<span class="cov0" title="0">
                        var keeperData types.CreateKeeperData
                        if err := c.ShouldBindJSON(&amp;keeperData); err != nil </span><span class="cov0" title="0">{
                                validationError = err
                        }</span> else<span class="cov0" title="0"> {
                                validationError = v.validate.Struct(keeperData)
                        }</span>

                case "/api/admin/api-keys":<span class="cov0" title="0">
                        var apiKeyData types.CreateApiKeyRequest
                        if err := c.ShouldBindJSON(&amp;apiKeyData); err != nil </span><span class="cov0" title="0">{
                                validationError = err
                        }</span> else<span class="cov0" title="0"> {
                                validationError = v.validate.Struct(apiKeyData)
                        }</span>

                default:<span class="cov0" title="0">
                        // For unknown endpoints, just pass through
                        c.Next()
                        return</span>
                }

                <span class="cov0" title="0">if validationError != nil </span><span class="cov0" title="0">{
                        v.logger.Errorf("Validation error: %v", validationError)
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "Validation failed",
                                "details": validationError.Error(),
                        })
                        c.Abort()
                        return
                }</span>

                // Validate based on the endpoint
                // var validationErrors []string
                // switch c.Request.URL.Path {
                // case "/api/jobs":
                //         for i, jobData := range jobDataArray {
                //                 if err := v.validateCreateJob(c, jobData); err != nil {
                //                         validationErrors = append(validationErrors, fmt.Sprintf("Job %d: %v", i+1, err))
                //                 }
                //         }
                // case "/api/tasks":
                //         if err := v.validateCreateTask(c, jobDataArray); err != nil {
                //                 validationErrors = append(validationErrors, err.Error())
                //         }
                // case "/api/keepers/form":
                //         if err := v.validateCreateKeeperForm(c, jobDataArray); err != nil {
                //                 validationErrors = append(validationErrors, err.Error())
                //         }
                // case "/api/admin/api-keys":
                //         if err := v.validateCreateApiKey(c, jobDataArray); err != nil {
                //                 validationErrors = append(validationErrors, err.Error())
                //         }
                // }

                // if len(validationErrors) &gt; 0 {
                //         c.JSON(http.StatusBadRequest, gin.H{
                //                 "error":   "Validation failed",
                //                 "details": validationErrors,
                //         })
                //         c.Abort()
                //         return
                // }

                // Restore the body for subsequent handlers
                <span class="cov0" title="0">c.Request.Body = io.NopCloser(bytes.NewBuffer(body))

                c.Next()</span>
        }
}

// func (v *Validator) validateCreateJob(c *gin.Context, jobData types.CreateJobData) error {
//         // First validate the common fields
//         if err := v.validate.Struct(jobData); err != nil {
//                 return err
//         }

// Determine job type based on TaskDefinitionID
// switch {
// case jobData.TaskDefinitionID &gt;= types.TaskDefTimeBasedStart &amp;&amp; jobData.TaskDefinitionID &lt;= types.TaskDefTimeBasedEnd:
// Time-based job validation
// if jobData.TimeInterval &lt;= 0 {
//         return fmt.Errorf("time_interval is required for time-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }
// Time jobs don't need trigger or condition fields
// if jobData.TriggerChainID != "" || jobData.TriggerContractAddress != "" || jobData.TriggerEvent != "" {
//         return fmt.Errorf("trigger fields should not be set for time-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }
// if jobData.ConditionType != "" || jobData.UpperLimit != 0 || jobData.LowerLimit != 0 {
//         return fmt.Errorf("condition fields should not be set for time-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }

// case jobData.TaskDefinitionID &gt;= types.TaskDefEventBasedStart &amp;&amp; jobData.TaskDefinitionID &lt;= types.TaskDefEventBasedEnd:
//         // Event-based job validation
//         if jobData.TriggerChainID == "" || jobData.TriggerContractAddress == "" || jobData.TriggerEvent == "" {
//                 return fmt.Errorf("trigger fields are required for event-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
//         }
// Event jobs don't need time interval or condition fields
// if jobData.TimeInterval != 0 {
//         return fmt.Errorf("time_interval should not be set for event-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }
// if jobData.ConditionType != "" || jobData.UpperLimit != 0 || jobData.LowerLimit != 0 {
//         return fmt.Errorf("condition fields should not be set for event-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }

// case jobData.TaskDefinitionID &gt;= types.TaskDefConditionBasedStart &amp;&amp; jobData.TaskDefinitionID &lt;= types.TaskDefConditionBasedEnd:
//         // Condition-based job validation
//         if jobData.ConditionType == "" || jobData.UpperLimit == 0 || jobData.LowerLimit == 0 {
//                 return fmt.Errorf("condition fields are required for condition-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
//         }
//         if jobData.ValueSourceType == "" || jobData.ValueSourceUrl == "" {
//                 return fmt.Errorf("value source fields are required for condition-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
//         }
// Condition jobs don't need time interval or trigger fields
// if jobData.TimeInterval != 0 {
//         return fmt.Errorf("time_interval should not be set for condition-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }
// if jobData.TriggerChainID != "" || jobData.TriggerContractAddress != "" || jobData.TriggerEvent != "" {
//         return fmt.Errorf("trigger fields should not be set for condition-based jobs (TaskDefinitionID: %d)", jobData.TaskDefinitionID)
// }

// default:
//         return fmt.Errorf("invalid TaskDefinitionID: %d", jobData.TaskDefinitionID)
// }

//         return nil
// }

// func (v *Validator) validateCreateTask(c *gin.Context, body interface{}) error {
//         var taskData types.CreateTaskDataRequest
//         if err := c.ShouldBindJSON(&amp;taskData); err != nil {
//                 return err
//         }

//         return v.validate.Struct(taskData)
// }

// func (v *Validator) validateCreateApiKey(c *gin.Context, body interface{}) error {
//         var apiKeyData types.CreateApiKeyRequest
//         if err := c.ShouldBindJSON(&amp;apiKeyData); err != nil {
//                 return err
//         }

//         return v.validate.Struct(apiKeyData)
// }

// Custom validation functions
func validateEthereumAddress(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        address := fl.Field().String()
        // Basic Ethereum address validation (0x followed by 40 hex characters)
        re := regexp.MustCompile("^0x[0-9a-fA-F]{40}$")
        return re.MatchString(address)
}</span>

func validateIPFSURL(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        url := fl.Field().String()

        // Check for native IPFS protocol
        if strings.HasPrefix(url, "ipfs://") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for HTTPS URLs that contain "/ipfs/" path (covers various gateways)
        <span class="cov0" title="0">if strings.HasPrefix(url, "https://") &amp;&amp; strings.Contains(url, "/ipfs/") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func validateChainID(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        chainID := fl.Field().String()
        // Add your chain ID validation logic here
        // For now, just checking if it's not empty
        return chainID != ""
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Client struct {
        client *redis.Client
        logger logging.Logger
}

func NewClient(logger logging.Logger) (*Client, error) <span class="cov0" title="0">{
        opt, err := redis.ParseURL(config.GetUpstashRedisUrl())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Redis URL: %w", err)
        }</span>

        <span class="cov0" title="0">if config.GetUpstashRedisRestToken() != "" </span><span class="cov0" title="0">{
                opt.Password = config.GetUpstashRedisRestToken()
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(opt)

        redisClient := &amp;Client{
                client: client,
                logger: logger,
        }

        if err := redisClient.CheckConnection(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return redisClient, nil</span>
}

func (c *Client) CheckConnection() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := c.client.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Errorf("Failed to connect to Redis: %v", err)
                return fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info("Successfully connected to Redis")
        return nil</span>
}

func (c *Client) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        val, err := c.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

func (c *Client) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        return c.client.Set(ctx, key, value, expiration).Err()
}</span>

func (c *Client) Del(ctx context.Context, keys ...string) error <span class="cov0" title="0">{
        return c.client.Del(ctx, keys...).Err()
}</span>

func (c *Client) Incr(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return c.client.Incr(ctx, key).Result()
}</span>

func (c *Client) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov0" title="0">{
        return c.client.Expire(ctx, key, expiration).Err()
}</span>

func (c *Client) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov0" title="0">{
        return c.client.TTL(ctx, key).Result()
}</span>

func (c *Client) Eval(ctx context.Context, script string, keys []string, args ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        return c.client.Eval(ctx, script, keys, args...).Result()
}</span>

func (c *Client) EvalScript(ctx context.Context, script string, keys []string, args []interface{}) (interface{}, error) <span class="cov0" title="0">{
        return c.client.Eval(ctx, script, keys, args...).Result()
}</span>

func (c *Client) Client() *redis.Client <span class="cov0" title="0">{
        return c.client
}</span>

func (c *Client) Close() error <span class="cov0" title="0">{
        return c.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type ApiKeysRepository interface {
        CreateApiKey(apiKey *types.ApiKeyData) error
        GetApiKeyDataByOwner(owner string) ([]*types.ApiKeyData, error) // changed to return slice
        GetApiKeyDataByKey(key string) (*types.ApiKeyData, error)
        GetApiKeyCounters(key string) (*types.ApiKeyCounters, error)
        GetApiKeyByOwner(owner string) (key string, err error)
        GetApiOwnerByApiKey(key string) (owner string, err error)
        UpdateApiKey(apiKey *types.UpdateApiKeyRequest) error
        UpdateApiKeyStatus(apiKey *types.UpdateApiKeyStatusRequest) error
        UpdateApiKeyLastUsed(key string, isSuccess bool) error
        DeleteApiKey(key string) error
}

type apiKeysRepository struct {
        db *database.Connection
}

func NewApiKeysRepository(db *database.Connection) ApiKeysRepository <span class="cov0" title="0">{
        return &amp;apiKeysRepository{
                db: db,
        }
}</span>

func (r *apiKeysRepository) CreateApiKey(apiKey *types.ApiKeyData) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CreateApiKeyQuery, apiKey.Key, apiKey.Owner, apiKey.IsActive, apiKey.RateLimit, apiKey.LastUsed, apiKey.CreatedAt).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *apiKeysRepository) GetApiKeyDataByOwner(owner string) ([]*types.ApiKeyData, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetApiKeyDataByOwnerQuery, owner).Iter()
        var apiKeys []*types.ApiKeyData
        var key, ownerVal string
        var isActive bool
        var rateLimit int
        var successCount, failedCount int64
        var lastUsed, createdAt time.Time
        for iter.Scan(&amp;key, &amp;ownerVal, &amp;isActive, &amp;rateLimit, &amp;successCount, &amp;failedCount, &amp;lastUsed, &amp;createdAt) </span><span class="cov0" title="0">{
                apiKeys = append(apiKeys, &amp;types.ApiKeyData{
                        Key:          key,
                        Owner:        ownerVal,
                        IsActive:     isActive,
                        RateLimit:    rateLimit,
                        SuccessCount: successCount,
                        FailedCount:  failedCount,
                        LastUsed:     lastUsed,
                        CreatedAt:    createdAt,
                })
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(apiKeys) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("owner not found")
        }</span>
        <span class="cov0" title="0">return apiKeys, nil</span>
}

func (r *apiKeysRepository) GetApiKeyDataByKey(key string) (*types.ApiKeyData, error) <span class="cov0" title="0">{
        apiKey := &amp;types.ApiKeyData{}
        var successCount, failedCount int64
        err := r.db.Session().Query(queries.GetApiKeyDataByApiKeyQuery, key).Scan(&amp;apiKey.Key, &amp;apiKey.Owner, &amp;apiKey.IsActive, &amp;apiKey.RateLimit, &amp;successCount, &amp;failedCount, &amp;apiKey.LastUsed, &amp;apiKey.CreatedAt)
        apiKey.SuccessCount = successCount
        apiKey.FailedCount = failedCount
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return nil, errors.New("api key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return apiKey, nil</span>
}

func (r *apiKeysRepository) GetApiKeyCounters(key string) (*types.ApiKeyCounters, error) <span class="cov0" title="0">{
        callCount := &amp;types.ApiKeyCounters{}
        err := r.db.Session().Query(queries.GetApiKeyCallCountQuery, key).Scan(&amp;callCount.SuccessCount, &amp;callCount.FailedCount)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return nil, errors.New("api key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return callCount, nil</span>
}

func (r *apiKeysRepository) GetApiKeyByOwner(owner string) (key string, err error) <span class="cov0" title="0">{
        key = ""
        err = r.db.Session().Query(queries.GetApiKeyByOwnerQuery, owner).Scan(&amp;key)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return "", errors.New("owner not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}

func (r *apiKeysRepository) GetApiOwnerByApiKey(key string) (owner string, err error) <span class="cov0" title="0">{
        owner = ""
        err = r.db.Session().Query(queries.GetApiOwnerByApiKeyQuery, key).Scan(&amp;owner)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return "", errors.New("api key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return owner, nil</span>
}

func (r *apiKeysRepository) UpdateApiKey(apiKey *types.UpdateApiKeyRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateApiKeyQuery, apiKey.Key, apiKey.IsActive, apiKey.RateLimit).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *apiKeysRepository) UpdateApiKeyStatus(apiKey *types.UpdateApiKeyStatusRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateApiKeyStatusQuery, apiKey.IsActive, apiKey.Key).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *apiKeysRepository) UpdateApiKeyLastUsed(key string, isSuccess bool) error <span class="cov0" title="0">{
        if isSuccess </span><span class="cov0" title="0">{
                err := r.db.Session().Query(queries.UpdateApiKeyLastUsedQuery, time.Now(), 1, 0, key).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                err := r.db.Session().Query(queries.UpdateApiKeyLastUsedQuery, time.Now(), 0, 1, key).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DeleteApiKey physically deletes an API key from the apikeys table
func (r *apiKeysRepository) DeleteApiKey(key string) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.DeleteApiKeyQuery, key).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package repository

import (
        "errors"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type ConditionJobRepository interface {
        CreateConditionJob(conditionJob *types.ConditionJobData) error
        GetConditionJobByJobID(jobID *big.Int) (types.ConditionJobData, error)
        CompleteConditionJob(jobID *big.Int) error
        UpdateConditionJobStatus(jobID *big.Int, isActive bool) error
        GetActiveConditionJobs() ([]types.ConditionJobData, error)
}

type conditionJobRepository struct {
        db *database.Connection
}

func NewConditionJobRepository(db *database.Connection) ConditionJobRepository <span class="cov0" title="0">{
        return &amp;conditionJobRepository{
                db: db,
        }
}</span>

func (r *conditionJobRepository) CreateConditionJob(conditionJob *types.ConditionJobData) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CreateConditionJobDataQuery,
                conditionJob.JobID, conditionJob.TaskDefinitionID, conditionJob.ExpirationTime, conditionJob.Recurring,
                conditionJob.ConditionType, conditionJob.UpperLimit, conditionJob.LowerLimit,
                conditionJob.ValueSourceType, conditionJob.ValueSourceUrl, conditionJob.TargetChainID,
                conditionJob.TargetContractAddress, conditionJob.TargetFunction,
                conditionJob.ABI, conditionJob.ArgType, conditionJob.Arguments,
                conditionJob.DynamicArgumentsScriptUrl, conditionJob.IsCompleted, conditionJob.IsActive,
                conditionJob.SelectedKeyRoute, time.Now(), time.Now()).Exec()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *conditionJobRepository) GetConditionJobByJobID(jobID *big.Int) (types.ConditionJobData, error) <span class="cov0" title="0">{
        var conditionJob types.ConditionJobData
        err := r.db.Session().Query(queries.GetConditionJobDataByJobIDQuery, jobID).Scan(
                &amp;conditionJob.JobID, &amp;conditionJob.ExpirationTime, &amp;conditionJob.Recurring, &amp;conditionJob.ConditionType,
                &amp;conditionJob.UpperLimit, &amp;conditionJob.LowerLimit, &amp;conditionJob.ValueSourceType,
                &amp;conditionJob.ValueSourceUrl, &amp;conditionJob.TargetChainID, &amp;conditionJob.TargetContractAddress,
                &amp;conditionJob.TargetFunction, &amp;conditionJob.ABI, &amp;conditionJob.ArgType, &amp;conditionJob.Arguments,
                &amp;conditionJob.DynamicArgumentsScriptUrl, &amp;conditionJob.IsCompleted, &amp;conditionJob.IsActive,
                &amp;conditionJob.SelectedKeyRoute,
        )
        if err != nil </span><span class="cov0" title="0">{
                return types.ConditionJobData{}, errors.New("failed to get condition job by job ID")
        }</span>

        <span class="cov0" title="0">return conditionJob, nil</span>
}

func (r *conditionJobRepository) CompleteConditionJob(jobID *big.Int) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CompleteConditionJobStatusQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to complete condition job")
        }</span>

        <span class="cov0" title="0">err = r.db.Session().Query(queries.UpdateJobDataToCompletedQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job_data status to completed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *conditionJobRepository) UpdateConditionJobStatus(jobID *big.Int, isActive bool) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateConditionJobStatusQuery, isActive, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update condition job status")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *conditionJobRepository) GetActiveConditionJobs() ([]types.ConditionJobData, error) <span class="cov0" title="0">{
        var conditionJobs []types.ConditionJobData
        iter := r.db.Session().Query(queries.GetActiveConditionJobsQuery).Iter()
        var conditionJob types.ConditionJobData
        for iter.Scan(
                &amp;conditionJob.JobID, &amp;conditionJob.ExpirationTime, &amp;conditionJob.Recurring,
                &amp;conditionJob.ConditionType, &amp;conditionJob.UpperLimit, &amp;conditionJob.LowerLimit,
                &amp;conditionJob.ValueSourceType, &amp;conditionJob.ValueSourceUrl, &amp;conditionJob.TargetChainID,
                &amp;conditionJob.TargetContractAddress, &amp;conditionJob.TargetFunction, &amp;conditionJob.ABI,
                &amp;conditionJob.ArgType, &amp;conditionJob.Arguments, &amp;conditionJob.DynamicArgumentsScriptUrl,
                &amp;conditionJob.IsCompleted, &amp;conditionJob.IsActive, &amp;conditionJob.SelectedKeyRoute) </span><span class="cov0" title="0">{
                conditionJobs = append(conditionJobs, conditionJob)
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to fetch active condition jobs")
        }</span>
        <span class="cov0" title="0">return conditionJobs, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package repository

import (
        "errors"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type EventJobRepository interface {
        CreateEventJob(eventJob *types.EventJobData) error
        GetEventJobByJobID(jobID *big.Int) (types.EventJobData, error)
        CompleteEventJob(jobID *big.Int) error
        UpdateEventJobStatus(jobID *big.Int, isActive bool) error
        GetActiveEventJobs() ([]types.EventJobData, error)
}

type eventJobRepository struct {
        db *database.Connection
}

func NewEventJobRepository(db *database.Connection) EventJobRepository <span class="cov0" title="0">{
        return &amp;eventJobRepository{
                db: db,
        }
}</span>

func (r *eventJobRepository) CreateEventJob(eventJob *types.EventJobData) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CreateEventJobDataQuery,
                eventJob.JobID, eventJob.TaskDefinitionID, eventJob.ExpirationTime, eventJob.Recurring,
                eventJob.TriggerChainID, eventJob.TriggerContractAddress, eventJob.TriggerEvent,
                eventJob.TargetChainID, eventJob.TargetContractAddress, eventJob.TargetFunction,
                eventJob.ABI, eventJob.ArgType, eventJob.Arguments, eventJob.DynamicArgumentsScriptUrl,
                eventJob.IsCompleted, eventJob.IsActive, time.Now(), time.Now()).Exec()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *eventJobRepository) GetEventJobByJobID(jobID *big.Int) (types.EventJobData, error) <span class="cov0" title="0">{
        var eventJob types.EventJobData
        err := r.db.Session().Query(queries.GetEventJobDataByJobIDQuery, jobID).Scan(
                &amp;eventJob.JobID, &amp;eventJob.ExpirationTime, &amp;eventJob.Recurring, &amp;eventJob.TriggerChainID,
                &amp;eventJob.TriggerContractAddress, &amp;eventJob.TriggerEvent, &amp;eventJob.TargetChainID,
                &amp;eventJob.TargetContractAddress, &amp;eventJob.TargetFunction, &amp;eventJob.ABI, &amp;eventJob.ArgType,
                &amp;eventJob.Arguments, &amp;eventJob.DynamicArgumentsScriptUrl, &amp;eventJob.IsCompleted, &amp;eventJob.IsActive,
        )
        if err != nil </span><span class="cov0" title="0">{
                return types.EventJobData{}, errors.New("failed to get event job by job ID")
        }</span>

        <span class="cov0" title="0">return eventJob, nil</span>
}

func (r *eventJobRepository) CompleteEventJob(jobID *big.Int) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CompleteEventJobStatusQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to complete event job")
        }</span>

        <span class="cov0" title="0">err = r.db.Session().Query(queries.UpdateJobDataToCompletedQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job_data status to completed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *eventJobRepository) UpdateEventJobStatus(jobID *big.Int, isActive bool) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateEventJobStatusQuery, isActive, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update event job status")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *eventJobRepository) GetActiveEventJobs() ([]types.EventJobData, error) <span class="cov0" title="0">{
        var eventJobs []types.EventJobData
        iter := r.db.Session().Query(queries.GetActiveEventJobsQuery).Iter()
        var eventJob types.EventJobData
        for iter.Scan(
                &amp;eventJob.JobID, &amp;eventJob.ExpirationTime, &amp;eventJob.Recurring,
                &amp;eventJob.TriggerChainID, &amp;eventJob.TriggerContractAddress, &amp;eventJob.TriggerEvent,
                &amp;eventJob.TargetChainID, &amp;eventJob.TargetContractAddress, &amp;eventJob.TargetFunction,
                &amp;eventJob.ABI, &amp;eventJob.ArgType, &amp;eventJob.Arguments, &amp;eventJob.DynamicArgumentsScriptUrl,
                &amp;eventJob.IsCompleted, &amp;eventJob.IsActive) </span><span class="cov0" title="0">{
                eventJobs = append(eventJobs, eventJob)
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to fetch active event jobs")
        }</span>
        <span class="cov0" title="0">return eventJobs, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package repository

import (
        "errors"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type JobRepository interface {
        CreateNewJob(job *types.JobData) (*big.Int, error)
        UpdateJobFromUserInDB(jobID *big.Int, job *types.UpdateJobDataFromUserRequest) error
        UpdateJobLastExecutedAt(jobID *big.Int, taskID int64, jobCostActual float64, lastExecutedAt time.Time) error
        UpdateJobStatus(jobID *big.Int, status string) error
        GetJobByID(jobID *big.Int) (*types.JobData, error)
        GetTaskDefinitionIDByJobID(jobID *big.Int) (int, error)
        GetTaskFeesByJobID(jobID *big.Int) ([]types.TaskFeeResponse, error)
}

type jobRepository struct {
        db *database.Connection
}

// NewJobRepository creates a new job repository instance
func NewJobRepository(db *database.Connection) JobRepository <span class="cov0" title="0">{
        return &amp;jobRepository{
                db: db,
        }
}</span>

func (r *jobRepository) CreateNewJob(job *types.JobData) (*big.Int, error) <span class="cov0" title="0">{
        // var lastJobID int64
        // err := r.db.Session().Query(queries.GetMaxJobIDQuery).Scan(&amp;lastJobID)
        // if err == gocql.ErrNotFound {
        //         return -1, nil
        // }

        err := r.db.Session().Query(queries.CreateJobDataQuery,
                job.JobID, job.JobTitle, job.TaskDefinitionID, job.UserID, job.LinkJobID, job.ChainStatus,
                job.Custom, job.TimeFrame, job.Recurring, job.Status, job.JobCostPrediction, time.Now(), time.Now(), job.Timezone, job.IsImua, job.CreatedChainID).Exec()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return job.JobID, nil</span>
}

func (r *jobRepository) UpdateJobFromUserInDB(jobID *big.Int, job *types.UpdateJobDataFromUserRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateJobDataFromUserQuery,
                job.JobTitle, job.TimeFrame, job.Recurring, job.Status, job.JobCostPrediction, time.Now(), jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job from user")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *jobRepository) UpdateJobLastExecutedAt(jobID *big.Int, taskID int64, jobCostActual float64, lastExecutedAt time.Time) error <span class="cov0" title="0">{
        var existingTaskIDs []int64
        err := r.db.Session().Query(queries.GetTaskIDsByJobIDQuery, jobID).Scan(&amp;existingTaskIDs)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to get task ids by job id")
        }</span>

        <span class="cov0" title="0">existingTaskIDs = append(existingTaskIDs, taskID)
        err = r.db.Session().Query(queries.UpdateJobDataLastExecutedAtQuery,
                existingTaskIDs, jobCostActual, lastExecutedAt).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job last executed at")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *jobRepository) UpdateJobStatus(jobID *big.Int, status string) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateJobDataStatusQuery,
                status, time.Now(), jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job status")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *jobRepository) GetJobByID(jobID *big.Int) (*types.JobData, error) <span class="cov0" title="0">{
        var jobData types.JobData
        err := r.db.Session().Query(queries.GetJobDataByJobIDQuery, jobID).Scan(
                &amp;jobData.JobID, &amp;jobData.JobTitle, &amp;jobData.TaskDefinitionID, &amp;jobData.UserID,
                &amp;jobData.LinkJobID, &amp;jobData.ChainStatus, &amp;jobData.Custom, &amp;jobData.TimeFrame,
                &amp;jobData.Recurring, &amp;jobData.Status, &amp;jobData.JobCostPrediction, &amp;jobData.JobCostActual,
                &amp;jobData.TaskIDs, &amp;jobData.CreatedAt, &amp;jobData.UpdatedAt, &amp;jobData.LastExecutedAt,
                &amp;jobData.Timezone, &amp;jobData.IsImua, &amp;jobData.CreatedChainID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;jobData, nil</span>
}

func (r *jobRepository) GetTaskDefinitionIDByJobID(jobID *big.Int) (int, error) <span class="cov0" title="0">{
        var taskDefinitionID int
        err := r.db.Session().Query(queries.GetTaskDefinitionIDByJobIDQuery, jobID).Scan(&amp;taskDefinitionID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("failed to get task definition id by job id")
        }</span>
        <span class="cov0" title="0">return taskDefinitionID, nil</span>
}

func (r *jobRepository) GetTaskFeesByJobID(jobID *big.Int) ([]types.TaskFeeResponse, error) <span class="cov0" title="0">{
        session := r.db.Session()
        iter := session.Query(queries.GetTaskFeesByJobIDQuery, jobID).Iter()

        var results []types.TaskFeeResponse
        var taskID int64
        var taskOpxCost float64
        for iter.Scan(&amp;taskID, &amp;taskOpxCost) </span><span class="cov0" title="0">{
                results = append(results, types.TaskFeeResponse{
                        TaskID:      taskID,
                        TaskOpxCost: taskOpxCost,
                })
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package repository

import (
        "fmt"
        "sort"

        // "time"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type KeeperRepository interface {
        CheckKeeperExists(address string) (int64, error)
        CreateKeeper(keeperData types.CreateKeeperData) (int64, error)
        GetKeeperAsPerformer() ([]types.GetPerformerData, error)
        GetKeeperDataByID(id int64) (types.KeeperData, error)
        IncrementKeeperTaskCount(id int64) (int64, error)
        GetKeeperTaskCount(id int64) (int64, error)
        UpdateKeeperPoints(id int64, taskFee float64) (float64, error)
        UpdateKeeperChatID(address string, chatID int64) error
        GetKeeperPointsByIDInDB(id int64) (float64, error)
        GetKeeperCommunicationInfo(id int64) (types.KeeperCommunicationInfo, error)
        GetKeeperLeaderboard() ([]types.KeeperLeaderboardEntry, error)
        GetKeeperLeaderboardByOnImua(onImua bool) ([]types.KeeperLeaderboardEntry, error)
        GetKeeperLeaderboardByIdentifierInDB(address string, name string) (types.KeeperLeaderboardEntry, error)
        CheckKeeperExistsByAddress(address string) (int64, error)
        CreateOrUpdateKeeperFromGoogleForm(keeperData types.GoogleFormCreateKeeperData) (int64, error)
}

type keeperRepository struct {
        db *database.Connection
}

func NewKeeperRepository(db *database.Connection) KeeperRepository <span class="cov0" title="0">{
        return &amp;keeperRepository{
                db: db,
        }
}</span>

func (r *keeperRepository) CreateKeeper(keeperData types.CreateKeeperData) (int64, error) <span class="cov0" title="0">{
        var maxKeeperID int64
        err := r.db.Session().Query(queries.GetMaxKeeperIDQuery).Scan(&amp;maxKeeperID)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                // If no keeper exists yet, start with ID 1
                maxKeeperID = 0
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("error getting max keeper ID: %v", err)
        }</span>

        <span class="cov0" title="0">err = r.db.Session().Query(queries.CreateNewKeeperQuery, maxKeeperID+1, keeperData.KeeperName, keeperData.KeeperAddress, 1.0, 0.0, true, keeperData.EmailID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">return maxKeeperID + 1, nil</span>
}

func (r *keeperRepository) GetKeeperAsPerformer() ([]types.GetPerformerData, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetKeeperAsPerformersQuery).Iter()

        var performers []types.GetPerformerData
        var performer types.GetPerformerData
        for iter.Scan(
                &amp;performer.KeeperID, &amp;performer.KeeperAddress) </span><span class="cov0" title="0">{
                performers = append(performers, performer)
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return performers, nil</span>
}

func (r *keeperRepository) GetKeeperDataByID(id int64) (types.KeeperData, error) <span class="cov0" title="0">{
        var keeperData types.KeeperData
        err := r.db.Session().Query(queries.GetKeeperDataByIDQuery, id).Scan(
                &amp;keeperData.KeeperID,
                &amp;keeperData.KeeperName,
                &amp;keeperData.KeeperAddress,
                &amp;keeperData.ConsensusAddress,
                &amp;keeperData.RegisteredTx,
                &amp;keeperData.OperatorID,
                &amp;keeperData.RewardsAddress,
                &amp;keeperData.RewardsBooster,
                &amp;keeperData.VotingPower,
                &amp;keeperData.KeeperPoints,
                &amp;keeperData.ConnectionAddress,
                &amp;keeperData.PeerID,
                &amp;keeperData.Strategies,
                &amp;keeperData.Whitelisted,
                &amp;keeperData.Registered,
                &amp;keeperData.Online,
                &amp;keeperData.Version,
                &amp;keeperData.NoExecutedTasks,
                &amp;keeperData.NoAttestedTasks,
                &amp;keeperData.ChatID,
                &amp;keeperData.EmailID,
                &amp;keeperData.LastCheckedIn,
                &amp;keeperData.OnImua,
        )
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperData{}, err
        }</span>
        <span class="cov0" title="0">return keeperData, nil</span>
}

func (r *keeperRepository) CheckKeeperExists(address string) (int64, error) <span class="cov0" title="0">{
        var id int64
        err := r.db.Session().Query(queries.GetKeeperIDByAddressQuery, address).Scan(&amp;id)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return -1, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (r *keeperRepository) UpdateKeeperChatID(address string, chatID int64) error <span class="cov0" title="0">{
        var id int64
        err := r.db.Session().Query(queries.GetKeeperIDByAddressQuery, address).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = r.db.Session().Query(queries.UpdateKeeperChatIDQuery, id, chatID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *keeperRepository) IncrementKeeperTaskCount(id int64) (int64, error) <span class="cov0" title="0">{
        var currentCount int64
        err := r.db.Session().Query(queries.GetKeeperTaskCountByIDQuery, id).Scan(&amp;currentCount)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">newCount := currentCount + 1

        err = r.db.Session().Query(queries.UpdateKeeperTaskCountQuery, newCount, id).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return newCount, nil</span>
}

func (r *keeperRepository) GetKeeperTaskCount(id int64) (int64, error) <span class="cov0" title="0">{
        var taskCount int64
        err := r.db.Session().Query(queries.GetKeeperTaskCountByIDQuery, id).Scan(&amp;taskCount)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return taskCount, nil</span>
}

func (r *keeperRepository) GetKeeperPointsByIDInDB(id int64) (float64, error) <span class="cov0" title="0">{
        var points float64
        err := r.db.Session().Query(queries.GetKeeperPointsByIDQuery, id).Scan(&amp;points)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return points, nil</span>
}

func (r *keeperRepository) UpdateKeeperPoints(id int64, taskFee float64) (float64, error) <span class="cov0" title="0">{
        var existingPoints float64
        err := r.db.Session().Query(queries.GetKeeperPointsByIDQuery, id).Scan(&amp;existingPoints)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                existingPoints = 0
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">newPoints := existingPoints + taskFee

        err = r.db.Session().Query(queries.UpdateKeeperPointsQuery, newPoints, id).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return newPoints, nil</span>
}

func (r *keeperRepository) GetKeeperCommunicationInfo(id int64) (types.KeeperCommunicationInfo, error) <span class="cov0" title="0">{
        var keeperCommunicationInfo types.KeeperCommunicationInfo
        err := r.db.Session().Query(queries.GetKeeperCommunicationInfoQuery, id).Scan(&amp;keeperCommunicationInfo.ChatID, &amp;keeperCommunicationInfo.KeeperName, &amp;keeperCommunicationInfo.EmailID)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperCommunicationInfo{}, err
        }</span>
        <span class="cov0" title="0">return keeperCommunicationInfo, nil</span>
}

func (r *keeperRepository) GetKeeperLeaderboard() ([]types.KeeperLeaderboardEntry, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetKeeperLeaderboardQuery).Iter()

        var keeperLeaderboard []types.KeeperLeaderboardEntry
        var keeperEntry types.KeeperLeaderboardEntry

        for iter.Scan(
                &amp;keeperEntry.KeeperID,
                &amp;keeperEntry.KeeperAddress,
                &amp;keeperEntry.KeeperName,
                &amp;keeperEntry.NoExecutedTasks,
                &amp;keeperEntry.NoAttestedTasks,
                &amp;keeperEntry.KeeperPoints,
                &amp;keeperEntry.OnImua,
        ) </span><span class="cov0" title="0">{
                keeperLeaderboard = append(keeperLeaderboard, keeperEntry)
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort leaderboard by UserPoints (desc), TotalJobs (desc), TotalTasks (desc), UserID (asc)
        <span class="cov0" title="0">sort.Slice(keeperLeaderboard, func(i, j int) bool </span><span class="cov0" title="0">{
                // First compare UserPoints
                if keeperLeaderboard[i].KeeperPoints != keeperLeaderboard[j].KeeperPoints </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].KeeperPoints &gt; keeperLeaderboard[j].KeeperPoints
                }</span>
                // If UserPoints equal, compare TotalJobs
                <span class="cov0" title="0">if keeperLeaderboard[i].NoExecutedTasks != keeperLeaderboard[j].NoExecutedTasks </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].NoExecutedTasks &gt; keeperLeaderboard[j].NoExecutedTasks
                }</span>
                // If TotalJobs equal, compare TotalTasks
                <span class="cov0" title="0">if keeperLeaderboard[i].NoAttestedTasks != keeperLeaderboard[j].NoAttestedTasks </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].NoAttestedTasks &gt; keeperLeaderboard[j].NoAttestedTasks
                }</span>
                // If all else equal, sort by UserID ascending
                <span class="cov0" title="0">return keeperLeaderboard[i].KeeperID &lt; keeperLeaderboard[j].KeeperID</span>
        })

        <span class="cov0" title="0">return keeperLeaderboard, nil</span>
}

func (r *keeperRepository) GetKeeperLeaderboardByOnImua(onImua bool) ([]types.KeeperLeaderboardEntry, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetKeeperLeaderboardByOnImuaQuery, onImua).Iter()

        var keeperLeaderboard []types.KeeperLeaderboardEntry
        var keeperEntry types.KeeperLeaderboardEntry

        for iter.Scan(
                &amp;keeperEntry.KeeperID,
                &amp;keeperEntry.KeeperAddress,
                &amp;keeperEntry.KeeperName,
                &amp;keeperEntry.NoExecutedTasks,
                &amp;keeperEntry.NoAttestedTasks,
                &amp;keeperEntry.KeeperPoints,
                &amp;keeperEntry.OnImua,
        ) </span><span class="cov0" title="0">{
                keeperLeaderboard = append(keeperLeaderboard, keeperEntry)
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort leaderboard by UserPoints (desc), TotalJobs (desc), TotalTasks (desc), UserID (asc)
        <span class="cov0" title="0">sort.Slice(keeperLeaderboard, func(i, j int) bool </span><span class="cov0" title="0">{
                // First compare UserPoints
                if keeperLeaderboard[i].KeeperPoints != keeperLeaderboard[j].KeeperPoints </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].KeeperPoints &gt; keeperLeaderboard[j].KeeperPoints
                }</span>
                // If UserPoints equal, compare TotalJobs
                <span class="cov0" title="0">if keeperLeaderboard[i].NoExecutedTasks != keeperLeaderboard[j].NoExecutedTasks </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].NoExecutedTasks &gt; keeperLeaderboard[j].NoExecutedTasks
                }</span>
                // If TotalJobs equal, compare TotalTasks
                <span class="cov0" title="0">if keeperLeaderboard[i].NoAttestedTasks != keeperLeaderboard[j].NoAttestedTasks </span><span class="cov0" title="0">{
                        return keeperLeaderboard[i].NoAttestedTasks &gt; keeperLeaderboard[j].NoAttestedTasks
                }</span>
                // If all else equal, sort by UserID ascending
                <span class="cov0" title="0">return keeperLeaderboard[i].KeeperID &lt; keeperLeaderboard[j].KeeperID</span>
        })

        <span class="cov0" title="0">return keeperLeaderboard, nil</span>
}

func (r *keeperRepository) GetKeeperLeaderboardByIdentifierInDB(address string, name string) (types.KeeperLeaderboardEntry, error) <span class="cov0" title="0">{
        var keeperEntry types.KeeperLeaderboardEntry
        var query string
        var args []interface{}

        if address != "" </span><span class="cov0" title="0">{
                query = queries.GetKeeperLeaderboardByAddressQuery
                args = append(args, address)
        }</span> else<span class="cov0" title="0"> {
                query = queries.GetKeeperLeaderboardByNameQuery
                args = append(args, name)
        }</span>

        <span class="cov0" title="0">err := r.db.Session().Query(query, args...).Scan(&amp;keeperEntry.KeeperID, &amp;keeperEntry.KeeperAddress, &amp;keeperEntry.KeeperName, &amp;keeperEntry.NoExecutedTasks, &amp;keeperEntry.NoAttestedTasks, &amp;keeperEntry.KeeperPoints)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperLeaderboardEntry{}, err
        }</span>

        <span class="cov0" title="0">return keeperEntry, nil</span>
}

func (r *keeperRepository) CheckKeeperExistsByAddress(address string) (int64, error) <span class="cov0" title="0">{
        var id int64
        err := r.db.Session().Query(queries.GetKeeperIDByAddressQuery, address).Scan(&amp;id)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (r *keeperRepository) CreateOrUpdateKeeperFromGoogleForm(keeperData types.GoogleFormCreateKeeperData) (int64, error) <span class="cov0" title="0">{
        existingKeeperID, err := r.CheckKeeperExistsByAddress(keeperData.KeeperAddress)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if existingKeeperID != 0 </span><span class="cov0" title="0">{
                err = r.db.Session().Query(
                        queries.UpdateKeeperFromGoogleFormQuery,
                        keeperData.KeeperName,
                        keeperData.KeeperAddress,
                        keeperData.RewardsAddress,
                        keeperData.EmailID,
                        keeperData.OnImua,
                        existingKeeperID,
                ).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return existingKeeperID, nil</span>
        }
        <span class="cov0" title="0">var maxKeeperID int64
        err = r.db.Session().Query(queries.GetMaxKeeperIDQuery).Scan(&amp;maxKeeperID)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                maxKeeperID = 0
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">currentKeeperID := maxKeeperID + 1
        err = r.db.Session().Query(
                queries.CreateNewKeeperFromGoogleFormQuery,
                currentKeeperID,
                keeperData.KeeperName,
                keeperData.KeeperAddress,
                keeperData.RewardsAddress,
                keeperData.EmailID,
                keeperData.OnImua,
        ).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return currentKeeperID, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package repository

import (
        "errors"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type TaskRepository interface {
        CreateTaskDataInDB(task *types.CreateTaskDataRequest) (int64, error)
        AddTaskPerformerID(taskID int64, performerID int64) error
        UpdateTaskExecutionDataInDB(task *types.UpdateTaskExecutionDataRequest) error
        UpdateTaskAttestationDataInDB(task *types.UpdateTaskAttestationDataRequest) error
        UpdateTaskNumberAndStatus(taskID int64, taskNumber int64, status string, txHash string) error
        GetTaskDataByID(taskID int64) (types.TaskData, error)
        GetTasksByJobID(jobID *big.Int) ([]types.GetTasksByJobID, error)
        AddTaskIDToJob(jobID *big.Int, taskID int64) error
        UpdateTaskFee(taskID int64, fee float64) error
        GetTaskFee(taskID int64) (float64, error)
        GetCreatedChainIDByJobID(jobID *big.Int) (string, error)
}

type taskRepository struct {
        db *database.Connection
}

func NewTaskRepository(db *database.Connection) TaskRepository <span class="cov0" title="0">{
        return &amp;taskRepository{
                db: db,
        }
}</span>

func (r *taskRepository) CreateTaskDataInDB(task *types.CreateTaskDataRequest) (int64, error) <span class="cov0" title="0">{
        var maxTaskID int64
        err := r.db.Session().Query(queries.GetMaxTaskIDQuery).Scan(&amp;maxTaskID)
        if err != nil </span><span class="cov0" title="0">{
                return -1, errors.New("error getting max task ID")
        }</span>
        <span class="cov0" title="0">err = r.db.Session().Query(queries.CreateTaskDataQuery, maxTaskID+1, task.JobID, task.TaskDefinitionID, time.Now(), task.IsImua).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return -1, errors.New("error creating task data")
        }</span>
        <span class="cov0" title="0">return maxTaskID + 1, nil</span>
}

func (r *taskRepository) AddTaskPerformerID(taskID int64, performerID int64) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.AddTaskPerformerIDQuery, taskID, performerID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error adding task performer ID")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) UpdateTaskExecutionDataInDB(task *types.UpdateTaskExecutionDataRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTaskExecutionDataQuery, task.TaskPerformerID, task.ExecutionTimestamp, task.ExecutionTxHash, task.ProofOfTask, task.TaskOpXCost, task.TaskID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error updating task execution data")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) UpdateTaskAttestationDataInDB(task *types.UpdateTaskAttestationDataRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTaskAttestationDataQuery, task.TaskNumber, task.TaskAttesterIDs, task.TpSignature, task.TaSignature, task.TaskSubmissionTxHash, task.IsSuccessful, task.TaskID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error updating task attestation data")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) UpdateTaskNumberAndStatus(taskID int64, taskNumber int64, status string, txHash string) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTaskNumberAndStatusQuery, taskNumber, status, txHash, taskID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error updating task number and status")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) GetTaskDataByID(taskID int64) (types.TaskData, error) <span class="cov0" title="0">{
        var task types.TaskData
        err := r.db.Session().Query(queries.GetTaskDataByIDQuery, taskID).Scan(&amp;task.TaskID, &amp;task.TaskNumber, &amp;task.JobID, &amp;task.TaskDefinitionID, &amp;task.CreatedAt, &amp;task.TaskOpXCost, &amp;task.ExecutionTimestamp, &amp;task.ExecutionTxHash, &amp;task.TaskPerformerID, &amp;task.ProofOfTask, &amp;task.TaskAttesterIDs, &amp;task.TpSignature, &amp;task.TaSignature, &amp;task.TaskSubmissionTxHash, &amp;task.IsSuccessful, &amp;task.TaskStatus, &amp;task.IsImua)
        if err != nil </span><span class="cov0" title="0">{
                return types.TaskData{}, errors.New("error getting task data by ID")
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func (r *taskRepository) GetTasksByJobID(jobID *big.Int) ([]types.GetTasksByJobID, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetTasksByJobIDQuery, jobID).Iter()
        var tasks []types.GetTasksByJobID
        var task types.GetTasksByJobID

        for iter.Scan(
                &amp;task.TaskID,
                &amp;task.TaskNumber,
                &amp;task.TaskOpXCost,
                &amp;task.ExecutionTimestamp,
                &amp;task.ExecutionTxHash,
                &amp;task.TaskPerformerID,
                &amp;task.TaskAttesterIDs,
                &amp;task.IsSuccessful,
                &amp;task.TaskStatus,
        ) </span><span class="cov0" title="0">{
                tasks = append(tasks, task)
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return []types.GetTasksByJobID{}, errors.New("error getting tasks by job ID: " + err.Error())
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *taskRepository) AddTaskIDToJob(jobID *big.Int, taskID int64) error <span class="cov0" title="0">{
        var taskIDs []int64
        iter := r.db.Session().Query(queries.GetTaskIDsByJobIDQuery, jobID).Iter()
        for iter.Scan(&amp;taskIDs) </span><span class="cov0" title="0">{
                taskIDs = append(taskIDs, taskID)
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return errors.New("error getting task IDs by job ID")
        }</span>
        <span class="cov0" title="0">taskIDs = append(taskIDs, taskID)
        err := r.db.Session().Query(queries.AddTaskIDToJobQuery, taskIDs, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error adding task ID to job")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) UpdateTaskFee(taskID int64, fee float64) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTaskFeeQuery, fee, taskID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error updating task fee")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *taskRepository) GetTaskFee(taskID int64) (float64, error) <span class="cov0" title="0">{
        var fee float64
        err := r.db.Session().Query(queries.GetTaskFeeQuery, taskID).Scan(&amp;fee)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("error getting task fee")
        }</span>
        <span class="cov0" title="0">return fee, nil</span>
}

func (r *taskRepository) GetCreatedChainIDByJobID(jobID *big.Int) (string, error) <span class="cov0" title="0">{
        var createdChainID string
        err := r.db.Session().Query(queries.GetCreatedChainIDByJobIDQuery, jobID).Scan(&amp;createdChainID)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("error getting created chain ID by job ID")
        }</span>
        <span class="cov0" title="0">return createdChainID, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package repository

import (
        "errors"
        "fmt"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/parser"
        commonTypes "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type TimeJobRepository interface {
        CreateTimeJob(timeJob *types.TimeJobData) error
        GetTimeJobByJobID(jobID *big.Int) (types.TimeJobData, error)
        CompleteTimeJob(jobID *big.Int) error
        UpdateTimeJobStatus(jobID *big.Int, isActive bool) error
        GetTimeJobsByNextExecutionTimestamp(lookAheadTime time.Time) ([]commonTypes.ScheduleTimeTaskData, error)
        UpdateTimeJobNextExecutionTimestamp(jobID *big.Int, nextExecutionTimestamp time.Time) error
        UpdateTimeJobInterval(jobID *big.Int, timeInterval int64) error
        GetActiveTimeJobs() ([]types.TimeJobData, error)
}

type timeJobRepository struct {
        db *database.Connection
}

func NewTimeJobRepository(db *database.Connection) TimeJobRepository <span class="cov0" title="0">{
        return &amp;timeJobRepository{
                db: db,
        }
}</span>

func (r *timeJobRepository) CreateTimeJob(timeJob *types.TimeJobData) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CreateTimeJobDataQuery,
                timeJob.JobID, timeJob.TaskDefinitionID, timeJob.ExpirationTime, timeJob.NextExecutionTimestamp,
                timeJob.ScheduleType, timeJob.TimeInterval, timeJob.CronExpression, timeJob.SpecificSchedule,
                timeJob.Timezone, timeJob.TargetChainID, timeJob.TargetContractAddress, timeJob.TargetFunction,
                timeJob.ABI, timeJob.ArgType, timeJob.Arguments, timeJob.DynamicArgumentsScriptUrl,
                timeJob.IsCompleted, timeJob.IsActive, time.Now(), time.Now()).Exec()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *timeJobRepository) GetTimeJobByJobID(jobID *big.Int) (types.TimeJobData, error) <span class="cov0" title="0">{
        var timeJob types.TimeJobData
        err := r.db.Session().Query(queries.GetTimeJobDataByJobIDQuery, jobID).Scan(
                &amp;timeJob.JobID, &amp;timeJob.ExpirationTime, &amp;timeJob.NextExecutionTimestamp,
                &amp;timeJob.ScheduleType, &amp;timeJob.TimeInterval, &amp;timeJob.CronExpression,
                &amp;timeJob.SpecificSchedule, &amp;timeJob.Timezone, &amp;timeJob.TargetChainID,
                &amp;timeJob.TargetContractAddress, &amp;timeJob.TargetFunction, &amp;timeJob.ABI, &amp;timeJob.ArgType,
                &amp;timeJob.Arguments, &amp;timeJob.DynamicArgumentsScriptUrl, &amp;timeJob.IsCompleted, &amp;timeJob.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                return types.TimeJobData{}, fmt.Errorf("failed to get time job by job ID: %v", err)
        }</span>

        <span class="cov0" title="0">return timeJob, nil</span>
}

func (r *timeJobRepository) CompleteTimeJob(jobID *big.Int) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.CompleteTimeJobStatusQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to complete time job")
        }</span>

        <span class="cov0" title="0">err = r.db.Session().Query(queries.UpdateJobDataToCompletedQuery, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update job_data status to completed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *timeJobRepository) UpdateTimeJobStatus(jobID *big.Int, isActive bool) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTimeJobStatusQuery, isActive, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update time job status")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *timeJobRepository) GetTimeJobsByNextExecutionTimestamp(lookAheadTime time.Time) ([]commonTypes.ScheduleTimeTaskData, error) <span class="cov0" title="0">{
        currentTime := time.Now()
        iter := r.db.Session().Query(queries.GetTimeJobsByNextExecutionTimestampQuery, currentTime, lookAheadTime).Iter()

        var timeJobs []commonTypes.ScheduleTimeTaskData
        var timeJob commonTypes.ScheduleTimeTaskData

        for iter.Scan(
                &amp;timeJob.TaskTargetData.JobID, &amp;timeJob.LastExecutedAt, &amp;timeJob.ExpirationTime, &amp;timeJob.TimeInterval,
                &amp;timeJob.ScheduleType, &amp;timeJob.CronExpression, &amp;timeJob.SpecificSchedule, &amp;timeJob.NextExecutionTimestamp,
                &amp;timeJob.TaskTargetData.TargetChainID, &amp;timeJob.TaskTargetData.TargetContractAddress, &amp;timeJob.TaskTargetData.TargetFunction, &amp;timeJob.TaskTargetData.ABI, &amp;timeJob.TaskTargetData.ArgType,
                &amp;timeJob.TaskTargetData.Arguments, &amp;timeJob.TaskTargetData.DynamicArgumentsScriptUrl,
        ) </span><span class="cov0" title="0">{
                if timeJob.TaskTargetData.DynamicArgumentsScriptUrl != "" </span><span class="cov0" title="0">{
                        timeJob.TaskDefinitionID = 2
                        timeJob.TaskTargetData.TaskDefinitionID = 2
                }</span> else<span class="cov0" title="0"> {
                        timeJob.TaskDefinitionID = 1
                        timeJob.TaskTargetData.TaskDefinitionID = 1
                }</span>

                <span class="cov0" title="0">var isImua bool
                err := r.db.Session().Query(queries.IsJobImuaQuery, timeJob.TaskTargetData.JobID).Scan(&amp;isImua)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">timeJob.IsImua = isImua

                // Calculate next execution time after the current execution time
                nextExecutionTime, err := parser.CalculateNextExecutionTime(timeJob.NextExecutionTimestamp, timeJob.ScheduleType, timeJob.TimeInterval, timeJob.CronExpression, timeJob.SpecificSchedule)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // If the next execution time is after the expiration time, That means the job will be completed after current execution time that is being passed
                <span class="cov0" title="0">if nextExecutionTime.After(timeJob.ExpirationTime) </span><span class="cov0" title="0">{
                        err = r.CompleteTimeJob(timeJob.TaskTargetData.JobID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">err = r.UpdateTimeJobStatus(timeJob.TaskTargetData.JobID, false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = r.UpdateTimeJobNextExecutionTimestamp(timeJob.TaskTargetData.JobID, nextExecutionTime)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">timeJobs = append(timeJobs, timeJob)</span>
        }
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return timeJobs, nil</span>
}

func (r *timeJobRepository) UpdateTimeJobNextExecutionTimestamp(jobID *big.Int, nextExecutionTimestamp time.Time) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTimeJobNextExecutionTimestampQuery, nextExecutionTimestamp, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update time job next execution timestamp")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *timeJobRepository) UpdateTimeJobInterval(jobID *big.Int, timeInterval int64) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateTimeJobIntervalQuery, timeInterval, jobID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to update time_interval in time_job_data")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *timeJobRepository) GetActiveTimeJobs() ([]types.TimeJobData, error) <span class="cov0" title="0">{
        var timeJobs []types.TimeJobData
        iter := r.db.Session().Query(queries.GetActiveTimeJobsQuery).Iter()
        var timeJob types.TimeJobData
        for iter.Scan(
                &amp;timeJob.JobID, &amp;timeJob.ExpirationTime, &amp;timeJob.NextExecutionTimestamp, &amp;timeJob.ScheduleType,
                &amp;timeJob.TimeInterval, &amp;timeJob.CronExpression, &amp;timeJob.SpecificSchedule, &amp;timeJob.Timezone,
                &amp;timeJob.TargetChainID, &amp;timeJob.TargetContractAddress, &amp;timeJob.TargetFunction, &amp;timeJob.ABI, &amp;timeJob.ArgType,
                &amp;timeJob.Arguments, &amp;timeJob.DynamicArgumentsScriptUrl, &amp;timeJob.IsCompleted, &amp;timeJob.IsActive) </span><span class="cov0" title="0">{
                timeJobs = append(timeJobs, timeJob)
        }</span>
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return timeJobs, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package repository

import (
        "errors"
        "math/big"
        "sort"
        "time"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/repository/queries"
        "github.com/trigg3rX/triggerx-backend/internal/dbserver/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
)

type UserRepository interface {
        CheckUserExists(address string) (int64, error)
        CreateNewUser(user *types.CreateUserDataRequest) (types.UserData, error)
        UpdateUserBalance(user *types.UpdateUserBalanceRequest) error
        UpdateUserJobIDs(userID int64, jobIDs []*big.Int) error
        UpdateUserTasksAndPoints(userID int64, tasksCompleted int64, userPoints float64) error
        GetUserDataByAddress(address string) (int64, types.UserData, error)
        GetUserPointsByID(id int64) (float64, error)
        GetUserPointsByAddress(address string) (float64, error)
        GetUserJobIDsByAddress(address string) (int64, []*big.Int, error)
        GetUserLeaderboard() ([]types.UserLeaderboardEntry, error)
        GetUserLeaderboardByAddress(address string) (types.UserLeaderboardEntry, error)
        UpdateUserEmail(address string, email string) error
}

type userRepository struct {
        db *database.Connection
}

func NewUserRepository(db *database.Connection) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                db: db,
        }
}</span>

func (r *userRepository) CheckUserExists(address string) (int64, error) <span class="cov0" title="0">{
        var userID int64
        err := r.db.Session().Query(queries.GetUserIDByAddressQuery, address).Scan(&amp;userID)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return -1, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return userID, nil</span>
}

func (r *userRepository) CreateNewUser(user *types.CreateUserDataRequest) (types.UserData, error) <span class="cov0" title="0">{
        var maxUserID int64
        err := r.db.Session().Query(queries.GetMaxUserIDQuery).Scan(&amp;maxUserID)
        if err != nil </span><span class="cov0" title="0">{
                return types.UserData{}, err
        }</span>
        <span class="cov0" title="0">err = r.db.Session().Query(queries.CreateUserDataQuery, maxUserID+1, user.UserAddress, user.EtherBalance, user.TokenBalance, user.UserPoints, 0, 0, time.Now()).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return types.UserData{}, err
        }</span>
        <span class="cov0" title="0">return types.UserData{
                UserID:       maxUserID + 1,
                UserAddress:  user.UserAddress,
                EtherBalance: user.EtherBalance,
                TokenBalance: user.TokenBalance,
                UserPoints:   user.UserPoints,
        }, nil</span>
}

func (r *userRepository) UpdateUserBalance(user *types.UpdateUserBalanceRequest) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateUserBalanceQuery, user.EtherBalance, user.TokenBalance, user.UserID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) UpdateUserJobIDs(userID int64, jobIDs []*big.Int) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateUserJobIDsQuery, jobIDs, len(jobIDs), time.Now(), userID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) UpdateUserTasksAndPoints(userID int64, tasksCompleted int64, userPoints float64) error <span class="cov0" title="0">{
        err := r.db.Session().Query(queries.UpdateUserTasksAndPointsQuery, tasksCompleted, userPoints, userID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) UpdateUserEmail(address string, email string) error <span class="cov0" title="0">{
        var userID int64
        err := r.db.Session().Query(queries.GetUserIDByAddressQuery, address).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = r.db.Session().Query(queries.UpdateUserEmailByIDQuery, email, userID).Exec()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) GetUserDataByAddress(address string) (int64, types.UserData, error) <span class="cov0" title="0">{
        var userID int64
        err := r.db.Session().Query(queries.GetUserIDByAddressQuery, address).Scan(&amp;userID)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return -1, types.UserData{}, gocql.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return -1, types.UserData{}, err
        }</span>
        <span class="cov0" title="0">var userData types.UserData
        err = r.db.Session().Query(queries.GetUserDataByIDQuery, userID).Scan(
                &amp;userData.UserID, &amp;userData.UserAddress, &amp;userData.JobIDs, &amp;userData.TotalJobs, &amp;userData.TotalTasks,
                &amp;userData.EtherBalance, &amp;userData.TokenBalance, &amp;userData.UserPoints,
                &amp;userData.CreatedAt, &amp;userData.LastUpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return -1, types.UserData{}, err
        }</span>
        <span class="cov0" title="0">return userID, userData, nil</span>
}

func (r *userRepository) GetUserPointsByID(id int64) (float64, error) <span class="cov0" title="0">{
        var userPoints float64
        err := r.db.Session().Query(queries.GetUserPointsByIDQuery, id).Scan(&amp;userPoints)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return userPoints, nil</span>
}

func (r *userRepository) GetUserPointsByAddress(address string) (float64, error) <span class="cov0" title="0">{
        var userPoints float64
        err := r.db.Session().Query(queries.GetUserPointsByAddressQuery, address).Scan(&amp;userPoints)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return 0, errors.New("user address not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return userPoints, nil</span>
}

func (r *userRepository) GetUserJobIDsByAddress(address string) (int64, []*big.Int, error) <span class="cov0" title="0">{
        var userID int64
        var jobIDs []*big.Int
        err := r.db.Session().Query(queries.GetUserJobIDsByAddressQuery, address).Scan(&amp;userID, &amp;jobIDs)
        if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                return -1, nil, errors.New("user address not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return -1, nil, err
        }</span>
        <span class="cov0" title="0">return userID, jobIDs, nil</span>
}

func (r *userRepository) GetUserLeaderboard() ([]types.UserLeaderboardEntry, error) <span class="cov0" title="0">{
        iter := r.db.Session().Query(queries.GetUserLeaderboardQuery).Iter()

        var leaderboard []types.UserLeaderboardEntry
        var userEntry types.UserLeaderboardEntry

        for iter.Scan(
                &amp;userEntry.UserID,
                &amp;userEntry.UserAddress,
                &amp;userEntry.TotalJobs,
                &amp;userEntry.TotalTasks,
                &amp;userEntry.UserPoints,
        ) </span><span class="cov0" title="0">{
                leaderboard = append(leaderboard, userEntry)
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort leaderboard by UserPoints (desc), TotalJobs (desc), TotalTasks (desc), UserID (asc)
        <span class="cov0" title="0">sort.Slice(leaderboard, func(i, j int) bool </span><span class="cov0" title="0">{
                // First compare UserPoints
                if leaderboard[i].UserPoints != leaderboard[j].UserPoints </span><span class="cov0" title="0">{
                        return leaderboard[i].UserPoints &gt; leaderboard[j].UserPoints
                }</span>
                // If UserPoints equal, compare TotalJobs
                <span class="cov0" title="0">if leaderboard[i].TotalJobs != leaderboard[j].TotalJobs </span><span class="cov0" title="0">{
                        return leaderboard[i].TotalJobs &gt; leaderboard[j].TotalJobs
                }</span>
                // If TotalJobs equal, compare TotalTasks
                <span class="cov0" title="0">if leaderboard[i].TotalTasks != leaderboard[j].TotalTasks </span><span class="cov0" title="0">{
                        return leaderboard[i].TotalTasks &gt; leaderboard[j].TotalTasks
                }</span>
                // If all else equal, sort by UserID ascending
                <span class="cov0" title="0">return leaderboard[i].UserID &lt; leaderboard[j].UserID</span>
        })
        <span class="cov0" title="0">return leaderboard, nil</span>
}

func (r *userRepository) GetUserLeaderboardByAddress(address string) (types.UserLeaderboardEntry, error) <span class="cov0" title="0">{
        var userEntry types.UserLeaderboardEntry
        err := r.db.Session().Query(queries.GetUserLeaderboardByAddressQuery, address).Scan(&amp;userEntry.UserID, &amp;userEntry.UserAddress, &amp;userEntry.TotalJobs, &amp;userEntry.TotalTasks, &amp;userEntry.UserPoints)
        if err != nil </span><span class="cov0" title="0">{
                return types.UserLeaderboardEntry{}, err
        }</span>

        <span class="cov0" title="0">return userEntry, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package types

import (
        "encoding/json"
        "math/big"
)

type BigIntString struct {
        *big.Int
}

func (b BigIntString) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if b.Int == nil </span><span class="cov0" title="0">{
                return []byte(`"0"`), nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(b.String())</span>
}

func (b *BigIntString) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">i := new(big.Int)
        i.SetString(s, 10)
        b.Int = i
        return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package types

import (
        "math/big"
        "time"
)

type JobData struct {
        JobID             *big.Int  `json:"job_id"`
        JobTitle          string    `json:"job_title"`
        TaskDefinitionID  int       `json:"task_definition_id"`
        UserID            int64     `json:"user_id"`
        LinkJobID         *big.Int  `json:"link_job_id"`
        ChainStatus       int       `json:"chain_status"`
        Custom            bool      `json:"custom"`
        TimeFrame         int64     `json:"time_frame"`
        Recurring         bool      `json:"recurring"`
        Status            string    `json:"status"`
        JobCostPrediction float64   `json:"job_cost_prediction"`
        JobCostActual     float64   `json:"job_cost_actual"`
        TaskIDs           []int64   `json:"task_ids"`
        CreatedAt         time.Time `json:"created_at"`
        UpdatedAt         time.Time `json:"updated_at"`
        LastExecutedAt    time.Time `json:"last_executed_at"`
        Timezone          string    `json:"timezone"`
        IsImua            bool      `json:"is_imua"`
        CreatedChainID    string    `json:"created_chain_id"`
}

// JobResponse is a unified type for different job types to be sent to the frontend
type JobResponse struct {
        JobData          JobData           `json:"job_data"`
        TimeJobData      *TimeJobData      `json:"time_job_data,omitempty"`
        EventJobData     *EventJobData     `json:"event_job_data,omitempty"`
        ConditionJobData *ConditionJobData `json:"condition_job_data,omitempty"`
}

const (
        // Time-based job task definitions
        TaskDefTimeBasedStart = 1
        TaskDefTimeBasedEnd   = 2

        // Event-based job task definitions
        TaskDefEventBasedStart = 3
        TaskDefEventBasedEnd   = 4

        // Condition-based job task definitions
        TaskDefConditionBasedStart = 5
        TaskDefConditionBasedEnd   = 6
)

type JobStatus string

const (
        JobStatusPending JobStatus = "pending"
        JobStatusInQueue JobStatus = "in-queue"
        JobStatusRunning JobStatus = "running"
)

type CreateJobData struct {
        // Common fields for all job types
        JobID        string   `json:"job_id" validate:"required"`
        UserAddress  string   `json:"user_address" validate:"required,ethereum_address"`
        EtherBalance *big.Int `json:"ether_balance" validate:"required"`
        TokenBalance *big.Int `json:"token_balance" validate:"required"`

        JobTitle          string  `json:"job_title" validate:"required,min=3,max=100"`
        TaskDefinitionID  int     `json:"task_definition_id" validate:"required,min=1,max=6"`
        Custom            bool    `json:"custom"`
        TimeFrame         int64   `json:"time_frame" validate:"required,min=1"`
        Recurring         bool    `json:"recurring"`
        JobCostPrediction float64 `json:"job_cost_prediction" validate:"required,min=0"`
        Timezone          string  `json:"timezone" validate:"required"`
        CreatedChainID    string  `json:"created_chain_id" validate:"required,chain_id"`

        // Time job specific fields
        ScheduleType     string `json:"schedule_type,omitempty" validate:"omitempty,oneof=cron specific interval"`
        TimeInterval     int64  `json:"time_interval,omitempty" validate:"omitempty,min=1"`
        CronExpression   string `json:"cron_expression,omitempty" validate:"omitempty,cron"`
        SpecificSchedule string `json:"specific_schedule,omitempty" validate:"omitempty"`

        // Event job specific fields
        TriggerChainID         string `json:"trigger_chain_id,omitempty" validate:"omitempty,chain_id"`
        TriggerContractAddress string `json:"trigger_contract_address,omitempty" validate:"omitempty,ethereum_address"`
        TriggerEvent           string `json:"trigger_event,omitempty" validate:"omitempty"`

        // Condition job specific fields
        ConditionType   string  `json:"condition_type,omitempty" validate:"omitempty"`
        UpperLimit      float64 `json:"upper_limit,omitempty" validate:"omitempty,gt=0"`
        LowerLimit      float64 `json:"lower_limit,omitempty" validate:"omitempty,gt=0"`
        ValueSourceType string  `json:"value_source_type,omitempty" validate:"omitempty"`
        ValueSourceUrl  string  `json:"value_source_url,omitempty" validate:"omitempty"`
        SelectedKeyRoute string  `json:"selected_key_route,omitempty" validate:"omitempty"`

        // Target fields (common for all job types)
        TargetChainID             string   `json:"target_chain_id" validate:"required,chain_id"`
        TargetContractAddress     string   `json:"target_contract_address" validate:"required,ethereum_address"`
        TargetFunction            string   `json:"target_function" validate:"required"`
        ABI                       string   `json:"abi" validate:"required"`
        ArgType                   int      `json:"arg_type" validate:"required"`
        Arguments                 []string `json:"arguments" validate:"omitempty"`
        DynamicArgumentsScriptUrl string   `json:"dynamic_arguments_script_url,omitempty" validate:"omitempty,ipfs_url"`

        IsImua bool `json:"is_imua"`
}

type CreateJobResponse struct {
        UserID            int64      `json:"user_id"`
        AccountBalance    *big.Int   `json:"account_balance"`
        TokenBalance      *big.Int   `json:"token_balance"`
        JobIDs            []*big.Int `json:"job_ids"`
        TaskDefinitionIDs []int      `json:"task_definition_ids"`
        TimeFrames        []int64    `json:"time_frames"`
}

type UpdateJobDataFromUserRequest struct {
        JobID             string  `json:"job_id"`
        JobTitle          string  `json:"job_title"`
        Recurring         bool    `json:"recurring"`
        Status            string  `json:"status"`
        TimeFrame         int64   `json:"time_frame"`
        JobCostPrediction float64 `json:"job_cost_prediction"`
        Timezone          string  `json:"timezone"`
        TimeInterval      int64   `json:"time_interval"`
}

type UpdateJobLastExecutedAtRequest struct {
        JobID          *big.Int  `json:"job_id"`
        TaskIDs        int64     `json:"task_ids"`
        JobCostActual  float64   `json:"job_cost_actual"`
        LastExecutedAt time.Time `json:"last_executed_at"`
}

// TaskFeeResponse represents the response structure for task fees by job
// TaskOpxCost corresponds to the task_opx_cost field in the database
type TaskFeeResponse struct {
        TaskID      int64   `json:"task_id"`
        TaskOpxCost float64 `json:"task_opx_cost"`
}

type JobDataAPI struct {
        JobID             BigIntString `json:"job_id"`
        JobTitle          string             `json:"job_title"`
        TaskDefinitionID  int                `json:"task_definition_id"`
        UserID            int64              `json:"user_id"`
        LinkJobID         BigIntString `json:"link_job_id"`
        ChainStatus       int                `json:"chain_status"`
        Custom            bool               `json:"custom"`
        TimeFrame         int64              `json:"time_frame"`
        Recurring         bool               `json:"recurring"`
        Status            string             `json:"status"`
        JobCostPrediction float64            `json:"job_cost_prediction"`
        JobCostActual     float64            `json:"job_cost_actual"`
        TaskIDs           []int64            `json:"task_ids"`
        CreatedAt         time.Time          `json:"created_at"`
        UpdatedAt         time.Time          `json:"updated_at"`
        LastExecutedAt    time.Time          `json:"last_executed_at"`
        Timezone          string             `json:"timezone"`
        IsImua            bool               `json:"is_imua"`
        CreatedChainID    string             `json:"created_chain_id"`
}

type JobResponseAPI struct {
        JobData          JobDataAPI        `json:"job_data"`
        TimeJobData      *TimeJobData      `json:"time_job_data,omitempty"`
        EventJobData     *EventJobData     `json:"event_job_data,omitempty"`
        ConditionJobData *ConditionJobData `json:"condition_job_data,omitempty"`
}

func ConvertJobResponseToAPI(j JobResponse) JobResponseAPI <span class="cov0" title="0">{
        return JobResponseAPI{
                JobData: JobDataAPI{
                        JobID:             BigIntString{j.JobData.JobID},
                        JobTitle:          j.JobData.JobTitle,
                        TaskDefinitionID:  j.JobData.TaskDefinitionID,
                        UserID:            j.JobData.UserID,
                        LinkJobID:         BigIntString{j.JobData.LinkJobID},
                        ChainStatus:       j.JobData.ChainStatus,
                        Custom:            j.JobData.Custom,
                        TimeFrame:         j.JobData.TimeFrame,
                        Recurring:         j.JobData.Recurring,
                        Status:            j.JobData.Status,
                        JobCostPrediction: j.JobData.JobCostPrediction,
                        JobCostActual:     j.JobData.JobCostActual,
                        TaskIDs:           j.JobData.TaskIDs,
                        CreatedAt:         j.JobData.CreatedAt,
                        UpdatedAt:         j.JobData.UpdatedAt,
                        LastExecutedAt:    j.JobData.LastExecutedAt,
                        Timezone:          j.JobData.Timezone,
                        IsImua:            j.JobData.IsImua,
                        CreatedChainID:    j.JobData.CreatedChainID,
                },
                TimeJobData:      j.TimeJobData,
                EventJobData:     j.EventJobData,
                ConditionJobData: j.ConditionJobData,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package client

import (
        "bytes"
        // "encoding/json"
        "errors"
        "fmt"

        // "net/http"
        "strings"
        "time"

        "github.com/go-gomail/gomail"
        "github.com/trigg3rX/triggerx-backend/internal/health/config"
        "github.com/trigg3rX/triggerx-backend/internal/health/telegram"

        "github.com/trigg3rX/triggerx-backend/internal/health/types"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        commonTypes "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// DatabaseManager handles database operations
type DatabaseManager struct {
        logger      logging.Logger
        db          *database.Connection
        telegramBot *telegram.Bot
}

var instance *DatabaseManager

// InitDatabaseManager initializes the database manager with a logger
func InitDatabaseManager(logger logging.Logger, connection *database.Connection, telegramBot *telegram.Bot) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                panic("logger cannot be nil")</span>
        }
        <span class="cov0" title="0">if connection == nil </span><span class="cov0" title="0">{
                panic("database connection cannot be nil")</span>
        }
        <span class="cov0" title="0">if telegramBot == nil </span><span class="cov0" title="0">{
                logger.Warn("Telegram bot is nil, notifications will not be sent")
        }</span>

        // Create a new logger with component field and proper level
        <span class="cov0" title="0">dbLogger := logger.With("component", "database")

        instance = &amp;DatabaseManager{
                logger:      dbLogger,
                db:          connection,
                telegramBot: telegramBot,
        }</span>
}

// GetInstance returns the database manager instance
func GetInstance() *DatabaseManager <span class="cov0" title="0">{
        if instance == nil </span><span class="cov0" title="0">{
                panic("database manager not initialized")</span>
        }
        <span class="cov0" title="0">return instance</span>
}

// KeeperRegistered registers a new keeper or updates an existing one (status = true)
func (dm *DatabaseManager) UpdateKeeperHealth(keeperHealth commonTypes.KeeperHealthCheckIn, isActive bool) error <span class="cov0" title="0">{
        dm.logger.Debug("Updating keeper status in database",
                "keeper", keeperHealth.KeeperAddress,
                "active", isActive,
        )

        keeperHealth.KeeperAddress = strings.ToLower(keeperHealth.KeeperAddress)
        keeperHealth.ConsensusAddress = strings.ToLower(keeperHealth.ConsensusAddress)

        if len(keeperHealth.KeeperAddress) &gt; 0 &amp;&amp; !bytes.HasPrefix([]byte(keeperHealth.KeeperAddress), []byte("0x")) </span><span class="cov0" title="0">{
                dm.logger.Debug("Adding 0x prefix to keeper address",
                        "keeper", keeperHealth.KeeperAddress,
                )
                keeperHealth.KeeperAddress = "0x" + keeperHealth.KeeperAddress
        }</span>

        <span class="cov0" title="0">var keeperID int64
        var prevOnline bool
        var prevLastCheckedIn time.Time
        var prevUptime int64

        // Fetch previous online status, last_checked_in, and uptime
        if err := dm.db.Session().Query(`
                SELECT keeper_id, online, last_checked_in, uptime FROM triggerx.keeper_data WHERE keeper_address = ? ALLOW FILTERING`,
                keeperHealth.KeeperAddress).Scan(&amp;keeperID, &amp;prevOnline, &amp;prevLastCheckedIn, &amp;prevUptime); err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to retrieve keeper_id and previous status",
                        "keeper", keeperHealth.KeeperAddress,
                        "error", err,
                )
                return err
        }</span>

        <span class="cov0" title="0">if keeperID == 0 </span><span class="cov0" title="0">{
                dm.logger.Errorf("[KeeperHealthCheckIn] No keeper found with address: %s", keeperHealth.KeeperAddress)
                return errors.New("keeper not found")
        }</span>

        <span class="cov0" title="0">if keeperHealth.PeerID == "" </span><span class="cov0" title="0">{
                keeperHealth.PeerID = "no-peer-id"
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("[KeeperHealthCheckIn] Keeper ID: %d | Online: %t", keeperID, isActive)

        // --- UPTIME LOGIC ---
        // If previously online, add to uptime (regardless of new isActive)
        if prevOnline </span><span class="cov0" title="0">{
                now := time.Now().UTC()
                uptimeToAdd := int64(now.Sub(prevLastCheckedIn).Seconds())
                if uptimeToAdd &lt; 0 </span><span class="cov0" title="0">{
                        uptimeToAdd = 0 // avoid negative values
                }</span>
                <span class="cov0" title="0">newUptime := prevUptime + uptimeToAdd

                // Update uptime field
                if err := dm.db.Session().Query(`
                        UPDATE triggerx.keeper_data 
                        SET uptime = ?
                        WHERE keeper_id = ?`,
                        newUptime, keeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Error("Failed to update keeper uptime",
                                "error", err,
                                "keeper_id", keeperID,
                                "keeper", keeperHealth.KeeperAddress,
                        )
                        return err
                }</span>
        }
        // --- END UPTIME LOGIC ---

        <span class="cov0" title="0">if !isActive </span><span class="cov0" title="0">{
                // If not active, just set online = false
                if err := dm.db.Session().Query(`
                        UPDATE triggerx.keeper_data 
                        SET online = ?
                        WHERE keeper_id = ?`,
                        false, keeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Error("Failed to update keeper inactive status",
                                "error", err,
                                "keeper_id", keeperID,
                                "keeper", keeperHealth.KeeperAddress,
                        )
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // If active, update all fields including last_checked_in
        <span class="cov0" title="0">if err := dm.db.Session().Query(`
                UPDATE triggerx.keeper_data 
                SET consensus_address = ?, online = ?, peer_id = ?, version = ?, last_checked_in = ? 
                WHERE keeper_id = ?`,
                keeperHealth.ConsensusAddress, true, keeperHealth.PeerID, keeperHealth.Version, keeperHealth.Timestamp, keeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to update keeper status",
                        "error", err,
                        "keeper_id", keeperID,
                )
                return err
        }</span>

        <span class="cov0" title="0">if !isActive </span><span class="cov0" title="0">{
                go dm.checkAndNotifyOfflineKeeper(keeperID)
        }</span>

        <span class="cov0" title="0">dm.logger.Info("Successfully updated keeper status",
                "keeper_id", keeperID,
                "active", isActive,
        )
        return nil</span>
}

func (dm *DatabaseManager) checkAndNotifyOfflineKeeper(keeperID int64) <span class="cov0" title="0">{
        time.Sleep(10 * time.Minute)

        dm.logger.Debug("Checking current status for offline keeper",
                "keeper_id", keeperID,
        )

        var online bool
        err := dm.db.Session().Query(`
                SELECT online FROM triggerx.keeper_data WHERE keeper_id = ?`,
                keeperID).Scan(&amp;online)

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to check keeper online status",
                        "error", err,
                        "keeper_id", keeperID,
                )
                return
        }</span>

        <span class="cov0" title="0">if !online </span><span class="cov0" title="0">{
                var chatID int64
                var keeperName, emailID string
                err := dm.db.Session().Query(`
                        SELECT chat_id, keeper_name, email_id 
                        FROM triggerx.keeper_data 
                        WHERE keeper_id = ?`,
                        keeperID).Scan(&amp;chatID, &amp;keeperName, &amp;emailID)

                if err != nil </span><span class="cov0" title="0">{
                        dm.logger.Error("Failed to fetch keeper communication info",
                                "error", err,
                                "keeper_id", keeperID,
                        )
                        return
                }</span>

                <span class="cov0" title="0">if chatID != 0 </span><span class="cov0" title="0">{
                        telegramMsg := fmt.Sprintf("Keeper %s is down for more than 10 minutes. Please check and start it.", keeperName)
                        if err := dm.telegramBot.SendMessage(chatID, telegramMsg); err != nil </span><span class="cov0" title="0">{
                                dm.logger.Error("Failed to send Telegram notification",
                                        "error", err,
                                        "keeper", keeperName,
                                        "keeper_id", keeperID,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        dm.logger.Warn("No Telegram chat ID found",
                                "keeper", keeperName,
                                "keeper_id", keeperID,
                        )
                }</span>

                <span class="cov0" title="0">if emailID != "" </span><span class="cov0" title="0">{
                        subject := fmt.Sprintf("TriggerX Keeper Down Alert - %s", keeperName)
                        emailBody := fmt.Sprintf(`
                                &lt;h2&gt;Keeper Update&lt;/h2&gt;
                                &lt;p&gt;This is a critical information from TriggerX. Your keeper &lt;strong&gt;%s&lt;/strong&gt; has been down for more than 10 minutes. Please take action immediately.&lt;/p&gt;
                                &lt;p&gt;Regards,&lt;br&gt;TriggerX Team&lt;/p&gt;
                        `, keeperName)

                        if err := dm.sendEmailNotification(emailID, subject, emailBody); err != nil </span><span class="cov0" title="0">{
                                dm.logger.Error("Failed to send email notification",
                                        "error", err,
                                        "keeper", keeperName,
                                        "keeper_id", keeperID,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        dm.logger.Warn("No email address found",
                                "keeper", keeperName,
                                "keeper_id", keeperID,
                        )
                }</span>

                <span class="cov0" title="0">dm.logger.Info("Completed notification process for offline keeper",
                        "keeper", keeperName,
                        "keeper_id", keeperID,
                )</span>
        } else<span class="cov0" title="0"> {
                dm.logger.Info("Keeper is back online",
                        "keeper_id", keeperID,
                )
        }</span>
}

// func (dm *DatabaseManager) sendTelegramNotification(chatID int64, message string) error {
//         url := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", config.GetBotToken())
//         payload := map[string]interface{}{
//                 "chat_id": chatID,
//                 "text":    message,
//         }

//         jsonData, err := json.Marshal(payload)
//         if err != nil {
//                 dm.logger.Errorf("[Notification] Failed to marshal Telegram payload: %v", err)
//                 return err
//         }

//         resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
//         if err != nil {
//                 dm.logger.Errorf("[Notification] Failed to send Telegram message: %v", err)
//                 return err
//         }
//         defer resp.Body.Close()

//         dm.logger.Infof("[Notification] Telegram message sent successfully to chat ID: %d (Status: %d)", chatID, resp.StatusCode)
//         return nil
// }

func (dm *DatabaseManager) sendEmailNotification(to, subject, body string) error <span class="cov0" title="0">{
        m := gomail.NewMessage()
        m.SetHeader("From", config.GetEmailUser())
        m.SetHeader("To", to)
        m.SetHeader("Subject", subject)
        m.SetBody("text/html", body)

        d := gomail.NewDialer("smtp.zeptomail.in", 587, config.GetEmailUser(), config.GetEmailPassword())
        if err := d.DialAndSend(m); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("[Notification] Failed to send email to %s: %v", to, err)
                return err
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("[Notification] Email sent successfully to: %s", to)
        return nil</span>
}

// GetVerifiedKeepers retrieves only verified keepers from the database
func (dm *DatabaseManager) GetVerifiedKeepers() ([]types.KeeperInfo, error) <span class="cov0" title="0">{
        var keepers []types.KeeperInfo

        iter := dm.db.Session().Query(`
                SELECT keeper_name, keeper_address, consensus_address, operator_id, version, peer_id, last_checked_in, on_imua
                FROM triggerx.keeper_data 
                WHERE registered = true AND whitelisted = true 
                ALLOW FILTERING`).Iter()

        var keeperName, keeperAddress, consensusAddress, operatorID, version, peerID string
        var lastCheckedIn time.Time
        var isImua bool

        for iter.Scan(&amp;keeperName, &amp;keeperAddress, &amp;consensusAddress, &amp;operatorID, &amp;version, &amp;peerID, &amp;lastCheckedIn, &amp;isImua) </span><span class="cov0" title="0">{
                keepers = append(keepers, types.KeeperInfo{
                        KeeperName:       keeperName,
                        KeeperAddress:    keeperAddress,
                        ConsensusAddress: consensusAddress,
                        OperatorID:       operatorID,
                        Version:          version,
                        PeerID:           peerID,
                        LastCheckedIn:    lastCheckedIn,
                        IsImua:           isImua,
                })
        }</span>

        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error closing iterator: %w", err)
        }</span>

        <span class="cov0" title="0">dm.logger.Debug("Retrieved verified keepers from database",
                "count", len(keepers),
        )
        return keepers, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package config

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Port at which health service will be running
        healthRPCPort string

        // Bot token for Telegram notifications
        botToken string
        // Email user for notifications
        emailUser     string
        emailPassword string

        // ScyllaDB Host and Port
        databaseHostAddress string
        databaseHostPort    string

        // IPFS configuration
        pinataHost string
        pinataJWT  string

        // Manager Signing Address
        managerSigningAddress string

        // Etherscan API Key
        etherscanAPIKey string

        // Alchemy API Key
        alchemyAPIKey string

        // Task Execution Address
        eigenlayerTaskExecutionAddress string
        imuaTaskExecutionAddress       string
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:             env.GetEnvBool("DEV_MODE", false),
                healthRPCPort:       env.GetEnvString("HEALTH_RPC_PORT", "9003"),
                botToken:            env.GetEnvString("BOT_TOKEN", ""),
                emailUser:           env.GetEnvString("EMAIL_USER", ""),
                emailPassword:       env.GetEnvString("EMAIL_PASS", ""),
                databaseHostAddress: env.GetEnvString("DATABASE_HOST_ADDRESS", "localhost"),
                databaseHostPort:    env.GetEnvString("DATABASE_HOST_PORT", "9042"),
                pinataHost:          env.GetEnvString("PINATA_HOST", ""),
                pinataJWT:           env.GetEnvString("PINATA_JWT", ""),
                managerSigningAddress: env.GetEnvString("MANAGER_SIGNING_ADDRESS", ""),
                etherscanAPIKey:     env.GetEnvString("ETHERSCAN_API_KEY", ""),
                alchemyAPIKey:       env.GetEnvString("ALCHEMY_API_KEY", ""),
                eigenlayerTaskExecutionAddress: env.GetEnvString("EIGENLAYER_TASK_EXECUTION_ADDRESS", ""),
                imuaTaskExecutionAddress:       env.GetEnvString("IMUA_TASK_EXECUTION_ADDRESS", ""),
        }
        if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig() error <span class="cov0" title="0">{
        if !env.IsValidPort(cfg.healthRPCPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Health RPC Port: %s", cfg.healthRPCPort)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.pinataHost) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Pinata Host: %s", cfg.pinataHost)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.pinataJWT) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Pinata JWT: %s", cfg.pinataJWT)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.etherscanAPIKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Etherscan API Key: %s", cfg.etherscanAPIKey)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.alchemyAPIKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Alchemy API Key: %s", cfg.alchemyAPIKey)
        }</span>
        <span class="cov0" title="0">if !env.IsValidIPAddress(cfg.databaseHostAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host address: %s", cfg.databaseHostAddress)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPort(cfg.databaseHostPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host port: %s", cfg.databaseHostPort)
        }</span>
        <span class="cov0" title="0">if !env.IsValidEthAddress(cfg.eigenlayerTaskExecutionAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Eigenlayer task execution address: %s", cfg.eigenlayerTaskExecutionAddress)
        }</span>
        <span class="cov0" title="0">if !env.IsValidEthAddress(cfg.imuaTaskExecutionAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Imua task execution address: %s", cfg.imuaTaskExecutionAddress)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                if !env.IsValidEmail(cfg.emailUser) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email user: %s", cfg.emailUser)
                }</span>
                <span class="cov0" title="0">if env.IsEmpty(cfg.emailPassword) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid email password: %s", cfg.emailPassword)
                }</span>
                <span class="cov0" title="0">if env.IsEmpty(cfg.botToken) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid bot token: %s", cfg.botToken)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func GetHealthRPCPort() string <span class="cov0" title="0">{
        return cfg.healthRPCPort
}</span>

func GetDatabaseHostAddress() string <span class="cov0" title="0">{
        return cfg.databaseHostAddress
}</span>

func GetDatabaseHostPort() string <span class="cov0" title="0">{
        return cfg.databaseHostPort
}</span>

func GetBotToken() string <span class="cov0" title="0">{
        return cfg.botToken
}</span>

func GetEmailUser() string <span class="cov0" title="0">{
        return cfg.emailUser
}</span>

func GetEmailPassword() string <span class="cov0" title="0">{
        return cfg.emailPassword
}</span>

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetPinataHost() string <span class="cov0" title="0">{
        return cfg.pinataHost
}</span>

func GetPinataJWT() string <span class="cov0" title="0">{
        return cfg.pinataJWT
}</span>

func GetEtherscanAPIKey() string <span class="cov0" title="0">{
        return cfg.etherscanAPIKey
}</span>

func GetAlchemyAPIKey() string <span class="cov0" title="0">{
        return cfg.alchemyAPIKey
}</span>

func GetEigenlayerTaskExecutionAddress() string <span class="cov0" title="0">{
        return cfg.eigenlayerTaskExecutionAddress
}</span>

func GetImuaTaskExecutionAddress() string <span class="cov0" title="0">{
        return cfg.imuaTaskExecutionAddress
}</span>

func GetManagerSigningAddress() string <span class="cov0" title="0">{
        return cfg.managerSigningAddress
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package keeper

import (
        "time"

        commonTypes "github.com/trigg3rX/triggerx-backend/pkg/types"
)

const (
        inactivityThreshold  = 70 * time.Second
        stateCleanupInterval = 5 * time.Second
)

func (sm *StateManager) startCleanupRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(stateCleanupInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                sm.checkInactiveKeepers()
        }</span>
}

func (sm *StateManager) checkInactiveKeepers() <span class="cov0" title="0">{
        now := time.Now().UTC()
        var inactiveKeepers []string

        sm.mu.Lock()
        for address, state := range sm.keepers </span><span class="cov0" title="0">{
                if state.IsActive &amp;&amp; now.Sub(state.LastCheckedIn) &gt; inactivityThreshold </span><span class="cov0" title="0">{
                        sm.logger.Info("Keeper became inactive",
                                "keeper", address,
                                "lastSeen", state.LastCheckedIn.Format(time.RFC3339),
                        )
                        state.IsActive = false
                        inactiveKeepers = append(inactiveKeepers, address)
                }</span>
        }
        <span class="cov0" title="0">sm.mu.Unlock()

        for _, address := range inactiveKeepers </span><span class="cov0" title="0">{
                keeperHealth := commonTypes.KeeperHealthCheckIn{
                        KeeperAddress: address,
                }

                if err := sm.updateKeeperStatusInDatabase(keeperHealth, false); err != nil </span><span class="cov0" title="0">{
                        sm.logger.Error("Failed to update inactive status",
                                "error", err,
                                "keeper", address,
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package keeper

import (
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/health/types"
        commonTypes "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// LoadVerifiedKeepers loads only verified keepers from the database
func (sm *StateManager) LoadVerifiedKeepers() error <span class="cov0" title="0">{
        sm.logger.Info("Loading verified keepers from database...")

        // Get only verified keepers from database
        keepers, err := sm.db.GetVerifiedKeepers()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load verified keepers from database: %w", err)
        }</span>

        <span class="cov0" title="0">sm.mu.Lock()
        defer sm.mu.Unlock()

        // Clear existing state
        sm.keepers = make(map[string]*types.KeeperInfo)

        // Load each keeper's state (initially marked as inactive)
        for _, keeper := range keepers </span><span class="cov0" title="0">{
                state := &amp;types.KeeperInfo{
                        KeeperName:       keeper.KeeperName,
                        KeeperAddress:    keeper.KeeperAddress,
                        ConsensusAddress: keeper.ConsensusAddress,
                        OperatorID:       keeper.OperatorID,
                        Version:          keeper.Version,
                        PeerID:           keeper.PeerID,
                        IsActive:         false,
                        LastCheckedIn:    keeper.LastCheckedIn,
                        IsImua:           keeper.IsImua,
                }
                sm.keepers[keeper.KeeperAddress] = state
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Successfully loaded verified keepers",
                "count", len(sm.keepers),
        )
        return nil</span>
}

// DumpState updates all keepers to inactive in the database
func (sm *StateManager) DumpState() error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        sm.logger.Info("Dumping keeper state to database...")

        for address, state := range sm.keepers </span><span class="cov0" title="0">{
                if state.IsActive </span><span class="cov0" title="0">{
                        // Create a minimal health check-in with just the address
                        health := commonTypes.KeeperHealthCheckIn{
                                KeeperAddress: address,
                        }

                        if err := sm.retryWithBackoff(func() error </span><span class="cov0" title="0">{
                                return sm.updateKeeperStatusInDatabase(health, false)
                        }</span>, maxRetries); err != nil <span class="cov0" title="0">{
                                sm.logger.Error("Failed to update keeper status during state dump",
                                        "error", err,
                                        "keeper", address,
                                )
                                continue</span>
                        }
                }
        }

        <span class="cov0" title="0">sm.logger.Info("Successfully dumped keeper state")
        return nil</span>
}

// RetryWithBackoff retries a database operation with exponential backoff
func (sm *StateManager) retryWithBackoff(operation func() error, maxRetries int) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                err = operation()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Calculate backoff duration (exponential backoff with jitter)
                <span class="cov0" title="0">backoff := time.Duration(i) * time.Second
                sm.logger.Warn("Database operation failed, retrying...",
                        "error", err,
                        "attempt", i+1,
                        "maxRetries", maxRetries,
                        "backoff", backoff,
                )

                time.Sleep(backoff)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("operation failed after %d retries: %w", maxRetries, err)</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package keeper

import (
        "sync"

        "github.com/trigg3rX/triggerx-backend/internal/health/client"
        "github.com/trigg3rX/triggerx-backend/internal/health/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// StateManager manages the state of all keepers
type StateManager struct {
        keepers     map[string]*types.KeeperInfo
        mu          sync.RWMutex
        logger      logging.Logger
        initialized bool
        db          *client.DatabaseManager
}

var (
        stateManager     *StateManager
        stateManagerOnce sync.Once
)

// InitializeStateManager creates and initializes the state manager
func InitializeStateManager(logger logging.Logger) *StateManager <span class="cov0" title="0">{
        stateManagerOnce.Do(func() </span><span class="cov0" title="0">{
                // Create a new logger with component field and proper level
                stateLogger := logger.With("component", "state_manager")

                stateManager = &amp;StateManager{
                        keepers:     make(map[string]*types.KeeperInfo),
                        logger:      stateLogger,
                        initialized: true,
                        db:          client.GetInstance(),
                }
                go stateManager.startCleanupRoutine()
        }</span>)
        <span class="cov0" title="0">return stateManager</span>
}

// GetStateManager returns the singleton instance of StateManager
func GetStateManager() *StateManager <span class="cov0" title="0">{
        if stateManager == nil </span><span class="cov0" title="0">{
                panic("state manager not initialized")</span>
        }
        <span class="cov0" title="0">return stateManager</span>
}

// IsKeeperActive checks if a keeper is currently active
func (sm *StateManager) IsKeeperActive(keeperAddress string) bool <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        state, exists := sm.keepers[keeperAddress]
        isActive := exists &amp;&amp; state.IsActive

        sm.logger.Debug("Checked keeper active status",
                "keeper", keeperAddress,
                "exists", exists,
                "is_active", isActive,
        )

        return isActive
}</span>

// GetAllActiveKeepers returns a list of all active keeper addresses
func (sm *StateManager) GetAllActiveKeepers() []string <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        var activeKeepers []string
        for address, state := range sm.keepers </span><span class="cov0" title="0">{
                if state.IsActive </span><span class="cov0" title="0">{
                        activeKeepers = append(activeKeepers, address)
                }</span>
        }

        <span class="cov0" title="0">sm.logger.Debug("Retrieved active keepers list",
                "total_active", len(activeKeepers),
        )

        return activeKeepers</span>
}

// GetKeeperCount returns the total number of keepers and active keepers
func (sm *StateManager) GetKeeperCount() (total int, active int) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        total = len(sm.keepers)
        for _, state := range sm.keepers </span><span class="cov0" title="0">{
                if state.IsActive </span><span class="cov0" title="0">{
                        active++
                }</span>
        }

        <span class="cov0" title="0">sm.logger.Debug("Retrieved keeper counts",
                "total", total,
                "active", active,
        )

        return total, active</span>
}

// GetDetailedKeeperInfo returns detailed information about all keepers
func (sm *StateManager) GetDetailedKeeperInfo() []types.KeeperInfo <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        var keeperInfoList []types.KeeperInfo

        for address, state := range sm.keepers </span><span class="cov0" title="0">{
                info := types.KeeperInfo{
                        KeeperName:       state.KeeperName,
                        KeeperAddress:    address,
                        ConsensusAddress: state.ConsensusAddress,
                        OperatorID:       state.OperatorID,
                        Version:          state.Version,
                        PeerID:           state.PeerID,
                        LastCheckedIn:    state.LastCheckedIn,
                        IsActive:         state.IsActive,
                        IsImua:           state.IsImua,
                }
                keeperInfoList = append(keeperInfoList, info)
        }</span>

        <span class="cov0" title="0">sm.logger.Debug("Retrieved detailed keeper information",
                "total_keepers", len(keeperInfoList),
        )

        return keeperInfoList</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package keeper

import (
        "errors"
        "fmt"
        "time"

        commonTypes "github.com/trigg3rX/triggerx-backend/pkg/types"
)

const (
        maxRetries = 3
)

// Custom error types
var (
        ErrKeeperNotVerified = errors.New("keeper not verified")
)

// UpdateKeeperHealth updates the health status of a keeper
func (sm *StateManager) UpdateKeeperHealth(keeperHealth commonTypes.KeeperHealthCheckIn) error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        address := keeperHealth.KeeperAddress
        now := time.Now().UTC()

        existingState, exists := sm.keepers[address]
        if !exists </span><span class="cov0" title="0">{
                sm.logger.Warn("Received health check-in from unverified keeper",
                        "keeper", address,
                )
                return ErrKeeperNotVerified
        }</span>

        // Update the state with new health check-in data
        <span class="cov0" title="0">existingState.Version = keeperHealth.Version
        existingState.PeerID = keeperHealth.PeerID
        existingState.LastCheckedIn = now
        existingState.IsActive = true
        existingState.IsImua = keeperHealth.IsImua

        // Update database
        if err := sm.retryWithBackoff(func() error </span><span class="cov0" title="0">{
                return sm.updateKeeperStatusInDatabase(keeperHealth, true )
        }</span>, maxRetries); err != nil <span class="cov0" title="0">{
                return fmt.Errorf("failed to update keeper status in database: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Updated keeper health status",
                "keeper", address,
                "version", keeperHealth.Version,
                "is_imua", keeperHealth.IsImua,
        )
        return nil</span>
}

func (sm *StateManager) updateKeeperStatusInDatabase(keeperHealth commonTypes.KeeperHealthCheckIn, isActive bool) error <span class="cov0" title="0">{
        if err := sm.db.UpdateKeeperHealth(keeperHealth, isActive); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update keeper status in database: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debug("Updated keeper status in database",
                "keeper", keeperHealth.KeeperAddress,
                "active", isActive,
                "version", keeperHealth.Version,
        )
        return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package metrics

import (
        "runtime"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/shirou/gopsutil/v3/cpu"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the health service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "uptime_seconds",
                Help:      "Time passed since Health Service started in seconds",
        })

        // HTTP request metrics
        HTTPRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "http_requests_total",
                Help:      "Total HTTP requests received",
        }, []string{"method", "endpoint", "status_code"})

        // HTTP Request duration metrics
        HTTPRequestDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "http_request_duration_seconds",
                Help:      "HTTP request processing time",
                Buckets:   prometheus.DefBuckets,
        }, []string{"method", "endpoint"})

        // Request throughput rate
        RequestsPerSecond = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "requests_per_second",
                Help:      "Request throughput rate",
        }, []string{"endpoint"})

        // Keeper check-in metrics
        CheckinsByVersionTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "checkins_by_version_total",
                Help:      "Check-ins by keeper version",
        }, []string{"version"})

        // Keeper status metrics
        KeepersTotal = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "keepers_total",
                Help:      "Total number of registered keepers",
        })

        // Keepers active total metrics
        KeepersActiveTotal = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "keepers_active_total",
                Help:      "Currently active keepers",
        })

        // Keepers inactive total metrics
        KeepersInactiveTotal = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "keepers_inactive_total",
                Help:      "Currently inactive keepers",
        })

        // Keeper uptime tracking
        KeeperUptimeSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "keeper_uptime_seconds",
                Help:      "Keeper uptime since first check-in",
        }, []string{"keeper_address"})

        // Keeper uptime tracking
        MostActiveKeeperSeconds = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "most_active_keeper_uptime_seconds",
                Help:      "Most active keeper uptime since first check-in",
        }, []string{"keeper_address"})

        // Database operation metrics
        DBHostOperationDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "db_host_operation_duration_seconds",
                Help:      "Scylla Database operation execution time",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5},
        }, []string{"operation"})

        // Telegram notification metrics
        TelegramKeeperNotificationsSentTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "telegram_keeper_notifications_sent_total",
                Help:      "Notifications sent per keeper",
        }, []string{"keeper_address"})

        // Memory usage metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        // CPU usage metrics
        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        // Goroutines active metrics
        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        // Garbage collection duration metrics
        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Network connection metrics
        NetworkConnectionsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "health_service",
                Name:      "network_connections_total",
                Help:      "Network connections (type=incoming/outgoing)",
        }, []string{"type"})
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()

        // Update system metrics every 30 seconds
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        // Memory metrics
                        var m runtime.MemStats
                        runtime.ReadMemStats(&amp;m)
                        MemoryUsageBytes.Set(float64(m.Alloc))
                        GoroutinesActive.Set(float64(runtime.NumGoroutine()))
                        GCDurationSeconds.Set(float64(m.PauseTotalNs) / 1e9) // Convert nanoseconds to seconds

                        // CPU usage metrics
                        cpuPercentages, err := cpu.Percent(0, false)
                        if err == nil &amp;&amp; len(cpuPercentages) &gt; 0 </span><span class="cov0" title="0">{
                                CPUUsagePercent.Set(cpuPercentages[0])
                        }</span> else<span class="cov0" title="0"> {
                                // Fallback to 0.0 if CPU monitoring fails
                                CPUUsagePercent.Set(0.0)
                        }</span>
                }
        }()
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package telegram

import (
        "strconv"
        "sync"

        tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Bot struct {
        api    *tgbotapi.BotAPI
        logger logging.Logger
        db     *database.Connection
}

func NewBot(token string, logger logging.Logger, db *database.Connection) (*Bot, error) <span class="cov0" title="0">{
        bot, err := tgbotapi.NewBotAPI(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Bot{
                api:    bot,
                logger: logger,
                db:     db,
        }, nil</span>
}

func (b *Bot) Start() <span class="cov0" title="0">{
        u := tgbotapi.NewUpdate(0)
        u.Timeout = 60

        updates := b.api.GetUpdatesChan(u)

        var wg sync.WaitGroup
        wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                for update := range updates </span><span class="cov0" title="0">{
                        if update.Message == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if update.Message.IsCommand() &amp;&amp; update.Message.Command() == "start" </span><span class="cov0" title="0">{
                                msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Enter Your Operator address (Keeper address)")
                                _, err := b.api.Send(msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        b.logger.Errorf("Failed to send message: %v", err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">chatID := update.Message.Chat.ID
                        keeperAddress := update.Message.Text

                        err := b.updateKeeperChatID(keeperAddress, chatID)
                        if err != nil </span><span class="cov0" title="0">{
                                b.logger.Errorf("Failed to update keeper chat ID: %v", err)
                                msg := tgbotapi.NewMessage(chatID, "Failed to register your keeper name. Please try again.")
                                _, err = b.api.Send(msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        b.logger.Errorf("Failed to send message: %v", err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">msg := tgbotapi.NewMessage(chatID, "Thanks! You will get the latest notifications")
                        _, err = b.api.Send(msg)
                        if err != nil </span><span class="cov0" title="0">{
                                b.logger.Errorf("Failed to send message: %v", err)
                        }</span>

                        <span class="cov0" title="0">testMsg := tgbotapi.NewMessage(chatID, "This is a test message to confirm your chat ID works!")
                        _, err = b.api.Send(testMsg)
                        if err != nil </span><span class="cov0" title="0">{
                                b.logger.Errorf("Failed to send message: %v", err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">wg.Wait()</span>
}

func (b *Bot) updateKeeperChatID(keeperAddress string, chatID int64) error <span class="cov0" title="0">{
        b.logger.Infof("[UpdateKeeperChatID] Finding keeper ID for keeper: %s", keeperAddress)

        var keeperID string
        if err := b.db.Session().Query(`
                SELECT keeper_id FROM triggerx.keeper_data 
                WHERE keeper_address = ? ALLOW FILTERING`, keeperAddress).Consistency(gocql.One).Scan(&amp;keeperID); err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("[UpdateKeeperChatID] Error finding keeper ID for keeper %s: %v", keeperAddress, err)
                return err
        }</span>

        <span class="cov0" title="0">b.logger.Infof("[UpdateKeeperChatID] Updating chat ID for keeper ID: %s", keeperID)

        chatIDStr := strconv.FormatInt(chatID, 10)

        if err := b.db.Session().Query(`
                UPDATE triggerx.keeper_data 
                SET chat_id = ? 
                WHERE keeper_id = ?`,
                chatIDStr, keeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("[UpdateKeeperChatID] Error updating chat ID for keeper ID %s: %v", keeperID, err)
                return err
        }</span>

        <span class="cov0" title="0">b.logger.Infof("[UpdateKeeperChatID] Successfully updated chat ID for keeper: %s", keeperAddress)
        return nil</span>
}

func (b *Bot) SendMessage(chatID int64, message string) error <span class="cov0" title="0">{
        msg := tgbotapi.NewMessage(chatID, message)
        _, err := b.api.Send(msg)
        return err
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package handlers

import (
        "context"
        "encoding/hex"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"

        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// ExecuteTask handles task execution requests
func (h *TaskHandler) ExecuteTask(c *gin.Context) <span class="cov0" title="0">{
        traceID := h.getTraceID(c)
        h.logger.Info("Executing task ...", "trace_id", traceID)

        if c.Request.Method != http.MethodPost </span><span class="cov0" title="0">{
                c.JSON(http.StatusMethodNotAllowed, gin.H{
                        "error": "Invalid method",
                })
                return
        }</span>

        <span class="cov0" title="0">var requestBody struct {
                Data string `json:"data"`
        }
        if err := c.BindJSON(&amp;requestBody); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON body"})
                return
        }</span>

        // Decode hex data
        <span class="cov0" title="0">hexData := requestBody.Data
        if len(hexData) &gt; 2 &amp;&amp; hexData[:2] == "0x" </span><span class="cov0" title="0">{
                hexData = hexData[2:]
        }</span>

        <span class="cov0" title="0">decodedData, err := hex.DecodeString(hexData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid hex data"})
                return
        }</span>

        <span class="cov0" title="0">decodedDataString := string(decodedData)

        var requestData types.SendTaskDataToKeeper
        if err := json.Unmarshal([]byte(decodedDataString), &amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Failed to parse JSON data",
                })
                return
        }</span>

        <span class="cov0" title="0">if !strings.EqualFold(config.GetKeeperAddress(), requestData.PerformerData.KeeperAddress) </span><span class="cov0" title="0">{
                h.logger.Infof("I am not the performer: %s", requestData.PerformerData.KeeperAddress)
                c.JSON(http.StatusOK, gin.H{"message": "I am not the performer"})
                return
        }</span> else<span class="cov0" title="0"> {
                h.logger.Infof("I am the performer: %s", requestData.PerformerData.KeeperAddress)

                TaskDefinitionID := requestData.TriggerData[0].TaskDefinitionID
                switch TaskDefinitionID </span>{
                case 1, 2:<span class="cov0" title="0">
                        h.logger.Info("Execution starts for following tasks:", "trace_id", traceID)
                        for _, task := range requestData.TargetData </span><span class="cov0" title="0">{
                                h.logger.Infof("Task ID: %d | Target Chain ID: %s", task.TaskID, task.TargetChainID)
                        }</span>
                case 3, 4, 5, 6:<span class="cov0" title="0">
                        h.logger.Info("Execution starts for task:", "task_id", requestData.TargetData[0].TaskID, "target_chain_id", requestData.TargetData[0].TargetChainID, "trace_id", traceID)</span>
                }
                <span class="cov0" title="0">success, err := h.executor.ExecuteTask(context.Background(), &amp;requestData, traceID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Task execution failed", "error", err, "trace_id", traceID)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Task execution failed"})
                        return
                }</span>

                <span class="cov0" title="0">h.logger.Info("Task execution completed", "success", success, "trace_id", traceID)
                c.JSON(http.StatusOK, gin.H{"success": strconv.FormatBool(success)})</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const TraceIDKey = "trace_id"

// TaskHandler handles task-related requests
type TaskHandler struct {
        logger    logging.Logger
        executor  *execution.TaskExecutor
        validator *validation.TaskValidator
}

// NewTaskHandler creates a new task handler
func NewTaskHandler(logger logging.Logger, executor *execution.TaskExecutor, validator *validation.TaskValidator) *TaskHandler <span class="cov0" title="0">{
        return &amp;TaskHandler{
                logger:    logger,
                executor:  executor,
                validator: validator,
        }
}</span>

func (h *TaskHandler) getTraceID(c *gin.Context) string <span class="cov0" title="0">{
        traceID, exists := c.Get(TraceIDKey)
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return traceID.(string)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// MetricsHandler handles metrics endpoint requests
type MetricsHandler struct {
        logger    logging.Logger
        collector *metrics.Collector
}

// NewMetricsHandler creates a new metrics handler
func NewMetricsHandler(logger logging.Logger) *MetricsHandler <span class="cov0" title="0">{
        collector := metrics.NewCollector()
        collector.Start()

        return &amp;MetricsHandler{
                logger:    logger,
                collector: collector,
        }
}</span>

// Metrics handles metrics endpoint requests
func (h *MetricsHandler) Metrics(c *gin.Context) <span class="cov0" title="0">{
        h.collector.Handler().ServeHTTP(c.Writer, c.Request)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type TaskValidationRequest struct {
        Data string `json:"data"`
}

type ValidationResponse struct {
        Data    bool   `json:"data"`
        Error   bool   `json:"error"`
        Message string `json:"message,omitempty"`
}

// ValidateTask handles task validation requests
func (h *TaskHandler) ValidateTask(c *gin.Context) <span class="cov0" title="0">{
        traceID := h.getTraceID(c)
        h.logger.Info("Validating task ...", "trace_id", traceID)

        var taskRequest TaskValidationRequest
        if err := c.ShouldBindJSON(&amp;taskRequest); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: fmt.Sprintf("Failed to parse request body: %v", err),
                })
                return
        }</span>

        // Unmarshal the JSON data into IPFSData struct
        <span class="cov0" title="0">var ipfsData types.IPFSData
        if err := json.Unmarshal([]byte(taskRequest.Data), &amp;ipfsData); err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("Failed to unmarshal IPFS data: %v", err)
                c.JSON(http.StatusBadRequest, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: fmt.Sprintf("Failed to unmarshal IPFS data: %v", err),
                })
                return
        }</span>

        // Validate that we have the required task data
        <span class="cov0" title="0">if ipfsData.TaskData == nil </span><span class="cov0" title="0">{
                h.logger.Error("IPFS data missing task_data")
                c.JSON(http.StatusBadRequest, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: "IPFS data missing task_data",
                })
                return
        }</span>

        // Validate job based on task definition ID
        <span class="cov0" title="0">isValid := false
        var validationErr error

        // h.logger.Info("Validating task ...", "trace_id", traceID)
        isValid, validationErr = h.validator.ValidateTask(context.Background(), ipfsData, traceID)

        if validationErr != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation error", "error", validationErr, "trace_id", traceID)
                c.JSON(http.StatusOK, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: validationErr.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Task validation completed", "trace_id", traceID)
        c.JSON(http.StatusOK, ValidationResponse{
                Data:    isValid,
                Error:   false,
                Message: "",
        })</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package api

import (
        "runtime"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const TraceIDHeader = "X-Trace-ID"
const TraceIDKey = "trace_id"

func TraceMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                traceID := c.GetHeader(TraceIDHeader)
                if traceID == "" </span><span class="cov0" title="0">{
                        traceID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Set(TraceIDKey, traceID)
                c.Header(TraceIDHeader, traceID)
                c.Next()</span>
        }
}

// MetricsMiddleware collects HTTP request metrics
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Process request
                c.Next()

                // Update system metrics
                var memStats runtime.MemStats
                runtime.ReadMemStats(&amp;memStats)
                metrics.MemoryUsageBytes.Set(float64(memStats.Alloc))
                metrics.CPUUsagePercent.Set(float64(memStats.Sys))
                metrics.GoroutinesActive.Set(float64(runtime.NumGoroutine()))
                metrics.GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)
        }</span>
}

// LoggerMiddleware creates a gin middleware for logging requests
func LoggerMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip logging for metrics endpoint
                if c.Request.URL.Path == "/metrics" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery
                traceID, _ := c.Get(TraceIDKey)

                // Process request
                c.Next()

                duration := time.Since(start)
                statusCode := c.Writer.Status()

                logger.Info("Request processed",
                        "trace_id", traceID,
                        "status", statusCode,
                        "method", c.Request.Method,
                        "path", path,
                        "query", raw,
                        "ip", c.ClientIP(),
                        "latency", duration,
                        "user-agent", c.Request.UserAgent(),
                )</span>
        }
}

// ErrorMiddleware handles errors in a consistent way
func ErrorMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check if there are any errors
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Get the last error
                        err := c.Errors.Last()
                        traceID, _ := c.Get(TraceIDKey)

                        logger.Error("Error",
                                "trace_id", traceID,
                                "error", err.Error(),
                                "path", c.Request.URL.Path,
                        )

                        // If the response hasn't been written yet
                        if !c.Writer.Written() </span><span class="cov0" title="0">{
                                c.JSON(c.Writer.Status(), gin.H{
                                        "error":    err.Error(),
                                        "trace_id": traceID,
                                })
                        }</span>
                }
        }
}

// TaskMetricsMiddleware tracks task-related metrics
func TaskMetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path

                // Track incoming tasks
                if path == "/p2p/message" &amp;&amp; c.Request.Method == "POST" </span><span class="cov0" title="0">{
                        metrics.TasksReceivedTotal.Inc()
                }</span>

                <span class="cov0" title="0">c.Next()

                duration := time.Since(start)
                statusCode := c.Writer.Status()

                // Track completed tasks based on endpoint and status
                if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov0" title="0">{
                        switch path </span>{
                        case "/p2p/message":<span class="cov0" title="0">
                                // Task execution endpoint
                                metrics.TasksPerDay.WithLabelValues("executed").Inc()
                                metrics.TasksCompletedTotal.WithLabelValues("executed").Inc()
                                metrics.TaskDurationSeconds.WithLabelValues("executed").Observe(duration.Seconds())</span>
                                // metrics.AverageTaskCompletionTimeSeconds.WithLabelValues("executed").Set(duration.Seconds())
                        case "/task/validate":<span class="cov0" title="0">
                                // Task validation endpoint
                                metrics.TasksPerDay.WithLabelValues("validated").Inc()
                                metrics.TasksCompletedTotal.WithLabelValues("validated").Inc()
                                metrics.TaskDurationSeconds.WithLabelValues("validated").Observe(duration.Seconds())</span>
                                // metrics.AverageTaskCompletionTimeSeconds.WithLabelValues("validated").Set(duration.Seconds())
                        }
                }
        }
}

// RestartTrackingMiddleware tracks service restarts
func RestartTrackingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        // This should be called once during service startup
        metrics.RestartsTotal.Inc()

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Server represents the API server
type Server struct {
        router     *gin.Engine
        httpServer *http.Server
        logger     logging.Logger
}

// Config holds the server configuration
type Config struct {
        Port           string
        ReadTimeout    time.Duration
        WriteTimeout   time.Duration
        MaxHeaderBytes int
}

// Dependencies holds the server dependencies
type Dependencies struct {
        Logger    logging.Logger
        Executor  *execution.TaskExecutor
        Validator *validation.TaskValidator
}

// NewServer creates a new API server
func NewServer(cfg Config, deps *Dependencies) *Server <span class="cov0" title="0">{
        if cfg.ReadTimeout == 0 </span><span class="cov0" title="0">{
                cfg.ReadTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if cfg.WriteTimeout == 0 </span><span class="cov0" title="0">{
                cfg.WriteTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if cfg.MaxHeaderBytes == 0 </span><span class="cov0" title="0">{
                cfg.MaxHeaderBytes = 1 &lt;&lt; 20 // 1MB
        }</span>

        <span class="cov0" title="0">gin.SetMode(gin.ReleaseMode)
        router := gin.New()

        // Create server instance
        srv := &amp;Server{
                router: router,
                logger: deps.Logger,
                httpServer: &amp;http.Server{
                        Addr:           fmt.Sprintf(":%s", cfg.Port),
                        Handler:        router,
                        ReadTimeout:    cfg.ReadTimeout,
                        WriteTimeout:   cfg.WriteTimeout,
                        MaxHeaderBytes: cfg.MaxHeaderBytes,
                },
        }

        // Setup middleware
        srv.setupMiddleware()

        // Setup routes
        srv.setupRoutes(deps)

        return srv</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting API server", "addr", s.httpServer.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Stopping API server")
        return s.httpServer.Shutdown(ctx)
}</span>

// setupMiddleware sets up the middleware for the server
func (s *Server) setupMiddleware() <span class="cov0" title="0">{
        s.router.Use(gin.Recovery())
        s.router.Use(TraceMiddleware())
        s.router.Use(MetricsMiddleware())
        s.router.Use(TaskMetricsMiddleware())
        s.router.Use(RestartTrackingMiddleware())
        s.router.Use(LoggerMiddleware(s.logger))
        s.router.Use(ErrorMiddleware(s.logger))
}</span>

// setupRoutes sets up the routes for the server
func (s *Server) setupRoutes(deps *Dependencies) <span class="cov0" title="0">{
        // Create handlers
        taskHandler := handlers.NewTaskHandler(deps.Logger, deps.Executor, deps.Validator)
        metricsHandler := handlers.NewMetricsHandler(deps.Logger)

        // Task routes
        s.router.POST("/p2p/message", taskHandler.ExecuteTask)
        s.router.POST("/task/validate", taskHandler.ValidateTask)

        // Health and metrics routes
        s.router.GET("/metrics", metricsHandler.Metrics)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package chainio

import (
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        gethcommon "github.com/ethereum/go-ethereum/common"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type AvsReader interface {
        GetTaskInfo(
                opts *bind.CallOpts,
                avsAddress string,
                taskID uint64,
        ) (avs.TaskInfo, error)
        IsOperator(
                opts *bind.CallOpts,
                operator string,
        ) (bool, error)

        GetAVSEpochIdentifier(
                opts *bind.CallOpts,
                avsAddress string,
        ) (string, error)
        GetCurrentEpoch(
                opts *bind.CallOpts,
                epochIdentifier string,
        ) (int64, error)
        GetChallengeInfo(
                opts *bind.CallOpts,
                taskAddress string,
                taskID uint64,
        ) (gethcommon.Address, error)

}

type ChainReader struct {
        logger     logging.Logger
        avsManager avs.TriggerXAvs
        ethClient  *ethclient.Client
}

// forces EthReader to implement the chainio.Reader interface
var _ AvsReader = (*ChainReader)(nil)

func NewChainReader(
        avsManager avs.TriggerXAvs,
        logger logging.Logger,
        ethClient *ethclient.Client,
) *ChainReader <span class="cov0" title="0">{
        return &amp;ChainReader{
                avsManager: avsManager,
                logger:     logger,
                ethClient:  ethClient,
        }
}</span>

func BuildChainReader(
        avsAddr gethcommon.Address,
        ethClient *ethclient.Client,
        logger logging.Logger,
) (*ChainReader, error) <span class="cov0" title="0">{
        contractBindings, err := NewContractBindings(
                avsAddr,
                ethClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewChainReader(
                *contractBindings.AVSManager,
                logger,
                ethClient,
        ), nil</span>
}

func (r *ChainReader) GetTaskInfo(opts *bind.CallOpts, avsAddress string, taskID uint64) (avs.TaskInfo, error) <span class="cov0" title="0">{
        info, err := r.avsManager.GetTaskInfo(
                opts,
                gethcommon.HexToAddress(avsAddress), taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetTaskInfo ", "err", err)
                return avs.TaskInfo{}, err
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

func (r *ChainReader) IsOperator(opts *bind.CallOpts, operator string) (bool, error) <span class="cov0" title="0">{
        flag, err := r.avsManager.IsOperator(
                opts,
                gethcommon.HexToAddress(operator))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return flag, nil</span>
}

func (r *ChainReader) GetAVSEpochIdentifier(opts *bind.CallOpts, avsAddress string) (string, error) <span class="cov0" title="0">{
        epochIdentifier, err := r.avsManager.GetAVSEpochIdentifier(
                opts,
                gethcommon.HexToAddress(avsAddress))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to GetAVSEpochIdentifier ", "err", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return epochIdentifier, nil</span>
}

func (r *ChainReader) GetCurrentEpoch(opts *bind.CallOpts, epochIdentifier string) (int64, error) <span class="cov0" title="0">{
        currentEpoch, err := r.avsManager.GetCurrentEpoch(
                opts,
                epochIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return currentEpoch, nil</span>
}

func (r *ChainReader) GetChallengeInfo(opts *bind.CallOpts, taskAddress string, taskID uint64) (gethcommon.Address, error) <span class="cov0" title="0">{
        address, err := r.avsManager.GetChallengeInfo(
                opts,
                gethcommon.HexToAddress(taskAddress),
                taskID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to exec IsOperator ", "err", err)
                return gethcommon.Address{}, err
        }</span>
        <span class="cov0" title="0">return address, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package chainio

import (
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/event"
        "github.com/ethereum/go-ethereum/ethclient"
        avssub "github.com/trigg3rX/imua-contracts/bindings/contracts"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type AvsRegistrySubscriber interface {
        SubscribeToNewTasks(newTaskCreatedChan chan *avssub.TriggerXAvsTaskCreated) event.Subscription
}

type AvsRegistryChainSubscriber struct {
        logger logging.Logger
        avssub avssub.TriggerXAvs
}

// forces EthSubscriber to implement the chainio.Subscriber interface
var _ AvsRegistrySubscriber = (*AvsRegistryChainSubscriber)(nil)

func NewAvsRegistryChainSubscriber(
        avssub avssub.TriggerXAvs,
        logger logging.Logger,
) (*AvsRegistryChainSubscriber, error) <span class="cov0" title="0">{
        return &amp;AvsRegistryChainSubscriber{
                logger: logger,
                avssub: avssub,
        }, nil
}</span>

func BuildAvsRegistryChainSubscriber(
        avssubAddr common.Address,
        ethWsClient *ethclient.Client,
        logger logging.Logger,
) (*AvsRegistryChainSubscriber, error) <span class="cov0" title="0">{
        avssub, err := avssub.NewTriggerXAvs(avssubAddr, ethWsClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create BLSApkRegistry contract", "err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewAvsRegistryChainSubscriber(*avssub, logger)</span>
}

func (s *AvsRegistryChainSubscriber) SubscribeToNewTasks(newTaskCreatedChan chan *avssub.TriggerXAvsTaskCreated) event.Subscription <span class="cov0" title="0">{
        sub, err := s.avssub.WatchTaskCreated(
                &amp;bind.WatchOpts{}, newTaskCreatedChan,
        )
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to subscribe to new  tasks", "err", err)
        }</span>
        <span class="cov0" title="0">s.logger.Infof("Subscribed to new TaskManager tasks")
        return sub</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package chainio

import (
        "context"
        "errors"

        gethcommon "github.com/ethereum/go-ethereum/common"
        gethtypes "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/imua-xyz/imua-avs-sdk/client/txmgr"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type AvsWriter interface {
        CreateNewTask(
                ctx context.Context,
                name string,
                taskDefinitionId uint8,
                taskData []byte,
                taskResponsePeriod uint64,
                taskChallengePeriod uint64,
                thresholdPercentage uint8,
                taskStatisticalPeriod uint64,
        ) (*gethtypes.Receipt, error)

        OperatorSubmitTask(
                ctx context.Context,
                taskID uint64,
                taskResponse []byte,
                blsSignature []byte,
                taskContractAddress string,
                phase uint8,
        ) (*gethtypes.Receipt, error)
}

type ChainWriter struct {
        avsManager  avs.TriggerXAvs
        chainReader AvsReader
        ethClient   *ethclient.Client
        logger      logging.Logger
        txMgr       txmgr.TxManager
}

var _ AvsWriter = (*ChainWriter)(nil)

func NewChainWriter(
        avsManager avs.TriggerXAvs,
        chainReader AvsReader,
        ethClient *ethclient.Client,
        logger logging.Logger,
        txMgr txmgr.TxManager,
) *ChainWriter <span class="cov0" title="0">{
        return &amp;ChainWriter{
                avsManager:  avsManager,
                chainReader: chainReader,
                logger:      logger,
                ethClient:   ethClient,
                txMgr:       txMgr,
        }
}</span>

func BuildChainWriter(
        avsAddr gethcommon.Address,
        ethClient *ethclient.Client,
        logger logging.Logger,
        txMgr txmgr.TxManager,
) (*ChainWriter, error) <span class="cov0" title="0">{
        contractBindings, err := NewContractBindings(
                avsAddr,
                ethClient,
                logger,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">chainReader := NewChainReader(
                *contractBindings.AVSManager,
                logger,
                ethClient,
        )
        return NewChainWriter(
                *contractBindings.AVSManager,
                chainReader,
                ethClient,
                logger,
                txMgr,
        ), nil</span>
}

func (w *ChainWriter) CreateNewTask(
        ctx context.Context,
        name string,
        taskDefinitionId uint8,
        taskData []byte,
        taskResponsePeriod uint64,
        taskChallengePeriod uint64,
        thresholdPercentage uint8,
        taskStatisticalPeriod uint64,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.CreateTask(
                noSendTxOpts,
                name,
                taskDefinitionId,
                taskData,
                taskResponsePeriod,
                taskChallengePeriod,
                thresholdPercentage,
                taskStatisticalPeriod,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}

func (w *ChainWriter) OperatorSubmitTask(
        ctx context.Context,
        taskID uint64,
        taskResponse []byte,
        blsSignature []byte,
        taskContractAddress string,
        phase uint8,
) (*gethtypes.Receipt, error) <span class="cov0" title="0">{
        noSendTxOpts, err := w.txMgr.GetNoSendTxOpts()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tx, err := w.avsManager.OperatorSubmitTask(
                noSendTxOpts,
                taskID,
                taskResponse,
                blsSignature,
                gethcommon.HexToAddress(taskContractAddress),
                phase)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">receipt, err := w.txMgr.Send(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to send tx with err: " + err.Error())
        }</span>
        <span class="cov0" title="0">w.logger.Infof("tx hash: %s", tx.Hash().String())

        return receipt, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package chainio

import (

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type ContractBindings struct {
        AvsAddr    common.Address
        AVSManager *avs.TriggerXAvs
}

func NewContractBindings(
        avsAddr common.Address,
        ethclient *ethclient.Client,
        logger logging.Logger,
) (*ContractBindings, error) <span class="cov0" title="0">{
        contractAvsManager, err := avs.NewTriggerXAvs(avsAddr, ethclient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to fetch Avs contract", "err", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ContractBindings{
                AvsAddr:    avsAddr,
                AVSManager: contractAvsManager,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package health

import (
        "bytes"
        "context"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        ethcrypto "github.com/ethereum/go-ethereum/crypto"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// Custom error types
var (
        ErrKeeperNotVerified = errors.New("keeper not verified")
)

// ErrorResponse represents the error response from the health service
type ErrorResponse struct {
        Error string `json:"error"`
        Code  string `json:"code"`
}

// Client represents a Health service client
type Client struct {
        httpClient *httppkg.HTTPClient
        logger     logging.Logger
        config     Config
}

// Config holds the configuration for the Health client
type Config struct {
        HealthServiceURL string
        PrivateKey       string
        KeeperAddress    string
        PeerID           string
        Version          string
        RequestTimeout   time.Duration
}

// NewClient creates a new Health service client
func NewClient(logger logging.Logger, cfg Config) (*Client, error) <span class="cov0" title="0">{
        if cfg.RequestTimeout == 0 </span><span class="cov0" title="0">{
                cfg.RequestTimeout = 10 * time.Second
        }</span>

        <span class="cov0" title="0">if cfg.Version == "" </span><span class="cov0" title="0">{
                cfg.Version = "0.1.6"
        }</span>

        <span class="cov0" title="0">retryConfig := httppkg.DefaultHTTPRetryConfig()

        httpClient, err := httppkg.NewHTTPClient(retryConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                httpClient: httpClient,
                logger:     logger,
                config:     cfg,
        }, nil</span>
}

// CheckIn performs a health check-in with the health service
func (c *Client) CheckIn(ctx context.Context) (types.KeeperHealthCheckInResponse, error) <span class="cov0" title="0">{
        // Get consensus address from private key
        privateKey, err := ethcrypto.HexToECDSA(c.config.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("invalid private key: %w", err)
        }</span>
        <span class="cov0" title="0">publicKeyBytes := ethcrypto.FromECDSAPub(&amp;privateKey.PublicKey)
        consensusPubKey := hex.EncodeToString(publicKeyBytes)
        consensusAddress := ethcrypto.PubkeyToAddress(privateKey.PublicKey).Hex()

        // Create message to sign
        msg := []byte(c.config.KeeperAddress)
        signature, err := cryptography.SignMessage(string(msg), c.config.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to sign check-in message: %w", err)
        }</span>

        // Prepare health check payload
        <span class="cov0" title="0">payload := types.KeeperHealthCheckIn{
                KeeperAddress:    c.config.KeeperAddress,
                ConsensusPubKey:  consensusPubKey,
                ConsensusAddress: consensusAddress,
                Version:          c.config.Version,
                Timestamp:        time.Now().UTC(),
                Signature:        signature,
                PeerID:           c.config.PeerID,
                IsImua:           config.IsImua(),
        }

        // c.logger.Infof("Payload: %+v", payload)

        // Send health check request
        response, err := c.sendHealthCheck(ctx, payload)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">metrics.SuccessfulHealthCheckinsTotal.Inc()

        // c.logger.Debug("Successfully completed health check-in",
        //         "status", response.Status,
        //         "keeperAddress", c.config.KeeperAddress,
        //         "timestamp", payload.Timestamp)

        return response, nil</span>
}

// sendHealthCheck sends the health check request to the health service
func (c *Client) sendHealthCheck(ctx context.Context, payload types.KeeperHealthCheckIn) (types.KeeperHealthCheckInResponse, error) <span class="cov0" title="0">{
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to marshal health check payload: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST",
                fmt.Sprintf("%s/health", c.config.HealthServiceURL),
                bytes.NewBuffer(payloadBytes))
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to send health check request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("failed to close response body", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        if errResp.Code == "KEEPER_NOT_VERIFIED" </span><span class="cov0" title="0">{
                                return types.KeeperHealthCheckInResponse{
                                        Status: false,
                                        Data:   errResp.Error,
                                }, ErrKeeperNotVerified
                        }</span>
                }
                <span class="cov0" title="0">return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   errResp.Error,
                }, fmt.Errorf("health service returned non-OK status: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">body, _ := io.ReadAll(resp.Body)
        var response types.KeeperHealthCheckInResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to unmarshal health check response: %w", err)
        }</span>

        // Only decrypt if the response was successful
        <span class="cov0" title="0">if response.Status </span><span class="cov0" title="0">{
                decryptedString, err := cryptography.DecryptMessage(c.config.PrivateKey, response.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return types.KeeperHealthCheckInResponse{
                                Status: false,
                                Data:   err.Error(),
                        }, fmt.Errorf("failed to decrypt health check response: %w", err)
                }</span>

                <span class="cov0" title="0">parts := strings.Split(decryptedString, ":")
                if len(parts) != 6 </span><span class="cov0" title="0">{
                        return types.KeeperHealthCheckInResponse{
                                Status: false,
                                Data:   "invalid response format",
                        }, fmt.Errorf("invalid response format: expected host:token")
                }</span>

                <span class="cov0" title="0">config.SetEtherscanAPIKey(parts[0])
                config.SetAlchemyAPIKey(parts[1])
                config.SetIpfsHost(parts[2])
                config.SetPinataJWT(parts[3])
                config.SetManagerSigningAddress(parts[4])
                config.SetTaskExecutionAddress(parts[5])

                return types.KeeperHealthCheckInResponse{
                        Status: true,
                        Data:   "Health check-in successful",
                }, nil</span>
        }

        // If response was not successful, return the error as is
        <span class="cov0" title="0">return response, nil</span>
}

// Close closes the HTTP client
func (c *Client) Close() <span class="cov0" title="0">{
        c.httpClient.Close()
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package config

import (
        "fmt"
        "crypto/ecdsa"
        "encoding/hex"
        "time"
        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"
        sdkEcdsa "github.com/imua-xyz/imua-avs-sdk/crypto/ecdsa"
        "github.com/prysmaticlabs/prysm/v5/crypto/bls"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

const (
        version = "0.1.6"
        isImua  = true
)

const (
        avsName = "hello-world-avs-demo"
        semVer  = "0.0.1"
        maxRetries = 80
        retryDelay = 1 * time.Second
)

type Config struct {
        devMode bool

        // RPC URLs for Ethereum and Base
        ethRPCUrl  string
        ethWsUrl   string

        // API Keys for Alchemy and Etherscan
        alchemyAPIKey   string
        etherscanAPIKey string

        // Controller Key and Keeper Address
        privateKeyController *ecdsa.PrivateKey
        keeperAddress        string

        privateKeyOwner *ecdsa.PrivateKey
        ownerAddress    string

        // Consensus Key and Address (BLS)
        consensusKeyPair bls.SecretKey

        // Public IP Address and Peer ID
        publicIPV4Address string
        peerID            string

        // Ports for Keeper API server, P2P connections, metrics and Grafana
        keeperRPCPort     string
        keeperP2PPort     string
        keeperMetricsPort string
        grafanaPort       string
        nodeApiPort       string

        // IPFS configuration
        ipfsHost  string
        pinataJWT string

        // TLS Proof configuration
        tlsProofHost string
        tlsProofPort string

        // Manager Signing Address
        managerSigningAddress string

        // Backend Service URLs
        aggregatorRPCUrl string
        healthRPCUrl     string

        l1Chain string
        l2Chain string

        // AVS Contract Address
        avsGovernanceAddress string
        taskExecutionAddress string

        // Othentic Bootstrap ID
        othenticBootstrapID string
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                  env.GetEnvBool("DEV_MODE", false),
                ethRPCUrl:                env.GetEnvString("ETH_RPC_URL", ""),
                ethWsUrl:                 env.GetEnvString("ETH_WS_URL", ""),
                alchemyAPIKey:           env.GetEnvString("ALCHEMY_API_KEY", ""),
                publicIPV4Address:        env.GetEnvString("PUBLIC_IPV4_ADDRESS", ""),
                peerID:                   env.GetEnvString("PEER_ID", ""),
                keeperRPCPort:            env.GetEnvString("OPERATOR_RPC_PORT", "9011"),
                keeperP2PPort:            env.GetEnvString("OPERATOR_P2P_PORT", "9012"),
                keeperMetricsPort:        env.GetEnvString("OPERATOR_METRICS_PORT", "9013"),
                nodeApiPort:              env.GetEnvString("OPERATOR_NODE_API_PORT", "9014"),
                grafanaPort:              env.GetEnvString("GRAFANA_PORT", "3000"),
                aggregatorRPCUrl:         env.GetEnvString("OTHENTIC_CLIENT_RPC_ADDRESS", "https://aggregator.triggerx.network"),
                healthRPCUrl:             env.GetEnvString("HEALTH_IP_ADDRESS", "https://health.triggerx.network"),
                tlsProofHost:             "www.google.com",
                tlsProofPort:             "443",
                l1Chain:                  env.GetEnvString("L1_CHAIN", "17000"),
                l2Chain:                  env.GetEnvString("L2_CHAIN", "84532"),
                avsGovernanceAddress:     env.GetEnvString("TRIGGERX_AVS_ADDRESS", "0x72A5016ECb9EB01d7d54ae48bFFB62CA0B8e57a5"),
                othenticBootstrapID:      env.GetEnvString("OTHENTIC_BOOTSTRAP_ID", "12D3KooWBNFG1QjuF3UKAKvqhdXcxh9iBmj88cM5eU2EK5Pa91KB"),
        }

        // Load BLS private key from environment variable
        blsPrivateKeyHex := env.GetEnvString("BLS_PRIVATE_KEY", "")
        if blsPrivateKeyHex == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("BLS_PRIVATE_KEY environment variable not set")
        }</span>

        // Remove 0x prefix if present
        <span class="cov0" title="0">if len(blsPrivateKeyHex) &gt;= 2 &amp;&amp; blsPrivateKeyHex[:2] == "0x" </span><span class="cov0" title="0">{
                blsPrivateKeyHex = blsPrivateKeyHex[2:]
        }</span>

        // Convert hex to bytes
        <span class="cov0" title="0">blsKeyBytes, err := hex.DecodeString(blsPrivateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid BLS private key format: %s", err)
        }</span>

        // Create BLS secret key from bytes
        <span class="cov0" title="0">blsKeyPair, err := bls.SecretKeyFromBytes(blsKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid bls key: %s", err)
        }</span>
        <span class="cov0" title="0">cfg.consensusKeyPair = blsKeyPair

        ecdsaKeyPassword := env.GetEnvString("OPERATOR_ECDSA_KEY_PASSWORD", "")
        ecdsaKeyStorePath := env.GetEnvString("OPERATOR_ECDSA_KEY_STORE_PATH", "")
        ecdsaPrivateKey, err := sdkEcdsa.ReadKey(ecdsaKeyStorePath, ecdsaKeyPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ecdsa key password: %s", err)
        }</span>
        <span class="cov0" title="0">cfg.privateKeyController = ecdsaPrivateKey

        ecdsaAddress, err := sdkEcdsa.GetAddressFromKeyStoreFile(ecdsaKeyStorePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ecdsa key password: %s", err)
        }</span>
        <span class="cov0" title="0">cfg.keeperAddress = ecdsaAddress.Hex()

        ownerEcdsaKeyPassword := env.GetEnvString("OWNER_ECDSA_KEY_PASSWORD", "")
        ownerEcdsaKeyStorePath := env.GetEnvString("OWNER_ECDSA_KEY_STORE_PATH", "")
        ownerEcdsaPrivateKey, err := sdkEcdsa.ReadKey(ownerEcdsaKeyStorePath, ownerEcdsaKeyPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ecdsa key password: %s", err)
        }</span>
        <span class="cov0" title="0">cfg.privateKeyOwner = ownerEcdsaPrivateKey

        ownerAddress, err := sdkEcdsa.GetAddressFromKeyStoreFile(ownerEcdsaKeyStorePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ecdsa key password: %s", err)
        }</span>
        <span class="cov0" title="0">cfg.ownerAddress = ownerAddress.Hex()

        if err := validateConfig(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        // isRegistered := checkKeeperRegistration()
        // if !isRegistered {
        //         log.Println("Keeper address is not yet registered on L2. Please register the address before continuing. If registered, please wait for the registration to be confirmed.")
        //         log.Fatal("Keeper address is not registered on L2")
        // }
        <span class="cov0" title="0">return nil</span>
}

func validateConfig(cfg Config) error <span class="cov0" title="0">{
        if env.IsEmpty(cfg.ethRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid eth rpc url: %s", cfg.ethRPCUrl)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.ethWsUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid eth ws url: %s", cfg.ethWsUrl)
        }</span>
        <span class="cov0" title="0">if !env.IsValidIPAddress(cfg.publicIPV4Address) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid public ipv4 address: %s", cfg.publicIPV4Address)
        }</span>
        // if !env.IsValidEthAddress(cfg.keeperAddress) {
        //         return fmt.Errorf("invalid keeper address: %s", cfg.keeperAddress)
        // }
        <span class="cov0" title="0">if !env.IsValidPeerID(cfg.peerID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid peer id: %s", cfg.peerID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetEthRPCUrl() string <span class="cov0" title="0">{
        return cfg.ethRPCUrl
}</span>

func GetEthWsUrl() string <span class="cov0" title="0">{
        return cfg.ethWsUrl
}</span>

// Only sets it if there was no key in env file
func SetAlchemyAPIKey(key string) <span class="cov0" title="0">{
        if !env.IsEmpty(cfg.alchemyAPIKey) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">cfg.alchemyAPIKey = key</span>
}

func GetAlchemyAPIKey() string <span class="cov0" title="0">{
        return cfg.alchemyAPIKey
}</span>

func SetEtherscanAPIKey(key string) <span class="cov0" title="0">{
        cfg.etherscanAPIKey = key
}</span>

func GetEtherscanAPIKey() string <span class="cov0" title="0">{
        return cfg.etherscanAPIKey
}</span>

func GetPrivateKeyController() *ecdsa.PrivateKey <span class="cov0" title="0">{
        return cfg.privateKeyController
}</span>

func GetPrivateKeyOwner() *ecdsa.PrivateKey <span class="cov0" title="0">{
        return cfg.privateKeyOwner
}</span>

func GetOwnerAddress() string <span class="cov0" title="0">{
        return cfg.ownerAddress
}</span>

func GetKeeperAddress() string <span class="cov0" title="0">{
        return cfg.keeperAddress
}</span>

func GetConsensusKeyPair() bls.SecretKey <span class="cov0" title="0">{
        return cfg.consensusKeyPair
}</span>

func GetPublicIPV4Address() string <span class="cov0" title="0">{
        return cfg.publicIPV4Address
}</span>

func GetPeerID() string <span class="cov0" title="0">{
        return cfg.peerID
}</span>

func GetOperatorRPCPort() string <span class="cov0" title="0">{
        return cfg.keeperRPCPort
}</span>

func GetOperatorNodeApiPort() string <span class="cov0" title="0">{
        return cfg.nodeApiPort
}</span>

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetKeeperRPCPort() string <span class="cov0" title="0">{
        return cfg.keeperRPCPort
}</span>

func GetAggregatorRPCUrl() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCUrl
}</span>

func GetHealthRPCUrl() string <span class="cov0" title="0">{
        return cfg.healthRPCUrl
}</span>

func GetAvsGovernanceAddress() string <span class="cov0" title="0">{
        return cfg.avsGovernanceAddress
}</span>

func GetVersion() string <span class="cov0" title="0">{
        return version
}</span>

func GetAvsName() string <span class="cov0" title="0">{
        return avsName
}</span>

func GetSemVer() string <span class="cov0" title="0">{
        return semVer
}</span>

func GetMaxRetries() int <span class="cov0" title="0">{
        return maxRetries
}</span>

func GetRetryDelay() time.Duration <span class="cov0" title="0">{
        return retryDelay
}</span>

func IsImua() bool <span class="cov0" title="0">{
        return isImua
}</span>

// IPFS configuration
func SetIpfsHost(host string) <span class="cov0" title="0">{
        cfg.ipfsHost = host
}</span>

func GetIpfsHost() string <span class="cov0" title="0">{
        return cfg.ipfsHost
}</span>

func SetPinataJWT(jwt string) <span class="cov0" title="0">{
        cfg.pinataJWT = jwt
}</span>

func GetPinataJWT() string <span class="cov0" title="0">{
        return cfg.pinataJWT
}</span>

// TLS Proof configuration
func SetTLSProofHost(host string) <span class="cov0" title="0">{
        cfg.tlsProofHost = host
}</span>

func SetTLSProofPort(port string) <span class="cov0" title="0">{
        cfg.tlsProofPort = port
}</span>

func GetTLSProofHost() string <span class="cov0" title="0">{
        return cfg.tlsProofHost
}</span>

func GetTLSProofPort() string <span class="cov0" title="0">{
        return cfg.tlsProofPort
}</span>

// Manager Signing Address
func SetManagerSigningAddress(addr string) <span class="cov0" title="0">{
        cfg.managerSigningAddress = addr
}</span>

func GetManagerSigningAddress() string <span class="cov0" title="0">{
        return cfg.managerSigningAddress
}</span>

func SetTaskExecutionAddress(addr string) <span class="cov0" title="0">{
        cfg.taskExecutionAddress = addr
}</span>

func GetTaskExecutionAddress() string <span class="cov0" title="0">{
        return cfg.taskExecutionAddress
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package execution

import (
        "context"
        "fmt"
        "math/big"
        "strconv"
        "strings"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi"
        ethcommon "github.com/ethereum/go-ethereum/common"
        ethtypes "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        dockertypes "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (e *TaskExecutor) executeAction(targetData *types.TaskTargetData, triggerData *types.TaskTriggerData, nonce uint64, client *ethclient.Client) (types.PerformerActionData, error) <span class="cov0" title="0">{
        if targetData.TargetContractAddress == "" </span><span class="cov0" title="0">{
                e.logger.Errorf("Execution contract address not configured")
                return types.PerformerActionData{}, fmt.Errorf("execution contract address not configured")
        }</span>

        <span class="cov0" title="0">var timeToNextTrigger time.Duration
        switch targetData.TaskDefinitionID </span>{
        case 1:<span class="cov0" title="0">
                timeToNextTrigger = time.Until(triggerData.NextTriggerTimestamp)
                timeToNextTrigger = timeToNextTrigger - 2*time.Second</span>
        case 2:<span class="cov0" title="0">
                timeToNextTrigger = time.Until(triggerData.NextTriggerTimestamp)
                timeToNextTrigger = timeToNextTrigger - 4*time.Second
                if timeToNextTrigger &lt; 0 </span><span class="cov0" title="0">{
                        timeToNextTrigger = 0
                }</span>
        default:<span class="cov0" title="0">
                timeToNextTrigger = 0</span>
        }
        <span class="cov0" title="0">time.Sleep(timeToNextTrigger)

        targetContractAddress := ethcommon.HexToAddress(targetData.TargetContractAddress)
        contractABI, method, err := e.getContractMethodAndABI(targetData.TargetFunction, targetData)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get contract method and ABI: %v", err)
        }</span>

        <span class="cov0" title="0">var argData []interface{}
        var result *dockertypes.ExecutionResult
        switch targetData.TaskDefinitionID </span>{
        case 2, 4, 6:<span class="cov0" title="0">
                var execErr error
                // Use the DockerManager from the validator to execute the code
                result, execErr = e.validator.GetDockerManager().Execute(context.Background(), targetData.DynamicArgumentsScriptUrl, 1)
                if execErr != nil </span><span class="cov0" title="0">{
                        return types.PerformerActionData{}, fmt.Errorf("failed to execute dynamic arguments script: %v", execErr)
                }</span>

                <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                        return types.PerformerActionData{}, fmt.Errorf("failed to execute dynamic arguments script: %v", result.Error)
                }</span>

                <span class="cov0" title="0">argData = e.parseDynamicArgs(result.Output)
                e.logger.Debugf("Parsed dynamic arguments: %+v", argData)</span>
        case 1, 3, 5:<span class="cov0" title="0">
                argData = e.parseStaticArgs(targetData.Arguments)
                result = &amp;dockertypes.ExecutionResult{
                        Stats: dockertypes.DockerResourceStats{
                                TotalCost: 0.1,
                        },
                }</span>
        default:<span class="cov0" title="0">
                return types.PerformerActionData{}, fmt.Errorf("unsupported task definition id: %d", targetData.TaskDefinitionID)</span>
        }

        // Handle args as potentially structured data
        <span class="cov0" title="0">convertedArgs, err := e.processArguments(argData, method.Inputs, contractABI)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("error processing arguments: %v", err)
        }</span>

        // Pack the target contract's function call data
        <span class="cov0" title="0">var callData []byte
        callData, err = contractABI.Pack(method.Name, convertedArgs...)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Error packing arguments: %v", err)
                return types.PerformerActionData{}, fmt.Errorf("error packing arguments: %v", err)
        }</span>

        // Create transaction data for execution contract
        <span class="cov0" title="0">e.logger.Debugf("Using nonce: %d", nonce)

        // Pack the execution contract's executeFunction call
        executionABI, err := abi.JSON(strings.NewReader(`[{"inputs":[{"internalType":"uint256","name":"jobId","type":"uint256"},{"internalType":"uint256","name":"tgAmount","type":"uint256"},{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"executeFunction","outputs":[],"stateMutability":"payable","type":"function"}]`))
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to parse execution contract ABI: %v", err)
        }</span>

        // According to the ABI, the function signature is:
        // executeFunction(uint256 jobId, uint256 tgAmount, address target, bytes data)
        // We use jobId from targetData.JobID, and tgAmount is determined by the execution result's total cost.
        <span class="cov0" title="0">var tgAmountBigInt = big.NewInt(0)
        if result != nil </span><span class="cov0" title="0">{
                // Assuming TotalCost is in float64 and needs to be converted to wei (1e18 multiplier) if it's in ETH
                tgAmountBigInt = new(big.Int).SetInt64(int64(result.Stats.TotalCost * 1e18))
        }</span>
        <span class="cov0" title="0">executionInput, err := executionABI.Pack("executeFunction", targetData.JobID, tgAmountBigInt, targetContractAddress, callData)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to pack execution contract input: %v", err)
        }</span>

        <span class="cov0" title="0">executionContractAddress := config.GetTaskExecutionAddress()
        chainID, err := client.ChainID(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get chain ID: %v", err)
        }</span>

        // Get nonce manager for this chain
        <span class="cov0" title="0">nonceManager, err := e.getNonceManager(targetData.TargetChainID)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get nonce manager: %w", err)
        }</span>

        // Submit transaction with smart retry
        <span class="cov0" title="0">receipt, finalTxHash, err := nonceManager.SubmitTransactionWithSmartRetry(
                context.Background(),
                nonce,
                ethcommon.HexToAddress(executionContractAddress),
                executionInput,
                chainID,
                config.GetPrivateKeyController(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, err
        }</span>

        <span class="cov0" title="0">executionResult := types.PerformerActionData{
                TaskID:             targetData.TaskID,
                ActionTxHash:       finalTxHash,
                GasUsed:            strconv.FormatUint(receipt.GasUsed, 10),
                Status:             receipt.Status == ethtypes.ReceiptStatusSuccessful,
                MemoryUsage:        result.Stats.MemoryUsage,
                CPUPercentage:      result.Stats.CPUPercentage,
                NetworkRx:          result.Stats.RxBytes,
                NetworkTx:          result.Stats.TxBytes,
                BlockRead:          result.Stats.BlockRead,
                BlockWrite:         result.Stats.BlockWrite,
                BandwidthRate:      result.Stats.BandwidthRate,
                TotalFee:           result.Stats.TotalCost,
                StaticComplexity:   result.Stats.StaticComplexity,
                DynamicComplexity:  result.Stats.DynamicComplexity,
                ExecutionTimestamp: time.Now().UTC(),
        }
        metrics.TransactionsSentTotal.WithLabelValues(targetData.TargetChainID, "success").Inc()
        metrics.GasUsedTotal.WithLabelValues(targetData.TargetChainID).Add(float64(receipt.GasUsed))
        metrics.TransactionFeesTotal.WithLabelValues(targetData.TargetChainID).Add(result.Stats.TotalCost)

        e.logger.Infof("Task ID %d executed successfully. Transaction: %s", targetData.TaskID, finalTxHash)

        return executionResult, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package execution

import (
        "encoding/json"
        "fmt"
        "math"
        "math/big"
        "reflect"
        "strconv"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
        ethcommon "github.com/ethereum/go-ethereum/common"
)

type ArgumentConverter struct{}

func (ac *ArgumentConverter) convertToType(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Handle different input types and convert to appropriate blockchain types
        switch targetType.T </span>{
        case abi.UintTy, abi.IntTy:<span class="cov0" title="0">
                return ac.convertToInteger(value, targetType)</span>
        case abi.StringTy:<span class="cov0" title="0">
                return ac.convertToString(value)</span>
        case abi.BoolTy:<span class="cov0" title="0">
                return ac.convertToBool(value)</span>
        case abi.AddressTy:<span class="cov0" title="0">
                return ac.convertToAddress(value)</span>
        case abi.BytesTy, abi.FixedBytesTy:<span class="cov0" title="0">
                return ac.convertToBytes(value)</span>
        case abi.ArrayTy, abi.SliceTy:<span class="cov0" title="0">
                return ac.convertToArray(value, targetType)</span>
        case abi.TupleTy:<span class="cov0" title="0">
                return ac.convertToStruct(value, targetType)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported type conversion: %v", targetType)</span>
        }
}

func (ac *ArgumentConverter) convertToInteger(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Add this case to handle when the value is already a *big.Int
        if bigInt, ok := value.(*big.Int); ok </span><span class="cov0" title="0">{
                return bigInt, nil
        }</span>

        <span class="cov0" title="0">switch targetType.T </span>{
        case abi.UintTy:<span class="cov0" title="0">
                if targetType.Size == 32 </span><span class="cov0" title="0">{
                        // Handle uint32 specifically
                        switch v := value.(type) </span>{
                        case string:<span class="cov0" title="0">
                                // Parse as float first, then convert to uint32
                                floatVal, err := strconv.ParseFloat(v, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if floatVal &lt; 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("cannot convert negative value %f to uint32", floatVal)
                                }</span>
                                <span class="cov0" title="0">if floatVal &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("value %f exceeds maximum uint32 value", floatVal)
                                }</span>
                                <span class="cov0" title="0">return uint32(floatVal), nil</span>
                        case float64:<span class="cov0" title="0">
                                return uint32(v), nil</span>
                        case int:<span class="cov0" title="0">
                                if v &lt; 0 </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("cannot convert negative value %d to uint32", v)
                                }</span>
                                <span class="cov0" title="0">if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("value %d exceeds maximum uint32 value", v)
                                }</span>
                                <span class="cov0" title="0">return uint32(v), nil</span>
                        }
                }
                // For other uint sizes, use big.Int
                <span class="cov0" title="0">fallthrough</span>
        default:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        return big.NewInt(int64(v)), nil</span>
                case string:<span class="cov0" title="0">
                        // Parse as float first, then convert to big.Int
                        floatVal, err := strconv.ParseFloat(v, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot convert string to integer: %v", err)
                        }</span>
                        <span class="cov0" title="0">return big.NewInt(int64(floatVal)), nil</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        // This could be a struct that we need to convert to an integer
                        if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                                var floatVal float64
                                if err := json.Unmarshal(jsonBytes, &amp;floatVal); err == nil </span><span class="cov0" title="0">{
                                        return big.NewInt(int64(floatVal)), nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert map to integer")</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("cannot convert type %T to integer", v)</span>
                }
        }
}

func (ac *ArgumentConverter) convertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        // Convert various types to string
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v, nil</span>
        case float64, int, uint:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v), nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // This could be a JSON object that we need to convert to a string
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return string(jsonBytes), nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("cannot convert map to string")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("cannot convert type %T to string", v)</span>
        }
}

func (ac *ArgumentConverter) convertToBool(value interface{}) (bool, error) <span class="cov0" title="0">{
        // Convert various types to bool
        switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseBool(v)</span>
        case float64:<span class="cov0" title="0">
                return v != 0, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to convert JSON to bool
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        var boolVal bool
                        if err := json.Unmarshal(jsonBytes, &amp;boolVal); err == nil </span><span class="cov0" title="0">{
                                return boolVal, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("cannot convert map to bool")</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("cannot convert type %T to bool", v)</span>
        }
}

func (ac *ArgumentConverter) convertToAddress(value interface{}) (ethcommon.Address, error) <span class="cov0" title="0">{
        // Convert to Ethereum address
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                if !ethcommon.IsHexAddress(v) </span><span class="cov0" title="0">{
                        return ethcommon.Address{}, fmt.Errorf("invalid Ethereum address: %s", v)
                }</span>
                <span class="cov0" title="0">return ethcommon.HexToAddress(v), nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Check if we have a string representation in the map
                if addrStr, ok := v["address"].(string); ok </span><span class="cov0" title="0">{
                        if !ethcommon.IsHexAddress(addrStr) </span><span class="cov0" title="0">{
                                return ethcommon.Address{}, fmt.Errorf("invalid Ethereum address: %s", addrStr)
                        }</span>
                        <span class="cov0" title="0">return ethcommon.HexToAddress(addrStr), nil</span>
                }
                <span class="cov0" title="0">return ethcommon.Address{}, fmt.Errorf("cannot convert map to address")</span>
        default:<span class="cov0" title="0">
                return ethcommon.Address{}, fmt.Errorf("cannot convert type %T to address", v)</span>
        }
}

func (ac *ArgumentConverter) convertToBytes(value interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Convert to bytes
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                // Check if it's a hex string
                if strings.HasPrefix(v, "0x") </span><span class="cov0" title="0">{
                        return ethcommon.FromHex(v), nil
                }</span>
                <span class="cov0" title="0">return []byte(v), nil</span>
        case []byte:<span class="cov0" title="0">
                return v, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to convert JSON to bytes
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return jsonBytes, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert map to bytes")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert type %T to bytes", v)</span>
        }
}

func (ac *ArgumentConverter) convertToArray(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // First, ensure the value is actually an array/slice
        var sourceArray []interface{}

        switch v := value.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                sourceArray = v</span>
        case string:<span class="cov0" title="0">
                // Try to parse as JSON array
                if err := json.Unmarshal([]byte(v), &amp;sourceArray); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse string as JSON array: %v", err)
                }</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to parse map as JSON array
                jsonBytes, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal map as JSON: %v", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonBytes, &amp;sourceArray); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse map as JSON array: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert type %T to array/slice", v)</span>
        }

        // Create a new slice with the correct element type
        <span class="cov0" title="0">sliceType := reflect.SliceOf(targetType.Elem.GetType())
        result := reflect.MakeSlice(sliceType, len(sourceArray), len(sourceArray))

        // Convert each element
        for i, elem := range sourceArray </span><span class="cov0" title="0">{
                convertedElem, err := ac.convertToType(elem, *targetType.Elem)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting array element %d: %v", i, err)
                }</span>

                // Set the element in the slice
                <span class="cov0" title="0">resultElem := reflect.ValueOf(convertedElem)
                result.Index(i).Set(resultElem)</span>
        }

        <span class="cov0" title="0">return result.Interface(), nil</span>
}

func (ac *ArgumentConverter) convertToStruct(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Create a new instance of the struct type
        structType := targetType.GetType()
        structValue := reflect.New(structType).Elem()

        // Prepare source data
        var sourceMap map[string]interface{}

        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                sourceMap = v</span>
        case string:<span class="cov0" title="0">
                // Try to parse as JSON object
                if err := json.Unmarshal([]byte(v), &amp;sourceMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse string as JSON object: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                // If it's already a struct, we can try to convert it directly
                valueVal := reflect.ValueOf(value)
                if valueVal.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        // Convert struct to map for easier processing
                        jsonBytes, err := json.Marshal(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal struct: %v", err)
                        }</span>
                        <span class="cov0" title="0">if err := json.Unmarshal(jsonBytes, &amp;sourceMap); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal struct to map: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("cannot convert type %T to struct", v)
                }</span>
        }

        // Iterate through the tuple components and set corresponding fields
        <span class="cov0" title="0">for i, component := range targetType.TupleElems </span><span class="cov0" title="0">{
                fieldName := targetType.TupleRawNames[i]
                fieldValue, exists := sourceMap[fieldName]

                if !exists </span><span class="cov0" title="0">{
                        // Try with case-insensitive match
                        for k, v := range sourceMap </span><span class="cov0" title="0">{
                                if strings.EqualFold(k, fieldName) </span><span class="cov0" title="0">{
                                        fieldValue = v
                                        exists = true
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert the field value to the correct type
                <span class="cov0" title="0">convertedValue, err := ac.convertToType(fieldValue, *component)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting struct field %s: %v", fieldName, err)
                }</span>

                // Find the corresponding field in the struct
                <span class="cov0" title="0">var structField reflect.Value
                for j := 0; j &lt; structValue.NumField(); j++ </span><span class="cov0" title="0">{
                        if strings.EqualFold(structType.Field(j).Name, fieldName) </span><span class="cov0" title="0">{
                                structField = structValue.Field(j)
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !structField.IsValid() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("struct field %s not found", fieldName)
                }</span>

                // Set the field value
                <span class="cov0" title="0">convertedValueReflect := reflect.ValueOf(convertedValue)
                if structField.Type() != convertedValueReflect.Type() </span><span class="cov0" title="0">{
                        // Try to convert the value to the correct type
                        if convertedValueReflect.Type().ConvertibleTo(structField.Type()) </span><span class="cov0" title="0">{
                                convertedValueReflect = convertedValueReflect.Convert(structField.Type())
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("cannot convert %v to field type %v", convertedValueReflect.Type(), structField.Type())
                        }</span>
                }
                <span class="cov0" title="0">structField.Set(convertedValueReflect)</span>
        }

        <span class="cov0" title="0">return structValue.Interface(), nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package execution

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "sync"

        // "strconv"
        "time"

        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/proof"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TaskExecutor is the default implementation of TaskExecutor
type TaskExecutor struct {
        alchemyAPIKey    string
        argConverter     *ArgumentConverter
        validator        *validation.TaskValidator
        aggregatorClient *aggregator.AggregatorClient
        avsWriter        chainio.AvsWriter
        logger           logging.Logger
        nonceManagers    map[string]*NonceManager // Chain ID -&gt; NonceManager
        nonceMutex       sync.RWMutex
}

// NewTaskExecutor creates a new instance of TaskExecutor
func NewTaskExecutor(
        alchemyAPIKey string,
        validator *validation.TaskValidator,
        aggregatorClient *aggregator.AggregatorClient,
        avsWriter chainio.AvsWriter,
        logger logging.Logger) *TaskExecutor <span class="cov0" title="0">{
        return &amp;TaskExecutor{
                alchemyAPIKey:    alchemyAPIKey,
                argConverter:     &amp;ArgumentConverter{},
                validator:        validator,
                aggregatorClient: aggregatorClient,
                avsWriter:        avsWriter,
                logger:           logger,
                nonceManagers:    make(map[string]*NonceManager),
        }
}</span>

func (e *TaskExecutor) ExecuteTask(ctx context.Context, task *types.SendTaskDataToKeeper, traceID string) (bool, error) <span class="cov0" title="0">{
        // Check for nil task
        if task == nil </span><span class="cov0" title="0">{
                e.logger.Error("Task data is nil", "trace_id", traceID)
                return false, fmt.Errorf("task data cannot be nil")
        }</span>

        // Check for nil TargetData and TriggerData
        <span class="cov0" title="0">if task.TargetData == nil </span><span class="cov0" title="0">{
                e.logger.Error("TargetData is nil", "task_id", task.TaskID, "trace_id", traceID)
                return false, fmt.Errorf("target data cannot be nil")
        }</span>
        <span class="cov0" title="0">if task.TriggerData == nil </span><span class="cov0" title="0">{
                e.logger.Error("TriggerData is nil", "task_id", task.TaskID, "trace_id", traceID)
                return false, fmt.Errorf("trigger data cannot be nil")
        }</span>

        // check if the scheduler signature is valid
        <span class="cov0" title="0">isManagerSignatureTrue, err := e.validator.ValidateManagerSignature(task, traceID)
        if !isManagerSignatureTrue </span><span class="cov0" title="0">{
                e.logger.Error("Manager signature validation failed", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">e.logger.Info("Scheduler signature validation passed", "task_id", task.TaskID, "trace_id", traceID)

        var (
                resultCh = make(chan struct {
                        success bool
                        err     error
                }, len(task.TargetData))
        )

        for i := range len(task.TargetData) </span><span class="cov0" title="0">{
                go func(idx int) </span><span class="cov0" title="0">{
                        // check if trigger is valid
                        isTriggerTrue, err := e.validator.ValidateTrigger(&amp;task.TriggerData[idx], traceID)
                        if !isTriggerTrue </span><span class="cov0" title="0">{
                                e.logger.Error("Trigger validation failed", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("Trigger validation passed", "task_id", task.TaskID, "trace_id", traceID)

                        // Get nonce manager for this chain
                        nonceManager, err := e.getNonceManager(task.TargetData[idx].TargetChainID)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to get nonce manager", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>

                        // Get next nonce atomically
                        <span class="cov0" title="0">nonce, err := nonceManager.GetNextNonce(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to get nonce", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>

                        // create a client for validating event based and performing action
                        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(task.TargetData[idx].TargetChainID)
                        client, err := ethclient.Dial(rpcURL)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to connect to chain", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">defer client.Close()
                        e.logger.Debugf("Connected to chain: %s", rpcURL)

                        // execute the action with the allocated nonce
                        var actionData types.PerformerActionData
                        actionData, err = e.executeAction(&amp;task.TargetData[idx], &amp;task.TriggerData[idx], nonce, client)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to execute action", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("Action execution completed", "task_id", task.TaskID, "trace_id", traceID)

                        ipfsData := types.IPFSData{
                                TaskData: &amp;types.SendTaskDataToKeeper{
                                        TaskID:           []int64{task.TargetData[idx].TaskID},
                                        PerformerData:    task.PerformerData,
                                        TargetData:       []types.TaskTargetData{task.TargetData[idx]},
                                        TriggerData:      []types.TaskTriggerData{task.TriggerData[idx]},
                                        SchedulerID:      task.SchedulerID,
                                        ManagerSignature: task.ManagerSignature,
                                },
                                ActionData:         &amp;actionData,
                                ProofData:          &amp;types.ProofData{},
                                PerformerSignature: &amp;types.PerformerSignatureData{},
                        }
                        ipfsData.ProofData.TaskID = task.TaskID[0]
                        ipfsData.PerformerSignature.TaskID = task.TaskID[0]
                        ipfsData.PerformerSignature.PerformerSigningAddress = string(config.GetConsensusKeyPair().PublicKey().Marshal())

                        tlsConfig := proof.DefaultTLSProofConfig(config.GetTLSProofHost())
                        tlsConfig.TargetPort = config.GetTLSProofPort()
                        proofData, err := proof.GenerateProofWithTLSConnection(ipfsData, tlsConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to generate TLS proof, falling back to mock", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                        }</span> else<span class="cov0" title="0"> {
                                e.logger.Info("TLS proof generated successfully", "task_id", task.TaskID, "trace_id", traceID)
                        }</span>

                        <span class="cov0" title="0">ipfsData.ProofData = &amp;proofData

                        // Create a copy of ipfsData without the signature for signing
                        ipfsDataForSigning := types.IPFSData{
                                TaskData:   ipfsData.TaskData,
                                ActionData: ipfsData.ActionData,
                                ProofData:  ipfsData.ProofData,
                                PerformerSignature: &amp;types.PerformerSignatureData{
                                        TaskID:                  ipfsData.PerformerSignature.TaskID,
                                        PerformerSigningAddress: ipfsData.PerformerSignature.PerformerSigningAddress,
                                        // Note: PerformerSignature field is intentionally left empty for signing
                                },
                        }
                        ipfsDataForSigningBytes, err := json.Marshal(ipfsDataForSigning)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to marshal ipfs data for signing", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        // Convert the data to 32-byte hash for BLS signing
                        <span class="cov0" title="0">var messageHash [32]byte
                        copy(messageHash[:], ipfsDataForSigningBytes)

                        // Sign using Prysmaticlabs BLS
                        performerSignature := config.GetConsensusKeyPair().Sign(messageHash[:])

                        // Encode signature as base64 for proper serialization
                        signatureBytes := performerSignature.Marshal()
                        performerSignatureEncoded := base64.StdEncoding.EncodeToString(signatureBytes)

                        // Encode public key as base64 for proper serialization
                        publicKeyBytes := config.GetConsensusKeyPair().PublicKey().Marshal()
                        performerSigningAddressEncoded := base64.StdEncoding.EncodeToString(publicKeyBytes)

                        ipfsData.PerformerSignature = &amp;types.PerformerSignatureData{
                                TaskID:                  task.TaskID[0],
                                PerformerSignature:      performerSignatureEncoded,
                                PerformerSigningAddress: performerSigningAddressEncoded,
                        }
                        e.logger.Info("IPFS data signed", "task_id", task.TaskID, "trace_id", traceID)
                        e.logger.Info("Performer signature", "performerSignature", ipfsData.PerformerSignature)

                        // filename := fmt.Sprintf("proof_of_task_%d_%s.json", task.TaskID, time.Now().Format("20060102150405"))
                        // ipfsDataBytes, err := json.Marshal(ipfsData)
                        // if err != nil {
                        //         resultCh &lt;- struct {
                        //                 success bool
                        //                 err     error
                        //         }{false, err}
                        //         return
                        // }
                        // _, err = utils.UploadToIPFS(filename, ipfsDataBytes)
                        // if err != nil {
                        //         e.logger.Error("Failed to upload IPFS data", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                        //         resultCh &lt;- struct {
                        //                 success bool
                        //                 err     error
                        //         }{false, err}
                        //         return
                        // }
                        // e.logger.Info("IPFS data uploaded", "task_id", task.TaskID, "trace_id", traceID)

                        // Create task on-chain instead of sending to aggregator
                        taskName := fmt.Sprintf("Task_%d_%s", task.TaskID[0], time.Now().Format("20060102150405"))
                        taskDefinitionId := uint8(task.TargetData[idx].TaskDefinitionID)

                        // Use default values for task parameters
                        taskResponsePeriod := uint64(2)
                        taskChallengePeriod := uint64(2)
                        thresholdPercentage := uint8(80) // 80% threshold
                        taskStatisticalPeriod := uint64(2)

                        // Create task data from IPFS data
                        taskData, err := json.Marshal(ipfsData)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to marshal task data", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>

                        // Create task on-chain
                        <span class="cov0" title="0">receipt, err := e.avsWriter.CreateNewTask(
                                ctx,
                                taskName,
                                taskDefinitionId,
                                taskData,
                                taskResponsePeriod,
                                taskChallengePeriod,
                                thresholdPercentage,
                                taskStatisticalPeriod,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to create task on-chain", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, fmt.Errorf("failed to create task on-chain: %w", err)}
                                return
                        }</span>

                        <span class="cov0" title="0">e.logger.Info("Task created on-chain successfully",
                                "task_id", task.TaskID,
                                "trace_id", traceID,
                                "tx_hash", receipt.TxHash.String(),
                                "block_number", receipt.BlockNumber)

                        resultCh &lt;- struct {
                                success bool
                                err     error
                        }{true, nil}</span>
                }(i)
        }

        <span class="cov0" title="0">for range task.TargetData </span><span class="cov0" title="0">{
                res := &lt;-resultCh
                if res.err != nil || !res.success </span><span class="cov0" title="0">{
                        return false, res.err
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// getNonceManager returns or creates a nonce manager for the given chain
func (e *TaskExecutor) getNonceManager(chainID string) (*NonceManager, error) <span class="cov0" title="0">{
        e.nonceMutex.RLock()
        if nm, exists := e.nonceManagers[chainID]; exists </span><span class="cov0" title="0">{
                e.nonceMutex.RUnlock()
                return nm, nil
        }</span>
        <span class="cov0" title="0">e.nonceMutex.RUnlock()

        e.nonceMutex.Lock()
        defer e.nonceMutex.Unlock()

        // Double-check after acquiring write lock
        if nm, exists := e.nonceManagers[chainID]; exists </span><span class="cov0" title="0">{
                return nm, nil
        }</span>

        // Create new client and nonce manager
        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(chainID)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client for chain %s: %w", chainID, err)
        }</span>

        <span class="cov0" title="0">nm := NewNonceManager(client, e.logger)
        if err := nm.Initialize(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize nonce manager for chain %s: %w", chainID, err)
        }</span>

        <span class="cov0" title="0">e.nonceManagers[chainID] = nm
        return nm, nil</span>
}

// func parseStringToInt(str string) int {
//         num, err := strconv.Atoi(str)
//         if err != nil {
//                 return 0
//         }
//         return num
// }
</pre>
		
		<pre class="file" id="file82" style="display: none">package execution

import (
        "context"
        "crypto/ecdsa"
        "fmt"
        "math/big"
        "strings"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// NonceManager handles nonce allocation and transaction retry logic
type NonceManager struct {
        mu           sync.Mutex
        currentNonce uint64
        client       *ethclient.Client
        address      common.Address
        logger       logging.Logger
        lastSyncTime time.Time
        syncInterval time.Duration

        // Transaction tracking
        pendingTxs map[uint64]*PendingTransaction
        txMutex    sync.RWMutex

        // Retry configuration
        maxRetries  int
        baseTimeout time.Duration
        priorityFee *big.Int // Base priority fee for EIP-1559
}

type PendingTransaction struct {
        Nonce        uint64
        TxHash       string
        CreatedAt    time.Time
        Status       string // "pending", "confirmed", "failed", "replaced"
        Attempts     int
        LastGasPrice *big.Int
        Data         []byte
        To           common.Address
        ChainID      *big.Int
        PrivateKey   *ecdsa.PrivateKey
}

// NewNonceManager creates a new nonce manager with optimized retry settings
func NewNonceManager(client *ethclient.Client, logger logging.Logger) *NonceManager <span class="cov0" title="0">{
        return &amp;NonceManager{
                client:       client,
                address:      common.HexToAddress(config.GetKeeperAddress()),
                logger:       logger,
                syncInterval: 15 * time.Second, // More frequent sync for low latency
                maxRetries:   5,                // More retries for reliability
                baseTimeout:  3 * time.Second,  // Shorter timeout for faster retries
                priorityFee:  big.NewInt(2e9),  // 2 Gwei base priority fee
                pendingTxs:   make(map[uint64]*PendingTransaction),
        }
}</span>

// Initialize sets up the initial nonce
func (nm *NonceManager) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        nm.mu.Lock()
        defer nm.mu.Unlock()

        return nm.syncWithBlockchain(ctx)
}</span>

// GetNextNonce returns the next available nonce atomically
func (nm *NonceManager) GetNextNonce(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        nm.mu.Lock()
        defer nm.mu.Unlock()

        // Sync with blockchain if needed
        if time.Since(nm.lastSyncTime) &gt; nm.syncInterval </span><span class="cov0" title="0">{
                if err := nm.syncWithBlockchain(ctx); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to sync nonce with blockchain: %w", err)
                }</span>
        }

        <span class="cov0" title="0">nonce := nm.currentNonce
        nm.currentNonce++

        nm.logger.Debugf("Allocated nonce: %d", nonce)
        return nonce, nil</span>
}

// syncWithBlockchain updates the current nonce from the blockchain
func (nm *NonceManager) syncWithBlockchain(ctx context.Context) error <span class="cov0" title="0">{
        pendingNonce, err := nm.client.PendingNonceAt(ctx, nm.address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pending nonce: %w", err)
        }</span>

        // Use the higher of pending nonce or our current nonce
        <span class="cov0" title="0">if pendingNonce &gt; nm.currentNonce </span><span class="cov0" title="0">{
                nm.currentNonce = pendingNonce
                nm.logger.Infof("Synced nonce with blockchain: %d", nm.currentNonce)
        }</span>

        <span class="cov0" title="0">nm.lastSyncTime = time.Now()
        return nil</span>
}

// SubmitTransactionWithSmartRetry submits a transaction with intelligent retry logic
func (nm *NonceManager) SubmitTransactionWithSmartRetry(
        ctx context.Context,
        nonce uint64,
        to common.Address,
        data []byte,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        // Check if we should replace an existing transaction
        nm.txMutex.RLock()
        if existingTx, exists := nm.pendingTxs[nonce]; exists &amp;&amp; existingTx.Status == "pending" </span><span class="cov0" title="0">{
                nm.txMutex.RUnlock()

                // If existing tx is older than 30 seconds, replace it
                if time.Since(existingTx.CreatedAt) &gt; 30*time.Second </span><span class="cov0" title="0">{
                        return nm.replaceTransaction(ctx, existingTx, data, to, chainID, privateKey)
                }</span>

                // Otherwise, wait for the existing transaction
                <span class="cov0" title="0">return nm.waitForExistingTransaction(ctx, existingTx)</span>
        }
        <span class="cov0" title="0">nm.txMutex.RUnlock()

        // Submit new transaction
        return nm.submitNewTransaction(ctx, nonce, to, data, chainID, privateKey)</span>
}

// submitNewTransaction submits a new transaction with EIP-1559 support
func (nm *NonceManager) submitNewTransaction(
        ctx context.Context,
        nonce uint64,
        to common.Address,
        data []byte,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        // Get current gas parameters
        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get gas parameters: %w", err)
        }</span>

        // Create transaction (prefer EIP-1559 if supported)
        <span class="cov0" title="0">var tx *types.Transaction
        var signedTx *types.Transaction
        var signErr error

        // Try EIP-1559 first if supported
        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Attempting EIP-1559 transaction with nonce %d", nonce)
                tx = types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     nonce,
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Try to sign EIP-1559 transaction
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("EIP-1559 transaction signing failed, falling back to legacy: %v", signErr)
                }</span>
        }

        // Fallback to legacy transaction if EIP-1559 failed or not supported
        <span class="cov0" title="0">if signedTx == nil || signErr != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Using legacy transaction with nonce %d", nonce)
                if gasPrice == nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("gas price is required for legacy transaction")
                }</span>

                <span class="cov0" title="0">tx = types.NewTransaction(nonce, to, big.NewInt(0), 300000, gasPrice, data)
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to sign legacy transaction: %w", signErr)
                }</span>
        }

        // Track the transaction
        <span class="cov0" title="0">nm.trackTransaction(nonce, signedTx.Hash().Hex(), data, to, chainID, privateKey, gasPrice)

        // Submit with retry logic
        return nm.submitWithRetry(ctx, signedTx, nonce, privateKey)</span>
}

// replaceTransaction replaces a stuck transaction with higher fees
func (nm *NonceManager) replaceTransaction(
        ctx context.Context,
        existingTx *PendingTransaction,
        data []byte,
        to common.Address,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        nm.logger.Infof("Replacing stuck transaction with nonce %d", existingTx.Nonce)

        // Get higher gas parameters for replacement
        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get gas parameters: %w", err)
        }</span>

        // Increase fees by 20% for replacement
        <span class="cov0" title="0">if gasPrice != nil </span><span class="cov0" title="0">{
                gasPrice = new(big.Int).Mul(gasPrice, big.NewInt(120))
                gasPrice = new(big.Int).Div(gasPrice, big.NewInt(100))
        }</span>
        <span class="cov0" title="0">if maxFeePerGas != nil </span><span class="cov0" title="0">{
                maxFeePerGas = new(big.Int).Mul(maxFeePerGas, big.NewInt(120))
                maxFeePerGas = new(big.Int).Div(maxFeePerGas, big.NewInt(100))
        }</span>
        <span class="cov0" title="0">if maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                maxPriorityFeePerGas = new(big.Int).Mul(maxPriorityFeePerGas, big.NewInt(120))
                maxPriorityFeePerGas = new(big.Int).Div(maxPriorityFeePerGas, big.NewInt(100))
        }</span>

        // Create replacement transaction with fallback logic
        <span class="cov0" title="0">var tx *types.Transaction
        var signedTx *types.Transaction
        var signErr error

        // Try EIP-1559 first if supported
        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Attempting EIP-1559 replacement transaction with nonce %d", existingTx.Nonce)
                tx = types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     existingTx.Nonce,
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Try to sign EIP-1559 transaction
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("EIP-1559 replacement transaction signing failed, falling back to legacy: %v", signErr)
                }</span>
        }

        // Fallback to legacy transaction if EIP-1559 failed or not supported
        <span class="cov0" title="0">if signedTx == nil || signErr != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Using legacy replacement transaction with nonce %d", existingTx.Nonce)
                if gasPrice == nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("gas price is required for legacy replacement transaction")
                }</span>

                <span class="cov0" title="0">tx = types.NewTransaction(existingTx.Nonce, to, big.NewInt(0), 300000, gasPrice, data)
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to sign legacy replacement transaction: %w", signErr)
                }</span>
        }

        // Update tracking
        <span class="cov0" title="0">nm.updateTransactionStatus(existingTx.Nonce, signedTx.Hash().Hex(), gasPrice)

        return nm.submitWithRetry(ctx, signedTx, existingTx.Nonce, privateKey)</span>
}

// waitForExistingTransaction waits for an existing transaction to be confirmed
func (nm *NonceManager) waitForExistingTransaction(ctx context.Context, existingTx *PendingTransaction) (*types.Receipt, string, error) <span class="cov0" title="0">{
        nm.logger.Infof("Waiting for existing transaction with nonce %d: %s", existingTx.Nonce, existingTx.TxHash)

        // Wait for the transaction to be confirmed
        receipt, err := bind.WaitMined(ctx, nm.client, &amp;types.Transaction{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to wait for existing transaction: %w", err)
        }</span>

        <span class="cov0" title="0">nm.markTransactionConfirmed(existingTx.Nonce, existingTx.TxHash)
        return receipt, existingTx.TxHash, nil</span>
}

// submitWithRetry handles the actual submission with intelligent retry logic
func (nm *NonceManager) submitWithRetry(ctx context.Context, signedTx *types.Transaction, nonce uint64, privateKey *ecdsa.PrivateKey) (*types.Receipt, string, error) <span class="cov0" title="0">{

        for attempt := 0; attempt &lt; nm.maxRetries; attempt++ </span><span class="cov0" title="0">{
                // Send transaction
                err := nm.client.SendTransaction(ctx, signedTx)
                if err != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("Failed to send transaction (attempt %d): %v", attempt+1, err)

                        // Check if it's a nonce too low error - this means we need to sync
                        if isNonceTooLowError(err) </span><span class="cov0" title="0">{
                                if syncErr := nm.syncWithBlockchain(ctx); syncErr != nil </span><span class="cov0" title="0">{
                                        return nil, "", fmt.Errorf("failed to sync after nonce error: %w", syncErr)
                                }</span>
                        }

                        <span class="cov0" title="0">if attempt == nm.maxRetries-1 </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("failed to send transaction after %d attempts: %v", nm.maxRetries, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">txHash := signedTx.Hash().Hex()
                nm.logger.Infof("Transaction sent (attempt %d): %s", attempt+1, txHash)

                // Wait for confirmation with exponential backoff
                timeout := nm.baseTimeout * time.Duration(1&lt;&lt;attempt) // Exponential backoff
                ctx, cancel := context.WithTimeout(ctx, timeout)
                receipt, err := bind.WaitMined(ctx, nm.client, signedTx)
                cancel()

                if err == nil </span><span class="cov0" title="0">{
                        nm.markTransactionConfirmed(nonce, txHash)
                        nm.logger.Infof("Transaction confirmed: %s", txHash)
                        return receipt, txHash, nil
                }</span>

                // Handle timeout - create replacement with higher fees
                <span class="cov0" title="0">if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        nm.logger.Warnf("Transaction %s timed out after %v, creating replacement", txHash, timeout)

                        // Create replacement transaction with higher fees
                        replacementTx, err := nm.createReplacementTransaction(signedTx, attempt+1, privateKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("failed to create replacement transaction: %w", err)
                        }</span>
                        <span class="cov0" title="0">signedTx = replacementTx
                        continue</span>
                }

                // Other error occurred
                <span class="cov0" title="0">nm.logger.Warnf("Error waiting for transaction %s: %v", txHash, err)
                if attempt == nm.maxRetries-1 </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("transaction failed after %d attempts: %v", nm.maxRetries, err)
                }</span>
        }

        <span class="cov0" title="0">return nil, "", fmt.Errorf("transaction failed after %d attempts", nm.maxRetries)</span>
}

// getOptimalGasParams gets optimal gas parameters for current network conditions
func (nm *NonceManager) getOptimalGasParams(ctx context.Context) (*big.Int, *big.Int, *big.Int, error) <span class="cov0" title="0">{

        // Always get legacy gas price as fallback
        gasPrice, err := nm.client.SuggestGasPrice(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to get gas price: %w", err)
        }</span>

        // Add 20% buffer for network congestion
        <span class="cov0" title="0">gasPrice.Mul(gasPrice, big.NewInt(120))
        gasPrice.Div(gasPrice, big.NewInt(100))

        // Try to get EIP-1559 parameters
        head, err := nm.client.HeaderByNumber(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                nm.logger.Warnf("Failed to get latest header for EIP-1559 detection: %v", err)
                return gasPrice, nil, nil, nil
        }</span>

        // Check if EIP-1559 is supported and base fee is reasonable
        <span class="cov0" title="0">if head.BaseFee != nil &amp;&amp; head.BaseFee.Cmp(big.NewInt(0)) &gt; 0 </span><span class="cov0" title="0">{
                nm.logger.Debugf("EIP-1559 detected with base fee: %s", head.BaseFee.String())

                // Calculate optimal EIP-1559 parameters
                baseFee := head.BaseFee
                maxPriorityFeePerGas := new(big.Int).Set(nm.priorityFee)

                // Calculate max fee per gas (base fee + 2x priority fee for safety)
                maxFeePerGas := new(big.Int).Mul(maxPriorityFeePerGas, big.NewInt(2))
                maxFeePerGas.Add(maxFeePerGas, baseFee)

                // Add 20% buffer for network congestion
                maxFeePerGas.Mul(maxFeePerGas, big.NewInt(120))
                maxFeePerGas.Div(maxFeePerGas, big.NewInt(100))

                return gasPrice, maxFeePerGas, maxPriorityFeePerGas, nil
        }</span>

        <span class="cov0" title="0">nm.logger.Debugf("EIP-1559 not supported, using legacy gas price: %s", gasPrice.String())
        return gasPrice, nil, nil, nil</span>
}

// createReplacementTransaction creates a replacement transaction with higher fees
func (nm *NonceManager) createReplacementTransaction(originalTx *types.Transaction, attempt int, privateKey *ecdsa.PrivateKey) (*types.Transaction, error) <span class="cov0" title="0">{
        // Get the transaction data
        var to common.Address
        var data []byte
        var chainID *big.Int

        switch tx := originalTx.Type(); tx </span>{
        case 0:<span class="cov0" title="0"> // Legacy transaction
                to = *originalTx.To()
                data = originalTx.Data()
                chainID = originalTx.ChainId()</span>
        case 2:<span class="cov0" title="0"> // EIP-1559 transaction
                to = *originalTx.To()
                data = originalTx.Data()
                chainID = originalTx.ChainId()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported transaction type: %d", tx)</span>
        }

        // Get higher gas parameters
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get gas parameters for replacement: %w", err)
        }</span>

        // Increase fees by 20% for each attempt
        <span class="cov0" title="0">feeMultiplier := big.NewInt(int64(120 + (attempt * 20))) // 120%, 140%, 160%, etc.
        feeDivisor := big.NewInt(100)

        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                // EIP-1559 replacement
                maxFeePerGas.Mul(maxFeePerGas, feeMultiplier)
                maxFeePerGas.Div(maxFeePerGas, feeDivisor)
                maxPriorityFeePerGas.Mul(maxPriorityFeePerGas, feeMultiplier)
                maxPriorityFeePerGas.Div(maxPriorityFeePerGas, feeDivisor)

                tx := types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     originalTx.Nonce(),
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Test if we can sign this transaction type
                _, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if err == nil </span><span class="cov0" title="0">{
                        return tx, nil
                }</span>
                <span class="cov0" title="0">nm.logger.Warnf("EIP-1559 replacement transaction signing failed, falling back to legacy: %v", err)</span>
        }

        // Legacy replacement
        <span class="cov0" title="0">if gasPrice == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gas price is required for legacy replacement transaction")
        }</span>

        <span class="cov0" title="0">gasPrice.Mul(gasPrice, feeMultiplier)
        gasPrice.Div(gasPrice, feeDivisor)

        return types.NewTransaction(originalTx.Nonce(), to, big.NewInt(0), 300000, gasPrice, data), nil</span>
}

// Helper methods for transaction tracking
func (nm *NonceManager) trackTransaction(nonce uint64, txHash string, data []byte, to common.Address, chainID *big.Int, privateKey *ecdsa.PrivateKey, gasPrice *big.Int) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        nm.pendingTxs[nonce] = &amp;PendingTransaction{
                Nonce:        nonce,
                TxHash:       txHash,
                CreatedAt:    time.Now(),
                Status:       "pending",
                Attempts:     1,
                LastGasPrice: gasPrice,
                Data:         data,
                To:           to,
                ChainID:      chainID,
                PrivateKey:   privateKey,
        }
}</span>

func (nm *NonceManager) updateTransactionStatus(nonce uint64, txHash string, gasPrice *big.Int) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        if tx, exists := nm.pendingTxs[nonce]; exists </span><span class="cov0" title="0">{
                tx.TxHash = txHash
                tx.Status = "pending"
                tx.Attempts++
                tx.LastGasPrice = gasPrice
                tx.CreatedAt = time.Now()
        }</span>
}

func (nm *NonceManager) markTransactionConfirmed(nonce uint64, txHash string) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        if tx, exists := nm.pendingTxs[nonce]; exists </span><span class="cov0" title="0">{
                tx.Status = "confirmed"
                tx.TxHash = txHash
        }</span>
}

// Utility functions
func isNonceTooLowError(err error) bool <span class="cov0" title="0">{
        errStr := err.Error()
        return strings.Contains(errStr, "nonce too low") ||
                strings.Contains(errStr, "replacement transaction underpriced") ||
                strings.Contains(errStr, "already known")
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package execution

import (
        "bytes"
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"

        // "io/ioutil"
        // "net/http"
        // "reflect"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (e *TaskExecutor) getContractMethodAndABI(methodName string, targetData *types.TaskTargetData) (*abi.ABI, *abi.Method, error) <span class="cov0" title="0">{
        if targetData.ABI == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("contract ABI not provided in job data")
        }</span>

        <span class="cov0" title="0">abiData := []byte(targetData.ABI)

        parsed, err := abi.JSON(bytes.NewReader(abiData))
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Error parsing ABI: %v", err)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">e.logger.Debugf("Using ABI from database for contract %s", targetData.TargetContractAddress)

        method, ok := parsed.Methods[methodName]
        if !ok </span><span class="cov0" title="0">{
                e.logger.Warnf("Method %s not found in contract ABI", methodName)
                return nil, nil, fmt.Errorf("method %s not found in contract ABI", methodName)
        }</span>

        <span class="cov0" title="0">e.logger.Debugf("Found method: %+v", method)
        return &amp;parsed, &amp;method, nil</span>
}

func (e *TaskExecutor) processArguments(args interface{}, methodInputs []abi.Argument, contractABI *abi.ABI) ([]interface{}, error) <span class="cov0" title="0">{
        convertedArgs := make([]interface{}, 0)

        e.logger.Debugf("Processing arguments: %+v for method inputs: %+v", args, methodInputs)

        // Handle nil or empty args
        if args == nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Received nil arguments")
                return nil, fmt.Errorf("nil arguments provided")
        }</span>

        // Check if we have any inputs at all
        <span class="cov0" title="0">if len(methodInputs) == 0 </span><span class="cov0" title="0">{
                e.logger.Debugf("Method has no inputs, returning empty args")
                return convertedArgs, nil
        }</span>

        // Handle the case where we have a single struct argument
        <span class="cov0" title="0">if len(methodInputs) == 1 &amp;&amp; methodInputs[0].Type.T == abi.TupleTy </span><span class="cov0" title="0">{
                // Check if the input is a map or JSON string representing the struct
                switch v := args.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Direct map to struct conversion
                        convertedArg, err := e.argConverter.convertToStruct(v, methodInputs[0].Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting to struct: %v", err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                        return convertedArgs, nil</span>
                case string:<span class="cov0" title="0">
                        // Try to parse as JSON struct
                        var structData map[string]interface{}
                        if err := json.Unmarshal([]byte(v), &amp;structData); err == nil </span><span class="cov0" title="0">{
                                convertedArg, err := e.argConverter.convertToStruct(structData, methodInputs[0].Type)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error converting JSON string to struct: %v", err)
                                }</span>
                                <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                return convertedArgs, nil</span>
                        }
                case []interface{}:<span class="cov0" title="0">
                        // If there's a single array element and it's a map, try to use it as a struct
                        if len(v) == 1 </span><span class="cov0" title="0">{
                                if mapVal, ok := v[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        convertedArg, err := e.argConverter.convertToStruct(mapVal, methodInputs[0].Type)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error converting map from array to struct: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                        return convertedArgs, nil</span>
                                } else<span class="cov0" title="0"> if strVal, ok := v[0].(string); ok </span><span class="cov0" title="0">{
                                        // Try to parse as JSON struct
                                        var structData map[string]interface{}
                                        if err := json.Unmarshal([]byte(strVal), &amp;structData); err == nil </span><span class="cov0" title="0">{
                                                convertedArg, err := e.argConverter.convertToStruct(structData, methodInputs[0].Type)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, fmt.Errorf("error converting JSON string to struct: %v", err)
                                                }</span>
                                                <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                                return convertedArgs, nil</span>
                                        }
                                }
                        }
                }
        }

        // Handle multiple arguments or non-struct arguments
        <span class="cov0" title="0">switch argData := args.(type) </span>{
        case string:<span class="cov0" title="0">
                // Handle a single string value (like from our script)
                // If there's only one input parameter, use the string value directly
                if len(methodInputs) == 1 </span><span class="cov0" title="0">{
                        // First attempt to remove JSON string quotes if present
                        strValue := argData
                        if strings.HasPrefix(strValue, "\"") &amp;&amp; strings.HasSuffix(strValue, "\"") </span><span class="cov0" title="0">{
                                strValue = strings.Trim(strValue, "\"")
                        }</span>

                        <span class="cov0" title="0">convertedArg, err := e.argConverter.convertToType(strValue, methodInputs[0].Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting string argument: %v", err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                        return convertedArgs, nil</span>
                } else<span class="cov0" title="0"> {
                        // Try to parse as JSON array for multiple parameters
                        var arrayData []interface{}
                        if err := json.Unmarshal([]byte(argData), &amp;arrayData); err == nil </span><span class="cov0" title="0">{
                                if len(arrayData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("not enough arguments in JSON array: expected %d, got %d",
                                                len(methodInputs), len(arrayData))
                                }</span>

                                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                                        convertedArg, err := e.argConverter.convertToType(arrayData[i], inputParam.Type)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                                        }</span>
                                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                                }
                                <span class="cov0" title="0">return convertedArgs, nil</span>
                        }

                        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert single string to %d arguments", len(methodInputs))</span>
                }
        case []string:<span class="cov0" title="0">
                // Handle simple string array
                if len(argData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not enough arguments provided: expected %d, got %d",
                                len(methodInputs), len(argData))
                }</span>

                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        convertedArg, err := e.argConverter.convertToType(argData[i], inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        case []interface{}:<span class="cov0" title="0">
                // Handle array of mixed types
                if len(argData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not enough arguments provided: expected %d, got %d",
                                len(methodInputs), len(argData))
                }</span>

                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        convertedArg, err := e.argConverter.convertToType(argData[i], inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        case map[string]interface{}:<span class="cov0" title="0">
                // Handle map of named arguments
                for _, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        paramName := inputParam.Name
                        if paramName == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot use map arguments with unnamed parameters")
                        }</span>

                        <span class="cov0" title="0">argValue, exists := argData[paramName]
                        if !exists </span><span class="cov0" title="0">{
                                // Try with case-insensitive match
                                for k, v := range argData </span><span class="cov0" title="0">{
                                        if strings.EqualFold(k, paramName) </span><span class="cov0" title="0">{
                                                argValue = v
                                                exists = true
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("argument %s not found in input data", paramName)
                                }</span>
                        }

                        <span class="cov0" title="0">convertedArg, err := e.argConverter.convertToType(argValue, inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %s: %v", paramName, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported argument format: %T", args)</span>
        }

        <span class="cov0" title="0">return convertedArgs, nil</span>
}

func (e *TaskExecutor) parseDynamicArgs(output string) []interface{} <span class="cov0" title="0">{
        // First try to parse as JSON
        var argData []interface{}
        if err := json.Unmarshal([]byte(output), &amp;argData); err == nil &amp;&amp; len(argData) &gt; 0 </span><span class="cov0" title="0">{
                e.logger.Debugf("Successfully parsed dynamic arguments as JSON: %v", argData)
                return argData
        }</span>

        // If JSON parsing fails, try to extract values from container logs
        // Look for lines containing "Response:" which typically contain the values we need
        <span class="cov0" title="0">responsePattern := regexp.MustCompile(`Response:\s*([\d\.]+)`)
        matches := responsePattern.FindAllStringSubmatch(output, -1)

        if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                // Extract all response values
                argData = make([]interface{}, 0, len(matches))
                for _, match := range matches </span><span class="cov0" title="0">{
                        if len(match) &gt;= 2 </span><span class="cov0" title="0">{
                                // Try to parse as float first
                                if val, err := strconv.ParseFloat(match[1], 64); err == nil </span><span class="cov0" title="0">{
                                        e.logger.Debugf("Found numeric response value: %v", val)
                                        argData = append(argData, val)
                                        continue</span>
                                }

                                // If not a number, use as string
                                <span class="cov0" title="0">e.logger.Debugf("Found string response value: %s", match[1])
                                argData = append(argData, match[1])</span>
                        }
                }

                <span class="cov0" title="0">if len(argData) &gt; 0 </span><span class="cov0" title="0">{
                        return argData
                }</span>
        }

        // If we can't find "Response:" lines, look for any numeric values
        <span class="cov0" title="0">numericPattern := regexp.MustCompile(`[\d\.]+`)
        numMatches := numericPattern.FindAllString(output, -1)

        if len(numMatches) &gt; 0 </span><span class="cov0" title="0">{
                // Filter out timestamps and other irrelevant numbers
                for _, match := range numMatches </span><span class="cov0" title="0">{
                        if val, err := strconv.ParseFloat(match, 64); err == nil </span><span class="cov0" title="0">{
                                // Only consider "significant" numbers (not small ones that might be timestamps)
                                if val &gt; 100 </span><span class="cov0" title="0">{
                                        e.logger.Debugf("Found significant numeric value: %v", val)
                                        argData = append(argData, val)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(argData) &gt; 0 </span><span class="cov0" title="0">{
                        return argData
                }</span>
        }

        // As a fallback, check for "Condition satisfied: true" pattern
        <span class="cov0" title="0">if strings.Contains(output, "Condition satisfied: true") </span><span class="cov0" title="0">{
                e.logger.Debugf("Found condition satisfied pattern, using true as argument")
                return []interface{}{true}
        }</span>

        <span class="cov0" title="0">e.logger.Warnf("Failed to extract any arguments from output: %s", output)
        return []interface{}{"0"}</span> // Return a default value as fallback
}

func (e *TaskExecutor) parseStaticArgs(args []string) []interface{} <span class="cov0" title="0">{
        var argData []interface{}

        for _, arg := range args </span><span class="cov0" title="0">{
                argData = append(argData, arg)
        }</span>

        <span class="cov0" title="0">return argData</span>
}

// func (e *TaskExecutor) decodeContractOutput(contractABI *abi.ABI, method *abi.Method, output []byte) (interface{}, error) {
//         // Handle different output scenarios
//         if len(method.Outputs) == 0 {
//                 e.logger.Infof("Method %s has no outputs to decode", method.Name)
//                 return nil, nil
//         }

//         // Single output case
//         if len(method.Outputs) == 1 {
//                 outputType := method.Outputs[0]
//                 result := reflect.New(outputType.Type.GetType()).Elem()

//                 err := contractABI.UnpackIntoInterface(result.Addr().Interface(), method.Name, output)
//                 if err != nil {
//                         e.logger.Warnf("Error unpacking single output: %v", err)
//                         return nil, err
//                 }

//                 e.logger.Infof("Decoded single output: %v", result.Interface())
//                 return result.Interface(), nil
//         }

//         // Multiple outputs case
//         results := make([]interface{}, len(method.Outputs))
//         err := contractABI.UnpackIntoInterface(&amp;results, method.Name, output)
//         if err != nil {
//                 e.logger.Warnf("Error unpacking multiple outputs: %v", err)
//                 return nil, err
//         }

//         e.logger.Infof("Decoded multiple outputs: %+v", results)
//         return results, nil
// }

// func (e *JobExecutor) fetchContractABI(contractAddress string) ([]byte, error) {
//         if e.etherscanAPIKey == "" {
//                 return nil, fmt.Errorf("missing Etherscan API key")
//         }

//         // Update the URL to use Optimism Sepolia's API endpoint
//         blockscoutUrl := fmt.Sprintf(
//                 "https://optimism-sepolia.blockscout.com/api?module=contract&amp;action=getabi&amp;address=%s",
//                 contractAddress)

//         resp, err := http.Get(blockscoutUrl)
//         if err != nil || resp.StatusCode != http.StatusOK {
//                 logger.Warnf("Failed to fetch ABI from Blockscout: %v", err)
//                 // Fall back to another source or handle accordingly
//         }

//         defer resp.Body.Close()

//         body, err := ioutil.ReadAll(resp.Body)
//         if err != nil {
//                 return nil, err
//         }

//         var response struct {
//                 Status  string `json:"status"`
//                 Message string `json:"message"`
//                 Result  string `json:"result"`
//         }

//         err = json.Unmarshal(body, &amp;response)
//         if err != nil {
//                 return nil, err
//         }

//         if response.Status != "1" {
//                 return nil, fmt.Errorf("error fetching contract ABI: %s", response.Message)
//         }

//         return []byte(response.Result), nil
// }
</pre>
		
		<pre class="file" id="file84" style="display: none">package validation

import (
        "context"
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/types"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
)

const timeTolerance = 2200 * time.Millisecond
const expirationTimeTolerance = 5 * time.Second

func (v *TaskValidator) ValidateAction(targetData *types.TaskTargetData, triggerData *types.TaskTriggerData, actionData *types.PerformerActionData, client *ethclient.Client, traceID string) (bool, error) <span class="cov0" title="0">{
        // v.logger.Infof("txHash: %s", actionData.ActionTxHash)
        // time.Sleep(10 * time.Second)
        // Fetch the tx details from the action data
        txHash := common.HexToHash(actionData.ActionTxHash)
        receipt, err := client.TransactionReceipt(context.Background(), txHash)
        if err != nil || receipt == nil </span><span class="cov0" title="0">{
                _, isPending, err := client.TransactionByHash(context.Background(), txHash)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to get transaction: %v", err)
                }</span>
                <span class="cov0" title="0">if isPending </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction is pending")
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("transaction is not found")</span>
        }

        // check if the tx is successful
        // if receipt.Status != 1 {
        //         return false, fmt.Errorf("transaction is not successful")
        // }

        // TODO: get the action tx check right
        // check if the tx was made to correct target contract
        // fetch the AA contract address and the transaction from there to complete the flow

        <span class="cov0" title="0">txTimestamp, err := v.getBlockTimestamp(receipt, utils.GetChainRpcUrl(targetData.TargetChainID))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get block timestamp: %v", err)
        }</span>

        // check if the tx was made before expiration time + tolerance
        <span class="cov0" title="0">if txTimestamp.After(triggerData.ExpirationTime.Add(expirationTimeTolerance)) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was made after the expiration time by %v", txTimestamp.Sub(triggerData.ExpirationTime.Add(expirationTimeTolerance)))
        }</span>

        // check if the task was time, if yes, check if it was executed within the time interval + tolerance
        <span class="cov0" title="0">if targetData.TaskDefinitionID == 1 || targetData.TaskDefinitionID == 2 </span><span class="cov0" title="0">{
                if txTimestamp.After(triggerData.NextTriggerTimestamp.Add(timeTolerance)) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction was made after the next execution timestamp by %v", txTimestamp.Sub(triggerData.NextTriggerTimestamp.Add(timeTolerance)))
                }</span>
                // if txTimestamp.Before(triggerData.NextTriggerTimestamp.Add(-timeTolerance)) {
                //         return false, fmt.Errorf("transaction was made before the next execution timestamp by %v", triggerData.NextTriggerTimestamp.Add(-timeTolerance).Sub(txTimestamp))
                // }
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package validation

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"

        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/proof"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (v *TaskValidator) ValidateProof(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        proofData := ipfsData.ProofData
        if proofData == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("proof data is missing")
        }</span>
        <span class="cov0" title="0">if proofData.ProofOfTask == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("proof of task is empty")
        }</span>
        <span class="cov0" title="0">if proofData.CertificateHash == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("certificate hash is empty")
        }</span>

        // Validate TLS certificate by establishing connection to the same host/port
        // that was used during proof generation
        <span class="cov0" title="0">tlsConfig := proof.DefaultTLSProofConfig(config.GetTLSProofHost())
        tlsConfig.TargetPort = config.GetTLSProofPort()

        connState, err := proof.EstablishTLSConnection(tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Warn("Failed to establish TLS connection for validation", "trace_id", traceID, "error", err)
        }</span>
        <span class="cov0" title="0">if connState == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to establish TLS connection for validation")
        }</span>

        // Verify the certificate hash matches what was recorded in the proof
        <span class="cov0" title="0">if len(connState.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no peer certificates found during validation")
        }</span>

        <span class="cov0" title="0">currentCertHash := sha256.Sum256(connState.PeerCertificates[0].Raw)
        currentCertHashStr := hex.EncodeToString(currentCertHash[:])

        if currentCertHashStr != proofData.CertificateHash </span><span class="cov0" title="0">{
                v.logger.Warn("Certificate hash mismatch during validation",
                        "trace_id", traceID,
                        "expected", proofData.CertificateHash,
                        "actual", currentCertHashStr)
                // Certificate might have been renewed, this is not necessarily an error
                // but should be logged for investigation
        }</span>

        // Validate the proof hash by regenerating it
        <span class="cov0" title="0">return v.validateProofHash(ipfsData, traceID)</span>
}

func (v *TaskValidator) validateProofHash(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        // Create a copy of IPFS data without the proof for hash validation
        ipfsDataForValidation := types.IPFSData{
                TaskData:           ipfsData.TaskData,
                ActionData:         ipfsData.ActionData,
                ProofData:          &amp;types.ProofData{},
                PerformerSignature: &amp;types.PerformerSignatureData{},
        }
        ipfsDataForValidation.ProofData.TaskID = ipfsData.TaskData.TaskID[0]
        ipfsDataForValidation.PerformerSignature.TaskID = ipfsData.TaskData.TaskID[0]
        ipfsDataForValidation.PerformerSignature.PerformerSigningAddress = ipfsData.PerformerSignature.PerformerSigningAddress

        // Regenerate the proof hash
        // dataStr, err := proof.StringifyIPFSData(ipfsDataForValidation)
        // if err != nil {
        //         return false, fmt.Errorf("failed to stringify IPFS data for validation: %w", err)
        // }

        // expectedProofHash := sha256.Sum256([]byte(dataStr))
        // expectedProofHashStr := hex.EncodeToString(expectedProofHash[:])

        // if expectedProofHashStr != ipfsData.ProofData.ProofOfTask {
        //         return false, fmt.Errorf("proof hash validation failed: expected %s, got %s",
        //                 expectedProofHashStr, ipfsData.ProofData.ProofOfTask)
        // }

        v.logger.Info("Proof validation passed", "trace_id", traceID, "task_id", ipfsData.TaskData.TaskID)
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package validation

import (
        "encoding/base64"
        "encoding/json"
        "fmt"

        "github.com/prysmaticlabs/prysm/v5/crypto/bls"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (v *TaskValidator) ValidateManagerSignature(task *types.SendTaskDataToKeeper, traceID string) (bool, error) <span class="cov0" title="0">{
        logger := v.logger.With("traceID", traceID)

        // check if the manager signature is valid
        if task.ManagerSignature == "" </span><span class="cov0" title="0">{
                logger.Error("Manager signature data is missing")
                return false, fmt.Errorf("manager signature data is missing")
        }</span>

        // Create a copy of the task data without the signature for verification
        <span class="cov0" title="0">taskDataForVerification := types.SendTaskDataToKeeper{
                TaskID:        task.TaskID,
                PerformerData: task.PerformerData,
                TargetData:    task.TargetData,
                TriggerData:   task.TriggerData,
                SchedulerID:   task.SchedulerID,
        }

        // Convert the task data to JSON message format (same as signing process)
        isValid, err := cryptography.VerifySignatureFromJSON(
                taskDataForVerification,
                task.ManagerSignature,
                config.GetManagerSigningAddress(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to verify manager signature", "error", err)
                return false, fmt.Errorf("failed to verify manager signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("Manager signature verification failed")
                return false, fmt.Errorf("manager signature verification failed")
        }</span>

        <span class="cov0" title="0">logger.Info("Manager signature verification successful")
        return true, nil</span>
}

func (v *TaskValidator) ValidatePerformerSignature(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        logger := v.logger.With("traceID", traceID)

        if ipfsData.PerformerSignature == nil </span><span class="cov0" title="0">{
                logger.Error("Performer signature data is missing")
                return false, fmt.Errorf("performer signature data is missing")
        }</span>

        <span class="cov0" title="0">if ipfsData.PerformerSignature.PerformerSignature == "" </span><span class="cov0" title="0">{
                logger.Error("Performer signature is empty")
                return false, fmt.Errorf("performer signature is empty")
        }</span>

        <span class="cov0" title="0">if ipfsData.PerformerSignature.PerformerSigningAddress == "" </span><span class="cov0" title="0">{
                logger.Error("Performer signing address is empty")
                return false, fmt.Errorf("performer signing address is empty")
        }</span>

        // TODO: Uncomment this when we have a way to get the Consensus address to perform the action with AA
        // check if the performer is the same as the the one assigned to the task
        // if ipfsData.PerformerSignature.PerformerSigningAddress != ipfsData.TaskData.PerformerData.KeeperAddress {
        //         return false, fmt.Errorf("performer signing address does not match the assigned performer")
        // }

        // Create a copy of the ipfs data without the signature for verification
        <span class="cov0" title="0">ipfsDataForVerification := types.IPFSData{
                TaskData:   ipfsData.TaskData,
                ActionData: ipfsData.ActionData,
                ProofData:  ipfsData.ProofData,
                PerformerSignature: &amp;types.PerformerSignatureData{
                        TaskID:                  ipfsData.PerformerSignature.TaskID,
                        PerformerSigningAddress: ipfsData.PerformerSignature.PerformerSigningAddress,
                        // Note: PerformerSignature field is intentionally left empty for verification
                },
        }

        // Convert the ipfs data to JSON message format (same as signing process)
        ipfsDataBytes, err := json.Marshal(ipfsDataForVerification)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to marshal ipfs data for verification", "error", err)
                return false, fmt.Errorf("failed to marshal ipfs data for verification: %w", err)
        }</span>

        // Decode the base64-encoded signature
        <span class="cov0" title="0">signatureBytes, err := base64.StdEncoding.DecodeString(ipfsData.PerformerSignature.PerformerSignature)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decode base64 signature", "error", err)
                return false, fmt.Errorf("failed to decode base64 signature: %w", err)
        }</span>
        <span class="cov0" title="0">v.logger.Info("Signature bytes", "signatureBytes", signatureBytes)
        v.logger.Info("Signature bytes length", "signatureBytesLength", len(signatureBytes))
        signature, err := bls.SignatureFromBytes(signatureBytes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse BLS signature", "error", err)
                return false, fmt.Errorf("failed to parse BLS signature: %w", err)
        }</span>

        // Decode the base64-encoded public key
        <span class="cov0" title="0">publicKeyBytes, err := base64.StdEncoding.DecodeString(ipfsData.PerformerSignature.PerformerSigningAddress)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decode base64 public key", "error", err)
                return false, fmt.Errorf("failed to decode base64 public key: %w", err)
        }</span>
        <span class="cov0" title="0">publicKey, err := bls.PublicKeyFromBytes(publicKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse BLS public key", "error", err)
                return false, fmt.Errorf("failed to parse BLS public key: %w", err)
        }</span>

        // Hash the message to 32 bytes for BLS verification
        <span class="cov0" title="0">var messageHash [32]byte
        copy(messageHash[:], ipfsDataBytes)

        // Verify the BLS signature
        isValid := signature.Verify(publicKey, messageHash[:])
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to verify BLS signature", "error", err)
                return false, fmt.Errorf("failed to verify BLS signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("Performer signature verification failed")
                return false, fmt.Errorf("performer signature verification failed")
        }</span>

        <span class="cov0" title="0">logger.Info("Performer signature verification successful")
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package validation

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// Supported condition types
const (
        ConditionGreaterThan  = "greater_than"
        ConditionLessThan     = "less_than"
        ConditionBetween      = "between"
        ConditionEquals       = "equals"
        ConditionNotEquals    = "not_equals"
        ConditionGreaterEqual = "greater_equal"
        ConditionLessEqual    = "less_equal"
)

func (e *TaskValidator) ValidateTrigger(triggerData *types.TaskTriggerData, traceID string) (bool, error) <span class="cov0" title="0">{
        e.logger.Info("Validating trigger data", "task_id", triggerData.TaskID, "trace_id", traceID)

        switch triggerData.TaskDefinitionID </span>{
        case 1, 2:<span class="cov0" title="0">
                isValid, err := e.IsValidTimeBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        case 3, 4:<span class="cov0" title="0">
                isValid, err := e.IsValidEventBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        case 5, 6:<span class="cov0" title="0">
                isValid, err := e.IsValidConditionBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid task definition id: %d", triggerData.TaskDefinitionID)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidTimeBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>

        // rest validation is handled when we validate the action

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidEventBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>

        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(triggerData.EventChainId)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to connect to chain: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Check if the contract exists on chain
        contractCode, err := client.CodeAt(context.Background(), common.HexToAddress(triggerData.EventTriggerContractAddress), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check contract existence: %v", err)
        }</span>

        <span class="cov0" title="0">if len(contractCode) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no contract found at address: %s", triggerData.EventTriggerContractAddress)
        }</span>

        // check if the tx is successful
        <span class="cov0" title="0">txHash := common.HexToHash(triggerData.EventTxHash)
        receipt, err := client.TransactionReceipt(context.Background(), txHash)
        if err != nil </span><span class="cov0" title="0">{
                _, isPending, err := client.TransactionByHash(context.Background(), txHash)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to get transaction: %v", err)
                }</span>
                <span class="cov0" title="0">if isPending </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction is pending")
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("transaction is not found")</span>
        }

        // check if the tx is successful
        <span class="cov0" title="0">if receipt.Status != 1 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction is not successful")
        }</span>

        // check if the tx was made to correct target contract
        <span class="cov0" title="0">if receipt.Logs[0].Address != common.HexToAddress(triggerData.EventTriggerContractAddress) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was not made to correct target contract")
        }</span>

        <span class="cov0" title="0">txTimestamp, err := v.getBlockTimestamp(receipt, rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get block timestamp: %v", err)
        }</span>

        <span class="cov0" title="0">expirationTime := triggerData.ExpirationTime.UTC()

        if txTimestamp.After(expirationTime.Add(timeTolerance)) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was made after the expiration time (tx: %v, exp+tolerance: %v)",
                        txTimestamp.Format(time.RFC3339),
                        expirationTime.Add(timeTolerance).Format(time.RFC3339))
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidConditionBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>
        // v.logger.Infof("trigger data: %+v", triggerData)
        <span class="cov0" title="0">v.logger.Infof("value: %v | upper limit: %v | lower limit: %v", triggerData.ConditionSatisfiedValue, triggerData.ConditionUpperLimit, triggerData.ConditionLowerLimit)

        // check if the condition was satisfied by the value
        if triggerData.ConditionType == ConditionEquals </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue == triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionNotEquals </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue != triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionGreaterThan </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt; triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionLessThan </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &lt; triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionGreaterEqual </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt;= triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionLessEqual </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &lt;= triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionBetween </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt;= triggerData.ConditionLowerLimit &amp;&amp; triggerData.ConditionSatisfiedValue &lt;= triggerData.ConditionUpperLimit, nil
        }</span>

        // TODO: add: to fetch the data at trigger timestamp, and check if the values fetched is true
        // oracles would be easy, apis would not be possible if there is no support for it

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package validation

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"

        ethtypes "github.com/ethereum/go-ethereum/core/types"
)

func (v *TaskValidator) getBlockTimestamp(receipt *ethtypes.Receipt, rpcURL string) (time.Time, error) <span class="cov0" title="0">{
        blockNumberHex := fmt.Sprintf("0x%x", receipt.BlockNumber)
        reqBody := map[string]interface{}{
                "jsonrpc": "2.0",
                "method":  "eth_getBlockByNumber",
                "params": []interface{}{
                        blockNumberHex,
                        false,
                },
                "id": 1,
        }
        reqBytes, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to marshal eth_getBlockReceipts request: %v", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequest("POST", rpcURL, bytes.NewBuffer(reqBytes))
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to create eth_getBlockReceipts request: %v", err)
        }</span>
        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        httpClient := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to call eth_getBlockReceipts: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return time.Time{}, fmt.Errorf("eth_getBlockReceipts returned status %d: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var rpcResp struct {
                Result json.RawMessage `json:"result"`
                Error  interface{}     `json:"error"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;rpcResp); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to decode eth_getBlockReceipts response: %v", err)
        }</span>
        <span class="cov0" title="0">if rpcResp.Error != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("eth_getBlockReceipts error: %v", rpcResp.Error)
        }</span>

        <span class="cov0" title="0">var block map[string]interface{}
        if err := json.Unmarshal(rpcResp.Result, &amp;block); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to unmarshal block: %v", err)
        }</span>

        <span class="cov0" title="0">timestampHex, ok := block["timestamp"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("block timestamp is not a string")
        }</span>
        <span class="cov0" title="0">timestampInt, err := strconv.ParseInt(timestampHex, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to parse block timestamp hex: %v", err)
        }</span>
        <span class="cov0" title="0">txTimestamp := time.Unix(timestampInt, 0).UTC()

        return txTimestamp, nil</span>
}

// func (v *TaskValidator) fetchContractABI(contractAddress string) (string, error) {
//         blockscoutUrl := fmt.Sprintf(
//                 "https://optimism-sepolia.blockscout.com/api?module=contract&amp;action=getabi&amp;address=%s",
//                 contractAddress)

//         resp, err := http.Get(blockscoutUrl)
//         if err == nil &amp;&amp; resp.StatusCode == http.StatusOK {
//                 defer func() {
//                         _ = resp.Body.Close()
//                 }()

//                 body, err := io.ReadAll(resp.Body)
//                 if err == nil {
//                         var response struct {
//                                 Status  string `json:"status"`
//                                 Message string `json:"message"`
//                                 Result  string `json:"result"`
//                         }

//                         err = json.Unmarshal(body, &amp;response)
//                         if err == nil &amp;&amp; response.Status == "1" {
//                                 return response.Result, nil
//                         }
//                 }
//         }
//         etherscanUrl := fmt.Sprintf(
//                 "https://api-sepolia-optimism.etherscan.io/api?module=contract&amp;action=getabi&amp;address=%s&amp;apikey=%s",
//                 contractAddress, v.etherscanAPIKey)

//         resp, err = http.Get(etherscanUrl)
//         if err != nil {
//                 return "", fmt.Errorf("failed to fetch ABI from both APIs: %v", err)
//         }
//         defer func() {
//                 _ = resp.Body.Close()
//         }()

//         if resp.StatusCode != http.StatusOK {
//                 return "", fmt.Errorf("failed to fetch ABI from both APIs, Etherscan status code: %d", resp.StatusCode)
//         }

//         body, err := io.ReadAll(resp.Body)
//         if err != nil {
//                 return "", fmt.Errorf("failed to read Etherscan response body: %v", err)
//         }

//         var response struct {
//                 Status  string `json:"status"`
//                 Message string `json:"message"`
//                 Result  string `json:"result"`
//         }

//         err = json.Unmarshal(body, &amp;response)
//         if err != nil {
//                 return "", fmt.Errorf("failed to parse Etherscan JSON response: %v", err)
//         }

//         if response.Status != "1" {
//                 return "", fmt.Errorf("error from both APIs, Etherscan error: %s", response.Message)
//         }

//         return response.Result, nil
// }
</pre>
		
		<pre class="file" id="file89" style="display: none">package validation

import (
        "context"

        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/docker"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type TaskValidator struct {
        alchemyAPIKey    string
        etherscanAPIKey  string
        dockerManager    *docker.DockerManager
        logger           logging.Logger
}

func NewTaskValidator(alchemyAPIKey string, etherscanAPIKey string, dockerManager *docker.DockerManager, logger logging.Logger) *TaskValidator <span class="cov0" title="0">{
        return &amp;TaskValidator{
                alchemyAPIKey:    alchemyAPIKey,
                etherscanAPIKey:  etherscanAPIKey,
                dockerManager:    dockerManager,
                logger:           logger,
        }
}</span>

func (v *TaskValidator) ValidateTask(ctx context.Context, ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        // check if the scheduler signature is valid
        isManagerSignatureTrue, err := v.ValidateManagerSignature(ipfsData.TaskData, traceID)
        if !isManagerSignatureTrue </span><span class="cov0" title="0">{
                v.logger.Error("Manager signature validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Scheduler signature validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        rpcURL := utils.GetChainRpcUrl(ipfsData.TaskData.TargetData[0].TargetChainID)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Error("Failed to connect to chain", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // check if trigger is valid
        isTriggerTrue, err := v.ValidateTrigger(&amp;ipfsData.TaskData.TriggerData[0], traceID)
        if !isTriggerTrue </span><span class="cov0" title="0">{
                v.logger.Error("Trigger validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Trigger validation successful", "traceID", traceID)

        // check if the action is valid
        isActionTrue, err := v.ValidateAction(&amp;ipfsData.TaskData.TargetData[0], &amp;ipfsData.TaskData.TriggerData[0], ipfsData.ActionData, client, traceID)
        if !isActionTrue </span><span class="cov0" title="0">{
                v.logger.Error("Action validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Action validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        // validate the proof data
        isProofTrue, err := v.ValidateProof(ipfsData, traceID)
        if !isProofTrue </span><span class="cov0" title="0">{
                v.logger.Error("Proof validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Proof validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        // check if the performer signature is valid
        isPerformerSignatureTrue, err := v.ValidatePerformerSignature(ipfsData, traceID)
        if !isPerformerSignatureTrue </span><span class="cov0" title="0">{
                v.logger.Error("Performer signature validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Target validation successful", "traceID", traceID)

        return true, nil</span>
}

// ValidateTarget validates a target
func (v *TaskValidator) ValidateTarget(targetData *types.TaskTargetData, traceID string) (bool, error) <span class="cov0" title="0">{
        // TODO: Implement target validation
        return true, nil
}</span>

// GetDockerManager returns the DockerManager instance
func (v *TaskValidator) GetDockerManager() *docker.DockerManager <span class="cov0" title="0">{
        return v.dockerManager
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package keeper

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        ethtypes "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/imua-xyz/imua-avs-sdk/client/txmgr"
        "github.com/imua-xyz/imua-avs-sdk/nodeapi"
        "github.com/imua-xyz/imua-avs-sdk/signer"
        avs "github.com/trigg3rX/imua-contracts/bindings/contracts"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/api/handlers"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/chainio"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Keeper struct {
        logger      logging.Logger
        ethClient   *ethclient.Client
        ethWsClient *ethclient.Client
        nodeApi     *nodeapi.NodeApi
        avsReader   chainio.AvsReader
        avsWriter   chainio.AvsWriter
        ctx         context.Context
        cancel      context.CancelFunc
}

func NewKeeper(logger logging.Logger) *Keeper <span class="cov0" title="0">{
        ethClient, err := ethclient.Dial(config.GetEthRPCUrl())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to connect to Ethereum: %v", err)
                return nil
        }</span>
        <span class="cov0" title="0">ethWsClient, err := ethclient.Dial(config.GetEthWsUrl())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to connect to Ethereum: %v", err)
                return nil
        }</span>
        <span class="cov0" title="0">chainId, err := ethClient.ChainID(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Cannot get chainId", "err", err)
                return nil
        }</span>

        // Setup Node Api
        <span class="cov0" title="0">nodeApi := nodeapi.NewNodeApi(config.GetAvsName(), config.GetSemVer(), config.GetOperatorNodeApiPort(), logger)
        signer, _, err := signer.SignerFromConfig(signer.Config{
                PrivateKey: config.GetPrivateKeyController(),
        },
                chainId,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">txMgr := txmgr.NewSimpleTxManager(ethClient, logger, signer, common.HexToAddress(config.GetKeeperAddress()))
        avsReader, _ := chainio.BuildChainReader(
                common.HexToAddress(config.GetAvsGovernanceAddress()),
                ethClient,
                logger)

        avsWriter, _ := chainio.BuildChainWriter(
                common.HexToAddress(config.GetAvsGovernanceAddress()),
                ethClient,
                logger,
                txMgr)

        // Create context for shutdown handling
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;Keeper{
                logger:      logger,
                ethClient:   ethClient,
                ethWsClient: ethWsClient,
                nodeApi:     nodeApi,
                avsReader:   avsReader,
                avsWriter:   avsWriter,
                ctx:         ctx,
                cancel:      cancel,
        }</span>
}

func (k *Keeper) Start(ctx context.Context) error <span class="cov0" title="0">{
        k.logger.Infof("Starting operator.")
        // k.nodeApi.Start()

        query := ethereum.FilterQuery{
                Addresses: []common.Address{common.HexToAddress(config.GetAvsGovernanceAddress())},
        }
        logs := make(chan ethtypes.Log)

        sub, err := k.ethWsClient.SubscribeFilterLogs(context.Background(), query, logs)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Subscribe failed", "err", err)
                return err
        }</span>
        <span class="cov0" title="0">defer sub.Unsubscribe()

        k.logger.Infof("Starting event monitoring...")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        k.logger.Info("Shutdown signal received, stopping keeper")
                        return ctx.Err()</span>
                case err := &lt;-sub.Err():<span class="cov0" title="0">
                        k.logger.Error("Subscription error:", err)</span>
                case vLog := &lt;-logs:<span class="cov0" title="0">
                        event, err := k.parseEvent(vLog)
                        if err != nil </span><span class="cov0" title="0">{
                                k.logger.Info("Not as expected TaskCreated log, parse err:", "err", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">if event != nil </span><span class="cov0" title="0">{
                                e := event.(*avs.TriggerXAvsTaskCreated)
                                // Process the task creation event
                                k.ProcessNewTaskCreatedLog(e)
                        }</span>
                }
        }
}

func (k *Keeper) parseEvent(vLog ethtypes.Log) (interface{}, error) <span class="cov0" title="0">{
        // Create a filterer to parse events
        filterer, err := avs.NewTriggerXAvsFilterer(common.HexToAddress(config.GetAvsGovernanceAddress()), k.ethClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create filterer: %w", err)
        }</span>

        // Try to parse as TaskCreated event
        <span class="cov0" title="0">event, err := filterer.ParseTaskCreated(vLog)
        if err == nil </span><span class="cov0" title="0">{
                return event, nil
        }</span>

        // If it's not a TaskCreated event, return nil
        <span class="cov0" title="0">return nil, fmt.Errorf("event is not a TaskCreated event")</span>
}

// ProcessNewTaskCreatedLog processes a new task creation event
func (k *Keeper) ProcessNewTaskCreatedLog(e *avs.TriggerXAvsTaskCreated) <span class="cov0" title="0">{
        k.logger.Info("Processing new task created event",
                "taskID", e.TaskId.Uint64(),
                "definitionHash", fmt.Sprintf("0x%x", e.TaskDefinitionId))

        validateRequest := handlers.TaskValidationRequest{
                Data: string(e.TaskData),
        }
        jsonData, err := json.Marshal(validateRequest)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to marshal validate request", "err", err)
                return
        }</span>
        <span class="cov0" title="0">request, err := http.NewRequest("POST", "http://localhost:"+config.GetOperatorRPCPort()+"/task/validate", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to create request", "err", err)
                return
        }</span>
        <span class="cov0" title="0">request.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{}
        response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to send request", "err", err)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := response.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to close response body", "err", err)
                }</span>
        }()

        <span class="cov0" title="0">body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to read response body", "err", err)
                return
        }</span>

        <span class="cov0" title="0">var validationResponse handlers.ValidationResponse
        err = json.Unmarshal(body, &amp;validationResponse)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to unmarshal response body", "err", err)
                return
        }</span>

        <span class="cov0" title="0">if validationResponse.Data </span><span class="cov0" title="0">{
                k.logger.Info("Task is valid", "taskNumber", e.TaskId.Uint64())
        }</span> else<span class="cov0" title="0"> {
                k.logger.Error("Task is invalid", "taskNumber", e.TaskId.Uint64())
        }</span>

        <span class="cov0" title="0">signature, responseBytes, err := k.SignTaskResponse(TaskResponse{
                TaskID:  e.TaskId.Uint64(),
                IsValid: validationResponse.Data,
        })
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Failed to sign task response", "err", err)
                return
        }</span>

        <span class="cov0" title="0">taskInfo, _ := k.avsReader.GetTaskInfo(&amp;bind.CallOpts{}, config.GetAvsGovernanceAddress(), e.TaskId.Uint64())
        go func() </span><span class="cov0" title="0">{
                _, err := k.SendSignedTaskResponseToChain(k.ctx, e.TaskId.Uint64(), responseBytes, signature, taskInfo)
                if err != nil </span><span class="cov0" title="0">{
                        k.logger.Error("Failed to send signed task response to chain", "err", err)
                }</span>
        }()
}

func (k *Keeper) SignTaskResponse(taskResponse TaskResponse) ([]byte, []byte, error) <span class="cov0" title="0">{
        taskResponseHash, data, err := GetTaskResponseDigestEncodeByAbi(taskResponse)
        if err != nil </span><span class="cov0" title="0">{
                k.logger.Error("Error SignTaskResponse with getting task response header hash. skipping task (this is not expected and should be investigated)", "err", err)
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">msgBytes := taskResponseHash[:]

        sig := config.GetConsensusKeyPair().Sign(msgBytes)

        return sig.Marshal(), data, nil</span>
}

func (k *Keeper) SendSignedTaskResponseToChain(
        ctx context.Context,
        taskId uint64,
        taskResponse []byte,
        blsSignature []byte,
        taskInfo avs.TaskInfo) (string, error) <span class="cov0" title="0">{

        startingEpoch := taskInfo.StartingEpoch
        taskResponsePeriod := taskInfo.TaskResponsePeriod
        taskStatisticalPeriod := taskInfo.TaskStatisticalPeriod

        // Track submission status for each phase
        phaseOneSubmitted := false
        phaseTwoSubmitted := false

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        k.logger.Info("Shutdown signal received, stopping task response submission", "taskId", taskId)
                        return "", ctx.Err()</span> // Gracefully exit if context is canceled
                default:<span class="cov0" title="0">
                        // Fetch the current epoch information
                        epochIdentifier, err := k.avsReader.GetAVSEpochIdentifier(&amp;bind.CallOpts{}, taskInfo.TaskContractAddress.String())
                        if err != nil </span><span class="cov0" title="0">{
                                k.logger.Error("Cannot GetAVSEpochIdentifier", "err", err)
                                return "", fmt.Errorf("failed to get AVS info: %w", err) // Stop on persistent error
                        }</span>

                        <span class="cov0" title="0">num, err := k.avsReader.GetCurrentEpoch(&amp;bind.CallOpts{}, epochIdentifier)
                        if err != nil </span><span class="cov0" title="0">{
                                k.logger.Error("Cannot exec GetCurrentEpoch", "err", err)
                                return "", fmt.Errorf("failed to get current epoch: %w", err) // Stop on persistent error
                        }</span>

                        <span class="cov0" title="0">currentEpoch := uint64(num)
                        // k.logger.Info("current epoch  is :", "currentEpoch", currentEpoch)
                        if currentEpoch &gt; startingEpoch+taskResponsePeriod+taskStatisticalPeriod </span><span class="cov0" title="0">{
                                k.logger.Info("Exiting loop: Task period has passed",
                                        "Task", taskInfo.TaskContractAddress.String()+"--"+strconv.FormatUint(taskId, 10))
                                return "The current task period has passed:", nil
                        }</span>

                        <span class="cov0" title="0">switch </span>{
                        case currentEpoch &lt;= startingEpoch:<span class="cov0" title="0">
                                // k.logger.Info("current epoch is less than or equal to the starting epoch", "currentEpoch", currentEpoch, "startingEpoch", startingEpoch, "taskId", taskId)
                                time.Sleep(config.GetRetryDelay())</span>

                        case currentEpoch &lt;= startingEpoch+taskResponsePeriod:<span class="cov0" title="0">
                                if !phaseOneSubmitted </span><span class="cov0" title="0">{
                                        k.logger.Info("Execute Phase One Submission Task", "currentEpoch", currentEpoch,
                                                "startingEpoch", startingEpoch, "taskResponsePeriod", taskResponsePeriod, "taskId", taskId)
                                        k.logger.Info("Submitting task response for task response period",
                                                "taskAddr", config.GetAvsGovernanceAddress(), "taskId", taskId, "operator-addr", config.GetKeeperAddress())
                                        _, err := k.avsWriter.OperatorSubmitTask(
                                                ctx,
                                                taskId,
                                                nil,
                                                blsSignature,
                                                config.GetAvsGovernanceAddress(),
                                                1)
                                        if err != nil </span><span class="cov0" title="0">{
                                                k.logger.Error("Avs failed to OperatorSubmitTask", "err", err, "taskId", taskId)
                                                return "", fmt.Errorf("failed to submit task during taskResponsePeriod: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">phaseOneSubmitted = true
                                        k.logger.Info("Successfully submitted task response for phase one", "taskId", taskId)</span>
                                } else<span class="cov0" title="0"> {
                                        // k.logger.Info("Phase One already submitted", "taskId", taskId)
                                        time.Sleep(config.GetRetryDelay())
                                }</span>

                        case currentEpoch &lt;= startingEpoch+taskResponsePeriod+taskStatisticalPeriod &amp;&amp; currentEpoch &gt; startingEpoch+taskResponsePeriod:<span class="cov0" title="0">
                                if !phaseTwoSubmitted </span><span class="cov0" title="0">{
                                        k.logger.Info("Execute Phase Two Submission Task", "currentEpoch", currentEpoch,
                                                "startingEpoch", startingEpoch, "taskResponsePeriod", taskResponsePeriod, "taskStatisticalPeriod", taskStatisticalPeriod, "taskId", taskId)
                                        k.logger.Info("Submitting task response for statistical period",
                                                "taskAddr", config.GetAvsGovernanceAddress(), "taskId", taskId, "operator-addr", config.GetKeeperAddress())
                                        _, err := k.avsWriter.OperatorSubmitTask(
                                                ctx,
                                                taskId,
                                                taskResponse,
                                                blsSignature,
                                                config.GetAvsGovernanceAddress(),
                                                2)
                                        if err != nil </span><span class="cov0" title="0">{
                                                k.logger.Error("Avs failed to OperatorSubmitTask", "err", err, "taskId", taskId)
                                                return "", fmt.Errorf("failed to submit task during statistical period: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">phaseTwoSubmitted = true
                                        k.logger.Info("Successfully submitted task response for phase two", "taskId", taskId)</span>
                                } else<span class="cov0" title="0"> {
                                        // k.logger.Info("Phase Two already submitted", "taskId", taskId)
                                        time.Sleep(config.GetRetryDelay())
                                }</span>

                        default:<span class="cov0" title="0">
                                k.logger.Info("Current epoch is not within expected range", "currentEpoch", currentEpoch, "taskId", taskId)
                                return "", fmt.Errorf("current epoch %d is not within expected range %d", currentEpoch, startingEpoch)</span>
                        }

                        // If both phases are submitted, exit the loop
                        <span class="cov0" title="0">if phaseOneSubmitted &amp;&amp; phaseTwoSubmitted </span><span class="cov0" title="0">{
                                k.logger.Info("Both phases completed successfully", "taskId", taskId)
                                return "Both task response phases completed successfully", nil
                        }</span>

                        // Add a small delay to prevent tight looping, but respect shutdown context
                        <span class="cov0" title="0">time.Sleep(config.GetRetryDelay())</span>
                }
        }
}

func (k *Keeper) Close() <span class="cov0" title="0">{
        k.logger.Info("Shutting down keeper...")
        k.cancel() // Cancel the context to signal shutdown to all goroutines
        // k.nodeApi.Stop()
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "uptime_seconds",
                Help:      "The uptime of the keeper service in seconds",
        })

        // Total task processing requests on keeper API server
        TasksReceivedTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_received_total",
                Help:      "Total tasks received",
        })

        // Totla task completed successfully, type: executed, validated
        TasksCompletedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_completed_total",
                Help:      "Total tasks completed",
        }, []string{"type"})

        // Time taken for task completion, type: executed, validated
        TaskDurationSeconds = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "task_duration_seconds",
                Help:      "Time taken for task completion",
                Buckets:   prometheus.DefBuckets,
        }, []string{"type"})

        // Total tasks validated by type/id: 1-6
        TasksByDefinitionIDTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_by_definition_id_total",
                Help:      "Tasks validated by type/id",
        }, []string{"id"})

        // Transaction metrics
        TransactionsSentTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "transactions_sent_total",
                Help:      "Total transactions done for task executions",
        }, []string{"chain_id", "status"})
        GasUsedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "gas_used_total",
                Help:      "Total gas used in transactions",
        }, []string{"chain_id"})
        TransactionFeesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "transaction_fees_total",
                Help:      "Total transaction fee incurred in transactions",
        }, []string{"chain_id"})

        // IPFS metrics
        IPFSDownloadSizeBytes = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "ipfs_download_size_bytes",
                Help:      "Total IPFS content downloaded",
        })
        IPFSUploadSizeBytes = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "ipfs_upload_size_bytes",
                Help:      "Total IPFS content uploaded",
        })

        // Health metrics
        SuccessfulHealthCheckinsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "successful_health_checkins_total",
                Help:      "Total successful health checkins",
        })

        // System metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization",
        })

        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Docker metrics
        DockerContainersCreatedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "docker_containers_created_total",
                Help:      "Docker container creation count",
        }, []string{"language"})
        
        DockerContainerDurationSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "docker_container_duration_seconds",
                Help:      "Container execution time",
        }, []string{"language"})

        // Aggregate metrics
        TaskSuccessRate = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "task_success_rate",
                Help:      "Overall task success percentage",
        }, []string{"type"})

        // Average task completion time in seconds, type: executed, validated
        // AverageTaskCompletionTimeSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
        //         Namespace: "triggerx",
        //         Subsystem: "keeper",
        //         Name:      "average_task_completion_time_seconds",
        //         Help:      "Mean completion time",
        // }, []string{"type"})

        // Tasks per minute, type: executed, validated
        TasksPerDay = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_per_day",
                Help:      "Task throughput rate",
        }, []string{"type"})

        // Total service restarts
        RestartsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "restarts_total",
                Help:      "Service restart count",
        })
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()

        // Reset metrics every day
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        TasksPerDay.Reset()
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package keeper

import (
        "bytes"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math/big"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/cosmos/btcutil/bech32"
        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "gopkg.in/yaml.v3"
)

var (
        taskResponseType, _ = abi.NewType("tuple", "struct", []abi.ArgumentMarshaling{
                {Name: "TaskID", Type: "uint64"},
                {Name: "IsValid", Type: "bool"},
        })

        Args = abi.Arguments{
                {Type: taskResponseType, Name: "TaskResponse"},
        }
)

type TaskResponse struct {
        TaskID  uint64
        IsValid bool
}

const BLSMessageToSign = "BLS12-381 Signed Message\nChainIDWithoutRevision: %s\nAccAddressBech32: %s"

func AbiEncode(resp TaskResponse) ([]byte, error) <span class="cov0" title="0">{

        abiArgs := abi.Arguments{
                {Name: "taskID", Type: mustNewType("uint64")},
                {Name: "isValid", Type: mustNewType("bool")},
        }

        taskID := new(big.Int).SetUint64(resp.TaskID)
        isValid := resp.IsValid

        return abiArgs.Pack(taskID, isValid)
}</span>

func AbiDecode(data []byte) (TaskResponse, error) <span class="cov0" title="0">{
        abiArgs := abi.Arguments{
                {Name: "taskID", Type: mustNewType("uint64")},
                {Name: "isValid", Type: mustNewType("bool")},
        }

        values, err := abiArgs.UnpackValues(data)
        if err != nil </span><span class="cov0" title="0">{
                return TaskResponse{}, err
        }</span>

        <span class="cov0" title="0">var (
                taskID, _  = values[0].(*big.Int)
                isValid, _ = values[1].(bool)
        )

        return TaskResponse{
                TaskID:  taskID.Uint64(),
                IsValid: isValid,
        }, nil</span>
}

func mustNewType(typeStr string) abi.Type <span class="cov0" title="0">{
        t, err := abi.NewType(typeStr, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return t</span>
}

// MarshalTaskResponse GetTaskResponseDigestEncodeByjson returns the hash of the TaskResponse, which is what operators sign over
// MarshalTaskResponse marshals the TaskResponse struct into JSON bytes.
func MarshalTaskResponse(h TaskResponse) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(h)
}</span>

// UnmarshalTaskResponse unmarshals the JSON bytes into a TaskResponse struct.
func UnmarshalTaskResponse(jsonData []byte) (TaskResponse, error) <span class="cov0" title="0">{
        var taskResponse TaskResponse
        err := json.Unmarshal(jsonData, &amp;taskResponse)
        return taskResponse, err
}</span>

// GetTaskResponseDigestEncodeByjson returns the hash of the TaskResponse, which is what operators sign over.
func GetTaskResponseDigestEncodeByjson(h TaskResponse) ([32]byte, []byte, error) <span class="cov0" title="0">{
        jsonData, err := MarshalTaskResponse(h)
        if err != nil </span><span class="cov0" title="0">{
                return [32]byte{}, []byte{}, err
        }</span>
        <span class="cov0" title="0">taskResponseDigest := crypto.Keccak256Hash(jsonData)
        return taskResponseDigest, jsonData, nil</span>
}
func GetTaskResponseDigestEncodeByAbi(h TaskResponse) ([32]byte, []byte, error) <span class="cov0" title="0">{
        packed, err := Args.Pack(h)
        if err != nil </span><span class="cov0" title="0">{
                return [32]byte{}, []byte{}, err
        }</span>
        <span class="cov0" title="0">taskResponseDigest := crypto.Keccak256Hash(packed)
        return taskResponseDigest, packed, nil</span>
}
func UpdateYAMLWithComments(filePath, key, newValue string) error <span class="cov0" title="0">{
        if newValue == "" </span><span class="cov0" title="0">{
                panic("param is nil")</span>
        }
        // Read the original YAML file content
        <span class="cov0" title="0">data, err := os.ReadFile(filepath.Clean(filePath))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Parse YAML using yaml.v3 node parser to preserve comments
        <span class="cov0" title="0">var doc yaml.Node
        err = yaml.Unmarshal(data, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Iterate through YAML content to find and update the specified key
        <span class="cov0" title="0">for i := 0; i &lt; len(doc.Content[0].Content); i += 2 </span><span class="cov0" title="0">{
                if doc.Content[0].Content[i].Value == key </span><span class="cov0" title="0">{
                        doc.Content[0].Content[i+1].Kind = yaml.ScalarNode
                        doc.Content[0].Content[i+1].Value = newValue
                        doc.Content[0].Content[i+1].Tag = "tag:yaml.org,2002:str"
                        break</span>
                }
        }

        <span class="cov0" title="0">var buf bytes.Buffer
        encoder := yaml.NewEncoder(&amp;buf)
        encoder.SetIndent(2)
        err = encoder.Encode(&amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filePath, buf.Bytes(), 0644)</span>
}
func GetFileInCurrentDirectory(filename string) (string, error) <span class="cov0" title="0">{
        // Get current working directory
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Construct full file path
        <span class="cov0" title="0">fullPath := filepath.Join(currentDir, filename)

        // Check if file exists
        _, err = os.Stat(fullPath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file %s not found in current directory", filename)
        }</span>

        <span class="cov0" title="0">return fullPath, nil</span>
}
func ConvertToEthAddresses(strArray []string) []common.Address <span class="cov0" title="0">{
        var ethAddresses []common.Address

        if len(strArray) &gt; 0 </span><span class="cov0" title="0">{
                for _, str := range strArray </span><span class="cov0" title="0">{
                        address := common.HexToAddress(str)
                        ethAddresses = append(ethAddresses, address)
                }</span>
        }

        <span class="cov0" title="0">return ethAddresses</span>
}
func SwitchEthAddressToImAddress(ethAddress string) (string, error) <span class="cov0" title="0">{
        b, err := hex.DecodeString(ethAddress[2:])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode eth address: %w", err)
        }</span>

        // Generate im address
        <span class="cov0" title="0">bech32Prefix := "im"
        imAddress, err := bech32.EncodeFromBase256(bech32Prefix, b)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode bech32 address: %w", err)
        }</span>

        <span class="cov0" title="0">return imAddress, nil</span>
}

// ChainIDWithoutRevision returns the chainID without the revision number.
// For example, "imuachaintestnet_233-1" returns "imuachaintestnet_233".
func ChainIDWithoutRevision(chainID string) string <span class="cov0" title="0">{
        if !IsRevisionFormat(chainID) </span><span class="cov0" title="0">{
                return chainID
        }</span>
        <span class="cov0" title="0">splitStr := strings.Split(chainID, "-")
        return splitStr[0]</span>
}

var IsRevisionFormat = regexp.MustCompile(`^.*[^\n-]-{1}[1-9][0-9]*$`).MatchString
</pre>
		
		<pre class="file" id="file94" style="display: none">package utils

import (
        "fmt"

        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
)

func GetChainRpcUrl(chainID string) string <span class="cov0" title="0">{
        switch chainID </span>{
        case "11155111":<span class="cov0" title="0">
                return fmt.Sprintf("https://eth-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        case "11155420":<span class="cov0" title="0">
                return fmt.Sprintf("https://opt-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        case "84532":<span class="cov0" title="0">
                return fmt.Sprintf("https://base-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package utils

import (
        "fmt"
        "io"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

func FetchDataFromUrl(url string, logger logging.Logger) (string, error) <span class="cov0" title="0">{
        response, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fetch data from url: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := response.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing response body", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">return string(body), nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package utils

import (
        "encoding/hex"
        "fmt"
        "github.com/btcsuite/btcutil/bech32"
)

func SwitchEthAddressToImAddress(ethAddress string) (string, error) <span class="cov0" title="0">{
        b, err := hex.DecodeString(ethAddress[2:])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode eth address: %w", err)
        }</span>

        // Generate im address
        <span class="cov0" title="0">bech32Prefix := "im"
        imAddress, err := bech32.Encode(bech32Prefix, b)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode bech32 address: %w", err)
        }</span>

        <span class="cov0" title="0">return imAddress, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package utils

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/imua-keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func UploadToIPFS(filename string, data []byte) (string, error) <span class="cov0" title="0">{
        metrics.IPFSUploadSizeBytes.Add(float64(len(data)))

        url := "https://uploads.pinata.cloud/v3/files"

        body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)

        // Add the "network" field and set it to "public"
        if err := writer.WriteField("network", "public"); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write network field: %v", err)
        }</span>

        <span class="cov0" title="0">part, err := writer.CreateFormFile("file", filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create form file: %v", err)
        }</span>
        <span class="cov0" title="0">if _, err := part.Write(data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write data to form: %v", err)
        }</span>
        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close writer: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+config.GetPinataJWT())
        req.Header.Set("Content-Type", writer.FormDataContentType())

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close response body: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to upload to IPFS: status code %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov0" title="0">var ipfsResponse struct {
                Data struct {
                        CID string `json:"cid"`
                } `json:"data"`
        }

        if err := json.Unmarshal([]byte(respBody), &amp;ipfsResponse); err != nil </span><span class="cov0" title="0">{
                return string(respBody), fmt.Errorf("failed to unmarshal IPFS response: %v", err)
        }</span>

        <span class="cov0" title="0">cid := ipfsResponse.Data.CID

        return cid, nil</span>
}

func FetchIPFSContent(cid string) (types.IPFSData, error) <span class="cov0" title="0">{
        const maxRetries = 5
        ipfsURL := "https://" + config.GetIpfsHost() + "/ipfs/" + cid

        var lastErr error
        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                resp, err := http.Get(ipfsURL)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("failed to fetch IPFS content (attempt %d): %v", attempt, err)
                        time.Sleep(300 * time.Millisecond)
                        continue</span>
                }

                <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                _ = resp.Body.Close()
                        }</span>()

                        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                lastErr = fmt.Errorf("failed to fetch IPFS content: status code %d", resp.StatusCode)
                                time.Sleep(300 * time.Millisecond)
                                return
                        }</span>

                        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                lastErr = fmt.Errorf("failed to read response body: %v", err)
                                time.Sleep(300 * time.Millisecond)
                                return
                        }</span>

                        <span class="cov0" title="0">var ipfsData types.IPFSData
                        if err := json.Unmarshal(body, &amp;ipfsData); err != nil </span><span class="cov0" title="0">{
                                lastErr = fmt.Errorf("failed to unmarshal IPFS data: %v", err)
                                time.Sleep(300 * time.Millisecond)
                                return
                        }</span>

                        <span class="cov0" title="0">metrics.IPFSDownloadSizeBytes.Add(float64(len(body)))
                        lastErr = nil
                        // Return from the outer function with the result
                        ipfsDataResult = ipfsData</span>
                }()

                <span class="cov0" title="0">if lastErr == nil </span><span class="cov0" title="0">{
                        return ipfsDataResult, nil
                }</span>
        }

        <span class="cov0" title="0">return types.IPFSData{}, lastErr</span>
}

var ipfsDataResult types.IPFSData
</pre>
		
		<pre class="file" id="file98" style="display: none">package handlers

import (
        "context"
        "encoding/hex"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"

        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// ExecuteTask handles task execution requests
func (h *TaskHandler) ExecuteTask(c *gin.Context) <span class="cov0" title="0">{
        traceID := h.getTraceID(c)
        h.logger.Info("Executing task ...", "trace_id", traceID)

        if c.Request.Method != http.MethodPost </span><span class="cov0" title="0">{
                c.JSON(http.StatusMethodNotAllowed, gin.H{
                        "error": "Invalid method",
                })
                return
        }</span>

        <span class="cov0" title="0">var requestBody struct {
                Data string `json:"data"`
        }
        if err := c.BindJSON(&amp;requestBody); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON body"})
                return
        }</span>

        // Decode hex data
        <span class="cov0" title="0">hexData := requestBody.Data
        if len(hexData) &gt; 2 &amp;&amp; hexData[:2] == "0x" </span><span class="cov0" title="0">{
                hexData = hexData[2:]
        }</span>

        <span class="cov0" title="0">decodedData, err := hex.DecodeString(hexData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid hex data"})
                return
        }</span>

        <span class="cov0" title="0">decodedDataString := string(decodedData)

        var requestData types.SendTaskDataToKeeper
        if err := json.Unmarshal([]byte(decodedDataString), &amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Failed to parse JSON data",
                })
                return
        }</span>

        <span class="cov0" title="0">if !strings.EqualFold(config.GetKeeperAddress(), requestData.PerformerData.KeeperAddress) </span><span class="cov0" title="0">{
                h.logger.Infof("I am not the performer: %s", requestData.PerformerData.KeeperAddress)
                c.JSON(http.StatusOK, gin.H{"message": "I am not the performer"})
                return
        }</span> else<span class="cov0" title="0"> {
                h.logger.Infof("I am the performer: %s", requestData.PerformerData.KeeperAddress)

                TaskDefinitionID := requestData.TriggerData[0].TaskDefinitionID
                switch TaskDefinitionID </span>{
                case 1, 2:<span class="cov0" title="0">
                        h.logger.Info("Execution starts for following tasks:", "trace_id", traceID)
                        for _, task := range requestData.TargetData </span><span class="cov0" title="0">{
                                h.logger.Infof("Task ID: %d | Target Chain ID: %s", task.TaskID, task.TargetChainID)
                        }</span>
                case 3, 4, 5, 6:<span class="cov0" title="0">
                        h.logger.Info("Execution starts for task:", "task_id", requestData.TargetData[0].TaskID, "target_chain_id", requestData.TargetData[0].TargetChainID, "trace_id", traceID)</span>
                }
                <span class="cov0" title="0">success, err := h.executor.ExecuteTask(context.Background(), &amp;requestData, traceID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Task execution failed", "error", err, "trace_id", traceID)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Task execution failed"})
                        return
                }</span>

                <span class="cov0" title="0">h.logger.Info("Task execution completed", "success", success, "trace_id", traceID)
                c.JSON(http.StatusOK, gin.H{"success": strconv.FormatBool(success)})</span>
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const TraceIDKey = "trace_id"

// TaskHandler handles task-related requests
type TaskHandler struct {
        logger    logging.Logger
        executor  *execution.TaskExecutor
        validator *validation.TaskValidator
}

// NewTaskHandler creates a new task handler
func NewTaskHandler(logger logging.Logger, executor *execution.TaskExecutor, validator *validation.TaskValidator) *TaskHandler <span class="cov0" title="0">{
        return &amp;TaskHandler{
                logger:    logger,
                executor:  executor,
                validator: validator,
        }
}</span>

func (h *TaskHandler) getTraceID(c *gin.Context) string <span class="cov0" title="0">{
        traceID, exists := c.Get(TraceIDKey)
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return traceID.(string)</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// MetricsHandler handles metrics endpoint requests
type MetricsHandler struct {
        logger    logging.Logger
        collector *metrics.Collector
}

// NewMetricsHandler creates a new metrics handler
func NewMetricsHandler(logger logging.Logger) *MetricsHandler <span class="cov0" title="0">{
        collector := metrics.NewCollector()
        collector.Start()

        return &amp;MetricsHandler{
                logger:    logger,
                collector: collector,
        }
}</span>

// Metrics handles metrics endpoint requests
func (h *MetricsHandler) Metrics(c *gin.Context) <span class="cov0" title="0">{
        h.collector.Handler().ServeHTTP(c.Writer, c.Request)
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package handlers

import (
        "context"
        "fmt"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
)

type TaskValidationRequest struct {
        ProofOfTask      string `json:"proofOfTask"`
        Data             string `json:"data"`
        TaskDefinitionID uint16 `json:"taskDefinitionId"`
        Performer        string `json:"performer"`
}

type ValidationResponse struct {
        Data    bool   `json:"data"`
        Error   bool   `json:"error"`
        Message string `json:"message,omitempty"`
}

// ValidateTask handles task validation requests
func (h *TaskHandler) ValidateTask(c *gin.Context) <span class="cov0" title="0">{
        traceID := h.getTraceID(c)
        h.logger.Info("Validating task ...", "trace_id", traceID)

        var taskRequest TaskValidationRequest
        if err := c.ShouldBindJSON(&amp;taskRequest); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: fmt.Sprintf("Failed to parse request body: %v", err),
                })
                return
        }</span>

        // Track task by definition ID for validation
        <span class="cov0" title="0">taskDefID := strconv.Itoa(int(taskRequest.TaskDefinitionID))
        metrics.TasksByDefinitionIDTotal.WithLabelValues(taskDefID).Inc()

        // Validate job based on task definition ID
        isValid := false
        var validationErr error

        h.logger.Info("Validating task ...", "trace_id", traceID)
        isValid, validationErr = h.validator.ValidateTask(context.Background(), taskRequest.Data, traceID)

        if validationErr != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation error", "error", validationErr, "trace_id", traceID)
                c.JSON(http.StatusOK, ValidationResponse{
                        Data:    false,
                        Error:   true,
                        Message: validationErr.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Task validation completed", "trace_id", traceID)
        c.JSON(http.StatusOK, ValidationResponse{
                Data:    isValid,
                Error:   false,
                Message: "",
        })</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package api

import (
        "runtime"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

const TraceIDHeader = "X-Trace-ID"
const TraceIDKey = "trace_id"

func TraceMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                traceID := c.GetHeader(TraceIDHeader)
                if traceID == "" </span><span class="cov0" title="0">{
                        traceID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Set(TraceIDKey, traceID)
                c.Header(TraceIDHeader, traceID)
                c.Next()</span>
        }
}

// MetricsMiddleware collects HTTP request metrics
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Process request
                c.Next()

                // Update system metrics
                var memStats runtime.MemStats
                runtime.ReadMemStats(&amp;memStats)
                metrics.MemoryUsageBytes.Set(float64(memStats.Alloc))
                metrics.CPUUsagePercent.Set(float64(memStats.Sys))
                metrics.GoroutinesActive.Set(float64(runtime.NumGoroutine()))
                metrics.GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)
        }</span>
}

// LoggerMiddleware creates a gin middleware for logging requests
func LoggerMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip logging for metrics endpoint
                if c.Request.URL.Path == "/metrics" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery
                traceID, _ := c.Get(TraceIDKey)

                // Process request
                c.Next()

                duration := time.Since(start)
                statusCode := c.Writer.Status()

                logger.Info("Request processed",
                        "trace_id", traceID,
                        "status", statusCode,
                        "method", c.Request.Method,
                        "path", path,
                        "query", raw,
                        "ip", c.ClientIP(),
                        "latency", duration,
                        "user-agent", c.Request.UserAgent(),
                )</span>
        }
}

// ErrorMiddleware handles errors in a consistent way
func ErrorMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check if there are any errors
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Get the last error
                        err := c.Errors.Last()
                        traceID, _ := c.Get(TraceIDKey)

                        logger.Error("Error",
                                "trace_id", traceID,
                                "error", err.Error(),
                                "path", c.Request.URL.Path,
                        )

                        // If the response hasn't been written yet
                        if !c.Writer.Written() </span><span class="cov0" title="0">{
                                c.JSON(c.Writer.Status(), gin.H{
                                        "error":    err.Error(),
                                        "trace_id": traceID,
                                })
                        }</span>
                }
        }
}

// TaskMetricsMiddleware tracks task-related metrics
func TaskMetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path

                // Track incoming tasks
                if path == "/p2p/message" &amp;&amp; c.Request.Method == "POST" </span><span class="cov0" title="0">{
                        metrics.TasksReceivedTotal.Inc()
                }</span>

                <span class="cov0" title="0">c.Next()

                duration := time.Since(start)
                statusCode := c.Writer.Status()

                // Track completed tasks based on endpoint and status
                if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov0" title="0">{
                        switch path </span>{
                        case "/p2p/message":<span class="cov0" title="0">
                                // Task execution endpoint
                                metrics.TasksPerDay.WithLabelValues("executed").Inc()
                                metrics.TasksCompletedTotal.WithLabelValues("executed").Inc()
                                metrics.TaskDurationSeconds.WithLabelValues("executed").Observe(duration.Seconds())</span>
                                // metrics.AverageTaskCompletionTimeSeconds.WithLabelValues("executed").Set(duration.Seconds())
                        case "/task/validate":<span class="cov0" title="0">
                                // Task validation endpoint
                                metrics.TasksPerDay.WithLabelValues("validated").Inc()
                                metrics.TasksCompletedTotal.WithLabelValues("validated").Inc()
                                metrics.TaskDurationSeconds.WithLabelValues("validated").Observe(duration.Seconds())</span>
                                // metrics.AverageTaskCompletionTimeSeconds.WithLabelValues("validated").Set(duration.Seconds())
                        }
                }
        }
}

// RestartTrackingMiddleware tracks service restarts
func RestartTrackingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        // This should be called once during service startup
        metrics.RestartsTotal.Inc()

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/api/handlers"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/execution"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Server represents the API server
type Server struct {
        router     *gin.Engine
        httpServer *http.Server
        logger     logging.Logger
}

// Config holds the server configuration
type Config struct {
        Port           string
        ReadTimeout    time.Duration
        WriteTimeout   time.Duration
        MaxHeaderBytes int
}

// Dependencies holds the server dependencies
type Dependencies struct {
        Logger    logging.Logger
        Executor  *execution.TaskExecutor
        Validator *validation.TaskValidator
}

// NewServer creates a new API server
func NewServer(cfg Config, deps *Dependencies) *Server <span class="cov0" title="0">{
        if cfg.ReadTimeout == 0 </span><span class="cov0" title="0">{
                cfg.ReadTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if cfg.WriteTimeout == 0 </span><span class="cov0" title="0">{
                cfg.WriteTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if cfg.MaxHeaderBytes == 0 </span><span class="cov0" title="0">{
                cfg.MaxHeaderBytes = 1 &lt;&lt; 20 // 1MB
        }</span>

        <span class="cov0" title="0">gin.SetMode(gin.ReleaseMode)
        router := gin.New()

        // Create server instance
        srv := &amp;Server{
                router: router,
                logger: deps.Logger,
                httpServer: &amp;http.Server{
                        Addr:           fmt.Sprintf(":%s", cfg.Port),
                        Handler:        router,
                        ReadTimeout:    cfg.ReadTimeout,
                        WriteTimeout:   cfg.WriteTimeout,
                        MaxHeaderBytes: cfg.MaxHeaderBytes,
                },
        }

        // Setup middleware
        srv.setupMiddleware()

        // Setup routes
        srv.setupRoutes(deps)

        return srv</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting API server", "addr", s.httpServer.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Stopping API server")
        return s.httpServer.Shutdown(ctx)
}</span>

// setupMiddleware sets up the middleware for the server
func (s *Server) setupMiddleware() <span class="cov0" title="0">{
        s.router.Use(gin.Recovery())
        s.router.Use(TraceMiddleware())
        s.router.Use(MetricsMiddleware())
        s.router.Use(TaskMetricsMiddleware())
        s.router.Use(RestartTrackingMiddleware())
        s.router.Use(LoggerMiddleware(s.logger))
        s.router.Use(ErrorMiddleware(s.logger))
}</span>

// setupRoutes sets up the routes for the server
func (s *Server) setupRoutes(deps *Dependencies) <span class="cov0" title="0">{
        // Create handlers
        taskHandler := handlers.NewTaskHandler(deps.Logger, deps.Executor, deps.Validator)
        metricsHandler := handlers.NewMetricsHandler(deps.Logger)

        // Task routes
        s.router.POST("/p2p/message", taskHandler.ExecuteTask)
        s.router.POST("/task/validate", taskHandler.ValidateTask)

        // Health and metrics routes
        s.router.GET("/metrics", metricsHandler.Metrics)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package ethclient

import (
        "context"
        "math/big"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
)

// EthClient is an interface for Ethereum client operations
type EthClient interface {
        ChainID(ctx context.Context) (*big.Int, error)
        BalanceAt(ctx context.Context, account common.Address, blockNumber *big.Int) (*big.Int, error)
        FilterLogs(ctx context.Context, query ethereum.FilterQuery) ([]types.Log, error)
        SubscribeFilterLogs(ctx context.Context, query ethereum.FilterQuery, ch chan&lt;- types.Log) (ethereum.Subscription, error)
        CallContract(ctx context.Context, call ethereum.CallMsg, blockNumber *big.Int) ([]byte, error)
        bind.ContractBackend
}

// Client wraps the ethclient.Client to implement our EthClient interface
type Client struct {
        *ethclient.Client
}

// NewClient creates a new Ethereum client
func NewClient(rpcURL string) (EthClient, error) <span class="cov0" title="0">{
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{Client: client}, nil</span>
}

// NewWebSocketClient creates a new WebSocket Ethereum client for event subscriptions
func NewWebSocketClient(wsURL string) (EthClient, error) <span class="cov0" title="0">{
        client, err := ethclient.Dial(wsURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{Client: client}, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package health

import (
        "bytes"
        "context"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        ethcrypto "github.com/ethereum/go-ethereum/crypto"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// Custom error types
var (
        ErrKeeperNotVerified = errors.New("keeper not verified")
)

// ErrorResponse represents the error response from the health service
type ErrorResponse struct {
        Error string `json:"error"`
        Code  string `json:"code"`
}

// Client represents a Health service client
type Client struct {
        httpClient *httppkg.HTTPClient
        logger     logging.Logger
        config     Config
}

// Config holds the configuration for the Health client
type Config struct {
        HealthServiceURL string
        PrivateKey       string
        KeeperAddress    string
        PeerID           string
        Version          string
        RequestTimeout   time.Duration
}

// NewClient creates a new Health service client
func NewClient(logger logging.Logger, cfg Config) (*Client, error) <span class="cov8" title="1">{
        if cfg.RequestTimeout == 0 </span><span class="cov8" title="1">{
                cfg.RequestTimeout = 10 * time.Second
        }</span>

        <span class="cov8" title="1">if cfg.Version == "" </span><span class="cov8" title="1">{
                cfg.Version = "0.1.6"
        }</span>

        <span class="cov8" title="1">retryConfig := httppkg.DefaultHTTPRetryConfig()

        httpClient, err := httppkg.NewHTTPClient(retryConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Client{
                httpClient: httpClient,
                logger:     logger,
                config:     cfg,
        }, nil</span>
}

// CheckIn performs a health check-in with the health service
func (c *Client) CheckIn(ctx context.Context) (types.KeeperHealthCheckInResponse, error) <span class="cov0" title="0">{
        // Get consensus address from private key
        privateKey, err := ethcrypto.HexToECDSA(c.config.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("invalid private key: %w", err)
        }</span>
        <span class="cov0" title="0">publicKeyBytes := ethcrypto.FromECDSAPub(&amp;privateKey.PublicKey)
        consensusPubKey := hex.EncodeToString(publicKeyBytes)
        consensusAddress := ethcrypto.PubkeyToAddress(privateKey.PublicKey).Hex()

        // Create message to sign
        msg := []byte(c.config.KeeperAddress)
        signature, err := cryptography.SignMessage(string(msg), c.config.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to sign check-in message: %w", err)
        }</span>

        // Prepare health check payload
        <span class="cov0" title="0">payload := types.KeeperHealthCheckIn{
                KeeperAddress:    c.config.KeeperAddress,
                ConsensusPubKey:  consensusPubKey,
                ConsensusAddress: consensusAddress,
                Version:          c.config.Version,
                Timestamp:        time.Now().UTC(),
                Signature:        signature,
                PeerID:           c.config.PeerID,
                IsImua:           config.IsImua(),
        }

        // c.logger.Infof("Payload: %+v", payload)

        // Send health check request
        response, err := c.sendHealthCheck(ctx, payload)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">metrics.SuccessfulHealthCheckinsTotal.Inc()

        // c.logger.Debug("Successfully completed health check-in",
        //         "status", response.Status,
        //         "keeperAddress", c.config.KeeperAddress,
        //         "timestamp", payload.Timestamp)

        return response, nil</span>
}

// sendHealthCheck sends the health check request to the health service
func (c *Client) sendHealthCheck(ctx context.Context, payload types.KeeperHealthCheckIn) (types.KeeperHealthCheckInResponse, error) <span class="cov0" title="0">{
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to marshal health check payload: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST",
                fmt.Sprintf("%s/health", c.config.HealthServiceURL),
                bytes.NewBuffer(payloadBytes))
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to send health check request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("failed to close response body", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        if errResp.Code == "KEEPER_NOT_VERIFIED" </span><span class="cov0" title="0">{
                                return types.KeeperHealthCheckInResponse{
                                        Status: false,
                                        Data:   errResp.Error,
                                }, ErrKeeperNotVerified
                        }</span>
                }
                <span class="cov0" title="0">return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   errResp.Error,
                }, fmt.Errorf("health service returned non-OK status: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">body, _ := io.ReadAll(resp.Body)
        var response types.KeeperHealthCheckInResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return types.KeeperHealthCheckInResponse{
                        Status: false,
                        Data:   err.Error(),
                }, fmt.Errorf("failed to unmarshal health check response: %w", err)
        }</span>

        // Only decrypt if the response was successful
        <span class="cov0" title="0">if response.Status </span><span class="cov0" title="0">{
                decryptedString, err := cryptography.DecryptMessage(c.config.PrivateKey, response.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return types.KeeperHealthCheckInResponse{
                                Status: false,
                                Data:   err.Error(),
                        }, fmt.Errorf("failed to decrypt health check response: %w", err)
                }</span>

                <span class="cov0" title="0">parts := strings.Split(decryptedString, ":")
                if len(parts) != 6 </span><span class="cov0" title="0">{
                        return types.KeeperHealthCheckInResponse{
                                Status: false,
                                Data:   "invalid response format",
                        }, fmt.Errorf("invalid response format: expected host:token")
                }</span>

                <span class="cov0" title="0">config.SetEtherscanAPIKey(parts[0])
                config.SetAlchemyAPIKey(parts[1])
                config.SetIpfsHost(parts[2])
                config.SetPinataJWT(parts[3])
                config.SetManagerSigningAddress(parts[4])
                config.SetTaskExecutionAddress(parts[5])

                return types.KeeperHealthCheckInResponse{
                        Status: true,
                        Data:   "Health check-in successful",
                }, nil</span>
        }

        // If response was not successful, return the error as is
        <span class="cov0" title="0">return response, nil</span>
}

// Close closes the HTTP client
func (c *Client) Close() <span class="cov8" title="1">{
        c.httpClient.Close()
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package config

import (
        "fmt"
        "log"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

const (
        version = "0.1.6"
        isImua  = false
)

type Config struct {
        devMode bool

        // RPC URLs for Ethereum and Base
        ethRPCUrl  string
        baseRPCUrl string

        // API Keys for Alchemy and Etherscan
        alchemyAPIKey   string
        etherscanAPIKey string

        // Controller Key and Keeper Address
        privateKeyController string
        keeperAddress        string

        // Consensus Key and Address
        privateKeyConsensus string
        consensusAddress    string

        // Public IP Address and Peer ID
        publicIPV4Address string
        peerID            string

        // Ports for Keeper API server, P2P connections, metrics and Grafana
        keeperRPCPort     string
        keeperP2PPort     string
        keeperMetricsPort string
        grafanaPort       string

        // IPFS configuration
        ipfsHost  string
        pinataJWT string

        // TLS Proof configuration
        tlsProofHost string
        tlsProofPort string

        // Manager Signing Address
        managerSigningAddress string

        // Backend Service URLs
        aggregatorRPCUrl string
        healthRPCUrl     string

        l1Chain string
        l2Chain string

        // AVS Contract Address
        avsGovernanceAddress     string
        attestationCenterAddress string
        taskExecutionAddress     string

        // Othentic Bootstrap ID
        othenticBootstrapID string
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                  env.GetEnvBool("DEV_MODE", false),
                ethRPCUrl:                env.GetEnvString("L1_RPC", ""),
                baseRPCUrl:               env.GetEnvString("L2_RPC", ""),
                privateKeyConsensus:      env.GetEnvString("PRIVATE_KEY", ""),
                privateKeyController:     env.GetEnvString("OPERATOR_PRIVATE_KEY", ""),
                keeperAddress:            env.GetEnvString("OPERATOR_ADDRESS", ""),
                consensusAddress:         crypto.PubkeyToAddress(crypto.ToECDSAUnsafe(common.FromHex(env.GetEnvString("PRIVATE_KEY", ""))).PublicKey).Hex(),
                publicIPV4Address:        env.GetEnvString("PUBLIC_IPV4_ADDRESS", ""),
                peerID:                   env.GetEnvString("PEER_ID", ""),
                keeperRPCPort:            env.GetEnvString("OPERATOR_RPC_PORT", "9011"),
                keeperP2PPort:            env.GetEnvString("OPERATOR_P2P_PORT", "9012"),
                keeperMetricsPort:        env.GetEnvString("OPERATOR_METRICS_PORT", "9013"),
                grafanaPort:              env.GetEnvString("GRAFANA_PORT", "3000"),
                aggregatorRPCUrl:         env.GetEnvString("OTHENTIC_CLIENT_RPC_ADDRESS", "https://aggregator.triggerx.network"),
                healthRPCUrl:             env.GetEnvString("HEALTH_IP_ADDRESS", "https://health.triggerx.network"),
                tlsProofHost:             "www.google.com",
                tlsProofPort:             "443",
                l1Chain:                  env.GetEnvString("L1_CHAIN", "17000"),
                l2Chain:                  env.GetEnvString("L2_CHAIN", "84532"),
                avsGovernanceAddress:     env.GetEnvString("AVS_GOVERNANCE_ADDRESS", "0x12f45551f11Df20b3EcBDf329138Bdc65cc58Ec0"),
                attestationCenterAddress: env.GetEnvString("ATTESTATION_CENTER_ADDRESS", "0x9725fB95B5ec36c062A49ca2712b3B1ff66F04eD"),
                othenticBootstrapID:      env.GetEnvString("OTHENTIC_BOOTSTRAP_ID", "12D3KooWBNFG1QjuF3UKAKvqhdXcxh9iBmj88cM5eU2EK5Pa91KB"),
        }
        if err := validateConfig(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">isRegistered := checkKeeperRegistration()
        if !isRegistered </span><span class="cov0" title="0">{
                log.Println("Keeper address is not yet registered on L2. Please register the address before continuing. If registered, please wait for the registration to be confirmed.")
                log.Fatal("Keeper address is not registered on L2")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig(cfg Config) error <span class="cov0" title="0">{
        if env.IsEmpty(cfg.ethRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid eth rpc url: %s", cfg.ethRPCUrl)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.baseRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid base rpc url: %s", cfg.baseRPCUrl)
        }</span>
        <span class="cov0" title="0">if !env.IsValidIPAddress(cfg.publicIPV4Address) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid public ipv4 address: %s", cfg.publicIPV4Address)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPrivateKey(cfg.privateKeyConsensus) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid private key consensus: %s", cfg.privateKeyConsensus)
        }</span>
        <span class="cov0" title="0">if !env.IsValidEthAddress(cfg.keeperAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid keeper address: %s", cfg.keeperAddress)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPeerID(cfg.peerID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid peer id: %s", cfg.peerID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetEthRPCUrl() string <span class="cov0" title="0">{
        return cfg.ethRPCUrl
}</span>

func GetBaseRPCUrl() string <span class="cov0" title="0">{
        return cfg.baseRPCUrl
}</span>

// Only sets it if there was no key in env file
func SetAlchemyAPIKey(key string) <span class="cov0" title="0">{
        if !env.IsEmpty(cfg.alchemyAPIKey) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">cfg.alchemyAPIKey = key</span>
}

func GetAlchemyAPIKey() string <span class="cov0" title="0">{
        return cfg.alchemyAPIKey
}</span>

func SetEtherscanAPIKey(key string) <span class="cov0" title="0">{
        cfg.etherscanAPIKey = key
}</span>

func GetEtherscanAPIKey() string <span class="cov0" title="0">{
        return cfg.etherscanAPIKey
}</span>

func GetPrivateKeyConsensus() string <span class="cov0" title="0">{
        return cfg.privateKeyConsensus
}</span>

func GetPrivateKeyController() string <span class="cov0" title="0">{
        return cfg.privateKeyController
}</span>

func GetKeeperAddress() string <span class="cov0" title="0">{
        return cfg.keeperAddress
}</span>

func GetConsensusAddress() string <span class="cov0" title="0">{
        return cfg.consensusAddress
}</span>

func GetPublicIPV4Address() string <span class="cov0" title="0">{
        return cfg.publicIPV4Address
}</span>

func GetPeerID() string <span class="cov0" title="0">{
        return cfg.peerID
}</span>

func GetOperatorRPCPort() string <span class="cov0" title="0">{
        return cfg.keeperRPCPort
}</span>

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetKeeperRPCPort() string <span class="cov0" title="0">{
        return cfg.keeperRPCPort
}</span>

func GetAggregatorRPCUrl() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCUrl
}</span>

func GetHealthRPCUrl() string <span class="cov0" title="0">{
        return cfg.healthRPCUrl
}</span>

func GetAvsGovernanceAddress() string <span class="cov0" title="0">{
        return cfg.avsGovernanceAddress
}</span>

func GetAttestationCenterAddress() string <span class="cov0" title="0">{
        return cfg.attestationCenterAddress
}</span>

func GetVersion() string <span class="cov0" title="0">{
        return version
}</span>

func IsImua() bool <span class="cov0" title="0">{
        return isImua
}</span>

// IPFS configuration
func SetIpfsHost(host string) <span class="cov0" title="0">{
        cfg.ipfsHost = host
}</span>

func GetIpfsHost() string <span class="cov0" title="0">{
        return cfg.ipfsHost
}</span>

func SetPinataJWT(jwt string) <span class="cov0" title="0">{
        cfg.pinataJWT = jwt
}</span>

func GetPinataJWT() string <span class="cov0" title="0">{
        return cfg.pinataJWT
}</span>

// TLS Proof configuration
func SetTLSProofHost(host string) <span class="cov0" title="0">{
        cfg.tlsProofHost = host
}</span>

func SetTLSProofPort(port string) <span class="cov0" title="0">{
        cfg.tlsProofPort = port
}</span>

func GetTLSProofHost() string <span class="cov0" title="0">{
        return cfg.tlsProofHost
}</span>

func GetTLSProofPort() string <span class="cov0" title="0">{
        return cfg.tlsProofPort
}</span>

// Manager Signing Address
func SetManagerSigningAddress(addr string) <span class="cov0" title="0">{
        cfg.managerSigningAddress = addr
}</span>

func GetManagerSigningAddress() string <span class="cov0" title="0">{
        return cfg.managerSigningAddress
}</span>

func SetTaskExecutionAddress(addr string) <span class="cov0" title="0">{
        cfg.taskExecutionAddress = addr
}</span>

func GetTaskExecutionAddress() string <span class="cov0" title="0">{
        return cfg.taskExecutionAddress
}</span>

// SetKeeperAddress sets the keeper address in the config (for testing)
func SetKeeperAddress(addr string) <span class="cov0" title="0">{
        cfg.keeperAddress = addr
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package config

import (
        "context"
        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
        "log"
        "math/big"
        "strings"
)

const AttestationCenterABI = `[{
        "inputs": [
          {
                "internalType": "address",
                "name": "_operator",
                "type": "address"
          }
        ],
        "name": "operatorsIdsByAddress",
        "outputs": [
          {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
}]`

func checkKeeperRegistration() bool <span class="cov0" title="0">{
        client, err := ethclient.Dial(GetBaseRPCUrl())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to connect to L2 network", "error", err)
                return false
        }</span>
        <span class="cov0" title="0">defer client.Close()

        parsedABI, err := abi.JSON(strings.NewReader(AttestationCenterABI))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to parse AttestationCenter ABI", "error", err)
                return false
        }</span>

        <span class="cov0" title="0">keeperAddr := common.HexToAddress(GetKeeperAddress())
        data, err := parsedABI.Pack("operatorsIdsByAddress", keeperAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to pack function call data", "error", err)
                return false
        }</span>

        <span class="cov0" title="0">attestationCenterAddr := common.HexToAddress(GetAttestationCenterAddress())
        result, err := client.CallContract(context.Background(), ethereum.CallMsg{
                To:   &amp;attestationCenterAddr,
                Data: data,
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to call AttestationCenter contract", "error", err)
                return false
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                log.Fatal("Empty result from contract call")
                return false
        }</span>

        <span class="cov0" title="0">operatorID := new(big.Int).SetBytes(result)

        if operatorID.Cmp(big.NewInt(0)) == 0 </span><span class="cov0" title="0">{
                log.Fatal("Keeper address is not registered on L2")
                return false
        }</span>

        <span class="cov0" title="0">log.Println("Keeper address", GetKeeperAddress(), "is registered on L2 with operator ID", operatorID)

        return true</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package execution

import (
        "context"
        "fmt"
        "math/big"
        "strconv"
        "strings"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi"
        ethcommon "github.com/ethereum/go-ethereum/common"
        ethtypes "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/metrics"
        dockertypes "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (e *TaskExecutor) executeAction(targetData *types.TaskTargetData, triggerData *types.TaskTriggerData, nonce uint64, client *ethclient.Client) (types.PerformerActionData, error) <span class="cov0" title="0">{
        if targetData.TargetContractAddress == "" </span><span class="cov0" title="0">{
                e.logger.Errorf("Execution contract address not configured")
                return types.PerformerActionData{}, fmt.Errorf("execution contract address not configured")
        }</span>

        <span class="cov0" title="0">var timeToNextTrigger time.Duration
        switch targetData.TaskDefinitionID </span>{
        case 1:<span class="cov0" title="0">
                timeToNextTrigger = time.Until(triggerData.NextTriggerTimestamp)
                timeToNextTrigger = timeToNextTrigger - 2*time.Second</span>
        case 2:<span class="cov0" title="0">
                timeToNextTrigger = time.Until(triggerData.NextTriggerTimestamp)
                timeToNextTrigger = timeToNextTrigger - 4*time.Second
                if timeToNextTrigger &lt; 0 </span><span class="cov0" title="0">{
                        timeToNextTrigger = 0
                }</span>
        default:<span class="cov0" title="0">
                timeToNextTrigger = 0</span>
        }
        <span class="cov0" title="0">time.Sleep(timeToNextTrigger)

        targetContractAddress := ethcommon.HexToAddress(targetData.TargetContractAddress)
        contractABI, method, err := e.getContractMethodAndABI(targetData.TargetFunction, targetData)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get contract method and ABI: %v", err)
        }</span>

        <span class="cov0" title="0">var argData []interface{}
        var result *dockertypes.ExecutionResult
        switch targetData.TaskDefinitionID </span>{
        case 2, 4, 6:<span class="cov0" title="0">
                var execErr error
                // Use the DockerManager from the validator to execute the code
                result, execErr = e.validator.GetDockerManager().Execute(context.Background(), targetData.DynamicArgumentsScriptUrl, 1)
                if execErr != nil </span><span class="cov0" title="0">{
                        return types.PerformerActionData{}, fmt.Errorf("failed to execute dynamic arguments script: %v", execErr)
                }</span>

                <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                        return types.PerformerActionData{}, fmt.Errorf("failed to execute dynamic arguments script: %v", result.Error)
                }</span>

                <span class="cov0" title="0">argData = e.parseDynamicArgs(result.Output)
                e.logger.Debugf("Parsed dynamic arguments: %+v", argData)</span>
        case 1, 3, 5:<span class="cov0" title="0">
                argData = e.parseStaticArgs(targetData.Arguments)
                result = &amp;dockertypes.ExecutionResult{
                        Stats: dockertypes.DockerResourceStats{
                                TotalCost: 0.1,
                        },
                }</span>
        default:<span class="cov0" title="0">
                return types.PerformerActionData{}, fmt.Errorf("unsupported task definition id: %d", targetData.TaskDefinitionID)</span>
        }

        // Handle args as potentially structured data
        <span class="cov0" title="0">convertedArgs, err := e.processArguments(argData, method.Inputs, contractABI)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("error processing arguments: %v", err)
        }</span>

        // Pack the target contract's function call data
        <span class="cov0" title="0">var callData []byte
        callData, err = contractABI.Pack(method.Name, convertedArgs...)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Error packing arguments: %v", err)
                return types.PerformerActionData{}, fmt.Errorf("error packing arguments: %v", err)
        }</span>

        // Create transaction data for execution contract
        <span class="cov0" title="0">privateKey, err := crypto.HexToECDSA(config.GetPrivateKeyController())
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to parse private key: %v", err)
        }</span>
        <span class="cov0" title="0">e.logger.Debugf("Using nonce: %d", nonce)

        // Pack the execution contract's executeFunction call
        executionABI, err := abi.JSON(strings.NewReader(`[{"inputs":[{"internalType":"uint256","name":"jobId","type":"uint256"},{"internalType":"uint256","name":"tgAmount","type":"uint256"},{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"executeFunction","outputs":[],"stateMutability":"payable","type":"function"}]`))
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to parse execution contract ABI: %v", err)
        }</span>

        // According to the ABI, the function signature is:
        // executeFunction(uint256 jobId, uint256 tgAmount, address target, bytes data)
        // We use jobId from targetData.JobID, and tgAmount is determined by the execution result's total cost.
        <span class="cov0" title="0">var tgAmountBigInt = big.NewInt(0)
        if result != nil </span><span class="cov0" title="0">{
                // Assuming TotalCost is in float64 and needs to be converted to wei (1e18 multiplier) if it's in ETH
                tgAmountBigInt = new(big.Int).SetInt64(int64(result.Stats.TotalCost * 1e18))
        }</span>
        <span class="cov0" title="0">executionInput, err := executionABI.Pack("executeFunction", targetData.JobID, tgAmountBigInt, targetContractAddress, callData)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to pack execution contract input: %v", err)
        }</span>

        <span class="cov0" title="0">executionContractAddress := config.GetTaskExecutionAddress()
        chainID, err := client.ChainID(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get chain ID: %v", err)
        }</span>

        // Get nonce manager for this chain
        <span class="cov0" title="0">nonceManager, err := e.getNonceManager(targetData.TargetChainID)
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, fmt.Errorf("failed to get nonce manager: %w", err)
        }</span>

        // Submit transaction with smart retry
        <span class="cov0" title="0">receipt, finalTxHash, err := nonceManager.SubmitTransactionWithSmartRetry(
                context.Background(),
                nonce,
                ethcommon.HexToAddress(executionContractAddress),
                executionInput,
                chainID,
                privateKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                return types.PerformerActionData{}, err
        }</span>

        <span class="cov0" title="0">executionResult := types.PerformerActionData{
                TaskID:             targetData.TaskID,
                ActionTxHash:       finalTxHash,
                GasUsed:            strconv.FormatUint(receipt.GasUsed, 10),
                Status:             receipt.Status == ethtypes.ReceiptStatusSuccessful,
                MemoryUsage:        result.Stats.MemoryUsage,
                CPUPercentage:      result.Stats.CPUPercentage,
                NetworkRx:          result.Stats.RxBytes,
                NetworkTx:          result.Stats.TxBytes,
                BlockRead:          result.Stats.BlockRead,
                BlockWrite:         result.Stats.BlockWrite,
                BandwidthRate:      result.Stats.BandwidthRate,
                TotalFee:           result.Stats.TotalCost,
                StaticComplexity:   result.Stats.StaticComplexity,
                DynamicComplexity:  result.Stats.DynamicComplexity,
                ExecutionTimestamp: time.Now().UTC(),
        }
        metrics.TransactionsSentTotal.WithLabelValues(targetData.TargetChainID, "success").Inc()
        metrics.GasUsedTotal.WithLabelValues(targetData.TargetChainID).Add(float64(receipt.GasUsed))
        metrics.TransactionFeesTotal.WithLabelValues(targetData.TargetChainID).Add(result.Stats.TotalCost)

        e.logger.Infof("Task ID %d executed successfully. Transaction: %s", targetData.TaskID, finalTxHash)

        return executionResult, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package execution

import (
        "encoding/json"
        "fmt"
        "math"
        "math/big"
        "reflect"
        "strconv"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
        ethcommon "github.com/ethereum/go-ethereum/common"
)

type ArgumentConverter struct{}

func (ac *ArgumentConverter) convertToType(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Handle different input types and convert to appropriate blockchain types
        switch targetType.T </span>{
        case abi.UintTy, abi.IntTy:<span class="cov0" title="0">
                return ac.convertToInteger(value, targetType)</span>
        case abi.StringTy:<span class="cov0" title="0">
                return ac.convertToString(value)</span>
        case abi.BoolTy:<span class="cov0" title="0">
                return ac.convertToBool(value)</span>
        case abi.AddressTy:<span class="cov0" title="0">
                return ac.convertToAddress(value)</span>
        case abi.BytesTy, abi.FixedBytesTy:<span class="cov0" title="0">
                return ac.convertToBytes(value)</span>
        case abi.ArrayTy, abi.SliceTy:<span class="cov0" title="0">
                return ac.convertToArray(value, targetType)</span>
        case abi.TupleTy:<span class="cov0" title="0">
                return ac.convertToStruct(value, targetType)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported type conversion: %v", targetType)</span>
        }
}

func (ac *ArgumentConverter) convertToInteger(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Add this case to handle when the value is already a *big.Int
        if bigInt, ok := value.(*big.Int); ok </span><span class="cov0" title="0">{
                return bigInt, nil
        }</span>

        <span class="cov0" title="0">switch targetType.T </span>{
        case abi.UintTy:<span class="cov0" title="0">
                if targetType.Size == 32 </span><span class="cov0" title="0">{
                        // Handle uint32 specifically
                        switch v := value.(type) </span>{
                        case string:<span class="cov0" title="0">
                                // Parse as float first, then convert to uint32
                                floatVal, err := strconv.ParseFloat(v, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if floatVal &lt; 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("cannot convert negative value %f to uint32", floatVal)
                                }</span>
                                <span class="cov0" title="0">if floatVal &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("value %f exceeds maximum uint32 value", floatVal)
                                }</span>
                                <span class="cov0" title="0">return uint32(floatVal), nil</span>
                        case float64:<span class="cov0" title="0">
                                return uint32(v), nil</span>
                        case int:<span class="cov0" title="0">
                                if v &lt; 0 </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("cannot convert negative value %d to uint32", v)
                                }</span>
                                <span class="cov0" title="0">if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                                        return 0, fmt.Errorf("value %d exceeds maximum uint32 value", v)
                                }</span>
                                <span class="cov0" title="0">return uint32(v), nil</span>
                        }
                }
                // For other uint sizes, use big.Int
                <span class="cov0" title="0">fallthrough</span>
        default:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        return big.NewInt(int64(v)), nil</span>
                case string:<span class="cov0" title="0">
                        // Parse as float first, then convert to big.Int
                        floatVal, err := strconv.ParseFloat(v, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot convert string to integer: %v", err)
                        }</span>
                        <span class="cov0" title="0">return big.NewInt(int64(floatVal)), nil</span>
                case map[string]interface{}:<span class="cov0" title="0">
                        // This could be a struct that we need to convert to an integer
                        if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                                var floatVal float64
                                if err := json.Unmarshal(jsonBytes, &amp;floatVal); err == nil </span><span class="cov0" title="0">{
                                        return big.NewInt(int64(floatVal)), nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert map to integer")</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("cannot convert type %T to integer", v)</span>
                }
        }
}

func (ac *ArgumentConverter) convertToString(value interface{}) (string, error) <span class="cov0" title="0">{
        // Convert various types to string
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v, nil</span>
        case float64, int, uint:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v), nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // This could be a JSON object that we need to convert to a string
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return string(jsonBytes), nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("cannot convert map to string")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("cannot convert type %T to string", v)</span>
        }
}

func (ac *ArgumentConverter) convertToBool(value interface{}) (bool, error) <span class="cov0" title="0">{
        // Convert various types to bool
        switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseBool(v)</span>
        case float64:<span class="cov0" title="0">
                return v != 0, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to convert JSON to bool
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        var boolVal bool
                        if err := json.Unmarshal(jsonBytes, &amp;boolVal); err == nil </span><span class="cov0" title="0">{
                                return boolVal, nil
                        }</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("cannot convert map to bool")</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("cannot convert type %T to bool", v)</span>
        }
}

func (ac *ArgumentConverter) convertToAddress(value interface{}) (ethcommon.Address, error) <span class="cov0" title="0">{
        // Convert to Ethereum address
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                if !ethcommon.IsHexAddress(v) </span><span class="cov0" title="0">{
                        return ethcommon.Address{}, fmt.Errorf("invalid Ethereum address: %s", v)
                }</span>
                <span class="cov0" title="0">return ethcommon.HexToAddress(v), nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Check if we have a string representation in the map
                if addrStr, ok := v["address"].(string); ok </span><span class="cov0" title="0">{
                        if !ethcommon.IsHexAddress(addrStr) </span><span class="cov0" title="0">{
                                return ethcommon.Address{}, fmt.Errorf("invalid Ethereum address: %s", addrStr)
                        }</span>
                        <span class="cov0" title="0">return ethcommon.HexToAddress(addrStr), nil</span>
                }
                <span class="cov0" title="0">return ethcommon.Address{}, fmt.Errorf("cannot convert map to address")</span>
        default:<span class="cov0" title="0">
                return ethcommon.Address{}, fmt.Errorf("cannot convert type %T to address", v)</span>
        }
}

func (ac *ArgumentConverter) convertToBytes(value interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Convert to bytes
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                // Check if it's a hex string
                if strings.HasPrefix(v, "0x") </span><span class="cov0" title="0">{
                        return ethcommon.FromHex(v), nil
                }</span>
                <span class="cov0" title="0">return []byte(v), nil</span>
        case []byte:<span class="cov0" title="0">
                return v, nil</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to convert JSON to bytes
                if jsonBytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return jsonBytes, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert map to bytes")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert type %T to bytes", v)</span>
        }
}

func (ac *ArgumentConverter) convertToArray(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // First, ensure the value is actually an array/slice
        var sourceArray []interface{}

        switch v := value.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                sourceArray = v</span>
        case string:<span class="cov0" title="0">
                // Try to parse as JSON array
                if err := json.Unmarshal([]byte(v), &amp;sourceArray); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse string as JSON array: %v", err)
                }</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Try to parse map as JSON array
                jsonBytes, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal map as JSON: %v", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonBytes, &amp;sourceArray); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse map as JSON array: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot convert type %T to array/slice", v)</span>
        }

        // Create a new slice with the correct element type
        <span class="cov0" title="0">sliceType := reflect.SliceOf(targetType.Elem.GetType())
        result := reflect.MakeSlice(sliceType, len(sourceArray), len(sourceArray))

        // Convert each element
        for i, elem := range sourceArray </span><span class="cov0" title="0">{
                convertedElem, err := ac.convertToType(elem, *targetType.Elem)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting array element %d: %v", i, err)
                }</span>

                // Set the element in the slice
                <span class="cov0" title="0">resultElem := reflect.ValueOf(convertedElem)
                result.Index(i).Set(resultElem)</span>
        }

        <span class="cov0" title="0">return result.Interface(), nil</span>
}

func (ac *ArgumentConverter) convertToStruct(value interface{}, targetType abi.Type) (interface{}, error) <span class="cov0" title="0">{
        // Create a new instance of the struct type
        structType := targetType.GetType()
        structValue := reflect.New(structType).Elem()

        // Prepare source data
        var sourceMap map[string]interface{}

        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                sourceMap = v</span>
        case string:<span class="cov0" title="0">
                // Try to parse as JSON object
                if err := json.Unmarshal([]byte(v), &amp;sourceMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse string as JSON object: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                // If it's already a struct, we can try to convert it directly
                valueVal := reflect.ValueOf(value)
                if valueVal.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        // Convert struct to map for easier processing
                        jsonBytes, err := json.Marshal(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal struct: %v", err)
                        }</span>
                        <span class="cov0" title="0">if err := json.Unmarshal(jsonBytes, &amp;sourceMap); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal struct to map: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("cannot convert type %T to struct", v)
                }</span>
        }

        // Iterate through the tuple components and set corresponding fields
        <span class="cov0" title="0">for i, component := range targetType.TupleElems </span><span class="cov0" title="0">{
                fieldName := targetType.TupleRawNames[i]
                fieldValue, exists := sourceMap[fieldName]

                if !exists </span><span class="cov0" title="0">{
                        // Try with case-insensitive match
                        for k, v := range sourceMap </span><span class="cov0" title="0">{
                                if strings.EqualFold(k, fieldName) </span><span class="cov0" title="0">{
                                        fieldValue = v
                                        exists = true
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert the field value to the correct type
                <span class="cov0" title="0">convertedValue, err := ac.convertToType(fieldValue, *component)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting struct field %s: %v", fieldName, err)
                }</span>

                // Find the corresponding field in the struct
                <span class="cov0" title="0">var structField reflect.Value
                for j := 0; j &lt; structValue.NumField(); j++ </span><span class="cov0" title="0">{
                        if strings.EqualFold(structType.Field(j).Name, fieldName) </span><span class="cov0" title="0">{
                                structField = structValue.Field(j)
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !structField.IsValid() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("struct field %s not found", fieldName)
                }</span>

                // Set the field value
                <span class="cov0" title="0">convertedValueReflect := reflect.ValueOf(convertedValue)
                if structField.Type() != convertedValueReflect.Type() </span><span class="cov0" title="0">{
                        // Try to convert the value to the correct type
                        if convertedValueReflect.Type().ConvertibleTo(structField.Type()) </span><span class="cov0" title="0">{
                                convertedValueReflect = convertedValueReflect.Convert(structField.Type())
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("cannot convert %v to field type %v", convertedValueReflect.Type(), structField.Type())
                        }</span>
                }
                <span class="cov0" title="0">structField.Set(convertedValueReflect)</span>
        }

        <span class="cov0" title="0">return structValue.Interface(), nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package execution

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"

        // "strconv"
        "time"

        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/core/validation"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/proof"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TaskExecutor is the default implementation of TaskExecutor
type TaskExecutor struct {
        alchemyAPIKey    string
        argConverter     *ArgumentConverter
        validator        *validation.TaskValidator
        aggregatorClient *aggregator.AggregatorClient
        logger           logging.Logger
        nonceManagers    map[string]*NonceManager // Chain ID -&gt; NonceManager
        nonceMutex       sync.RWMutex
}

// NewTaskExecutor creates a new instance of TaskExecutor
func NewTaskExecutor(
        alchemyAPIKey string,
        validator *validation.TaskValidator,
        aggregatorClient *aggregator.AggregatorClient,
        logger logging.Logger) *TaskExecutor <span class="cov0" title="0">{
        return &amp;TaskExecutor{
                alchemyAPIKey:    alchemyAPIKey,
                argConverter:     &amp;ArgumentConverter{},
                validator:        validator,
                aggregatorClient: aggregatorClient,
                logger:           logger,
                nonceManagers:    make(map[string]*NonceManager),
        }
}</span>

func (e *TaskExecutor) ExecuteTask(ctx context.Context, task *types.SendTaskDataToKeeper, traceID string) (bool, error) <span class="cov0" title="0">{
        // Check for nil task
        if task == nil </span><span class="cov0" title="0">{
                e.logger.Error("Task data is nil", "trace_id", traceID)
                return false, fmt.Errorf("task data cannot be nil")
        }</span>

        // Check for nil TargetData and TriggerData
        <span class="cov0" title="0">if task.TargetData == nil </span><span class="cov0" title="0">{
                e.logger.Error("TargetData is nil", "task_id", task.TaskID, "trace_id", traceID)
                return false, fmt.Errorf("target data cannot be nil")
        }</span>
        <span class="cov0" title="0">if task.TriggerData == nil </span><span class="cov0" title="0">{
                e.logger.Error("TriggerData is nil", "task_id", task.TaskID, "trace_id", traceID)
                return false, fmt.Errorf("trigger data cannot be nil")
        }</span>

        // check if the scheduler signature is valid
        <span class="cov0" title="0">isManagerSignatureTrue, err := e.validator.ValidateManagerSignature(task, traceID)
        if !isManagerSignatureTrue </span><span class="cov0" title="0">{
                e.logger.Error("Manager signature validation failed", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">e.logger.Info("Scheduler signature validation passed", "task_id", task.TaskID, "trace_id", traceID)

        var (
                resultCh = make(chan struct {
                        success bool
                        err     error
                }, len(task.TargetData))
        )

        for i := range len(task.TargetData) </span><span class="cov0" title="0">{
                go func(idx int) </span><span class="cov0" title="0">{
                        // check if trigger is valid
                        isTriggerTrue, err := e.validator.ValidateTrigger(&amp;task.TriggerData[idx], traceID)
                        if !isTriggerTrue </span><span class="cov0" title="0">{
                                e.logger.Error("Trigger validation failed", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("Trigger validation passed", "task_id", task.TaskID, "trace_id", traceID)

                        // Get nonce manager for this chain
                        nonceManager, err := e.getNonceManager(task.TargetData[idx].TargetChainID)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to get nonce manager", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>

                        // Get next nonce atomically
                        <span class="cov0" title="0">nonce, err := nonceManager.GetNextNonce(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to get nonce", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>

                        // create a client for validating event based and performing action
                        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(task.TargetData[idx].TargetChainID)
                        client, err := ethclient.Dial(rpcURL)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to connect to chain", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">defer client.Close()
                        e.logger.Debugf("Connected to chain: %s", rpcURL)

                        // execute the action with the allocated nonce
                        var actionData types.PerformerActionData
                        actionData, err = e.executeAction(&amp;task.TargetData[idx], &amp;task.TriggerData[idx], nonce, client)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to execute action", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("Action execution completed", "task_id", task.TaskID, "trace_id", traceID)
                        

                        ipfsData := types.IPFSData{
                                TaskData: &amp;types.SendTaskDataToKeeper{
                                        TaskID:           []int64{task.TargetData[idx].TaskID},
                                        PerformerData:    task.PerformerData,
                                        TargetData:       []types.TaskTargetData{task.TargetData[idx]},
                                        TriggerData:      []types.TaskTriggerData{task.TriggerData[idx]},
                                        SchedulerID:      task.SchedulerID,
                                        ManagerSignature: task.ManagerSignature,
                                },
                                ActionData:         &amp;actionData,
                                ProofData:          &amp;types.ProofData{},
                                PerformerSignature: &amp;types.PerformerSignatureData{},
                        }
                        ipfsData.ProofData.TaskID = task.TaskID[0]
                        ipfsData.PerformerSignature.TaskID = task.TaskID[0]
                        ipfsData.PerformerSignature.PerformerSigningAddress = config.GetConsensusAddress()

                        tlsConfig := proof.DefaultTLSProofConfig(config.GetTLSProofHost())
                        tlsConfig.TargetPort = config.GetTLSProofPort()
                        proofData, err := proof.GenerateProofWithTLSConnection(ipfsData, tlsConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to generate TLS proof, falling back to mock", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                        }</span> else<span class="cov0" title="0"> {
                                e.logger.Info("TLS proof generated successfully", "task_id", task.TaskID, "trace_id", traceID)
                        }</span>

                        <span class="cov0" title="0">ipfsData.ProofData = &amp;proofData

                        // Create a copy of ipfsData without the signature for signing
                        ipfsDataForSigning := types.IPFSData{
                                TaskData:   ipfsData.TaskData,
                                ActionData: ipfsData.ActionData,
                                ProofData:  ipfsData.ProofData,
                                PerformerSignature: &amp;types.PerformerSignatureData{
                                        TaskID:                  ipfsData.PerformerSignature.TaskID,
                                        PerformerSigningAddress: ipfsData.PerformerSignature.PerformerSigningAddress,
                                        // Note: PerformerSignature field is intentionally left empty for signing
                                },
                        }

                        performerSignature, err := cryptography.SignJSONMessage(ipfsDataForSigning, config.GetPrivateKeyConsensus())
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to sign the ipfs data", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">ipfsData.PerformerSignature = &amp;types.PerformerSignatureData{
                                TaskID:                  task.TaskID[0],
                                PerformerSignature:      performerSignature,
                                PerformerSigningAddress: config.GetConsensusAddress(),
                        }
                        e.logger.Info("IPFS data signed", "task_id", task.TaskID, "trace_id", traceID)

                        filename := fmt.Sprintf("proof_of_task_%d_%s.json", task.TaskID, time.Now().Format("20060102150405"))
                        ipfsDataBytes, err := json.Marshal(ipfsData)
                        if err != nil </span><span class="cov0" title="0">{
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">cid, err := e.validator.IpfsClient.Upload(filename, ipfsDataBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to upload IPFS data", "task_id", task.TaskID, "trace_id", traceID, "error", err)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, err}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("IPFS data uploaded", "task_id", task.TaskID, "trace_id", traceID)

                        aggregatorData := types.BroadcastDataForValidators{
                                ProofOfTask:        proofData.ProofOfTask,
                                Data:               []byte(cid),
                                TaskDefinitionID:   task.TargetData[idx].TaskDefinitionID,
                                PerformerAddress:   config.GetConsensusAddress(),
                        }

                        success, err := e.aggregatorClient.SendTaskToValidators(ctx, &amp;aggregatorData)
                        if !success </span><span class="cov0" title="0">{
                                e.logger.Error("Failed to send task result to aggregator", "task_id", task.TaskID, "error", err, "trace_id", traceID)
                                resultCh &lt;- struct {
                                        success bool
                                        err     error
                                }{false, fmt.Errorf("failed to send task result to aggregator")}
                                return
                        }</span>
                        <span class="cov0" title="0">e.logger.Info("Task result sent to aggregator", "task_id", task.TaskID, "trace_id", traceID)
                        resultCh &lt;- struct {
                                success bool
                                err     error
                        }{true, nil}</span>
                }(i)
        }

        <span class="cov0" title="0">for range task.TargetData </span><span class="cov0" title="0">{
                res := &lt;-resultCh
                if res.err != nil || !res.success </span><span class="cov0" title="0">{
                        return false, res.err
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// getNonceManager returns or creates a nonce manager for the given chain
func (e *TaskExecutor) getNonceManager(chainID string) (*NonceManager, error) <span class="cov0" title="0">{
        e.nonceMutex.RLock()
        if nm, exists := e.nonceManagers[chainID]; exists </span><span class="cov0" title="0">{
                e.nonceMutex.RUnlock()
                return nm, nil
        }</span>
        <span class="cov0" title="0">e.nonceMutex.RUnlock()

        e.nonceMutex.Lock()
        defer e.nonceMutex.Unlock()

        // Double-check after acquiring write lock
        if nm, exists := e.nonceManagers[chainID]; exists </span><span class="cov0" title="0">{
                return nm, nil
        }</span>

        // Create new client and nonce manager
        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(chainID)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create client for chain %s: %w", chainID, err)
        }</span>

        <span class="cov0" title="0">nm := NewNonceManager(client, e.logger)
        if err := nm.Initialize(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize nonce manager for chain %s: %w", chainID, err)
        }</span>

        <span class="cov0" title="0">e.nonceManagers[chainID] = nm
        return nm, nil</span>
}

// func parseStringToInt(str string) int {
//         num, err := strconv.Atoi(str)
//         if err != nil {
//                 return 0
//         }
//         return num
// }
</pre>
		
		<pre class="file" id="file111" style="display: none">package execution

import (
        "context"
        "crypto/ecdsa"
        "fmt"
        "math/big"
        "strings"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi/bind"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// NonceManager handles nonce allocation and transaction retry logic
type NonceManager struct {
        mu           sync.Mutex
        currentNonce uint64
        client       *ethclient.Client
        address      common.Address
        logger       logging.Logger
        lastSyncTime time.Time
        syncInterval time.Duration

        // Transaction tracking
        pendingTxs map[uint64]*PendingTransaction
        txMutex    sync.RWMutex

        // Retry configuration
        maxRetries  int
        baseTimeout time.Duration
        priorityFee *big.Int // Base priority fee for EIP-1559
}

type PendingTransaction struct {
        Nonce        uint64
        TxHash       string
        CreatedAt    time.Time
        Status       string // "pending", "confirmed", "failed", "replaced"
        Attempts     int
        LastGasPrice *big.Int
        Data         []byte
        To           common.Address
        ChainID      *big.Int
        PrivateKey   *ecdsa.PrivateKey
}

// NewNonceManager creates a new nonce manager with optimized retry settings
func NewNonceManager(client *ethclient.Client, logger logging.Logger) *NonceManager <span class="cov0" title="0">{
        return &amp;NonceManager{
                client:       client,
                address:      common.HexToAddress(config.GetKeeperAddress()),
                logger:       logger,
                syncInterval: 15 * time.Second, // More frequent sync for low latency
                maxRetries:   5,                // More retries for reliability
                baseTimeout:  3 * time.Second,  // Shorter timeout for faster retries
                priorityFee:  big.NewInt(2e9),  // 2 Gwei base priority fee
                pendingTxs:   make(map[uint64]*PendingTransaction),
        }
}</span>

// Initialize sets up the initial nonce
func (nm *NonceManager) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        nm.mu.Lock()
        defer nm.mu.Unlock()

        return nm.syncWithBlockchain(ctx)
}</span>

// GetNextNonce returns the next available nonce atomically
func (nm *NonceManager) GetNextNonce(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        nm.mu.Lock()
        defer nm.mu.Unlock()

        // Sync with blockchain if needed
        if time.Since(nm.lastSyncTime) &gt; nm.syncInterval </span><span class="cov0" title="0">{
                if err := nm.syncWithBlockchain(ctx); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to sync nonce with blockchain: %w", err)
                }</span>
        }

        <span class="cov0" title="0">nonce := nm.currentNonce
        nm.currentNonce++

        nm.logger.Debugf("Allocated nonce: %d", nonce)
        return nonce, nil</span>
}

// syncWithBlockchain updates the current nonce from the blockchain
func (nm *NonceManager) syncWithBlockchain(ctx context.Context) error <span class="cov0" title="0">{
        pendingNonce, err := nm.client.PendingNonceAt(ctx, nm.address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pending nonce: %w", err)
        }</span>

        // Use the higher of pending nonce or our current nonce
        <span class="cov0" title="0">if pendingNonce &gt; nm.currentNonce </span><span class="cov0" title="0">{
                nm.currentNonce = pendingNonce
                nm.logger.Infof("Synced nonce with blockchain: %d", nm.currentNonce)
        }</span>

        <span class="cov0" title="0">nm.lastSyncTime = time.Now()
        return nil</span>
}

// SubmitTransactionWithSmartRetry submits a transaction with intelligent retry logic
func (nm *NonceManager) SubmitTransactionWithSmartRetry(
        ctx context.Context,
        nonce uint64,
        to common.Address,
        data []byte,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        // Check if we should replace an existing transaction
        nm.txMutex.RLock()
        if existingTx, exists := nm.pendingTxs[nonce]; exists &amp;&amp; existingTx.Status == "pending" </span><span class="cov0" title="0">{
                nm.txMutex.RUnlock()

                // If existing tx is older than 30 seconds, replace it
                if time.Since(existingTx.CreatedAt) &gt; 30*time.Second </span><span class="cov0" title="0">{
                        return nm.replaceTransaction(ctx, existingTx, data, to, chainID, privateKey)
                }</span>

                // Otherwise, wait for the existing transaction
                <span class="cov0" title="0">return nm.waitForExistingTransaction(ctx, existingTx)</span>
        }
        <span class="cov0" title="0">nm.txMutex.RUnlock()

        // Submit new transaction
        return nm.submitNewTransaction(ctx, nonce, to, data, chainID, privateKey)</span>
}

// submitNewTransaction submits a new transaction with EIP-1559 support
func (nm *NonceManager) submitNewTransaction(
        ctx context.Context,
        nonce uint64,
        to common.Address,
        data []byte,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        // Get current gas parameters
        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get gas parameters: %w", err)
        }</span>

        // Create transaction (prefer EIP-1559 if supported)
        <span class="cov0" title="0">var tx *types.Transaction
        var signedTx *types.Transaction
        var signErr error

        // Try EIP-1559 first if supported
        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Attempting EIP-1559 transaction with nonce %d", nonce)
                tx = types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     nonce,
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Try to sign EIP-1559 transaction
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("EIP-1559 transaction signing failed, falling back to legacy: %v", signErr)
                }</span>
        }

        // Fallback to legacy transaction if EIP-1559 failed or not supported
        <span class="cov0" title="0">if signedTx == nil || signErr != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Using legacy transaction with nonce %d", nonce)
                if gasPrice == nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("gas price is required for legacy transaction")
                }</span>

                <span class="cov0" title="0">tx = types.NewTransaction(nonce, to, big.NewInt(0), 300000, gasPrice, data)
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to sign legacy transaction: %w", signErr)
                }</span>
        }

        // Track the transaction
        <span class="cov0" title="0">nm.trackTransaction(nonce, signedTx.Hash().Hex(), data, to, chainID, privateKey, gasPrice)

        // Submit with retry logic
        return nm.submitWithRetry(ctx, signedTx, nonce, privateKey)</span>
}

// replaceTransaction replaces a stuck transaction with higher fees
func (nm *NonceManager) replaceTransaction(
        ctx context.Context,
        existingTx *PendingTransaction,
        data []byte,
        to common.Address,
        chainID *big.Int,
        privateKey *ecdsa.PrivateKey,
) (*types.Receipt, string, error) <span class="cov0" title="0">{

        nm.logger.Infof("Replacing stuck transaction with nonce %d", existingTx.Nonce)

        // Get higher gas parameters for replacement
        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get gas parameters: %w", err)
        }</span>

        // Increase fees by 20% for replacement
        <span class="cov0" title="0">if gasPrice != nil </span><span class="cov0" title="0">{
                gasPrice = new(big.Int).Mul(gasPrice, big.NewInt(120))
                gasPrice = new(big.Int).Div(gasPrice, big.NewInt(100))
        }</span>
        <span class="cov0" title="0">if maxFeePerGas != nil </span><span class="cov0" title="0">{
                maxFeePerGas = new(big.Int).Mul(maxFeePerGas, big.NewInt(120))
                maxFeePerGas = new(big.Int).Div(maxFeePerGas, big.NewInt(100))
        }</span>
        <span class="cov0" title="0">if maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                maxPriorityFeePerGas = new(big.Int).Mul(maxPriorityFeePerGas, big.NewInt(120))
                maxPriorityFeePerGas = new(big.Int).Div(maxPriorityFeePerGas, big.NewInt(100))
        }</span>

        // Create replacement transaction with fallback logic
        <span class="cov0" title="0">var tx *types.Transaction
        var signedTx *types.Transaction
        var signErr error

        // Try EIP-1559 first if supported
        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Attempting EIP-1559 replacement transaction with nonce %d", existingTx.Nonce)
                tx = types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     existingTx.Nonce,
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Try to sign EIP-1559 transaction
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("EIP-1559 replacement transaction signing failed, falling back to legacy: %v", signErr)
                }</span>
        }

        // Fallback to legacy transaction if EIP-1559 failed or not supported
        <span class="cov0" title="0">if signedTx == nil || signErr != nil </span><span class="cov0" title="0">{
                nm.logger.Debugf("Using legacy replacement transaction with nonce %d", existingTx.Nonce)
                if gasPrice == nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("gas price is required for legacy replacement transaction")
                }</span>

                <span class="cov0" title="0">tx = types.NewTransaction(existingTx.Nonce, to, big.NewInt(0), 300000, gasPrice, data)
                signedTx, signErr = types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if signErr != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to sign legacy replacement transaction: %w", signErr)
                }</span>
        }

        // Update tracking
        <span class="cov0" title="0">nm.updateTransactionStatus(existingTx.Nonce, signedTx.Hash().Hex(), gasPrice)

        return nm.submitWithRetry(ctx, signedTx, existingTx.Nonce, privateKey)</span>
}

// waitForExistingTransaction waits for an existing transaction to be confirmed
func (nm *NonceManager) waitForExistingTransaction(ctx context.Context, existingTx *PendingTransaction) (*types.Receipt, string, error) <span class="cov0" title="0">{
        nm.logger.Infof("Waiting for existing transaction with nonce %d: %s", existingTx.Nonce, existingTx.TxHash)

        // Wait for the transaction to be confirmed
        receipt, err := bind.WaitMined(ctx, nm.client, &amp;types.Transaction{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to wait for existing transaction: %w", err)
        }</span>

        <span class="cov0" title="0">nm.markTransactionConfirmed(existingTx.Nonce, existingTx.TxHash)
        return receipt, existingTx.TxHash, nil</span>
}

// submitWithRetry handles the actual submission with intelligent retry logic
func (nm *NonceManager) submitWithRetry(ctx context.Context, signedTx *types.Transaction, nonce uint64, privateKey *ecdsa.PrivateKey) (*types.Receipt, string, error) <span class="cov0" title="0">{

        for attempt := 0; attempt &lt; nm.maxRetries; attempt++ </span><span class="cov0" title="0">{
                // Send transaction
                err := nm.client.SendTransaction(ctx, signedTx)
                if err != nil </span><span class="cov0" title="0">{
                        nm.logger.Warnf("Failed to send transaction (attempt %d): %v", attempt+1, err)

                        // Check if it's a nonce too low error - this means we need to sync
                        if isNonceTooLowError(err) </span><span class="cov0" title="0">{
                                if syncErr := nm.syncWithBlockchain(ctx); syncErr != nil </span><span class="cov0" title="0">{
                                        return nil, "", fmt.Errorf("failed to sync after nonce error: %w", syncErr)
                                }</span>
                        }

                        <span class="cov0" title="0">if attempt == nm.maxRetries-1 </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("failed to send transaction after %d attempts: %v", nm.maxRetries, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">txHash := signedTx.Hash().Hex()
                nm.logger.Infof("Transaction sent (attempt %d): %s", attempt+1, txHash)

                // Wait for confirmation with exponential backoff
                timeout := nm.baseTimeout * time.Duration(1&lt;&lt;attempt) // Exponential backoff
                ctx, cancel := context.WithTimeout(ctx, timeout)
                receipt, err := bind.WaitMined(ctx, nm.client, signedTx)
                cancel()

                if err == nil </span><span class="cov0" title="0">{
                        nm.markTransactionConfirmed(nonce, txHash)
                        nm.logger.Infof("Transaction confirmed: %s", txHash)
                        return receipt, txHash, nil
                }</span>

                // Handle timeout - create replacement with higher fees
                <span class="cov0" title="0">if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        nm.logger.Warnf("Transaction %s timed out after %v, creating replacement", txHash, timeout)

                        // Create replacement transaction with higher fees
                        replacementTx, err := nm.createReplacementTransaction(signedTx, attempt+1, privateKey)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, "", fmt.Errorf("failed to create replacement transaction: %w", err)
                        }</span>
                        <span class="cov0" title="0">signedTx = replacementTx
                        continue</span>
                }

                // Other error occurred
                <span class="cov0" title="0">nm.logger.Warnf("Error waiting for transaction %s: %v", txHash, err)
                if attempt == nm.maxRetries-1 </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("transaction failed after %d attempts: %v", nm.maxRetries, err)
                }</span>
        }

        <span class="cov0" title="0">return nil, "", fmt.Errorf("transaction failed after %d attempts", nm.maxRetries)</span>
}

// getOptimalGasParams gets optimal gas parameters for current network conditions
func (nm *NonceManager) getOptimalGasParams(ctx context.Context) (*big.Int, *big.Int, *big.Int, error) <span class="cov0" title="0">{

        // Always get legacy gas price as fallback
        gasPrice, err := nm.client.SuggestGasPrice(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to get gas price: %w", err)
        }</span>

        // Add 20% buffer for network congestion
        <span class="cov0" title="0">gasPrice.Mul(gasPrice, big.NewInt(120))
        gasPrice.Div(gasPrice, big.NewInt(100))

        // Try to get EIP-1559 parameters
        head, err := nm.client.HeaderByNumber(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                nm.logger.Warnf("Failed to get latest header for EIP-1559 detection: %v", err)
                return gasPrice, nil, nil, nil
        }</span>

        // Check if EIP-1559 is supported and base fee is reasonable
        <span class="cov0" title="0">if head.BaseFee != nil &amp;&amp; head.BaseFee.Cmp(big.NewInt(0)) &gt; 0 </span><span class="cov0" title="0">{
                nm.logger.Debugf("EIP-1559 detected with base fee: %s", head.BaseFee.String())

                // Calculate optimal EIP-1559 parameters
                baseFee := head.BaseFee
                maxPriorityFeePerGas := new(big.Int).Set(nm.priorityFee)

                // Calculate max fee per gas (base fee + 2x priority fee for safety)
                maxFeePerGas := new(big.Int).Mul(maxPriorityFeePerGas, big.NewInt(2))
                maxFeePerGas.Add(maxFeePerGas, baseFee)

                // Add 20% buffer for network congestion
                maxFeePerGas.Mul(maxFeePerGas, big.NewInt(120))
                maxFeePerGas.Div(maxFeePerGas, big.NewInt(100))

                return gasPrice, maxFeePerGas, maxPriorityFeePerGas, nil
        }</span>

        <span class="cov0" title="0">nm.logger.Debugf("EIP-1559 not supported, using legacy gas price: %s", gasPrice.String())
        return gasPrice, nil, nil, nil</span>
}

// createReplacementTransaction creates a replacement transaction with higher fees
func (nm *NonceManager) createReplacementTransaction(originalTx *types.Transaction, attempt int, privateKey *ecdsa.PrivateKey) (*types.Transaction, error) <span class="cov0" title="0">{
        // Get the transaction data
        var to common.Address
        var data []byte
        var chainID *big.Int

        switch tx := originalTx.Type(); tx </span>{
        case 0:<span class="cov0" title="0"> // Legacy transaction
                to = *originalTx.To()
                data = originalTx.Data()
                chainID = originalTx.ChainId()</span>
        case 2:<span class="cov0" title="0"> // EIP-1559 transaction
                to = *originalTx.To()
                data = originalTx.Data()
                chainID = originalTx.ChainId()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported transaction type: %d", tx)</span>
        }

        // Get higher gas parameters
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        gasPrice, maxFeePerGas, maxPriorityFeePerGas, err := nm.getOptimalGasParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get gas parameters for replacement: %w", err)
        }</span>

        // Increase fees by 20% for each attempt
        <span class="cov0" title="0">feeMultiplier := big.NewInt(int64(120 + (attempt * 20))) // 120%, 140%, 160%, etc.
        feeDivisor := big.NewInt(100)

        if maxFeePerGas != nil &amp;&amp; maxPriorityFeePerGas != nil </span><span class="cov0" title="0">{
                // EIP-1559 replacement
                maxFeePerGas.Mul(maxFeePerGas, feeMultiplier)
                maxFeePerGas.Div(maxFeePerGas, feeDivisor)
                maxPriorityFeePerGas.Mul(maxPriorityFeePerGas, feeMultiplier)
                maxPriorityFeePerGas.Div(maxPriorityFeePerGas, feeDivisor)

                tx := types.NewTx(&amp;types.DynamicFeeTx{
                        ChainID:   chainID,
                        Nonce:     originalTx.Nonce(),
                        GasTipCap: maxPriorityFeePerGas,
                        GasFeeCap: maxFeePerGas,
                        Gas:       300000,
                        To:        &amp;to,
                        Value:     big.NewInt(0),
                        Data:      data,
                })

                // Test if we can sign this transaction type
                _, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
                if err == nil </span><span class="cov0" title="0">{
                        return tx, nil
                }</span>
                <span class="cov0" title="0">nm.logger.Warnf("EIP-1559 replacement transaction signing failed, falling back to legacy: %v", err)</span>
        }

        // Legacy replacement
        <span class="cov0" title="0">if gasPrice == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gas price is required for legacy replacement transaction")
        }</span>

        <span class="cov0" title="0">gasPrice.Mul(gasPrice, feeMultiplier)
        gasPrice.Div(gasPrice, feeDivisor)

        return types.NewTransaction(originalTx.Nonce(), to, big.NewInt(0), 300000, gasPrice, data), nil</span>
}

// Helper methods for transaction tracking
func (nm *NonceManager) trackTransaction(nonce uint64, txHash string, data []byte, to common.Address, chainID *big.Int, privateKey *ecdsa.PrivateKey, gasPrice *big.Int) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        nm.pendingTxs[nonce] = &amp;PendingTransaction{
                Nonce:        nonce,
                TxHash:       txHash,
                CreatedAt:    time.Now(),
                Status:       "pending",
                Attempts:     1,
                LastGasPrice: gasPrice,
                Data:         data,
                To:           to,
                ChainID:      chainID,
                PrivateKey:   privateKey,
        }
}</span>

func (nm *NonceManager) updateTransactionStatus(nonce uint64, txHash string, gasPrice *big.Int) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        if tx, exists := nm.pendingTxs[nonce]; exists </span><span class="cov0" title="0">{
                tx.TxHash = txHash
                tx.Status = "pending"
                tx.Attempts++
                tx.LastGasPrice = gasPrice
                tx.CreatedAt = time.Now()
        }</span>
}

func (nm *NonceManager) markTransactionConfirmed(nonce uint64, txHash string) <span class="cov0" title="0">{
        nm.txMutex.Lock()
        defer nm.txMutex.Unlock()

        if tx, exists := nm.pendingTxs[nonce]; exists </span><span class="cov0" title="0">{
                tx.Status = "confirmed"
                tx.TxHash = txHash
        }</span>
}

// Utility functions
func isNonceTooLowError(err error) bool <span class="cov0" title="0">{
        errStr := err.Error()
        return strings.Contains(errStr, "nonce too low") ||
                strings.Contains(errStr, "replacement transaction underpriced") ||
                strings.Contains(errStr, "already known")
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package execution

import (
        "bytes"
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"

        // "io/ioutil"
        // "net/http"
        // "reflect"
        "strings"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (e *TaskExecutor) getContractMethodAndABI(methodName string, targetData *types.TaskTargetData) (*abi.ABI, *abi.Method, error) <span class="cov0" title="0">{
        if targetData.ABI == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("contract ABI not provided in job data")
        }</span>

        <span class="cov0" title="0">abiData := []byte(targetData.ABI)

        parsed, err := abi.JSON(bytes.NewReader(abiData))
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Error parsing ABI: %v", err)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">e.logger.Debugf("Using ABI from database for contract %s", targetData.TargetContractAddress)

        method, ok := parsed.Methods[methodName]
        if !ok </span><span class="cov0" title="0">{
                e.logger.Warnf("Method %s not found in contract ABI", methodName)
                return nil, nil, fmt.Errorf("method %s not found in contract ABI", methodName)
        }</span>

        <span class="cov0" title="0">e.logger.Debugf("Found method: %+v", method)
        return &amp;parsed, &amp;method, nil</span>
}

func (e *TaskExecutor) processArguments(args interface{}, methodInputs []abi.Argument, contractABI *abi.ABI) ([]interface{}, error) <span class="cov0" title="0">{
        convertedArgs := make([]interface{}, 0)

        e.logger.Debugf("Processing arguments: %+v for method inputs: %+v", args, methodInputs)

        // Handle nil or empty args
        if args == nil </span><span class="cov0" title="0">{
                e.logger.Warnf("Received nil arguments")
                return nil, fmt.Errorf("nil arguments provided")
        }</span>

        // Check if we have any inputs at all
        <span class="cov0" title="0">if len(methodInputs) == 0 </span><span class="cov0" title="0">{
                e.logger.Debugf("Method has no inputs, returning empty args")
                return convertedArgs, nil
        }</span>

        // Handle the case where we have a single struct argument
        <span class="cov0" title="0">if len(methodInputs) == 1 &amp;&amp; methodInputs[0].Type.T == abi.TupleTy </span><span class="cov0" title="0">{
                // Check if the input is a map or JSON string representing the struct
                switch v := args.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Direct map to struct conversion
                        convertedArg, err := e.argConverter.convertToStruct(v, methodInputs[0].Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting to struct: %v", err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                        return convertedArgs, nil</span>
                case string:<span class="cov0" title="0">
                        // Try to parse as JSON struct
                        var structData map[string]interface{}
                        if err := json.Unmarshal([]byte(v), &amp;structData); err == nil </span><span class="cov0" title="0">{
                                convertedArg, err := e.argConverter.convertToStruct(structData, methodInputs[0].Type)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error converting JSON string to struct: %v", err)
                                }</span>
                                <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                return convertedArgs, nil</span>
                        }
                case []interface{}:<span class="cov0" title="0">
                        // If there's a single array element and it's a map, try to use it as a struct
                        if len(v) == 1 </span><span class="cov0" title="0">{
                                if mapVal, ok := v[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        convertedArg, err := e.argConverter.convertToStruct(mapVal, methodInputs[0].Type)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error converting map from array to struct: %v", err)
                                        }</span>
                                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                        return convertedArgs, nil</span>
                                } else<span class="cov0" title="0"> if strVal, ok := v[0].(string); ok </span><span class="cov0" title="0">{
                                        // Try to parse as JSON struct
                                        var structData map[string]interface{}
                                        if err := json.Unmarshal([]byte(strVal), &amp;structData); err == nil </span><span class="cov0" title="0">{
                                                convertedArg, err := e.argConverter.convertToStruct(structData, methodInputs[0].Type)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, fmt.Errorf("error converting JSON string to struct: %v", err)
                                                }</span>
                                                <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                                                return convertedArgs, nil</span>
                                        }
                                }
                        }
                }
        }

        // Handle multiple arguments or non-struct arguments
        <span class="cov0" title="0">switch argData := args.(type) </span>{
        case string:<span class="cov0" title="0">
                // Handle a single string value (like from our script)
                // If there's only one input parameter, use the string value directly
                if len(methodInputs) == 1 </span><span class="cov0" title="0">{
                        // First attempt to remove JSON string quotes if present
                        strValue := argData
                        if strings.HasPrefix(strValue, "\"") &amp;&amp; strings.HasSuffix(strValue, "\"") </span><span class="cov0" title="0">{
                                strValue = strings.Trim(strValue, "\"")
                        }</span>

                        <span class="cov0" title="0">convertedArg, err := e.argConverter.convertToType(strValue, methodInputs[0].Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting string argument: %v", err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)
                        return convertedArgs, nil</span>
                } else<span class="cov0" title="0"> {
                        // Try to parse as JSON array for multiple parameters
                        var arrayData []interface{}
                        if err := json.Unmarshal([]byte(argData), &amp;arrayData); err == nil </span><span class="cov0" title="0">{
                                if len(arrayData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("not enough arguments in JSON array: expected %d, got %d",
                                                len(methodInputs), len(arrayData))
                                }</span>

                                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                                        convertedArg, err := e.argConverter.convertToType(arrayData[i], inputParam.Type)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                                        }</span>
                                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                                }
                                <span class="cov0" title="0">return convertedArgs, nil</span>
                        }

                        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert single string to %d arguments", len(methodInputs))</span>
                }
        case []string:<span class="cov0" title="0">
                // Handle simple string array
                if len(argData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not enough arguments provided: expected %d, got %d",
                                len(methodInputs), len(argData))
                }</span>

                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        convertedArg, err := e.argConverter.convertToType(argData[i], inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        case []interface{}:<span class="cov0" title="0">
                // Handle array of mixed types
                if len(argData) &lt; len(methodInputs) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("not enough arguments provided: expected %d, got %d",
                                len(methodInputs), len(argData))
                }</span>

                <span class="cov0" title="0">for i, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        convertedArg, err := e.argConverter.convertToType(argData[i], inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        case map[string]interface{}:<span class="cov0" title="0">
                // Handle map of named arguments
                for _, inputParam := range methodInputs </span><span class="cov0" title="0">{
                        paramName := inputParam.Name
                        if paramName == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot use map arguments with unnamed parameters")
                        }</span>

                        <span class="cov0" title="0">argValue, exists := argData[paramName]
                        if !exists </span><span class="cov0" title="0">{
                                // Try with case-insensitive match
                                for k, v := range argData </span><span class="cov0" title="0">{
                                        if strings.EqualFold(k, paramName) </span><span class="cov0" title="0">{
                                                argValue = v
                                                exists = true
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("argument %s not found in input data", paramName)
                                }</span>
                        }

                        <span class="cov0" title="0">convertedArg, err := e.argConverter.convertToType(argValue, inputParam.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting argument %s: %v", paramName, err)
                        }</span>
                        <span class="cov0" title="0">convertedArgs = append(convertedArgs, convertedArg)</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported argument format: %T", args)</span>
        }

        <span class="cov0" title="0">return convertedArgs, nil</span>
}

func (e *TaskExecutor) parseDynamicArgs(output string) []interface{} <span class="cov0" title="0">{
        // First try to parse as JSON
        var argData []interface{}
        if err := json.Unmarshal([]byte(output), &amp;argData); err == nil &amp;&amp; len(argData) &gt; 0 </span><span class="cov0" title="0">{
                e.logger.Debugf("Successfully parsed dynamic arguments as JSON: %v", argData)
                return argData
        }</span>

        // If JSON parsing fails, try to extract values from container logs
        // Look for lines containing "Response:" which typically contain the values we need
        <span class="cov0" title="0">responsePattern := regexp.MustCompile(`Response:\s*([\d\.]+)`)
        matches := responsePattern.FindAllStringSubmatch(output, -1)

        if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                // Extract all response values
                argData = make([]interface{}, 0, len(matches))
                for _, match := range matches </span><span class="cov0" title="0">{
                        if len(match) &gt;= 2 </span><span class="cov0" title="0">{
                                // Try to parse as float first
                                if val, err := strconv.ParseFloat(match[1], 64); err == nil </span><span class="cov0" title="0">{
                                        e.logger.Debugf("Found numeric response value: %v", val)
                                        argData = append(argData, val)
                                        continue</span>
                                }

                                // If not a number, use as string
                                <span class="cov0" title="0">e.logger.Debugf("Found string response value: %s", match[1])
                                argData = append(argData, match[1])</span>
                        }
                }

                <span class="cov0" title="0">if len(argData) &gt; 0 </span><span class="cov0" title="0">{
                        return argData
                }</span>
        }

        // If we can't find "Response:" lines, look for any numeric values
        <span class="cov0" title="0">numericPattern := regexp.MustCompile(`[\d\.]+`)
        numMatches := numericPattern.FindAllString(output, -1)

        if len(numMatches) &gt; 0 </span><span class="cov0" title="0">{
                // Filter out timestamps and other irrelevant numbers
                for _, match := range numMatches </span><span class="cov0" title="0">{
                        if val, err := strconv.ParseFloat(match, 64); err == nil </span><span class="cov0" title="0">{
                                // Only consider "significant" numbers (not small ones that might be timestamps)
                                if val &gt; 100 </span><span class="cov0" title="0">{
                                        e.logger.Debugf("Found significant numeric value: %v", val)
                                        argData = append(argData, val)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(argData) &gt; 0 </span><span class="cov0" title="0">{
                        return argData
                }</span>
        }

        // As a fallback, check for "Condition satisfied: true" pattern
        <span class="cov0" title="0">if strings.Contains(output, "Condition satisfied: true") </span><span class="cov0" title="0">{
                e.logger.Debugf("Found condition satisfied pattern, using true as argument")
                return []interface{}{true}
        }</span>

        <span class="cov0" title="0">e.logger.Warnf("Failed to extract any arguments from output: %s", output)
        return []interface{}{"0"}</span> // Return a default value as fallback
}

func (e *TaskExecutor) parseStaticArgs(args []string) []interface{} <span class="cov0" title="0">{
        var argData []interface{}

        for _, arg := range args </span><span class="cov0" title="0">{
                argData = append(argData, arg)
        }</span>

        <span class="cov0" title="0">return argData</span>
}

// func (e *TaskExecutor) decodeContractOutput(contractABI *abi.ABI, method *abi.Method, output []byte) (interface{}, error) {
//         // Handle different output scenarios
//         if len(method.Outputs) == 0 {
//                 e.logger.Infof("Method %s has no outputs to decode", method.Name)
//                 return nil, nil
//         }

//         // Single output case
//         if len(method.Outputs) == 1 {
//                 outputType := method.Outputs[0]
//                 result := reflect.New(outputType.Type.GetType()).Elem()

//                 err := contractABI.UnpackIntoInterface(result.Addr().Interface(), method.Name, output)
//                 if err != nil {
//                         e.logger.Warnf("Error unpacking single output: %v", err)
//                         return nil, err
//                 }

//                 e.logger.Infof("Decoded single output: %v", result.Interface())
//                 return result.Interface(), nil
//         }

//         // Multiple outputs case
//         results := make([]interface{}, len(method.Outputs))
//         err := contractABI.UnpackIntoInterface(&amp;results, method.Name, output)
//         if err != nil {
//                 e.logger.Warnf("Error unpacking multiple outputs: %v", err)
//                 return nil, err
//         }

//         e.logger.Infof("Decoded multiple outputs: %+v", results)
//         return results, nil
// }

// func (e *JobExecutor) fetchContractABI(contractAddress string) ([]byte, error) {
//         if e.etherscanAPIKey == "" {
//                 return nil, fmt.Errorf("missing Etherscan API key")
//         }

//         // Update the URL to use Optimism Sepolia's API endpoint
//         blockscoutUrl := fmt.Sprintf(
//                 "https://optimism-sepolia.blockscout.com/api?module=contract&amp;action=getabi&amp;address=%s",
//                 contractAddress)

//         resp, err := http.Get(blockscoutUrl)
//         if err != nil || resp.StatusCode != http.StatusOK {
//                 logger.Warnf("Failed to fetch ABI from Blockscout: %v", err)
//                 // Fall back to another source or handle accordingly
//         }

//         defer resp.Body.Close()

//         body, err := ioutil.ReadAll(resp.Body)
//         if err != nil {
//                 return nil, err
//         }

//         var response struct {
//                 Status  string `json:"status"`
//                 Message string `json:"message"`
//                 Result  string `json:"result"`
//         }

//         err = json.Unmarshal(body, &amp;response)
//         if err != nil {
//                 return nil, err
//         }

//         if response.Status != "1" {
//                 return nil, fmt.Errorf("error fetching contract ABI: %s", response.Message)
//         }

//         return []byte(response.Result), nil
// }
</pre>
		
		<pre class="file" id="file113" style="display: none">package validation

import (
        "context"
        "fmt"
        "time"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/types"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
)

const timeTolerance = 2200 * time.Millisecond
const expirationTimeTolerance = 5 * time.Second

func (v *TaskValidator) ValidateAction(targetData *types.TaskTargetData, triggerData *types.TaskTriggerData, actionData *types.PerformerActionData, client *ethclient.Client, traceID string) (bool, error) <span class="cov0" title="0">{
        // v.logger.Infof("txHash: %s", actionData.ActionTxHash)
        // time.Sleep(10 * time.Second)
        // Fetch the tx details from the action data
        txHash := common.HexToHash(actionData.ActionTxHash)
        receipt, err := client.TransactionReceipt(context.Background(), txHash)
        if err != nil || receipt == nil </span><span class="cov0" title="0">{
                _, isPending, err := client.TransactionByHash(context.Background(), txHash)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to get transaction: %v", err)
                }</span>
                <span class="cov0" title="0">if isPending </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction is pending")
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("transaction is not found")</span>
        }

        // check if the tx is successful
        <span class="cov0" title="0">if receipt.Status != 1 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction is not successful")
        }</span>

        // TODO: get the action tx check right
        // check if the tx was made to correct target contract
        // fetch the AA contract address and the transaction from there to complete the flow

        <span class="cov0" title="0">txTimestamp, err := v.getBlockTimestamp(receipt, utils.GetChainRpcUrl(targetData.TargetChainID))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get block timestamp: %v", err)
        }</span>

        // check if the tx was made before expiration time + tolerance
        <span class="cov0" title="0">if txTimestamp.After(triggerData.ExpirationTime.Add(expirationTimeTolerance)) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was made after the expiration time by %v", txTimestamp.Sub(triggerData.ExpirationTime.Add(expirationTimeTolerance)))
        }</span>

        // check if the task was time, if yes, check if it was executed within the time interval + tolerance
        <span class="cov0" title="0">if targetData.TaskDefinitionID == 1 || targetData.TaskDefinitionID == 2 </span><span class="cov0" title="0">{
                if txTimestamp.After(triggerData.NextTriggerTimestamp.Add(timeTolerance)) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction was made after the next execution timestamp by %v", txTimestamp.Sub(triggerData.NextTriggerTimestamp.Add(timeTolerance)))
                }</span>
                // if txTimestamp.Before(triggerData.NextTriggerTimestamp.Add(-timeTolerance)) {
                //         return false, fmt.Errorf("transaction was made before the next execution timestamp by %v", triggerData.NextTriggerTimestamp.Add(-timeTolerance).Sub(txTimestamp))
                // }
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package validation

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"

        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/proof"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (v *TaskValidator) ValidateProof(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        proofData := ipfsData.ProofData
        if proofData == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("proof data is missing")
        }</span>
        <span class="cov0" title="0">if proofData.ProofOfTask == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("proof of task is empty")
        }</span>
        <span class="cov0" title="0">if proofData.CertificateHash == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("certificate hash is empty")
        }</span>

        // Validate TLS certificate by establishing connection to the same host/port
        // that was used during proof generation
        <span class="cov0" title="0">tlsConfig := proof.DefaultTLSProofConfig(config.GetTLSProofHost())
        tlsConfig.TargetPort = config.GetTLSProofPort()

        connState, err := proof.EstablishTLSConnection(tlsConfig)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Warn("Failed to establish TLS connection for validation", "trace_id", traceID, "error", err)
        }</span>
        <span class="cov0" title="0">if connState == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to establish TLS connection for validation")
        }</span>

        // Verify the certificate hash matches what was recorded in the proof
        <span class="cov0" title="0">if len(connState.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no peer certificates found during validation")
        }</span>

        <span class="cov0" title="0">currentCertHash := sha256.Sum256(connState.PeerCertificates[0].Raw)
        currentCertHashStr := hex.EncodeToString(currentCertHash[:])

        if currentCertHashStr != proofData.CertificateHash </span><span class="cov0" title="0">{
                v.logger.Warn("Certificate hash mismatch during validation",
                        "trace_id", traceID,
                        "expected", proofData.CertificateHash,
                        "actual", currentCertHashStr)
                // Certificate might have been renewed, this is not necessarily an error
                // but should be logged for investigation
        }</span>

        // Validate the proof hash by regenerating it
        <span class="cov0" title="0">return v.validateProofHash(ipfsData, traceID)</span>
}

func (v *TaskValidator) validateProofHash(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        // Create a copy of IPFS data without the proof for hash validation
        ipfsDataForValidation := types.IPFSData{
                TaskData:           ipfsData.TaskData,
                ActionData:         ipfsData.ActionData,
                ProofData:          &amp;types.ProofData{},
                PerformerSignature: &amp;types.PerformerSignatureData{},
        }
        ipfsDataForValidation.ProofData.TaskID = ipfsData.TaskData.TaskID[0]
        ipfsDataForValidation.PerformerSignature.TaskID = ipfsData.TaskData.TaskID[0]
        ipfsDataForValidation.PerformerSignature.PerformerSigningAddress = ipfsData.PerformerSignature.PerformerSigningAddress

        // Regenerate the proof hash
        dataStr, err := proof.StringifyIPFSData(ipfsDataForValidation)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to stringify IPFS data for validation: %w", err)
        }</span>

        <span class="cov0" title="0">expectedProofHash := sha256.Sum256([]byte(dataStr))
        expectedProofHashStr := hex.EncodeToString(expectedProofHash[:])

        if expectedProofHashStr != ipfsData.ProofData.ProofOfTask </span><span class="cov0" title="0">{
                return false, fmt.Errorf("proof hash validation failed: expected %s, got %s",
                        expectedProofHashStr, ipfsData.ProofData.ProofOfTask)
        }</span>

        <span class="cov0" title="0">v.logger.Info("Proof validation passed", "trace_id", traceID, "task_id", ipfsData.TaskData.TaskID)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package validation

import (
        "fmt"

        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (v *TaskValidator) ValidateManagerSignature(task *types.SendTaskDataToKeeper, traceID string) (bool, error) <span class="cov0" title="0">{
        logger := v.logger.With("traceID", traceID)

        // check if the manager signature is valid
        if task.ManagerSignature == "" </span><span class="cov0" title="0">{
                logger.Error("Manager signature data is missing")
                return false, fmt.Errorf("manager signature data is missing")
        }</span>

        // Create a copy of the task data without the signature for verification
        <span class="cov0" title="0">taskDataForVerification := types.SendTaskDataToKeeper{
                TaskID:        task.TaskID,
                PerformerData: task.PerformerData,
                TargetData:    task.TargetData,
                TriggerData:   task.TriggerData,
                SchedulerID:   task.SchedulerID,
        }

        // Convert the task data to JSON message format (same as signing process)
        isValid, err := cryptography.VerifySignatureFromJSON(
                taskDataForVerification,
                task.ManagerSignature,
                config.GetManagerSigningAddress(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to verify manager signature", "error", err)
                return false, fmt.Errorf("failed to verify manager signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("Manager signature verification failed")
                return false, fmt.Errorf("manager signature verification failed")
        }</span>

        <span class="cov0" title="0">logger.Info("Manager signature verification successful")
        return true, nil</span>
}

func (v *TaskValidator) ValidatePerformerSignature(ipfsData types.IPFSData, traceID string) (bool, error) <span class="cov0" title="0">{
        logger := v.logger.With("traceID", traceID)

        if ipfsData.PerformerSignature == nil </span><span class="cov0" title="0">{
                logger.Error("Performer signature data is missing")
                return false, fmt.Errorf("performer signature data is missing")
        }</span>

        <span class="cov0" title="0">if ipfsData.PerformerSignature.PerformerSignature == "" </span><span class="cov0" title="0">{
                logger.Error("Performer signature is empty")
                return false, fmt.Errorf("performer signature is empty")
        }</span>

        <span class="cov0" title="0">if ipfsData.PerformerSignature.PerformerSigningAddress == "" </span><span class="cov0" title="0">{
                logger.Error("Performer signing address is empty")
                return false, fmt.Errorf("performer signing address is empty")
        }</span>

        // TODO: Uncomment this when we have a way to get the Consensus address to perform the action with AA
        // check if the performer is the same as the the one assigned to the task
        // if ipfsData.PerformerSignature.PerformerSigningAddress != ipfsData.TaskData.PerformerData.KeeperAddress {
        //         return false, fmt.Errorf("performer signing address does not match the assigned performer")
        // }

        // Create a copy of the ipfs data without the signature for verification
        <span class="cov0" title="0">ipfsDataForVerification := types.IPFSData{
                TaskData:   ipfsData.TaskData,
                ActionData: ipfsData.ActionData,
                ProofData:  ipfsData.ProofData,
                PerformerSignature: &amp;types.PerformerSignatureData{
                        TaskID:                  ipfsData.PerformerSignature.TaskID,
                        PerformerSigningAddress: ipfsData.PerformerSignature.PerformerSigningAddress,
                        // Note: PerformerSignature field is intentionally left empty for verification
                },
        }

        // Convert the task data to JSON message format (same as signing process)
        isValid, err := cryptography.VerifySignatureFromJSON(
                ipfsDataForVerification,
                ipfsData.PerformerSignature.PerformerSignature,
                ipfsData.PerformerSignature.PerformerSigningAddress,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to verify performer signature", "error", err)
                return false, fmt.Errorf("failed to verify performer signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("Performer signature verification failed")
                return false, fmt.Errorf("performer signature verification failed")
        }</span>

        <span class="cov0" title="0">logger.Info("Performer signature verification successful")
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package validation

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// Supported condition types
const (
        ConditionGreaterThan  = "greater_than"
        ConditionLessThan     = "less_than"
        ConditionBetween      = "between"
        ConditionEquals       = "equals"
        ConditionNotEquals    = "not_equals"
        ConditionGreaterEqual = "greater_equal"
        ConditionLessEqual    = "less_equal"
)

func (e *TaskValidator) ValidateTrigger(triggerData *types.TaskTriggerData, traceID string) (bool, error) <span class="cov0" title="0">{
        e.logger.Info("Validating trigger data", "task_id", triggerData.TaskID, "trace_id", traceID)

        switch triggerData.TaskDefinitionID </span>{
        case 1, 2:<span class="cov0" title="0">
                isValid, err := e.IsValidTimeBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        case 3, 4:<span class="cov0" title="0">
                isValid, err := e.IsValidEventBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        case 5, 6:<span class="cov0" title="0">
                isValid, err := e.IsValidConditionBasedTrigger(triggerData)
                if !isValid </span><span class="cov0" title="0">{
                        return isValid, err
                }</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid task definition id: %d", triggerData.TaskDefinitionID)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidTimeBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>

        // rest validation is handled when we validate the action

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidEventBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>
        
        <span class="cov0" title="0">rpcURL := utils.GetChainRpcUrl(triggerData.EventChainId)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to connect to chain: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // Check if the contract exists on chain
        contractCode, err := client.CodeAt(context.Background(), common.HexToAddress(triggerData.EventTriggerContractAddress), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check contract existence: %v", err)
        }</span>

        <span class="cov0" title="0">if len(contractCode) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no contract found at address: %s", triggerData.EventTriggerContractAddress)
        }</span>

        // check if the tx is successful
        <span class="cov0" title="0">txHash := common.HexToHash(triggerData.EventTxHash)
        receipt, err := client.TransactionReceipt(context.Background(), txHash)
        if err != nil </span><span class="cov0" title="0">{
                _, isPending, err := client.TransactionByHash(context.Background(), txHash)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to get transaction: %v", err)
                }</span>
                <span class="cov0" title="0">if isPending </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("transaction is pending")
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("transaction is not found")</span>
        }

        // check if the tx is successful
        <span class="cov0" title="0">if receipt.Status != 1 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction is not successful")
        }</span>

        // check if the tx was made to correct target contract
        <span class="cov0" title="0">if receipt.Logs[0].Address != common.HexToAddress(triggerData.EventTriggerContractAddress) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was not made to correct target contract")
        }</span>

        <span class="cov0" title="0">txTimestamp, err := v.getBlockTimestamp(receipt, rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get block timestamp: %v", err)
        }</span>

        <span class="cov0" title="0">expirationTime := triggerData.ExpirationTime.UTC()

        if txTimestamp.After(expirationTime.Add(timeTolerance)) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("transaction was made after the expiration time (tx: %v, exp+tolerance: %v)",
                        txTimestamp.Format(time.RFC3339),
                        expirationTime.Add(timeTolerance).Format(time.RFC3339))
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (v *TaskValidator) IsValidConditionBasedTrigger(triggerData *types.TaskTriggerData) (bool, error) <span class="cov0" title="0">{
        // check if expiration time is before trigger timestamp
        if triggerData.ExpirationTime.Before(triggerData.NextTriggerTimestamp) </span><span class="cov0" title="0">{
                return false, errors.New("expiration time is before trigger timestamp")
        }</span>
        // v.logger.Infof("trigger data: %+v", triggerData)
        <span class="cov0" title="0">v.logger.Infof("value: %v | upper limit: %v | lower limit: %v", triggerData.ConditionSatisfiedValue, triggerData.ConditionUpperLimit, triggerData.ConditionLowerLimit)

        // check if the condition was satisfied by the value
        if triggerData.ConditionType == ConditionEquals </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue == triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionNotEquals </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue != triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionGreaterThan </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt; triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionLessThan </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &lt; triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionGreaterEqual </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt;= triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionLessEqual </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &lt;= triggerData.ConditionUpperLimit, nil
        }</span>
        <span class="cov0" title="0">if triggerData.ConditionType == ConditionBetween </span><span class="cov0" title="0">{
                return triggerData.ConditionSatisfiedValue &gt;= triggerData.ConditionLowerLimit &amp;&amp; triggerData.ConditionSatisfiedValue &lt;= triggerData.ConditionUpperLimit, nil
        }</span>

        // TODO: add: to fetch the data at trigger timestamp, and check if the values fetched is true
        // oracles would be easy, apis would not be possible if there is no support for it

        <span class="cov0" title="0">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package validation

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"

        ethtypes "github.com/ethereum/go-ethereum/core/types"
)

func (v *TaskValidator) getBlockTimestamp(receipt *ethtypes.Receipt, rpcURL string) (time.Time, error) <span class="cov0" title="0">{
        blockNumberHex := fmt.Sprintf("0x%x", receipt.BlockNumber)
        reqBody := map[string]interface{}{
                "jsonrpc": "2.0",
                "method":  "eth_getBlockByNumber",
                "params": []interface{}{
                        blockNumberHex,
                        false,
                },
                "id": 1,
        }
        reqBytes, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to marshal eth_getBlockReceipts request: %v", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequest("POST", rpcURL, bytes.NewBuffer(reqBytes))
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to create eth_getBlockReceipts request: %v", err)
        }</span>
        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        httpClient := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to call eth_getBlockReceipts: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return time.Time{}, fmt.Errorf("eth_getBlockReceipts returned status %d: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var rpcResp struct {
                Result json.RawMessage `json:"result"`
                Error  interface{}     `json:"error"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;rpcResp); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to decode eth_getBlockReceipts response: %v", err)
        }</span>
        <span class="cov0" title="0">if rpcResp.Error != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("eth_getBlockReceipts error: %v", rpcResp.Error)
        }</span>

        <span class="cov0" title="0">var block map[string]interface{}
        if err := json.Unmarshal(rpcResp.Result, &amp;block); err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to unmarshal block: %v", err)
        }</span>

        <span class="cov0" title="0">timestampHex, ok := block["timestamp"].(string)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("block timestamp is not a string")
        }</span>
        <span class="cov0" title="0">timestampInt, err := strconv.ParseInt(timestampHex, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to parse block timestamp hex: %v", err)
        }</span>
        <span class="cov0" title="0">txTimestamp := time.Unix(timestampInt, 0).UTC()

        return txTimestamp, nil</span>
}

// func (v *TaskValidator) fetchContractABI(contractAddress string) (string, error) {
//         blockscoutUrl := fmt.Sprintf(
//                 "https://optimism-sepolia.blockscout.com/api?module=contract&amp;action=getabi&amp;address=%s",
//                 contractAddress)

//         resp, err := http.Get(blockscoutUrl)
//         if err == nil &amp;&amp; resp.StatusCode == http.StatusOK {
//                 defer func() {
//                         _ = resp.Body.Close()
//                 }()

//                 body, err := io.ReadAll(resp.Body)
//                 if err == nil {
//                         var response struct {
//                                 Status  string `json:"status"`
//                                 Message string `json:"message"`
//                                 Result  string `json:"result"`
//                         }

//                         err = json.Unmarshal(body, &amp;response)
//                         if err == nil &amp;&amp; response.Status == "1" {
//                                 return response.Result, nil
//                         }
//                 }
//         }
//         etherscanUrl := fmt.Sprintf(
//                 "https://api-sepolia-optimism.etherscan.io/api?module=contract&amp;action=getabi&amp;address=%s&amp;apikey=%s",
//                 contractAddress, v.etherscanAPIKey)

//         resp, err = http.Get(etherscanUrl)
//         if err != nil {
//                 return "", fmt.Errorf("failed to fetch ABI from both APIs: %v", err)
//         }
//         defer func() {
//                 _ = resp.Body.Close()
//         }()

//         if resp.StatusCode != http.StatusOK {
//                 return "", fmt.Errorf("failed to fetch ABI from both APIs, Etherscan status code: %d", resp.StatusCode)
//         }

//         body, err := io.ReadAll(resp.Body)
//         if err != nil {
//                 return "", fmt.Errorf("failed to read Etherscan response body: %v", err)
//         }

//         var response struct {
//                 Status  string `json:"status"`
//                 Message string `json:"message"`
//                 Result  string `json:"result"`
//         }

//         err = json.Unmarshal(body, &amp;response)
//         if err != nil {
//                 return "", fmt.Errorf("failed to parse Etherscan JSON response: %v", err)
//         }

//         if response.Status != "1" {
//                 return "", fmt.Errorf("error from both APIs, Etherscan error: %s", response.Message)
//         }

//         return response.Result, nil
// }
</pre>
		
		<pre class="file" id="file118" style="display: none">package validation

import (
        "context"
        "encoding/hex"

        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/utils"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
        "github.com/trigg3rX/triggerx-backend/pkg/docker"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
)

type TaskValidator struct {
        alchemyAPIKey    string
        etherscanAPIKey  string
        dockerManager    *docker.DockerManager
        aggregatorClient *aggregator.AggregatorClient
        logger           logging.Logger
        IpfsClient       ipfs.IPFSClient
}

func NewTaskValidator(
        alchemyAPIKey string,
        etherscanAPIKey string,
        dockerManager *docker.DockerManager,
        aggregatorClient *aggregator.AggregatorClient,
        logger logging.Logger,
        ipfsClient ipfs.IPFSClient,
) *TaskValidator <span class="cov0" title="0">{
        return &amp;TaskValidator{
                alchemyAPIKey:    alchemyAPIKey,
                etherscanAPIKey:  etherscanAPIKey,
                dockerManager:    dockerManager,
                aggregatorClient: aggregatorClient,
                logger:           logger,
                IpfsClient:       ipfsClient,
        }
}</span>

func (v *TaskValidator) ValidateTask(ctx context.Context, data string, traceID string) (bool, error) <span class="cov0" title="0">{
        // Decode the data if it's hex-encoded (with 0x prefix)
        dataBytes, err := hex.DecodeString(data[2:]) // Remove "0x" prefix before decoding
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Error("Failed to hex-decode data", "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">decodedData := string(dataBytes)
        ipfsData, err := v.IpfsClient.Fetch(decodedData)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Error("Failed to fetch IPFS content", "trace_id", traceID, "error", err)
                return false, err
        }</span>

        // check if the scheduler signature is valid
        <span class="cov0" title="0">isManagerSignatureTrue, err := v.ValidateManagerSignature(ipfsData.TaskData, traceID)
        if !isManagerSignatureTrue </span><span class="cov0" title="0">{
                v.logger.Error("Manager signature validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Scheduler signature validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        rpcURL := utils.GetChainRpcUrl(ipfsData.TaskData.TargetData[0].TargetChainID)
        client, err := ethclient.Dial(rpcURL)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Error("Failed to connect to chain", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        // check if trigger is valid
        isTriggerTrue, err := v.ValidateTrigger(&amp;ipfsData.TaskData.TriggerData[0], traceID)
        if !isTriggerTrue </span><span class="cov0" title="0">{
                v.logger.Error("Trigger validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Trigger validation successful", "traceID", traceID)

        // check if the action is valid
        isActionTrue, err := v.ValidateAction(&amp;ipfsData.TaskData.TargetData[0], &amp;ipfsData.TaskData.TriggerData[0], ipfsData.ActionData, client, traceID)
        if !isActionTrue </span><span class="cov0" title="0">{
                v.logger.Error("Action validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Action validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        // validate the proof data
        isProofTrue, err := v.ValidateProof(ipfsData, traceID)
        if !isProofTrue </span><span class="cov0" title="0">{
                v.logger.Error("Proof validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Proof validation passed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID)

        // check if the performer signature is valid
        isPerformerSignatureTrue, err := v.ValidatePerformerSignature(ipfsData, traceID)
        if !isPerformerSignatureTrue </span><span class="cov0" title="0">{
                v.logger.Error("Performer signature validation failed", "task_id", ipfsData.TaskData.TaskID, "trace_id", traceID, "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">v.logger.Info("Target validation successful", "traceID", traceID)

        return true, nil</span>
}

// ValidateTarget validates a target
func (v *TaskValidator) ValidateTarget(targetData *types.TaskTargetData, traceID string) (bool, error) <span class="cov0" title="0">{
        // TODO: Implement target validation
        return true, nil
}</span>

// GetDockerManager returns the DockerManager instance
func (v *TaskValidator) GetDockerManager() *docker.DockerManager <span class="cov0" title="0">{
        return v.dockerManager
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "uptime_seconds",
                Help:      "The uptime of the keeper service in seconds",
        })

        // Total task processing requests on keeper API server
        TasksReceivedTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_received_total",
                Help:      "Total tasks received",
        })

        // Totla task completed successfully, type: executed, validated
        TasksCompletedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_completed_total",
                Help:      "Total tasks completed",
        }, []string{"type"})

        // Time taken for task completion, type: executed, validated
        TaskDurationSeconds = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "task_duration_seconds",
                Help:      "Time taken for task completion",
                Buckets:   prometheus.DefBuckets,
        }, []string{"type"})

        // Total tasks validated by type/id: 1-6
        TasksByDefinitionIDTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_by_definition_id_total",
                Help:      "Tasks validated by type/id",
        }, []string{"id"})

        // Transaction metrics
        TransactionsSentTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "transactions_sent_total",
                Help:      "Total transactions done for task executions",
        }, []string{"chain_id", "status"})
        GasUsedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "gas_used_total",
                Help:      "Total gas used in transactions",
        }, []string{"chain_id"})
        TransactionFeesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "transaction_fees_total",
                Help:      "Total transaction fee incurred in transactions",
        }, []string{"chain_id"})

        // IPFS metrics
        IPFSDownloadSizeBytes = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "ipfs_download_size_bytes",
                Help:      "Total IPFS content downloaded",
        })
        IPFSUploadSizeBytes = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "ipfs_upload_size_bytes",
                Help:      "Total IPFS content uploaded",
        })

        // Health metrics
        SuccessfulHealthCheckinsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "successful_health_checkins_total",
                Help:      "Total successful health checkins",
        })

        // System metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization",
        })

        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Docker metrics
        DockerContainersCreatedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "docker_containers_created_total",
                Help:      "Docker container creation count",
        }, []string{"language"})
        
        DockerContainerDurationSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "docker_container_duration_seconds",
                Help:      "Container execution time",
        }, []string{"language"})

        // Aggregate metrics
        TaskSuccessRate = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "task_success_rate",
                Help:      "Overall task success percentage",
        }, []string{"type"})

        // Average task completion time in seconds, type: executed, validated
        // AverageTaskCompletionTimeSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
        //         Namespace: "triggerx",
        //         Subsystem: "keeper",
        //         Name:      "average_task_completion_time_seconds",
        //         Help:      "Mean completion time",
        // }, []string{"type"})

        // Tasks per minute, type: executed, validated
        TasksPerDay = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "tasks_per_day",
                Help:      "Task throughput rate",
        }, []string{"type"})

        // Total service restarts
        RestartsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "keeper",
                Name:      "restarts_total",
                Help:      "Service restart count",
        })
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()

        // Reset metrics every day
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        TasksPerDay.Reset()
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package utils

import (
        "fmt"
        "github.com/trigg3rX/triggerx-backend/internal/keeper/config"
)

func GetChainRpcUrl(chainID string) string <span class="cov8" title="1">{
        switch chainID </span>{
        case "11155111":<span class="cov8" title="1">
                return fmt.Sprintf("https://eth-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        case "11155420":<span class="cov8" title="1">
                return fmt.Sprintf("https://opt-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        case "84532":<span class="cov8" title="1">
                return fmt.Sprintf("https://base-sepolia.g.alchemy.com/v2/%s", config.GetAlchemyAPIKey())</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package utils

import (
        "fmt"
        "io"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

func FetchDataFromUrl(url string, logger logging.Logger) (string, error) <span class="cov8" title="1">{
        response, err := http.Get(url)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to fetch data from url: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := response.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing response body", "error", err)
                }</span>
        }()

        <span class="cov8" title="1">body, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov8" title="1">return string(body), nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package handlers

import (
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Handler struct {
        logger logging.Logger
}

func NewHandler(logger logging.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                logger: logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func (h *Handler) HandleMetrics(c *gin.Context) <span class="cov0" title="0">{
        promhttp.Handler().ServeHTTP(c.Writer, c.Request)
}</pre>
		
		<pre class="file" id="file125" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "net/http"
)

func (h *Handler) HandleStatus(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "ok"})
}</pre>
		
		<pre class="file" id="file126" style="display: none">package api

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

func LoggingMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                logger.Debugf("HTTP Request: %s %s", c.Request.Method, c.Request.URL.Path)
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package api

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/config"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/api/handlers"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Server struct {
    router     *gin.Engine
    httpServer *http.Server
    logger     logging.Logger
}

func NewServer(logger logging.Logger) *Server <span class="cov0" title="0">{
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()
    
    srv := &amp;Server{
        router:  router,
        logger:  logger,
        httpServer: &amp;http.Server{
            Addr:    fmt.Sprintf(":%s", config.GetRegistrarPort()),
            Handler: router,
        },
    }
    
    srv.setupRoutes()
    return srv
}</span>

func (s *Server) setupRoutes() <span class="cov0" title="0">{
    handler := handlers.NewHandler(s.logger)

    s.router.Use(gin.Recovery())
    s.router.Use(LoggingMiddleware(s.logger))
    
    s.router.GET("/metrics", handler.HandleMetrics)
    s.router.GET("/status", handler.HandleStatus)
    
    // status := s.router.Group("/status")
    // {
    //     status.GET("/", s.handleStatus)
    // }
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package database

import (
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// DatabaseClient handles database operations
type DatabaseClient struct {
        logger logging.Logger
        db     *database.Connection
}

// NewDatabaseClient initializes the database manager with a logger
func NewDatabaseClient(logger logging.Logger, connection *database.Connection) *DatabaseClient <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                panic("logger cannot be nil")</span>
        }
        <span class="cov0" title="0">if connection == nil </span><span class="cov0" title="0">{
                panic("database connection cannot be nil")</span>
        }

        <span class="cov0" title="0">return &amp;DatabaseClient{
                logger: logger.With("component", "database"),
                db:     connection,
        }</span>
}

func (c *DatabaseClient) Close() <span class="cov0" title="0">{
        c.db.Close()
}</pre>
		
		<pre class="file" id="file129" style="display: none">package database

import (
        "fmt"
        "strings"

        "github.com/gocql/gocql"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/queries"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/types"
)

// KeeperRegistered registers a new keeper or updates an existing one (status = true)
func (dm *DatabaseClient) UpdateKeeperRegistrationData(data types.KeeperRegistrationData) (int64, bool, error) <span class="cov0" title="0">{
        data.OperatorAddress = strings.ToLower(data.OperatorAddress)
        data.TxHash = strings.ToLower(data.TxHash)
        data.RewardsReceiver = strings.ToLower(data.RewardsReceiver)

        dm.logger.Infof("Updating keeper %s at database", data.OperatorAddress)

        var booster float32 = 1
        var keeperID int64
        var err error

        // Use RetryableIter since the query needs parameters
        iter := dm.db.NewQuery(queries.GetKeeperIDByAddress, data.OperatorAddress).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if iter.Scan(&amp;keeperID) </span><span class="cov0" title="0">{
                err = nil
        }</span> else<span class="cov0" title="0"> {
                err = gocql.ErrNotFound
        }</span>

        <span class="cov0" title="0">if err == gocql.ErrNotFound </span><span class="cov0" title="0">{
                var maxKeeperID int64
                if err := dm.db.NewQuery(queries.GetMaxKeeperID, &amp;maxKeeperID).Scan(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Debug("No keeper ID found, creating new keeper")
                        maxKeeperID = 0
                }</span>

                <span class="cov0" title="0">keeperID = maxKeeperID + 1

                if err := dm.db.NewQuery(queries.CreateKeeper,
                        keeperID,
                        data.OperatorAddress,
                        data.RewardsReceiver,
                        data.TxHash,
                        data.OperatorID,
                        data.VotingPower,
                        data.Strategies,
                        true, booster).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error creating new keeper: %v", err)
                        return 0, false, err
                }</span>

                <span class="cov0" title="0">dm.logger.Infof("Keeper registered: %d | %s", keeperID, data.OperatorAddress)
                return keeperID, false, nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Error getting keeper ID: %v", err)
                return 0, false, err
        }</span> else<span class="cov0" title="0"> {
                if err := dm.db.NewQuery(queries.UpdateKeeper,
                        data.RewardsReceiver, data.TxHash, data.OperatorID, data.VotingPower,
                        data.Strategies, true, booster, keeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error updating keeper with ID %d: %v", keeperID, err)
                        return 0, false, err
                }</span>
                <span class="cov0" title="0">dm.logger.Infof("Keeper registered: %d | %s", keeperID, data.OperatorAddress)
                return keeperID, true, nil</span>
        }
}

// KeeperUnregistered marks a keeper as unregistered (status = false)
func (dm *DatabaseClient) KeeperUnregistered(operatorAddress string) error <span class="cov0" title="0">{
        var currentKeeperID int64
        operatorAddress = strings.ToLower(operatorAddress)

        // Use RetryableIter since the query needs parameters
        iter := dm.db.NewQuery(queries.GetKeeperIDByAddress, operatorAddress).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;currentKeeperID) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Error getting keeper ID: no results found")
                return fmt.Errorf("keeper not found for address %s", operatorAddress)
        }</span>

        <span class="cov0" title="0">if err := dm.db.NewQuery(queries.UpdateKeeperRegistrationStatus,
                false, currentKeeperID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Error updating keeper with ID %d: %v", currentKeeperID, err)
                return err
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("Keeper unregistered: %d | %s", currentKeeperID, operatorAddress)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package database

import (
        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/queries"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/types"
)

// DailyRewardsPoints processes daily rewards for all eligible keepers
func (dm *DatabaseClient) DailyRewardsPoints() error <span class="cov0" title="0">{
        var keeperID int64
        var rewardsBooster float64
        var keeperPoints float64
        var currentKeeperPoints []types.DailyRewardsPoints

        iter := dm.db.NewQuery(queries.GetDailyRewardsPoints).Iter()

        for iter.Scan(&amp;keeperID, &amp;rewardsBooster, &amp;keeperPoints) </span><span class="cov0" title="0">{
                if keeperID == 1 || keeperID == 2 || keeperID == 3 || keeperID == 4 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">currentKeeperPoints = append(currentKeeperPoints, types.DailyRewardsPoints{
                        KeeperID:       keeperID,
                        RewardsBooster: rewardsBooster,
                        KeeperPoints:   keeperPoints,
                })</span>
        }
        <span class="cov0" title="0">if err := iter.Close(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get daily rewards points: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">for _, currentKeeperPoint := range currentKeeperPoints </span><span class="cov0" title="0">{
                newPoints := currentKeeperPoint.KeeperPoints + float64(10*currentKeeperPoint.RewardsBooster)

                err := dm.db.NewQuery(queries.UpdateKeeperPoints,
                        newPoints, currentKeeperPoint.KeeperID).Exec()
                if err != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Failed to update daily rewards for keeper ID %d: %v", currentKeeperPoint.KeeperID, err)
                        continue</span>
                }

                <span class="cov0" title="0">dm.logger.Infof("Added %d daily reward points to keeper ID %d (new total: %d)",
                        10*currentKeeperPoint.RewardsBooster,
                        currentKeeperPoint.KeeperID,
                        newPoints)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package database

import (
        "fmt"
        "math/big"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database/queries"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/types"
)

// UpdateTaskSubmissionData updates task number, success status and execution details in database
func (dm *DatabaseClient) UpdateTaskSubmissionData(data types.TaskSubmissionData) error <span class="cov0" title="0">{
        // dm.logger.Infof("Updating task %d with task number %d and acceptance status %t", data.TaskID, data.TaskNumber, data.IsAccepted)

        performerId, err := dm.GetKeeperIds([]string{data.PerformerAddress})
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get performer ID: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">attesterIds := data.AttesterIds

        if err := dm.db.NewQuery(queries.UpdateTaskSubmissionData,
                data.TaskNumber,
                data.IsAccepted,
                data.TaskSubmissionTxHash,
                performerId[0],
                attesterIds,
                data.ExecutionTxHash,
                data.ExecutionTimestamp,
                data.TaskOpxCost,
                data.ProofOfTask,
                data.TaskID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Error updating task execution details for task ID %d: %v", data.TaskID, err)
                return err
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("Successfully updated task %d with submission details", data.TaskID)
        return nil</span>
}

// UpdatePointsInDatabase updates points for all involved parties in a task
func (dm *DatabaseClient) UpdateKeeperPointsInDatabase(data types.TaskSubmissionData) error <span class="cov0" title="0">{
        var jobID *big.Int
        var userID int64
        var userTasks int64
        var taskPredictedOpxCost float64

        var keeperId int64
        var keeperPoints float64
        var rewardsBooster float64
        var noAttestedTasks int64
        var noExecutedTasks int64

        // Get task cost and job ID
        iter := dm.db.NewQuery(queries.GetTaskCostAndJobId, data.TaskID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;taskPredictedOpxCost, &amp;jobID) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get task fee and job ID for task ID %d: no results found", data.TaskID)
                return fmt.Errorf("task not found for task ID %d", data.TaskID)
        }</span>

        // dm.logger.Debugf("Details: taskID: %d, taskPredictedOpxCost: %f, taskOpxCost: %f, jobID: %d", data.TaskID, taskPredictedOpxCost, data.TaskOpxCost, jobID)

        // TODO:
        // Alert if taskOpxCost is greater than taskPredictedOpxCost by a threshold

        // Update the Attester Points
        <span class="cov0" title="0">for _, operator_id := range data.AttesterIds </span><span class="cov0" title="0">{
                // Use RetryableIter since the query needs parameters
                iter := dm.db.NewQuery(queries.GetAttesterPointsAndNoOfTasks, operator_id).Iter()
                defer func() </span><span class="cov0" title="0">{
                        if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                                dm.logger.Errorf("Error closing iterator: %v", cerr)
                        }</span>
                }()

                <span class="cov0" title="0">if !iter.Scan(&amp;keeperId, &amp;keeperPoints, &amp;rewardsBooster, &amp;noAttestedTasks) </span><span class="cov0" title="0">{
                        dm.logger.Error(fmt.Sprintf("Failed to get keeper points for operator_id %d: no results found", operator_id))
                        return fmt.Errorf("keeper not found for operator_id %d", operator_id)
                }</span>
                <span class="cov0" title="0">keeperPoints = keeperPoints + float64(rewardsBooster)*data.TaskOpxCost
                noAttestedTasks = noAttestedTasks + 1

                // dm.logger.Infof("Keeper points: %f, Rewards booster: %f, No attested tasks: %d", keeperPoints, rewardsBooster, noAttestedTasks)

                if err := dm.db.NewQuery(queries.UpdateAttesterPointsAndNoOfTasks,
                        keeperPoints, noAttestedTasks, keeperId).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Error(fmt.Sprintf("Failed to update keeper points: %v", err))
                        return err
                }</span>
        }

        // Update the Performer Points
        <span class="cov0" title="0">performerId, err := dm.GetKeeperIds([]string{data.PerformerAddress})
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get performer ID: %v", err)
                return err
        }</span>
        // Use RetryableIter since the query needs parameters
        <span class="cov0" title="0">iter = dm.db.NewQuery(queries.GetPerformerPointsAndNoOfTasks, performerId[0]).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;keeperPoints, &amp;rewardsBooster, &amp;noExecutedTasks) </span><span class="cov0" title="0">{
                dm.logger.Error(fmt.Sprintf("Failed to get keeper points for performer_id %d: no results found", performerId[0]))
                return fmt.Errorf("keeper not found for performer_id %d", performerId[0])
        }</span>
        <span class="cov0" title="0">if data.IsAccepted </span><span class="cov0" title="0">{
                keeperPoints = keeperPoints + float64(rewardsBooster)*data.TaskOpxCost
        }</span> else<span class="cov0" title="0"> {
                keeperPoints = keeperPoints - float64(rewardsBooster)*data.TaskOpxCost*0.1
        }</span>
        <span class="cov0" title="0">noExecutedTasks = noExecutedTasks + 1

        if err := dm.db.NewQuery(queries.UpdatePerformerPointsAndNoOfTasks,
                keeperPoints, noExecutedTasks, performerId[0]).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Error(fmt.Sprintf("Failed to update keeper points: %v", err))
                return err
        }</span>

        // Update the User Points
        <span class="cov0" title="0">iter = dm.db.NewQuery(queries.GetUserIdByJobId, jobID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;userID) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get user ID for job ID %d: no results found", jobID)
                return fmt.Errorf("user not found for job ID %d", jobID)
        }</span>

        <span class="cov0" title="0">var userPoints float64
        iter = dm.db.NewQuery(queries.GetUserPoints, userID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;userPoints, &amp;userTasks) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get user points for user ID %d: no results found", userID)
                return fmt.Errorf("user not found for user ID %d", userID)
        }</span>

        <span class="cov0" title="0">userTasks = userTasks + 1
        userPoints = userPoints + data.TaskOpxCost
        lastUpdatedAt := time.Now().UTC()

        if err := dm.db.NewQuery(queries.UpdateUserPoints,
                userPoints, userTasks, lastUpdatedAt, userID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to update user points for user ID %d: %v", userID, err)
                return err
        }</span>
        <span class="cov0" title="0">dm.logger.Infof("Successfully updated points for user ID %d: added %.2f points", userID, data.TaskOpxCost)
        return nil</span>
}

// GetKeeperIds gets keeper IDs from keeper addresses
func (dm *DatabaseClient) GetKeeperIds(keeperAddresses []string) ([]int64, error) <span class="cov0" title="0">{
        var keeperIds []int64
        for _, keeperAddress := range keeperAddresses </span><span class="cov0" title="0">{
                var keeperID int64
                keeperAddress = strings.ToLower(keeperAddress)

                // Use RetryableIter since the query needs parameters
                iter := dm.db.NewQuery(queries.GetKeeperIDByAddress, keeperAddress).Iter()
                defer func() </span><span class="cov0" title="0">{
                        if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                                dm.logger.Errorf("Error closing iterator: %v", cerr)
                        }</span>
                }()

                <span class="cov0" title="0">if iter.Scan(&amp;keeperID) </span><span class="cov0" title="0">{
                        dm.logger.Infof("Keeper ID for address %s: %d", keeperAddress, keeperID)
                        keeperIds = append(keeperIds, keeperID)
                }</span> else<span class="cov0" title="0"> {
                        dm.logger.Errorf("Failed to get keeper ID for address %s: no results found", keeperAddress)
                        return nil, fmt.Errorf("keeper not found for address %s", keeperAddress)
                }</span>
        }
        <span class="cov0" title="0">return keeperIds, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package taskmanager

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/config"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Client struct {
        retryClient *httppkg.HTTPClient
        logger      logging.Logger
}

func NewClient(logger logging.Logger) (*Client, error) <span class="cov0" title="0">{
        retryClient, err := httppkg.NewHTTPClient(httppkg.DefaultHTTPRetryConfig(), logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{retryClient: retryClient, logger: logger}, nil</span>
}

func (c *Client) InformTaskManager(taskID int64, isAccepted bool) error <span class="cov0" title="0">{
        payload := map[string]interface{}{
                "task_id": taskID,
                "is_accepted": isAccepted,
        }

        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(
                "POST",
                fmt.Sprintf("%s/task/submit", config.GetTaskManagerURL()),
                bytes.NewBuffer(jsonPayload),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resp, err := c.retryClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if cerr := resp.Body.Close(); cerr != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("error closing response body: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package websocket

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/gorilla/websocket"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Client manages WebSocket connections to multiple blockchains
type Client struct {
        logger    logging.Logger
        chains    map[string]*ChainConnection
        eventChan chan *ChainEvent
        mu        sync.RWMutex
        ctx       context.Context
        cancel    context.CancelFunc
        wg        sync.WaitGroup
}

// ChainConnection represents a WebSocket connection to a specific blockchain
type ChainConnection struct {
        chainID       string
        chainName     string
        ethClient     *ethclient.Client
        wsConn        *websocket.Conn
        subscriptions map[string]*Subscription
        subManager    *SubscriptionManager
        reconnectMgr  *ReconnectManager
        eventChan     chan *ChainEvent
        logger        logging.Logger
        mu            sync.RWMutex
        isConnected   bool
        lastMessage   time.Time
        websocketURL  string
}

// Subscription represents an event subscription
type Subscription struct {
        ID           string
        ChainID      string
        ContractAddr common.Address
        ContractType ContractType
        EventName    string
        Query        ethereum.FilterQuery
        Active       bool
        CreatedAt    time.Time
}

// ChainEvent represents an event from any blockchain
type ChainEvent struct {
        ChainID      string       `json:"chain_id"`
        ChainName    string       `json:"chain_name"`
        ContractAddr string       `json:"contract_address"`
        ContractType ContractType `json:"contract_type"`
        EventName    string       `json:"event_name"`
        BlockNumber  uint64       `json:"block_number"`
        TxHash       string       `json:"tx_hash"`
        LogIndex     uint         `json:"log_index"`
        Data         interface{}  `json:"data"`
        RawLog       types.Log    `json:"raw_log"`
        ProcessedAt  time.Time    `json:"processed_at"`
}

// NewClient creates a new multi-chain WebSocket client
func NewClient(logger logging.Logger) *Client <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;Client{
                logger:    logger,
                chains:    make(map[string]*ChainConnection),
                eventChan: make(chan *ChainEvent, 10000),
                ctx:       ctx,
                cancel:    cancel,
        }
}</span>

// AddChain adds a new blockchain to monitor
func (c *Client) AddChain(config ChainConfig) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, exists := c.chains[config.ChainID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s already exists", config.ChainID)
        }</span>

        // Create Ethereum client
        <span class="cov0" title="0">ethClient, err := ethclient.Dial(config.RPCURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to %s RPC: %w", config.Name, err)
        }</span>

        // Create subscription manager
        <span class="cov0" title="0">subManager := NewSubscriptionManager(config.ChainID, c.logger)

        // Create reconnection manager
        reconnectMgr := NewReconnectManagerWithConfig(config.WebSocketURL, config.Reconnect, c.logger)

        // Create chain connection
        chainConn := &amp;ChainConnection{
                chainID:       config.ChainID,
                chainName:     config.Name,
                ethClient:     ethClient,
                subscriptions: make(map[string]*Subscription),
                subManager:    subManager,
                reconnectMgr:  reconnectMgr,
                eventChan:     c.eventChan,
                logger:        c.logger,
                isConnected:   false,
                websocketURL:  config.WebSocketURL,
        }

        c.chains[config.ChainID] = chainConn

        // Auto-subscribe to contracts if specified in config
        if len(config.Contracts) &gt; 0 </span><span class="cov0" title="0">{
                for _, contractConfig := range config.Contracts </span><span class="cov0" title="0">{
                        if err := chainConn.subscribeToContractEvents(contractConfig); err != nil </span><span class="cov0" title="0">{
                                c.logger.Warnf("Failed to subscribe to contract %s: %v", contractConfig.Address, err)
                        }</span>
                }
        }

        // c.logger.Infof("Added chain %s (%s) for monitoring", config.Name, config.ChainID)
        <span class="cov0" title="0">return nil</span>
}

// Start begins monitoring all configured chains
func (c *Client) Start() error <span class="cov0" title="0">{
        // c.logger.Info("Starting multi-chain WebSocket client")

        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                c.wg.Add(1)
                go c.startChainConnection(chainID, chainConn)
        }</span>

        // c.logger.Infof("Started monitoring %d chains", len(c.chains))
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops all chain connections
func (c *Client) Stop() error <span class="cov0" title="0">{
        // c.logger.Info("Stopping multi-chain WebSocket client")

        c.cancel()
        c.wg.Wait()

        // Close all connections
        c.mu.Lock()
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                if err := chainConn.close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Error closing connection for chain %s: %v", chainID, err)
                }</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()

        close(c.eventChan)
        // c.logger.Info("Multi-chain WebSocket client stopped")
        return nil</span>
}

// SubscribeToContract subscribes to events from a specific contract using contract type
func (c *Client) SubscribeToContract(chainID string, contractAddr string, contractType ContractType, events []string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subscribeToContractWithType(contractAddr, contractType, events)</span>
}

// SubscribeToContractLegacy subscribes to events from a specific contract (legacy method)
func (c *Client) SubscribeToContractLegacy(chainID string, contractAddr string, events []string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subscribeToContract(contractAddr, events)</span>
}

// EventChannel returns the channel for receiving events from all chains
func (c *Client) EventChannel() &lt;-chan *ChainEvent <span class="cov0" title="0">{
        return c.eventChan
}</span>

// GetChainStatus returns the status of all chains
func (c *Client) GetChainStatus() map[string]ChainStatus <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        status := make(map[string]ChainStatus)
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                status[chainID] = chainConn.getStatus()
        }</span>
        <span class="cov0" title="0">return status</span>
}

// ChainStatus represents the status of a chain connection
type ChainStatus struct {
        ChainID        string    `json:"chain_id"`
        ChainName      string    `json:"chain_name"`
        Connected      bool      `json:"connected"`
        LastMessage    time.Time `json:"last_message"`
        Subscriptions  int       `json:"subscriptions"`
        ReconnectCount int       `json:"reconnect_count"`
        LatestBlock    uint64    `json:"latest_block,omitempty"`
}

// startChainConnection starts monitoring a specific chain
func (c *Client) startChainConnection(chainID string, chainConn *ChainConnection) <span class="cov0" title="0">{
        defer c.wg.Done()

        c.logger.Infof("Starting connection for chain %s", chainID)

        // Start the reconnection manager with the connect function
        chainConn.reconnectMgr.Start(c.ctx, chainConn.connect)

        // Start processing events from the subscription manager
        go chainConn.processEvents(c.ctx)

        // Keep the connection alive
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                        chainConn.mu.RLock()
                        isConnected := chainConn.isConnected
                        chainConn.mu.RUnlock()

                        if isConnected </span><span class="cov0" title="0">{
                                if err := chainConn.ping(); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Warnf("Ping failed for chain %s: %v", chainID, err)
                                        chainConn.markDisconnected()
                                        // Trigger reconnection
                                        chainConn.reconnectMgr.TriggerReconnect(c.ctx, chainConn.connect)
                                }</span>
                        }
                }
        }
}

// processEvents processes events from the WebSocket connection
func (cc *ChainConnection) processEvents(ctx context.Context) <span class="cov0" title="0">{
        cc.logger.Infof("Starting event processing for chain %s", cc.chainName)

        // Start ping ticker to keep connection alive
        pingTicker := time.NewTicker(30 * time.Second)
        defer pingTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        cc.logger.Infof("Stopping event processing for chain %s", cc.chainName)
                        return</span>
                case &lt;-pingTicker.C:<span class="cov0" title="0">
                        // Send ping to keep connection alive
                        if err := cc.ping(); err != nil </span><span class="cov0" title="0">{
                                cc.logger.Errorf("Failed to ping WebSocket for chain %s: %v", cc.chainName, err)
                                cc.markDisconnected()
                                // Trigger reconnection
                                cc.reconnectMgr.TriggerReconnect(ctx, cc.connect)
                                return
                        }</span>
                default:<span class="cov0" title="0">
                        // Read WebSocket messages
                        if err := cc.readMessage(); err != nil </span><span class="cov0" title="0">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                        cc.logger.Errorf("WebSocket connection closed unexpectedly for chain %s: %v", cc.chainName, err)
                                }</span> else<span class="cov0" title="0"> {
                                        cc.logger.Debugf("WebSocket read error for chain %s: %v", cc.chainName, err)
                                }</span>
                                <span class="cov0" title="0">cc.markDisconnected()
                                // Trigger reconnection
                                cc.reconnectMgr.TriggerReconnect(ctx, cc.connect)
                                return</span>
                        }
                }
        }
}

// readMessage reads and processes a single WebSocket message
func (cc *ChainConnection) readMessage() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Set read deadline
        <span class="cov0" title="0">err := conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        if err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to set read deadline: %v", err)
        }</span>

        // Read message
        <span class="cov0" title="0">_, message, err := conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update last message time
        <span class="cov0" title="0">cc.mu.Lock()
        cc.lastMessage = time.Now()
        cc.mu.Unlock()

        // Process the message using subscription manager
        if err := cc.subManager.ProcessWebSocketMessage(message, cc.eventChan); err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to process WebSocket message for chain %s: %v", cc.chainName, err)
                // Don't return error here as we want to continue processing other messages
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// connect establishes WebSocket connection for the chain
func (cc *ChainConnection) connect() error <span class="cov0" title="0">{
        cc.logger.Infof("Connecting to chain %s WebSocket at %s", cc.chainName, cc.websocketURL)

        if cc.websocketURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket URL not configured for chain %s", cc.chainName)
        }</span>

        // Create dialer with timeout and other options
        <span class="cov0" title="0">dialer := websocket.Dialer{
                HandshakeTimeout: 10 * time.Second,
                Proxy:            http.ProxyFromEnvironment,
        }

        // Connect to WebSocket
        conn, resp, err := dialer.Dial(cc.websocketURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to connect to WebSocket %s (status: %d): %w", cc.websocketURL, resp.StatusCode, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to connect to WebSocket %s: %w", cc.websocketURL, err)</span>
        }

        // Set connection parameters for reliability
        <span class="cov0" title="0">conn.SetReadLimit(512 * 1024) // 512KB max message size
        err = conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        if err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to set read deadline: %v", err)
        }</span>
        <span class="cov0" title="0">conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                err = conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to set read deadline: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        // Set ping handler to keep connection alive
        <span class="cov0" title="0">conn.SetPingHandler(func(appData string) error </span><span class="cov0" title="0">{
                // cc.logger.Debugf("Received ping from %s", cc.chainName)
                return conn.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(30*time.Second))
        }</span>)

        <span class="cov0" title="0">cc.mu.Lock()
        cc.wsConn = conn
        cc.isConnected = true
        cc.lastMessage = time.Now()
        cc.mu.Unlock()

        cc.logger.Infof("Successfully connected to chain %s WebSocket", cc.chainName)

        // Send subscription message for all active subscriptions
        if err := cc.sendSubscription(); err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to send subscription for chain %s: %v", cc.chainName, err)
                // Don't fail the connection for subscription errors
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendSubscription sends the WebSocket subscription message for all active subscriptions
func (cc *ChainConnection) sendSubscription() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Build subscription message
        <span class="cov0" title="0">subscriptionMsg, err := cc.subManager.BuildWebSocketSubscription()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build subscription message: %w", err)
        }</span>

        // Send subscription message
        <span class="cov0" title="0">err = conn.WriteMessage(websocket.TextMessage, subscriptionMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send subscription message: %w", err)
        }</span>

        <span class="cov0" title="0">cc.logger.Infof("Sent subscription message for chain %s", cc.chainName)
        return nil</span>
}

// subscribeToContractEvents subscribes to events from a contract using ContractConfig
func (cc *ChainConnection) subscribeToContractEvents(contractConfig ContractConfig) error <span class="cov0" title="0">{
        if contractConfig.ContractType != "" </span><span class="cov0" title="0">{
                return cc.subscribeToContractWithType(contractConfig.Address, contractConfig.ContractType, contractConfig.Events)
        }</span>
        <span class="cov0" title="0">return cc.subscribeToContract(contractConfig.Address, contractConfig.Events)</span>
}

// subscribeToContractWithType subscribes to events from a contract using contract type
func (cc *ChainConnection) subscribeToContractWithType(contractAddr string, contractType ContractType, events []string) error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        for _, eventName := range events </span><span class="cov0" title="0">{
                // Add subscription using the subscription manager
                _, err := cc.subManager.AddContractSubscription(contractAddr, contractType, eventName)
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to add contract subscription for %s.%s: %v", contractType, eventName, err)
                        continue</span>
                }

                // Also add to local subscriptions for tracking
                <span class="cov0" title="0">subID := fmt.Sprintf("%s_%s_%s_%s", cc.chainID, contractAddr, contractType, eventName)
                addr := common.HexToAddress(contractAddr)

                subscription := &amp;Subscription{
                        ID:           subID,
                        ChainID:      cc.chainID,
                        ContractAddr: addr,
                        ContractType: contractType,
                        EventName:    eventName,
                        Active:       true,
                        CreatedAt:    time.Now(),
                }

                cc.subscriptions[subID] = subscription</span>
                // cc.logger.Infof("Subscribed to %s.%s events from %s on chain %s", contractType, eventName, contractAddr, cc.chainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// subscribeToContract subscribes to events from a contract (legacy method)
func (cc *ChainConnection) subscribeToContract(contractAddr string, events []string) error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        addr := common.HexToAddress(contractAddr)

        for _, eventName := range events </span><span class="cov0" title="0">{
                subID := fmt.Sprintf("%s_%s_%s", cc.chainID, contractAddr, eventName)

                query := ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        // Add event signature filtering here
                }

                subscription := &amp;Subscription{
                        ID:           subID,
                        ChainID:      cc.chainID,
                        ContractAddr: addr,
                        EventName:    eventName,
                        Query:        query,
                        Active:       true,
                        CreatedAt:    time.Now(),
                }

                cc.subscriptions[subID] = subscription
                // cc.logger.Infof("Subscribed to %s events from %s on chain %s", eventName, contractAddr, cc.chainID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getStatus returns the current status of the chain connection
func (cc *ChainConnection) getStatus() ChainStatus <span class="cov0" title="0">{
        cc.mu.RLock()
        defer cc.mu.RUnlock()

        var latestBlock uint64
        if cc.ethClient != nil </span><span class="cov0" title="0">{
                if block, err := cc.ethClient.BlockNumber(context.Background()); err == nil </span><span class="cov0" title="0">{
                        latestBlock = block
                }</span>
        }

        <span class="cov0" title="0">return ChainStatus{
                ChainID:        cc.chainID,
                ChainName:      cc.chainName,
                Connected:      cc.isConnected,
                LastMessage:    cc.lastMessage,
                Subscriptions:  len(cc.subscriptions),
                ReconnectCount: cc.reconnectMgr.GetReconnectCount(),
                LatestBlock:    latestBlock,
        }</span>
}

// ping sends a ping to keep the connection alive
func (cc *ChainConnection) ping() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Send ping with current timestamp as data
        <span class="cov0" title="0">pingData := []byte(fmt.Sprintf("ping_%d", time.Now().Unix()))
        err := conn.WriteControl(websocket.PingMessage, pingData, time.Now().Add(10*time.Second))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send ping: %w", err)
        }</span>

        // cc.logger.Debugf("Sent ping to chain %s", cc.chainName)
        <span class="cov0" title="0">return nil</span>
}

// markDisconnected marks the connection as disconnected
func (cc *ChainConnection) markDisconnected() <span class="cov0" title="0">{
        cc.mu.Lock()
        cc.isConnected = false
        cc.mu.Unlock()
}</span>

// close closes the chain connection
func (cc *ChainConnection) close() error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        cc.isConnected = false

        if cc.wsConn != nil </span><span class="cov0" title="0">{
                err := cc.wsConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to close WebSocket connection: %v", err)
                }</span>
                <span class="cov0" title="0">cc.wsConn = nil</span>
        }

        <span class="cov0" title="0">if cc.ethClient != nil </span><span class="cov0" title="0">{
                cc.ethClient.Close()
        }</span>

        // Reset reconnection count when closing
        <span class="cov0" title="0">if cc.reconnectMgr != nil </span><span class="cov0" title="0">{
                cc.reconnectMgr.resetReconnectCount()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSubscriptionStats returns statistics for all subscriptions on a chain
func (c *Client) GetSubscriptionStats(chainID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subManager.GetSubscriptionStats(), nil</span>
}

// GetAllSubscriptionStats returns statistics for all chains
func (c *Client) GetAllSubscriptionStats() map[string]interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := make(map[string]interface{})
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                stats[chainID] = chainConn.subManager.GetSubscriptionStats()
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// TriggerReconnect manually triggers reconnection for a specific chain
func (c *Client) TriggerReconnect(chainID string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">chainConn.logger.Infof("Manual reconnection triggered for chain %s", chainID)
        chainConn.reconnectMgr.TriggerReconnect(c.ctx, chainConn.connect)
        return nil</span>
}

// GetReconnectStats returns reconnection statistics for all chains
func (c *Client) GetReconnectStats() map[string]interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := make(map[string]interface{})
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                stats[chainID] = map[string]interface{}{
                        "reconnect_count": chainConn.reconnectMgr.GetReconnectCount(),
                        "is_running":      chainConn.reconnectMgr.IsRunning(),
                        "config":          chainConn.reconnectMgr.GetConfig(),
                }
        }</span>

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package websocket

import (
        "context"
        "math"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// ReconnectManager handles WebSocket reconnection logic
type ReconnectManager struct {
        url            string
        logger         logging.Logger
        reconnectCount int
        maxRetries     int
        baseDelay      time.Duration
        maxDelay       time.Duration
        backoffFactor  float64
        jitter         bool
        mu             sync.RWMutex
        isRunning      bool
}

// ReconnectConfig holds reconnection configuration
type ReconnectConfig struct {
        MaxRetries    int           `default:"10"`
        BaseDelay     time.Duration `default:"5s"`
        MaxDelay      time.Duration `default:"300s"` // 5 minutes
        BackoffFactor float64       `default:"2.0"`
        Jitter        bool          `default:"true"`
}

// NewReconnectManager creates a new reconnection manager
func NewReconnectManager(url string, logger logging.Logger) *ReconnectManager <span class="cov0" title="0">{
        return &amp;ReconnectManager{
                url:           url,
                logger:        logger,
                maxRetries:    10,
                baseDelay:     5 * time.Second,
                maxDelay:      5 * time.Minute,
                backoffFactor: 2.0,
                jitter:        true,
        }
}</span>

// NewReconnectManagerWithConfig creates a new reconnection manager with custom config
func NewReconnectManagerWithConfig(url string, config ReconnectConfig, logger logging.Logger) *ReconnectManager <span class="cov0" title="0">{
        rm := NewReconnectManager(url, logger)

        if config.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                rm.maxRetries = config.MaxRetries
        }</span>
        <span class="cov0" title="0">if config.BaseDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.baseDelay = config.BaseDelay
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.maxDelay = config.MaxDelay
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &gt; 0 </span><span class="cov0" title="0">{
                rm.backoffFactor = config.BackoffFactor
        }</span>
        <span class="cov0" title="0">rm.jitter = config.Jitter

        return rm</span>
}

// Start begins the reconnection process
func (rm *ReconnectManager) Start(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        rm.mu.Lock()
        if rm.isRunning </span><span class="cov0" title="0">{
                rm.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">rm.isRunning = true
        rm.mu.Unlock()

        defer func() </span><span class="cov0" title="0">{
                rm.mu.Lock()
                rm.isRunning = false
                rm.mu.Unlock()
        }</span>()

        // Initial connection attempt
        <span class="cov0" title="0">if err := connectFunc(); err != nil </span><span class="cov0" title="0">{
                rm.logger.Errorf("Initial connection failed: %v", err)
                rm.startReconnectionLoop(ctx, connectFunc)
        }</span> else<span class="cov0" title="0"> {
                rm.logger.Info("Initial connection successful")
                rm.resetReconnectCount()
        }</span>
}

// startReconnectionLoop handles the reconnection attempts with exponential backoff
func (rm *ReconnectManager) startReconnectionLoop(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rm.logger.Info("Reconnection cancelled by context")
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if rm.maxRetries &gt; 0 &amp;&amp; rm.GetReconnectCount() &gt;= rm.maxRetries </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Max reconnection attempts (%d) reached for %s", rm.maxRetries, rm.url)
                        return
                }</span>

                <span class="cov0" title="0">delay := rm.calculateDelay()
                rm.logger.Warnf("Reconnecting to %s in %v (attempt %d/%d)",
                        rm.url, delay, rm.GetReconnectCount()+1, rm.maxRetries)

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">rm.incrementReconnectCount()

                if err := connectFunc(); err != nil </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Reconnection attempt %d failed: %v", rm.GetReconnectCount(), err)
                        continue</span>
                }

                <span class="cov0" title="0">rm.logger.Infof("Reconnection successful after %d attempts", rm.GetReconnectCount())
                rm.resetReconnectCount()
                return</span>
        }
}

// calculateDelay calculates the delay for the next reconnection attempt
func (rm *ReconnectManager) calculateDelay() time.Duration <span class="cov0" title="0">{
        attempts := rm.GetReconnectCount()

        // Exponential backoff: baseDelay * (backoffFactor ^ attempts)
        delay := time.Duration(float64(rm.baseDelay) * math.Pow(rm.backoffFactor, float64(attempts)))

        // Cap at maxDelay
        if delay &gt; rm.maxDelay </span><span class="cov0" title="0">{
                delay = rm.maxDelay
        }</span>

        // Add jitter if enabled (±25% randomization)
        <span class="cov0" title="0">if rm.jitter </span><span class="cov0" title="0">{
                jitterRange := float64(delay) * 0.25
                jitterOffset := (2.0*time.Now().UnixNano()%int64(jitterRange) - int64(jitterRange)) / int64(time.Nanosecond)
                delay += time.Duration(jitterOffset)

                // Ensure delay is not negative
                if delay &lt; 0 </span><span class="cov0" title="0">{
                        delay = rm.baseDelay
                }</span>
        }

        <span class="cov0" title="0">return delay</span>
}

// GetReconnectCount returns the current reconnection count
func (rm *ReconnectManager) GetReconnectCount() int <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.reconnectCount
}</span>

// incrementReconnectCount increments the reconnection counter
func (rm *ReconnectManager) incrementReconnectCount() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.reconnectCount++
}</span>

// resetReconnectCount resets the reconnection counter
func (rm *ReconnectManager) resetReconnectCount() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.reconnectCount = 0
}</span>

// TriggerReconnect manually triggers a reconnection
func (rm *ReconnectManager) TriggerReconnect(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        rm.logger.Info("Manual reconnection triggered")
        go rm.startReconnectionLoop(ctx, connectFunc)
}</span>

// IsRunning returns whether the reconnection manager is currently running
func (rm *ReconnectManager) IsRunning() bool <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.isRunning
}</span>

// UpdateConfig updates the reconnection configuration
func (rm *ReconnectManager) UpdateConfig(config ReconnectConfig) <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if config.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                rm.maxRetries = config.MaxRetries
        }</span>
        <span class="cov0" title="0">if config.BaseDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.baseDelay = config.BaseDelay
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.maxDelay = config.MaxDelay
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &gt; 0 </span><span class="cov0" title="0">{
                rm.backoffFactor = config.BackoffFactor
        }</span>
        <span class="cov0" title="0">rm.jitter = config.Jitter

        rm.logger.Info("Reconnection configuration updated")</span>
}

// GetConfig returns the current reconnection configuration
func (rm *ReconnectManager) GetConfig() ReconnectConfig <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        return ReconnectConfig{
                MaxRetries:    rm.maxRetries,
                BaseDelay:     rm.baseDelay,
                MaxDelay:      rm.maxDelay,
                BackoffFactor: rm.backoffFactor,
                Jitter:        rm.jitter,
        }
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package websocket

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"

        // Contract bindings
        contractAttestationCenter "github.com/trigg3rX/triggerx-contracts/bindings/contracts/AttestationCenter"
        contractAvsGovernance "github.com/trigg3rX/triggerx-contracts/bindings/contracts/AvsGovernance"
)

// ContractType represents the type of contract
type ContractType string

const (
        ContractTypeAttestationCenter ContractType = "attestation_center"
        ContractTypeAvsGovernance     ContractType = "avs_governance"
)

// ContractConfig represents a contract to monitor
type ContractConfig struct {
        Address      string
        ContractType ContractType
        ABI          string
        Events       []string // Event names to monitor
}

// ChainConfig represents configuration for a specific blockchain
type ChainConfig struct {
        ChainID      string
        Name         string
        RPCURL       string
        WebSocketURL string
        Contracts    []ContractConfig
        Reconnect    ReconnectConfig
}

// SubscriptionManager manages WebSocket event subscriptions for a chain
type SubscriptionManager struct {
        chainID       string
        subscriptions map[string]*EventSubscription
        eventFilters  map[string][]common.Hash // event name -&gt; topic hashes
        contractABIs  map[ContractType]abi.ABI
        logger        logging.Logger
        mu            sync.RWMutex
}

// EventSubscription represents a single event subscription
type EventSubscription struct {
        ID           string
        ChainID      string
        ContractAddr common.Address
        ContractType ContractType
        EventName    string
        EventSig     common.Hash
        FilterQuery  ethereum.FilterQuery
        Active       bool
        CreatedAt    time.Time
        LastEvent    time.Time
        EventCount   uint64
}

// ContractABI represents the ABI for a contract
type ContractABI struct {
        Address string           `json:"address"`
        Events  map[string]Event `json:"events"`
}

// Event represents an ABI event definition
type Event struct {
        Name      string       `json:"name"`
        Signature string       `json:"signature"`
        Inputs    []EventInput `json:"inputs"`
}

// EventInput represents an event input parameter
type EventInput struct {
        Name    string `json:"name"`
        Type    string `json:"type"`
        Indexed bool   `json:"indexed"`
}

// WebSocketMessage represents incoming WebSocket messages
type WebSocketMessage struct {
        ID     int         `json:"id"`
        Method string      `json:"method"`
        Params interface{} `json:"params"`
}

// SubscriptionResult represents a subscription result
type SubscriptionResult struct {
        Subscription string      `json:"subscription"`
        Result       interface{} `json:"result"`
}

// LogsSubscription represents the logs subscription parameters
type LogsSubscription struct {
        Address []string   `json:"address,omitempty"`
        Topics  [][]string `json:"topics,omitempty"`
}

// ContractEventData represents parsed contract event data
type ContractEventData struct {
        EventType    string                 `json:"event_type"`
        ContractType ContractType           `json:"contract_type"`
        ParsedData   map[string]interface{} `json:"parsed_data"`
        RawData      []byte                 `json:"raw_data"`
        Topics       []string               `json:"topics"`
        BlockNumber  uint64                 `json:"block_number"`
        TxHash       string                 `json:"tx_hash"`
        LogIndex     uint                   `json:"log_index"`
}

// NewSubscriptionManager creates a new subscription manager
func NewSubscriptionManager(chainID string, logger logging.Logger) *SubscriptionManager <span class="cov0" title="0">{
        sm := &amp;SubscriptionManager{
                chainID:       chainID,
                subscriptions: make(map[string]*EventSubscription),
                eventFilters:  make(map[string][]common.Hash),
                contractABIs:  make(map[ContractType]abi.ABI),
                logger:        logger,
        }

        // Initialize contract ABIs
        sm.initializeContractABIs()

        return sm
}</span>

// initializeContractABIs initializes the contract ABIs
func (sm *SubscriptionManager) initializeContractABIs() <span class="cov0" title="0">{
        // Initialize AttestationCenter ABI
        if attestationCenterABI, err := contractAttestationCenter.ContractAttestationCenterMetaData.GetAbi(); err == nil </span><span class="cov0" title="0">{
                sm.contractABIs[ContractTypeAttestationCenter] = *attestationCenterABI
                // sm.logger.Infof("Initialized AttestationCenter ABI")
        }</span> else<span class="cov0" title="0"> {
                sm.logger.Errorf("Failed to initialize AttestationCenter ABI: %v", err)
        }</span>

        // Initialize AvsGovernance ABI
        <span class="cov0" title="0">if avsGovernanceABI, err := contractAvsGovernance.ContractAvsGovernanceMetaData.GetAbi(); err == nil </span><span class="cov0" title="0">{
                sm.contractABIs[ContractTypeAvsGovernance] = *avsGovernanceABI
                // sm.logger.Infof("Initialized AvsGovernance ABI")
        }</span> else<span class="cov0" title="0"> {
                sm.logger.Errorf("Failed to initialize AvsGovernance ABI: %v", err)
        }</span>

        // // Initialize AVSGovernanceLogic ABI
        // if avsGovernanceLogicABI, err := contractAVSGovernanceLogic.ContractAVSGovernanceLogicMetaData.GetAbi(); err == nil {
        //         sm.contractABIs[ContractTypeAVSGovernanceLogic] = *avsGovernanceLogicABI
        //         sm.logger.Infof("Initialized AVSGovernanceLogic ABI")
        // } else {
        //         sm.logger.Errorf("Failed to initialize AVSGovernanceLogic ABI: %v", err)
        // }

        // // Initialize OBLS ABI
        // if oblsABI, err := contractOBLS.ContractOBLSMetaData.GetAbi(); err == nil {
        //         sm.contractABIs[ContractTypeOBLS] = *oblsABI
        //         sm.logger.Infof("Initialized OBLS ABI")
        // } else {
        //         sm.logger.Errorf("Failed to initialize OBLS ABI: %v", err)
        // }
}

// AddContractSubscription adds a new contract event subscription
func (sm *SubscriptionManager) AddContractSubscription(contractAddr string, contractType ContractType, eventName string) (*EventSubscription, error) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Get the ABI for the contract
        contractABI, exists := sm.contractABIs[contractType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("contract type %s not found", contractType)
        }</span>

        // Get the event from the ABI
        <span class="cov0" title="0">event, exists := contractABI.Events[eventName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event %s not found in contract %s", eventName, contractType)
        }</span>

        // Generate unique subscription ID
        <span class="cov0" title="0">subID := sm.generateSubscriptionID()

        addr := common.HexToAddress(contractAddr)
        eventSig := event.ID

        subscription := &amp;EventSubscription{
                ID:           subID,
                ChainID:      sm.chainID,
                ContractAddr: addr,
                ContractType: contractType,
                EventName:    eventName,
                EventSig:     eventSig,
                FilterQuery: ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        Topics:    [][]common.Hash{{eventSig}},
                },
                Active:    true,
                CreatedAt: time.Now(),
        }

        sm.subscriptions[subID] = subscription

        // Add to event filters
        if sm.eventFilters[eventName] == nil </span><span class="cov0" title="0">{
                sm.eventFilters[eventName] = make([]common.Hash, 0)
        }</span>
        <span class="cov0" title="0">sm.eventFilters[eventName] = append(sm.eventFilters[eventName], eventSig)

        // sm.logger.Infof("Added subscription %s for %s.%s events from %s on chain %s",
        //         subID, contractType, eventName, contractAddr, sm.chainID)

        return subscription, nil</span>
}

// AddEventSubscription adds a new event subscription (legacy method)
func (sm *SubscriptionManager) AddEventSubscription(contractAddr string, eventName string, eventSig string) (*EventSubscription, error) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Generate unique subscription ID
        subID := sm.generateSubscriptionID()

        addr := common.HexToAddress(contractAddr)
        sigHash := crypto.Keccak256Hash([]byte(eventSig))

        subscription := &amp;EventSubscription{
                ID:           subID,
                ChainID:      sm.chainID,
                ContractAddr: addr,
                EventName:    eventName,
                EventSig:     sigHash,
                FilterQuery: ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        Topics:    [][]common.Hash{{sigHash}},
                },
                Active:    true,
                CreatedAt: time.Now(),
        }

        sm.subscriptions[subID] = subscription

        // Add to event filters
        if sm.eventFilters[eventName] == nil </span><span class="cov0" title="0">{
                sm.eventFilters[eventName] = make([]common.Hash, 0)
        }</span>
        <span class="cov0" title="0">sm.eventFilters[eventName] = append(sm.eventFilters[eventName], sigHash)

        // sm.logger.Infof("Added subscription %s for %s events from %s on chain %s",
        //         subID, eventName, contractAddr, sm.chainID)

        return subscription, nil</span>
}

// RemoveSubscription removes an event subscription
func (sm *SubscriptionManager) RemoveSubscription(subID string) error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        subscription, exists := sm.subscriptions[subID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("subscription %s not found", subID)
        }</span>

        <span class="cov0" title="0">subscription.Active = false
        delete(sm.subscriptions, subID)

        // sm.logger.Infof("Removed subscription %s for %s events on chain %s",
        //         subID, subscription.EventName, sm.chainID)

        return nil</span>
}

// GetActiveSubscriptions returns all active subscriptions
func (sm *SubscriptionManager) GetActiveSubscriptions() map[string]*EventSubscription <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        active := make(map[string]*EventSubscription)
        for id, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        active[id] = sub
                }</span>
        }
        <span class="cov0" title="0">return active</span>
}

// BuildWebSocketSubscription creates a WebSocket subscription message
func (sm *SubscriptionManager) BuildWebSocketSubscription() ([]byte, error) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        // Collect all contract addresses and topics
        addresses := make(map[common.Address]bool)
        var allTopics []common.Hash

        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        addresses[sub.ContractAddr] = true
                        allTopics = append(allTopics, sub.EventSig)
                }</span>
        }

        // Convert to string arrays for JSON
        <span class="cov0" title="0">addressStrings := make([]string, 0, len(addresses))
        for addr := range addresses </span><span class="cov0" title="0">{
                addressStrings = append(addressStrings, addr.Hex())
        }</span>

        <span class="cov0" title="0">topicStrings := make([]string, 0, len(allTopics))
        for _, topic := range allTopics </span><span class="cov0" title="0">{
                topicStrings = append(topicStrings, topic.Hex())
        }</span>

        // Build subscription parameters
        <span class="cov0" title="0">params := map[string]interface{}{
                "id":     1,
                "method": "eth_subscribe",
                "params": []interface{}{
                        "logs",
                        LogsSubscription{
                                Address: addressStrings,
                                Topics:  [][]string{topicStrings},
                        },
                },
        }

        return json.Marshal(params)</span>
}

// ProcessWebSocketMessage processes incoming WebSocket messages
func (sm *SubscriptionManager) ProcessWebSocketMessage(data []byte, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        var msg WebSocketMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal WebSocket message: %w", err)
        }</span>

        // Handle subscription notifications
        <span class="cov0" title="0">if msg.Method == "eth_subscription" </span><span class="cov0" title="0">{
                return sm.processSubscriptionNotification(msg.Params, eventChan)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSubscriptionStats returns statistics for all subscriptions
func (sm *SubscriptionManager) GetSubscriptionStats() map[string]interface{} <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        stats := map[string]interface{}{
                "chain_id":             sm.chainID,
                "total_subscriptions":  len(sm.subscriptions),
                "active_subscriptions": 0,
                "subscriptions":        make([]map[string]interface{}, 0),
        }

        activeCount := 0
        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        activeCount++
                }</span>

                <span class="cov0" title="0">subStats := map[string]interface{}{
                        "id":          sub.ID,
                        "event_name":  sub.EventName,
                        "contract":    sub.ContractAddr.Hex(),
                        "active":      sub.Active,
                        "created_at":  sub.CreatedAt,
                        "last_event":  sub.LastEvent,
                        "event_count": sub.EventCount,
                }

                stats["subscriptions"] = append(stats["subscriptions"].([]map[string]interface{}), subStats)</span>
        }

        <span class="cov0" title="0">stats["active_subscriptions"] = activeCount
        return stats</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package websocket

import (
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math/big"
        "crypto/rand"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
)

// processSubscriptionNotification processes subscription notification messages
func (sm *SubscriptionManager) processSubscriptionNotification(params interface{}, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        paramsMap, ok := params.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid subscription params format")
        }</span>

        <span class="cov0" title="0">result, ok := paramsMap["result"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no result in subscription notification")
        }</span>

        // Parse the log entry
        <span class="cov0" title="0">logData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal log data: %w", err)
        }</span>

        <span class="cov0" title="0">var log types.Log
        if err := json.Unmarshal(logData, &amp;log); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal log: %w", err)
        }</span>

        // Process the log entry
        <span class="cov0" title="0">return sm.processLogEntry(log, eventChan)</span>
}

// processLogEntry processes a single log entry and routes it to the appropriate handler
func (sm *SubscriptionManager) processLogEntry(log types.Log, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        if len(log.Topics) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("log entry has no topics")
        }</span>

        <span class="cov0" title="0">eventSig := log.Topics[0]

        // Find matching subscription
        sm.mu.RLock()
        var matchedSub *EventSubscription
        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active &amp;&amp; sub.EventSig == eventSig &amp;&amp; sub.ContractAddr == log.Address </span><span class="cov0" title="0">{
                        matchedSub = sub
                        break</span>
                }
        }
        <span class="cov0" title="0">sm.mu.RUnlock()

        if matchedSub == nil </span><span class="cov0" title="0">{
                sm.logger.Debugf("No subscription found for event %s from %s", eventSig.Hex(), log.Address.Hex())
                return nil
        }</span>

        // Update subscription stats
        <span class="cov0" title="0">sm.updateSubscriptionStats(matchedSub.ID)

        // Create chain event
        chainEvent := &amp;ChainEvent{
                ChainID:      sm.chainID,
                ChainName:    sm.getChainName(sm.chainID),
                ContractAddr: log.Address.Hex(),
                ContractType: matchedSub.ContractType,
                EventName:    matchedSub.EventName,
                BlockNumber:  log.BlockNumber,
                TxHash:       log.TxHash.Hex(),
                LogIndex:     log.Index,
                Data:         sm.parseEventData(matchedSub, log),
                RawLog:       log,
                ProcessedAt:  time.Now(),
        }

        // Send to event channel (non-blocking)
        select </span>{
        case eventChan &lt;- chainEvent:<span class="cov0" title="0">
                sm.logger.Debugf("Processed %s event from %s at block %d",
                        matchedSub.EventName, log.Address.Hex(), log.BlockNumber)</span>
        default:<span class="cov0" title="0">
                sm.logger.Warnf("Event channel full, dropping event %s from %s",
                        matchedSub.EventName, log.Address.Hex())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parseEventData parses event data based on the contract type and event
func (sm *SubscriptionManager) parseEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        // Check if we have a contract type for proper parsing
        if sub.ContractType != "" </span><span class="cov0" title="0">{
                return sm.parseContractEventData(sub, log)
        }</span>

        // Fallback to basic parsing for legacy subscriptions
        <span class="cov0" title="0">eventData := map[string]interface{}{
                "event_signature": sub.EventSig.Hex(),
                "topics":          make([]string, len(log.Topics)),
                "data":            log.Data,
                "block_number":    log.BlockNumber,
                "tx_hash":         log.TxHash.Hex(),
                "log_index":       log.Index,
        }

        for i, topic := range log.Topics </span><span class="cov0" title="0">{
                eventData["topics"].([]string)[i] = topic.Hex()
        }</span>

        <span class="cov0" title="0">return eventData</span>
}

// parseContractEventData parses contract event data using the proper ABI
func (sm *SubscriptionManager) parseContractEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        contractABI, exists := sm.contractABIs[sub.ContractType]
        if !exists </span><span class="cov0" title="0">{
                sm.logger.Errorf("Contract ABI not found for type %s", sub.ContractType)
                return sm.parseBasicEventData(sub, log)
        }</span>

        <span class="cov0" title="0">event, exists := contractABI.Events[sub.EventName]
        if !exists </span><span class="cov0" title="0">{
                sm.logger.Errorf("Event %s not found in contract %s ABI", sub.EventName, sub.ContractType)
                return sm.parseBasicEventData(sub, log)
        }</span>

        // Parse the event data
        <span class="cov0" title="0">parsedData := make(map[string]interface{})

        // Parse indexed parameters from topics
        topicIndex := 1 // Skip the event signature (topics[0])
        for _, input := range event.Inputs </span><span class="cov0" title="0">{
                if input.Indexed </span><span class="cov0" title="0">{
                        if topicIndex &lt; len(log.Topics) </span><span class="cov0" title="0">{
                                parsedData[input.Name] = sm.parseTopicData(input, log.Topics[topicIndex])
                                topicIndex++
                        }</span>
                }
        }

        // Parse non-indexed parameters from data
        <span class="cov0" title="0">if len(log.Data) &gt; 0 </span><span class="cov0" title="0">{
                nonIndexedInputs := make([]abi.Argument, 0)
                for _, input := range event.Inputs </span><span class="cov0" title="0">{
                        if !input.Indexed </span><span class="cov0" title="0">{
                                nonIndexedInputs = append(nonIndexedInputs, input)
                        }</span>
                }

                <span class="cov0" title="0">if len(nonIndexedInputs) &gt; 0 </span><span class="cov0" title="0">{
                        values, err := contractABI.Unpack(sub.EventName, log.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Errorf("Failed to unpack event data for %s: %v", sub.EventName, err)
                        }</span> else<span class="cov0" title="0"> {
                                for i, input := range nonIndexedInputs </span><span class="cov0" title="0">{
                                        if i &lt; len(values) </span><span class="cov0" title="0">{
                                                parsedData[input.Name] = sm.formatValue(values[i])
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return &amp;ContractEventData{
                EventType:    sub.EventName,
                ContractType: sub.ContractType,
                ParsedData:   parsedData,
                RawData:      log.Data,
                Topics:       sm.formatTopics(log.Topics),
                BlockNumber:  log.BlockNumber,
                TxHash:       log.TxHash.Hex(),
                LogIndex:     log.Index,
        }</span>
}

// parseBasicEventData provides basic event data parsing as fallback
func (sm *SubscriptionManager) parseBasicEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "event_type":      sub.EventName,
                "contract_type":   sub.ContractType,
                "event_signature": sub.EventSig.Hex(),
                "topics":          sm.formatTopics(log.Topics),
                "data":            hex.EncodeToString(log.Data),
                "block_number":    log.BlockNumber,
                "tx_hash":         log.TxHash.Hex(),
                "log_index":       log.Index,
        }
}</span>

// parseTopicData parses topic data based on the input type
func (sm *SubscriptionManager) parseTopicData(input abi.Argument, topic common.Hash) interface{} <span class="cov0" title="0">{
        switch input.Type.String() </span>{
        case "address":<span class="cov0" title="0">
                return common.HexToAddress(topic.Hex()).Hex()</span>
        case "uint256", "uint128", "uint64", "uint32", "uint16", "uint8":<span class="cov0" title="0">
                return new(big.Int).SetBytes(topic.Bytes()).String()</span>
        case "int256", "int128", "int64", "int32", "int16", "int8":<span class="cov0" title="0">
                // For signed integers, we need to handle two's complement
                value := new(big.Int).SetBytes(topic.Bytes())
                if value.Bit(255) == 1 </span><span class="cov0" title="0">{ // Check if the sign bit is set
                        // Convert from two's complement
                        max := new(big.Int).Lsh(big.NewInt(1), 256)
                        value.Sub(value, max)
                }</span>
                <span class="cov0" title="0">return value.String()</span>
        case "bytes32":<span class="cov0" title="0">
                return topic.Hex()</span>
        case "bool":<span class="cov0" title="0">
                return topic.Big().Cmp(big.NewInt(0)) != 0</span>
        default:<span class="cov0" title="0">
                return topic.Hex()</span>
        }
}

// formatValue formats values for JSON serialization
func (sm *SubscriptionManager) formatValue(value interface{}) interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case *big.Int:<span class="cov0" title="0">
                return v.String()</span>
        case common.Address:<span class="cov0" title="0">
                return v.Hex()</span>
        case common.Hash:<span class="cov0" title="0">
                return v.Hex()</span>
        case []byte:<span class="cov0" title="0">
                return hex.EncodeToString(v)</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

// formatTopics formats topic slice for JSON serialization
func (sm *SubscriptionManager) formatTopics(topics []common.Hash) []string <span class="cov0" title="0">{
        result := make([]string, len(topics))
        for i, topic := range topics </span><span class="cov0" title="0">{
                result[i] = topic.Hex()
        }</span>
        <span class="cov0" title="0">return result</span>
}

// updateSubscriptionStats updates statistics for a subscription
func (sm *SubscriptionManager) updateSubscriptionStats(subID string) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        if sub, exists := sm.subscriptions[subID]; exists </span><span class="cov0" title="0">{
                sub.EventCount++
                sub.LastEvent = time.Now()
        }</span>
}

// generateSubscriptionID generates a unique subscription ID
func (sm *SubscriptionManager) generateSubscriptionID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Errorf("Failed to generate subscription ID: %v", err)
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s_%s", sm.chainID, hex.EncodeToString(bytes))</span>
}

// getChainName returns a human-readable chain name
func (sm *SubscriptionManager) getChainName(chainID string) string <span class="cov0" title="0">{
        chainNames := map[string]string{
                "17000":    "Ethereum Holesky",
                "11155111": "Ethereum Sepolia",
                "11155420": "Optimism Sepolia",
                "84532":    "Base Sepolia",
        }

        if name, exists := chainNames[chainID]; exists </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Chain %s", chainID)</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package config

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Registrar Port
        registrarPort string

        // Contract Addresses to listen for events
        avsGovernanceAddress      string
        // avsGovernanceLogicAddress string
        attestationCenterAddress  string
        // oblsAddress               string
        // taskExecutionHubAddress    string
        // triggerXJobRegistryAddress string
        // triggerGasRegistryAddress string

        // RPC URLs for Ethereum and Base
        rpcProvider     string
        rpcAPIKey       string

        // ScyllaDB Host and Port
        databaseHostAddress string
        databaseHostPort    string

        // Upstash Redis URL and Rest Token
        upstashRedisUrl       string
        upstashRedisRestToken string

        // Sync Configs Update
        lastRewardsUpdate string
        lastEthBlockUpdated  uint64
        lastBaseBlockUpdated uint64
        lastOptBlockUpdated  uint64

        // Pinata JWT and Host
        pinataJWT  string
        pinataHost string

        // Task Manager URL
        taskManagerURL string
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                   env.GetEnvBool("DEV_MODE", false),
                registrarPort:             env.GetEnvString("REGISTRAR_PORT", "9010"),
                avsGovernanceAddress:      env.GetEnvString("AVS_GOVERNANCE_ADDRESS", "0x12f45551f11Df20b3EcBDf329138Bdc65cc58Ec0"),
                // avsGovernanceLogicAddress: env.GetEnvString("AVS_GOVERNANCE_LOGIC_ADDRESS", "0x4EbE2f2b7db5B48559167f2be7d760B23b00B427"),
                attestationCenterAddress:  env.GetEnvString("ATTESTATION_CENTER_ADDRESS", "0x9725fB95B5ec36c062A49ca2712b3B1ff66F04eD"),
                // oblsAddress:               env.GetEnvString("OBLS_ADDRESS", "0x68853222A6Fc1DAE25Dd58FB184dc4470C98F73C"),
                // taskExecutionHubAddress:   env.GetEnvString("EIGENLAYER_TASK_EXECUTION_HUB_ADDRESS", "0x2469e89386947535A350EEBccC5F2754fd35F474"),
                // triggerGasRegistryAddress: env.GetEnvString("TRIGGER_GAS_REGISTRY_ADDRESS", "0x85ea3eB894105bD7e7e2A8D34cf66C8E8163CD2a"),
                // triggerXJobRegistryAddress: env.GetEnvString("TRIGGERX_JOB_REGISTRY_ADDRESS", "0xdB66c11221234C6B19cCBd29868310c31494C21C"),
                rpcProvider:               env.GetEnvString("RPC_PROVIDER", ""),
                rpcAPIKey:                 env.GetEnvString("RPC_API_KEY", ""),
                databaseHostAddress:       env.GetEnvString("DATABASE_HOST_ADDRESS", "localhost"),
                databaseHostPort:          env.GetEnvString("DATABASE_HOST_PORT", "9042"),
                upstashRedisUrl:           env.GetEnvString("UPSTASH_REDIS_URL", ""),
                upstashRedisRestToken:     env.GetEnvString("UPSTASH_REDIS_REST_TOKEN", ""),
                pinataJWT:                 env.GetEnvString("PINATA_JWT", ""),
                pinataHost:                env.GetEnvString("PINATA_HOST", ""),
                taskManagerURL:            env.GetEnvString("TASK_MANAGER_URL", "http://localhost:9003"),
        }
        if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig() error <span class="cov0" title="0">{
        if !env.IsValidPort(cfg.registrarPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid registrar port: %s", cfg.registrarPort)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.rpcProvider) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty RPC Provider")
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.rpcAPIKey) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty RPC API Key")
        }</span>
        <span class="cov0" title="0">if !env.IsValidEthAddress(cfg.avsGovernanceAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid AVS Governance Address: %s", cfg.avsGovernanceAddress)
        }</span>
        // if !env.IsValidEthAddress(cfg.avsGovernanceLogicAddress) {
        //         return fmt.Errorf("invalid AVS Governance Logic Address: %s", cfg.avsGovernanceLogicAddress)
        // }
        <span class="cov0" title="0">if !env.IsValidEthAddress(cfg.attestationCenterAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Attestation Address: %s", cfg.attestationCenterAddress)
        }</span>
        // if !env.IsValidEthAddress(cfg.oblsAddress) {
        //         return fmt.Errorf("invalid OBLS Address: %s", cfg.oblsAddress)
        // }
        // if !env.IsValidEthAddress(cfg.taskExecutionHubAddress) {
        //         return fmt.Errorf("invalid Task Execution Hub Address: %s", cfg.taskExecutionHubAddress)
        // }
        // if !env.IsValidEthAddress(cfg.triggerGasRegistryAddress) {
        //         return fmt.Errorf("invalid Trigger Gas Registry Address: %s", cfg.triggerGasRegistryAddress)
        // }
        // if !env.IsValidEthAddress(cfg.triggerXJobRegistryAddress) {
        //         return fmt.Errorf("invalid TriggerX Job Registry Address: %s", cfg.triggerXJobRegistryAddress)
        // }
        <span class="cov0" title="0">if !env.IsValidIPAddress(cfg.databaseHostAddress) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host address: %s", cfg.databaseHostAddress)
        }</span>
        <span class="cov0" title="0">if !env.IsValidPort(cfg.databaseHostPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database host port: %s", cfg.databaseHostPort)
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.upstashRedisUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty Upstash Redis URL field")
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.upstashRedisRestToken) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty Upstash Redis Rest Token field")
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.pinataJWT) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty Pinata JWT field")
        }</span>
        <span class="cov0" title="0">if env.IsEmpty(cfg.pinataHost) </span><span class="cov0" title="0">{
                return fmt.Errorf("empty Pinata Host field")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Setters
func SetLastRewardsUpdate(timestamp string) <span class="cov0" title="0">{
        cfg.lastRewardsUpdate = timestamp
}</span>

func SetLastEthBlockUpdated(blockNumber uint64) <span class="cov0" title="0">{
        cfg.lastEthBlockUpdated = blockNumber
}</span>

func SetLastBaseBlockUpdated(blockNumber uint64) <span class="cov0" title="0">{
        cfg.lastBaseBlockUpdated = blockNumber
}</span>

func SetLastOptBlockUpdated(blockNumber uint64) <span class="cov0" title="0">{
        cfg.lastOptBlockUpdated = blockNumber
}</span>

// Getters
func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetRegistrarPort() string <span class="cov0" title="0">{
        return cfg.registrarPort
}</span>

func GetAvsGovernanceAddress() string <span class="cov0" title="0">{
        return cfg.avsGovernanceAddress
}</span>

// func GetAvsGovernanceLogicAddress() string {
//         return cfg.avsGovernanceLogicAddress
// }

func GetAttestationCenterAddress() string <span class="cov0" title="0">{
        return cfg.attestationCenterAddress
}</span>

// func GetOBLSAddress() string {
//         return cfg.oblsAddress
// }

// func GetTaskExecutionHubAddress() string {
//         return cfg.taskExecutionHubAddress
// }

// func GetTriggerXJobRegistryAddress() string {
//         return cfg.triggerXJobRegistryAddress
// }

// func GetTriggerGasRegistryAddress() string {
//         return cfg.triggerGasRegistryAddress
// }

func GetDatabaseHostAddress() string <span class="cov0" title="0">{
        return cfg.databaseHostAddress
}</span>

func GetDatabaseHostPort() string <span class="cov0" title="0">{
        return cfg.databaseHostPort
}</span>

func GetUpstashRedisUrl() string <span class="cov0" title="0">{
        return cfg.upstashRedisUrl
}</span>

func GetUpstashRedisRestToken() string <span class="cov0" title="0">{
        return cfg.upstashRedisRestToken
}</span>

func GetLastRewardsUpdate() string <span class="cov0" title="0">{
        return cfg.lastRewardsUpdate
}</span>

func GetLastEthBlockUpdated() uint64 <span class="cov0" title="0">{
        return cfg.lastEthBlockUpdated
}</span>

func GetLastBaseBlockUpdated() uint64 <span class="cov0" title="0">{
        return cfg.lastBaseBlockUpdated
}</span>

func GetLastOptBlockUpdated() uint64 <span class="cov0" title="0">{
        return cfg.lastOptBlockUpdated
}</span>

func GetPinataJWT() string <span class="cov0" title="0">{
        return cfg.pinataJWT
}</span>

func GetPinataHost() string <span class="cov0" title="0">{
        return cfg.pinataHost
}</span>

func GetTaskManagerURL() string <span class="cov0" title="0">{
        return cfg.taskManagerURL
}</span>

// Get Chain Configs
func GetChainRPCUrl(isRPC bool, chainID string) string <span class="cov0" title="0">{
        var protocol string
        if isRPC </span><span class="cov0" title="0">{
                protocol = "https://"
        }</span> else<span class="cov0" title="0"> {
                protocol = "wss://"
        }</span>
        <span class="cov0" title="0">var domain string
        if cfg.rpcProvider == "alchemy" </span><span class="cov0" title="0">{
                switch chainID </span>{
                case "17000":<span class="cov0" title="0">
                        domain = "eth-holesky.g.alchemy.com/v2/"</span>
                case "11155111":<span class="cov0" title="0">
                        domain = "eth-sepolia.g.alchemy.com/v2/"</span>
                case "11155420":<span class="cov0" title="0">
                        domain = "opt-sepolia.g.alchemy.com/v2/"</span>
                case "84532":<span class="cov0" title="0">
                        domain = "base-sepolia.g.alchemy.com/v2/"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }
        <span class="cov0" title="0">if cfg.rpcProvider == "blast" </span><span class="cov0" title="0">{
                switch chainID </span>{
                case "17000":<span class="cov0" title="0">
                        domain = "eth-holesky.blastapi.io/"</span>
                case "11155111":<span class="cov0" title="0">
                        domain = "eth-sepolia.blastapi.io/"</span>
                case "11155420":<span class="cov0" title="0">
                        domain = "optimism-sepolia.blastapi.io/"</span>
                case "84532":<span class="cov0" title="0">
                        domain = "base-sepolia.blastapi.io/"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s%s%s", protocol, domain, cfg.rpcAPIKey)</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package events

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/config"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
)

// ContractEventListener handles listening to contract events across multiple chains
type ContractEventListener struct {
        logger       logging.Logger
        client       *websocket.Client
        config       *ListenerConfig
        ctx          context.Context
        cancel       context.CancelFunc
        wg           sync.WaitGroup
        isRunning    bool
        mu           sync.RWMutex
        eventChan    chan *websocket.ChainEvent
        processingWg sync.WaitGroup
        dbClient     *database.DatabaseClient
        ipfsClient   ipfs.IPFSClient
}

// ListenerConfig holds configuration for the event listener
type ListenerConfig struct {
        Chains            []ChainConfig                `json:"chains"`
        ReconnectConfig   ReconnectConfig              `json:"reconnect"`
        ProcessingWorkers int                          `json:"processing_workers"`
        EventBufferSize   int                          `json:"event_buffer_size"`
        ProcessingTimeout time.Duration                `json:"processing_timeout"`
        ContractAddresses map[string]map[string]string `json:"contract_addresses"` // chainID -&gt; contractType -&gt; address
}

// ChainConfig represents blockchain configuration for event listening
type ChainConfig struct {
        ChainID      string `json:"chain_id"`
        Name         string `json:"name"`
        RPCURL       string `json:"rpc_url"`
        WebSocketURL string `json:"websocket_url"`
        Enabled      bool   `json:"enabled"`
}

// ReconnectConfig holds reconnection settings
type ReconnectConfig struct {
        MaxRetries    int           `json:"max_retries"`
        BaseDelay     time.Duration `json:"base_delay"`
        MaxDelay      time.Duration `json:"max_delay"`
        BackoffFactor float64       `json:"backoff_factor"`
}

// EventProcessor handles individual event processing
type EventProcessor struct {
        logger          logging.Logger
        operatorHandler *OperatorEventHandler
        taskHandler     *TaskEventHandler
}

// OperatorEventHandler handles operator-related events
type OperatorEventHandler struct {
        logger logging.Logger
}

// TaskEventHandler handles task-related events
type TaskEventHandler struct {
        logger logging.Logger
        db     *database.DatabaseClient
        ipfsClient ipfs.IPFSClient
}

// NewContractEventListener creates a new contract event listener
func NewContractEventListener(logger logging.Logger, config *ListenerConfig, dbClient *database.DatabaseClient, ipfsClient ipfs.IPFSClient) *ContractEventListener <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        client := websocket.NewClient(logger)

        return &amp;ContractEventListener{
                logger:    logger,
                client:    client,
                config:    config,
                ctx:       ctx,
                cancel:    cancel,
                eventChan: make(chan *websocket.ChainEvent, config.EventBufferSize),
                dbClient:  dbClient,
                ipfsClient: ipfsClient,
        }
}</span>

// Start begins listening for contract events
func (l *ContractEventListener) Start() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if l.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("event listener is already running")
        }</span>

        <span class="cov0" title="0">l.logger.Info("Starting contract event listener")

        // Set up chain connections and subscriptions
        if err := l.setupChainConnections(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup chain connections: %w", err)
        }</span>

        // Start the websocket client
        <span class="cov0" title="0">if err := l.client.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start websocket client: %w", err)
        }</span>

        // Start event processing workers
        <span class="cov0" title="0">l.startEventProcessors()

        // Start the main event listening loop
        l.wg.Add(1)
        go l.eventListeningLoop()

        l.isRunning = true
        l.logger.Info("Contract event listener started successfully")

        return nil</span>
}

// Stop gracefully stops the event listener
func (l *ContractEventListener) Stop() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if !l.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("event listener is not running")
        }</span>

        <span class="cov0" title="0">l.logger.Info("Stopping contract event listener")

        // Cancel context to stop all goroutines
        l.cancel()

        // Stop the websocket client
        if err := l.client.Stop(); err != nil </span><span class="cov0" title="0">{
                l.logger.Errorf("Error stopping websocket client: %v", err)
        }</span>

        // Wait for all goroutines to finish
        <span class="cov0" title="0">l.wg.Wait()
        l.processingWg.Wait()

        l.isRunning = false
        l.logger.Info("Contract event listener stopped")

        return nil</span>
}

// setupChainConnections sets up blockchain connections and subscriptions
func (l *ContractEventListener) setupChainConnections() error <span class="cov0" title="0">{
        for _, chainConfig := range l.config.Chains </span><span class="cov0" title="0">{
                if !chainConfig.Enabled </span><span class="cov0" title="0">{
                        // l.logger.Infof("Skipping disabled chain: %s", chainConfig.Name)
                        continue</span>
                }

                // Add chain to websocket client
                <span class="cov0" title="0">wsConfig := websocket.ChainConfig{
                        ChainID:      chainConfig.ChainID,
                        Name:         chainConfig.Name,
                        RPCURL:       chainConfig.RPCURL,
                        WebSocketURL: chainConfig.WebSocketURL,
                        Contracts:    l.getContractConfigsForChain(chainConfig.ChainID),
                        Reconnect: websocket.ReconnectConfig{
                                MaxRetries:    l.config.ReconnectConfig.MaxRetries,
                                BaseDelay:     l.config.ReconnectConfig.BaseDelay,
                                MaxDelay:      l.config.ReconnectConfig.MaxDelay,
                                BackoffFactor: l.config.ReconnectConfig.BackoffFactor,
                                Jitter:        true,
                        },
                }

                if err := l.client.AddChain(wsConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add chain %s: %w", chainConfig.Name, err)
                }</span>

                // Set up specific contract subscriptions
                <span class="cov0" title="0">if err := l.setupContractSubscriptions(chainConfig.ChainID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to setup subscriptions for chain %s: %w", chainConfig.Name, err)
                }</span>

                // l.logger.Infof("Successfully configured chain: %s (%s)", chainConfig.Name, chainConfig.ChainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// getContractConfigsForChain returns contract configurations for a specific chain
func (l *ContractEventListener) getContractConfigsForChain(chainID string) []websocket.ContractConfig <span class="cov0" title="0">{
        var configs []websocket.ContractConfig

        chainAddresses, exists := l.config.ContractAddresses[chainID]
        if !exists </span><span class="cov0" title="0">{
                l.logger.Warnf("No contract addresses configured for chain %s", chainID)
                return configs
        }</span>

        // AvsGovernance contract
        <span class="cov0" title="0">if addr, exists := chainAddresses["avs_governance"]; exists </span><span class="cov0" title="0">{
                configs = append(configs, websocket.ContractConfig{
                        Address:      addr,
                        ContractType: websocket.ContractTypeAvsGovernance,
                        Events:       []string{"OperatorRegistered", "OperatorUnregistered"},
                })
        }</span>

        // AttestationCenter contract
        <span class="cov0" title="0">if addr, exists := chainAddresses["attestation_center"]; exists </span><span class="cov0" title="0">{
                configs = append(configs, websocket.ContractConfig{
                        Address:      addr,
                        ContractType: websocket.ContractTypeAttestationCenter,
                        Events:       []string{"TaskSubmitted", "TaskRejected"},
                })
        }</span>

        <span class="cov0" title="0">return configs</span>
}

// setupContractSubscriptions sets up specific contract event subscriptions
func (l *ContractEventListener) setupContractSubscriptions(chainID string) error <span class="cov0" title="0">{
        chainAddresses, exists := l.config.ContractAddresses[chainID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no contract addresses configured for chain %s", chainID)
        }</span>

        // Subscribe to AvsGovernance events
        <span class="cov0" title="0">if addr, exists := chainAddresses["avs_governance"]; exists </span><span class="cov0" title="0">{
                if err := l.client.SubscribeToContract(
                        chainID,
                        addr,
                        websocket.ContractTypeAvsGovernance,
                        []string{"OperatorRegistered", "OperatorUnregistered"},
                ); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to AvsGovernance events: %w", err)
                }</span>
                // l.logger.Infof("Subscribed to AvsGovernance events on chain %s", chainID)
        }

        // Subscribe to AttestationCenter events
        <span class="cov0" title="0">if addr, exists := chainAddresses["attestation_center"]; exists </span><span class="cov0" title="0">{
                if err := l.client.SubscribeToContract(
                        chainID,
                        addr,
                        websocket.ContractTypeAttestationCenter,
                        []string{"TaskSubmitted", "TaskRejected"},
                ); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to AttestationCenter events: %w", err)
                }</span>
                // l.logger.Infof("Subscribed to AttestationCenter events on chain %s", chainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// startEventProcessors starts worker goroutines for event processing
func (l *ContractEventListener) startEventProcessors() <span class="cov0" title="0">{
        processor := &amp;EventProcessor{
                logger:          l.logger,
                operatorHandler: &amp;OperatorEventHandler{logger: l.logger},
                taskHandler:     &amp;TaskEventHandler{logger: l.logger, db: l.dbClient, ipfsClient: l.ipfsClient},
        }

        // Start multiple processing workers
        for i := 0; i &lt; l.config.ProcessingWorkers; i++ </span><span class="cov0" title="0">{
                l.processingWg.Add(1)
                go l.eventProcessorWorker(processor, i)
        }</span>

        // l.logger.Infof("Started %d event processing workers", l.config.ProcessingWorkers)
}

// eventListeningLoop is the main event listening loop
func (l *ContractEventListener) eventListeningLoop() <span class="cov0" title="0">{
        defer l.wg.Done()

        l.logger.Info("Starting event listening loop")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov0" title="0">
                        l.logger.Info("Event listening loop stopped")
                        return</span>
                case event := &lt;-l.client.EventChannel():<span class="cov0" title="0">
                        // Forward event to processing workers
                        select </span>{
                        case l.eventChan &lt;- event:<span class="cov0" title="0"></span>
                                // Event queued successfully
                        default:<span class="cov0" title="0">
                                // Event channel is full, log warning
                                l.logger.Warnf("Event channel full, dropping event: %s from %s",
                                        event.EventName, event.ContractAddr)</span>
                        }
                }
        }
}

// eventProcessorWorker processes events from the event channel
func (l *ContractEventListener) eventProcessorWorker(processor *EventProcessor, workerID int) <span class="cov0" title="0">{
        defer l.processingWg.Done()

        l.logger.Debugf("Event processor worker %d started", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov0" title="0">
                        // l.logger.Infof("Event processor worker %d stopped", workerID)
                        return</span>
                case event := &lt;-l.eventChan:<span class="cov0" title="0">
                        l.processEvent(processor, event)</span>
                }
        }
}

// processEvent processes a single contract event
func (l *ContractEventListener) processEvent(processor *EventProcessor, event *websocket.ChainEvent) <span class="cov0" title="0">{
        // Set processing timeout
        // ctx, cancel := context.WithTimeout(l.ctx, l.config.ProcessingTimeout)
        // defer cancel()

        // l.logger.Debugf("Worker %d processing %s event from %s contract at %s",
        //         workerID, event.EventName, event.ContractType, event.ContractAddr)

        // Process event based on contract type
        switch event.ContractType </span>{
        case websocket.ContractTypeAvsGovernance:<span class="cov0" title="0">
                l.logger.Debugf("Processing %s event from AvsGovernance contract on chain %s", event.EventName, event.ChainID)
                processor.operatorHandler.ProcessOperatorEvent(l.ctx, event)</span>
        case websocket.ContractTypeAttestationCenter:<span class="cov0" title="0">
                l.logger.Debugf("Processing %s event from AttestationCenter contract on chain %s", event.EventName, event.ChainID)
                processor.taskHandler.ProcessTaskEvent(event)</span>
        default:<span class="cov0" title="0">
                l.logger.Warnf("Unknown contract type: %s for event %s from contract %s on chain %s",
                        event.ContractType, event.EventName, event.ContractAddr, event.ChainID)</span>
        }
}

// GetStatus returns the current status of the event listener
func (l *ContractEventListener) GetStatus() map[string]interface{} <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        status := map[string]interface{}{
                "running":            l.isRunning,
                "processing_workers": l.config.ProcessingWorkers,
                "event_buffer_size":  l.config.EventBufferSize,
                "event_buffer_used":  len(l.eventChan),
                "chains":             make(map[string]interface{}),
        }

        // Get chain-specific status
        chainStatus := l.client.GetChainStatus()
        status["chains"] = chainStatus

        return status
}</span>

// GetDefaultConfig returns a default configuration for the event listener
func GetDefaultConfig() *ListenerConfig <span class="cov0" title="0">{
        return &amp;ListenerConfig{
                Chains: []ChainConfig{
                        {
                                ChainID:      "17000",
                                Name:         "Ethereum Holesky",
                                RPCURL:       config.GetChainRPCUrl(true, "17000"),
                                WebSocketURL: config.GetChainRPCUrl(false, "17000"),
                                Enabled:      true,
                        },
                        {
                                ChainID:      "84532",
                                Name:         "Base Sepolia",
                                RPCURL:       config.GetChainRPCUrl(true, "84532"),
                                WebSocketURL: config.GetChainRPCUrl(false, "84532"),
                                Enabled:      true,
                        },
                },
                ReconnectConfig: ReconnectConfig{
                        MaxRetries:    10,
                        BaseDelay:     5 * time.Second,
                        MaxDelay:      5 * time.Minute,
                        BackoffFactor: 2.0,
                },
                ProcessingWorkers: 4,
                EventBufferSize:   1000,
                ProcessingTimeout: 30 * time.Second,
                ContractAddresses: map[string]map[string]string{
                        "17000": { // Ethereum Holesky
                                "avs_governance": config.GetAvsGovernanceAddress(),
                        },
                        "84532": { // Base Sepolia
                                "attestation_center": config.GetAttestationCenterAddress(),
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">package events

import (
        "context"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket"
)

// ProcessOperatorEvent processes operator-related events
func (h *OperatorEventHandler) ProcessOperatorEvent(ctx context.Context, event *websocket.ChainEvent) <span class="cov0" title="0">{
        switch event.EventName </span>{
        case "OperatorRegistered":<span class="cov0" title="0">
                h.handleOperatorRegistered(ctx, event)</span>
        case "OperatorUnregistered":<span class="cov0" title="0">
                h.handleOperatorUnregistered(ctx, event)</span>
        default:<span class="cov0" title="0">
                h.logger.Warnf("Unknown operator event: %s", event.EventName)</span>
        }
}

// handleOperatorRegistered handles OperatorRegistered events
func (h *OperatorEventHandler) handleOperatorRegistered(ctx context.Context, event *websocket.ChainEvent) <span class="cov0" title="0">{
        h.logger.Infof("Processing OperatorRegistered event on chain %s", event.ChainID)

        // Extract event data
        if eventData, ok := event.Data.(*websocket.ContractEventData); ok </span><span class="cov0" title="0">{
                h.logger.Infof("Operator registered: %+v", eventData.ParsedData)

                // TODO: Add your business logic here
                // - Update operator registry in database
                // - Send notifications
                // - Update metrics

                h.logger.Infof("Successfully processed OperatorRegistered event at block %d", event.BlockNumber)
        }</span> else<span class="cov0" title="0"> {
                h.logger.Errorf("Failed to parse OperatorRegistered event data")
        }</span>
}

// handleOperatorUnregistered handles OperatorUnregistered events
func (h *OperatorEventHandler) handleOperatorUnregistered(ctx context.Context, event *websocket.ChainEvent) <span class="cov0" title="0">{
        h.logger.Infof("Processing OperatorUnregistered event on chain %s", event.ChainID)

        // Extract event data
        if eventData, ok := event.Data.(*websocket.ContractEventData); ok </span><span class="cov0" title="0">{
                h.logger.Infof("Operator unregistered: %+v", eventData.ParsedData)

                // TODO: Add your business logic here
                // - Update operator registry in database
                // - Send notifications
                // - Update metrics

                h.logger.Infof("Successfully processed OperatorUnregistered event at block %d", event.BlockNumber)
        }</span> else<span class="cov0" title="0"> {
                h.logger.Errorf("Failed to parse OperatorUnregistered event data")
        }</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package events

import (
        "encoding/hex"
        "fmt"
        "math/big"
        "strconv"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/websocket"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/types"
)

// ProcessTaskEvent processes task-related events
func (h *TaskEventHandler) ProcessTaskEvent(event *websocket.ChainEvent) <span class="cov0" title="0">{
        if eventData, ok := event.Data.(*websocket.ContractEventData); ok </span><span class="cov0" title="0">{
                // Parse the event data to TaskSubmissionData
                taskData, err := h.parseTaskSubmissionData(eventData.ParsedData, event.TxHash)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Errorf("Failed to parse TaskSubmitted event data: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">if event.EventName == "TaskRejected" </span><span class="cov0" title="0">{
                        taskData.IsAccepted = false
                }</span>

                <span class="cov0" title="0">if taskData.TaskID != 0 </span><span class="cov0" title="0">{
                        // Update task submission data in database
                        if err := h.db.UpdateTaskSubmissionData(*taskData); err != nil </span><span class="cov0" title="0">{
                                h.logger.Errorf("Failed to update task submission data in database: %v", err)
                                return
                        }</span>
                        // Update keeper points in database
                        <span class="cov0" title="0">if err := h.db.UpdateKeeperPointsInDatabase(*taskData); err != nil </span><span class="cov0" title="0">{
                                h.logger.Errorf("Failed to update keeper points in database: %v", err)
                                return
                        }</span>
                }
        }
}

// parseTaskSubmissionData parses the event data into TaskSubmissionData
func (h *TaskEventHandler) parseTaskSubmissionData(parsedData map[string]interface{}, txHash string) (*types.TaskSubmissionData, error) <span class="cov0" title="0">{
        // Extract taskDefinitionId - it's indexed, so it comes as a string (hex-encoded)
        taskDefinitionIdStr, ok := parsedData["taskDefinitionId"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("taskDefinitionId not found or invalid type")
        }</span>

        // Convert hex string to integer
        <span class="cov0" title="0">taskDefinitionIdInt64, err := strconv.ParseInt(taskDefinitionIdStr, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse taskDefinitionId: %v", err)
        }</span>
        <span class="cov0" title="0">taskDefinitionId := int(taskDefinitionIdInt64)

        if taskDefinitionId == 10001 || taskDefinitionId == 10002 </span><span class="cov0" title="0">{
                taskData := &amp;types.TaskSubmissionData{
                        TaskID:               0,
                }
                return taskData, nil
        }</span>
        
        // Extract task number - it's already parsed as uint32, so we need to handle it as a number
        <span class="cov0" title="0">var taskNumber int64
        switch v := parsedData["taskNumber"].(type) </span>{
        case string:<span class="cov0" title="0">
                // If it's a string, parse it
                var err error
                taskNumber, err = strconv.ParseInt(v, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse taskNumber: %v", err)
                }</span>
        case float64:<span class="cov0" title="0">
                // If it's a float64 (from JSON unmarshaling), convert to int64
                taskNumber = int64(v)</span>
        case int64:<span class="cov0" title="0">
                taskNumber = v</span>
        case int:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        case uint32:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        case uint64:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("taskNumber has unexpected type: %T", v)</span>
        }

        // Extract proof of task
        <span class="cov0" title="0">proofOfTask, ok := parsedData["proofOfTask"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proofOfTask not found or invalid type")
        }</span>

        // Extract operator address
        <span class="cov0" title="0">performerAddress, ok := parsedData["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operator not found or invalid type")
        }</span>

        // Extract attesters IDs
        <span class="cov0" title="0">attestersIdsInterface, ok := parsedData["attestersIds"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("attestersIds not found")
        }</span>

        // Convert attestersIds to string slice
        <span class="cov0" title="0">var attestersIds []int64
        switch v := attestersIdsInterface.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                for _, id := range v </span><span class="cov0" title="0">{
                        switch idVal := id.(type) </span>{
                        case *big.Int:<span class="cov0" title="0">
                                attestersIds = append(attestersIds, idVal.Int64())</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("invalid attester ID type: %T", id)</span>
                        }
                }
        case []*big.Int:<span class="cov0" title="0">
                for _, id := range v </span><span class="cov0" title="0">{
                        attestersIds = append(attestersIds, id.Int64())
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("attestersIds is not a slice: %T", v)</span>
        }

        <span class="cov0" title="0">data, ok := parsedData["data"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data not found or invalid type")
        }</span>

        <span class="cov0" title="0">var decodedData string
        dataBytes, err := hex.DecodeString(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hex-decode data: %v", err)
        }</span>
        <span class="cov0" title="0">decodedData = string(dataBytes)

        ipfsData, err := h.ipfsClient.Fetch(decodedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch IPFS content: %v", err)
        }</span>

        <span class="cov0" title="0">taskData := &amp;types.TaskSubmissionData{
                TaskID:               ipfsData.ActionData.TaskID,
                TaskNumber:           taskNumber,
                TaskDefinitionID:     taskDefinitionId,
                IsAccepted:           true,
                TaskSubmissionTxHash: txHash,
                PerformerAddress:     performerAddress,
                AttesterIds:          attestersIds,
                ExecutionTxHash:      ipfsData.ActionData.ActionTxHash,
                ExecutionTimestamp:   ipfsData.ActionData.ExecutionTimestamp,
                TaskOpxCost:          ipfsData.ActionData.TotalFee,
                ProofOfTask:          proofOfTask,
        }

        return taskData, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the registrar service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "uptime_seconds",
                Help:      "Time passed since Registrar started in seconds",
        })

        // RPC request metrics
        RPCRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "rpc_requests_total",
                Help:      "RPC requests to blockchain nodes",
        }, []string{"chain", "method", "status"})

        // RPC error metrics
        RPCErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "rpc_errors_total",
                Help:      "RPC request errors",
        }, []string{"chain", "error_type"})

        // Current block number metrics
        CurrentBlockNumber = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "current_block_number",
                Help:      "Current processed block number",
        }, []string{"chain"})

        // Event detection metrics
        EventsDetectedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "events_detected_total",
                Help:      "Events detected (event_type=task_submitted/task_rejected)",
        }, []string{"event_type"})

        // Points distribution metrics
        PointsDistributedTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "points_distributed_total",
                Help:      "Points distributed (recipient_type=performer/attester/user)",
        }, []string{"recipient_type"})

        // Memory usage metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        // CPU usage metrics
        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        // Goroutines active metrics
        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        // Garbage collection duration metrics
        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "registrar",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package registrar

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/ethclient"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/config"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/events"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/rewards"
        syncMgr "github.com/trigg3rX/triggerx-backend/internal/registrar/sync"
        "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        dbClient "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
)

const (
        defaultConnectTimeout = 30 * time.Second
        defaultBlockOverlap   = uint64(5)
)

// RegistrarService manages the event polling and WebSocket listening
type RegistrarService struct {
        logger logging.Logger

        // Event listener
        eventListener *events.ContractEventListener

        // State management
        stateManager *syncMgr.StateManager

        // Rewards service
        rewardsService *rewards.RewardsService

        // Lifecycle management
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
        stopChan chan struct{}
}

// NewRegistrarService creates a new instance of RegistrarService
func NewRegistrarService(logger logging.Logger) (*RegistrarService, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize HTTP clients for fallback polling
        ethClient, err := ethclient.Dial(config.GetChainRPCUrl(true, "17000"))
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to connect to Ethereum node: %w", err)
        }</span>

        <span class="cov0" title="0">baseClient, err := ethclient.Dial(config.GetChainRPCUrl(true, "84532"))
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to connect to Base node: %w", err)
        }</span>

        // Initialize Redis client first
        <span class="cov0" title="0">redis, err := redis.NewRedisClient(logger, redis.RedisConfig{
                UpstashConfig: redis.UpstashConfig{
                        URL:   config.GetUpstashRedisUrl(),
                        Token: config.GetUpstashRedisRestToken(),
                },
                ConnectionSettings: redis.ConnectionSettings{
                        PoolSize:      10,
                        MaxIdleConns:  10,
                        MinIdleConns:  1,
                        MaxRetries:    3,
                        DialTimeout:   5 * time.Second,
                        ReadTimeout:   5 * time.Second,
                        WriteTimeout:  5 * time.Second,
                        PoolTimeout:   5 * time.Second,
                        PingTimeout:   5 * time.Second,
                        HealthTimeout: 5 * time.Second,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize Redis client: %w", err)
        }</span>

        // Initialize state manager
        <span class="cov0" title="0">stateManager := syncMgr.NewStateManager(redis, logger)

        // Try to load existing state from Redis first
        initCtx, initCancel := context.WithTimeout(ctx, defaultConnectTimeout)
        lastEthBlock, err := stateManager.GetLastEthBlockUpdated(initCtx)
        if err != nil || lastEthBlock == 0 </span><span class="cov0" title="0">{
                // Fallback to current blockchain block if Redis is empty
                logger.Info("No ETH block found in Redis, getting current block from blockchain")
                lastEthBlock, err = ethClient.BlockNumber(initCtx)
                if err != nil </span><span class="cov0" title="0">{
                        initCancel()
                        cancel()
                        return nil, fmt.Errorf("failed to get ETH latest block: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("Loaded ETH block %d from Redis", lastEthBlock)
        }</span>

        <span class="cov0" title="0">lastBaseBlock, err := stateManager.GetLastBaseBlockUpdated(initCtx)
        if err != nil || lastBaseBlock == 0 </span><span class="cov0" title="0">{
                logger.Info("No BASE block found in Redis, getting current block from blockchain")
                lastBaseBlock, err = baseClient.BlockNumber(initCtx)
                if err != nil </span><span class="cov0" title="0">{
                        initCancel()
                        cancel()
                        return nil, fmt.Errorf("failed to get BASE latest block: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("Loaded BASE block %d from Redis", lastBaseBlock)
        }</span>
        <span class="cov0" title="0">initCancel()

        // Ensure state is initialized in Redis (will only set if not already present)
        if err := stateManager.InitializeState(ctx, lastEthBlock, lastBaseBlock, 0, time.Now().UTC()); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize blockchain state: %w", err)
        }</span>

        <span class="cov0" title="0">dbCfg := &amp;dbClient.Config{
                Hosts:       []string{config.GetDatabaseHostAddress() + ":" + config.GetDatabaseHostPort()},
                Keyspace:    "triggerx",
                Timeout:     10 * time.Second,
                Retries:     3,
                ConnectWait: 5 * time.Second,
        }
        dbConn, err := dbClient.NewConnection(dbCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize database client: %w", err)
        }</span>

        // Initialize database client
        <span class="cov0" title="0">databaseClient := database.NewDatabaseClient(logger, dbConn)

        ipfsCfg := ipfs.NewConfig(config.GetPinataHost(), config.GetPinataJWT())
        ipfsClient, err := ipfs.NewClient(ipfsCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize IPFS client: %w", err)
        }</span>
        <span class="cov0" title="0">eventListener := events.NewContractEventListener(logger, events.GetDefaultConfig(), databaseClient, ipfsClient)

        // Initialize rewards service
        rewardsService := rewards.NewRewardsService(logger, stateManager, databaseClient)

        return &amp;RegistrarService{
                logger:         logger,
                eventListener:  eventListener,
                stateManager:   stateManager,
                rewardsService: rewardsService,
                ctx:            ctx,
                cancel:         cancel,
                stopChan:       make(chan struct{}),
        }, nil</span>
}

// Start begins the event monitoring service
func (s *RegistrarService) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting registrar service...")

        // Start Rewards Service (if initialized)
        if s.rewardsService != nil </span><span class="cov0" title="0">{
                go s.rewardsService.StartDailyRewardsPoints()
        }</span> else<span class="cov0" title="0"> {
                s.logger.Info("Rewards service not initialized (database client not available)")
        }</span>

        // Start event listener
        <span class="cov0" title="0">if err := s.eventListener.Start(); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("Failed to start event listener: %v", err)
                s.logger.Info("Falling back to polling mode")
        }</span>

        <span class="cov0" title="0">s.logger.Info("Registrar service started successfully")
        return nil</span>
}

// Stop gracefully stops the service
func (s *RegistrarService) Stop() error <span class="cov0" title="0">{
        s.logger.Info("Stopping registrar service...")

        // Signal all goroutines to stop
        s.cancel()
        close(s.stopChan)

        // Wait for all goroutines with timeout
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                s.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                s.logger.Info("All goroutines stopped successfully")</span>
        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                s.logger.Warn("Timeout waiting for goroutines to stop")</span>
        }

        // Stop event listener
        <span class="cov0" title="0">if err := s.eventListener.Stop(); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("Error stopping event listener: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Registrar service stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package rewards

import (
        "context"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/registrar/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/registrar/sync"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type RewardsService struct {
        logger         logging.Logger
        stateManager   *sync.StateManager
        databaseClient *database.DatabaseClient
        ctx            context.Context
}

func NewRewardsService(logger logging.Logger, stateManager *sync.StateManager, databaseClient *database.DatabaseClient) *RewardsService <span class="cov0" title="0">{
        return &amp;RewardsService{
                logger:         logger,
                stateManager:   stateManager,
                databaseClient: databaseClient,
                ctx:            context.Background(),
        }
}</span>

func (s *RewardsService) StartDailyRewardsPoints() <span class="cov0" title="0">{
        s.logger.Info("Starting daily rewards service...")

        ctx, cancel := context.WithTimeout(s.ctx, 10*time.Second)
        defer cancel()

        lastRewardsUpdate, err := s.stateManager.GetLastRewardsUpdate(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("Failed to get last rewards update from Redis: %v", err)
                lastRewardsUpdate = time.Now().AddDate(0, 0, -1)
        }</span> else<span class="cov0" title="0"> if lastRewardsUpdate.IsZero() </span><span class="cov0" title="0">{
                s.logger.Info("No previous rewards update found, starting from yesterday")
                lastRewardsUpdate = time.Now().AddDate(0, 0, -1)
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Last rewards update: %v", lastRewardsUpdate)

        now := time.Now()
        startDate := lastRewardsUpdate.AddDate(0, 0, 1).Truncate(24 * time.Hour)
        today := now.Truncate(24 * time.Hour)

        for d := startDate; !d.After(today); d = d.AddDate(0, 0, 1) </span><span class="cov0" title="0">{
                rewardTime := time.Date(d.Year(), d.Month(), d.Day(), 6, 30, 0, 0, time.UTC)

                if now.After(rewardTime) </span><span class="cov0" title="0">{
                        s.logger.Infof("Distributing missed rewards for %v", d.Format("2006-01-02"))
                        err := s.databaseClient.DailyRewardsPoints()
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Errorf("Failed to distribute rewards for %v: %v", d.Format("2006-01-02"), err)
                                continue</span>
                        }
                        <span class="cov0" title="0">s.updateLastRewardsTimestamp(rewardTime)
                        s.logger.Infof("Rewards distributed for %v", d.Format("2006-01-02"))</span>
                }
        }

        <span class="cov0" title="0">go s.scheduleNextReward()</span>
}

func (s *RewardsService) scheduleNextReward() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                now := time.Now()
                nextReward := time.Date(now.Year(), now.Month(), now.Day(), 06, 30, 0, 0, time.UTC)

                if now.After(nextReward) </span><span class="cov0" title="0">{
                        nextReward = nextReward.AddDate(0, 0, 1)
                }</span>

                <span class="cov0" title="0">waitDuration := nextReward.Sub(now)
                s.logger.Infof("Next reward scheduled for: %v (in %v)", nextReward, waitDuration)

                time.Sleep(waitDuration)

                s.logger.Info("It's 06:30, distributing daily rewards now...")
                err := s.databaseClient.DailyRewardsPoints()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("Failed to distribute daily rewards: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        s.updateLastRewardsTimestamp(time.Now().UTC())
                        s.logger.Info("Daily rewards distributed successfully")
                }</span>

                <span class="cov0" title="0">time.Sleep(time.Minute)</span>
        }
}

func (s *RewardsService) updateLastRewardsTimestamp(timestamp time.Time) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(s.ctx, 5*time.Second)
        defer cancel()

        if err := s.stateManager.SetLastRewardsUpdate(ctx, timestamp); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("Failed to update last rewards timestamp in Redis: %v", err)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Debugf("Updated last rewards timestamp to %s", timestamp.Format(time.RFC3339))
        }</span>
}

// GetRewardsHealth returns health information about the rewards service
func (s *RewardsService) GetRewardsHealth() map[string]interface{} <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(s.ctx, 5*time.Second)
        defer cancel()

        health := map[string]interface{}{
                "service": "rewards",
                "status":  "running",
        }

        // Get last rewards update from Redis
        lastUpdate, err := s.stateManager.GetLastRewardsUpdate(ctx)
        if err != nil </span><span class="cov0" title="0">{
                health["last_rewards_update_error"] = err.Error()
                health["status"] = "degraded"
        }</span> else<span class="cov0" title="0"> {
                health["last_rewards_update"] = lastUpdate.Format(time.RFC3339)
                health["last_update_age"] = time.Since(lastUpdate).String()

                // Check if rewards are overdue (more than 25 hours since last update)
                if time.Since(lastUpdate) &gt; 25*time.Hour </span><span class="cov0" title="0">{
                        health["status"] = "overdue"
                        health["warning"] = "rewards distribution is overdue"
                }</span>
        }

        // Calculate next reward time
        <span class="cov0" title="0">now := time.Now()
        nextReward := time.Date(now.Year(), now.Month(), now.Day(), 6, 30, 0, 0, time.UTC)
        if now.After(nextReward) </span><span class="cov0" title="0">{
                nextReward = nextReward.AddDate(0, 0, 1)
        }</span>
        <span class="cov0" title="0">health["next_scheduled_reward"] = nextReward.Format(time.RFC3339)
        health["time_until_next_reward"] = nextReward.Sub(now).String()

        return health</span>
}

func (s *RewardsService) Close() <span class="cov0" title="0">{
        s.databaseClient.Close()
}</pre>
		
		<pre class="file" id="file145" style="display: none">package sync

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Redis keys for storing state
const (
        KeyLastEthBlockUpdated  = "registrar:state:last_eth_block_updated"
        KeyLastBaseBlockUpdated = "registrar:state:last_base_block_updated"
        KeyLastRewardsUpdate   = "registrar:state:last_rewards_update"
)

// StateManager manages blockchain synchronization state in Redis
type StateManager struct {
        redis  *redis.Client
        logger logging.Logger
}

// BlockchainState represents the current state of blockchain synchronization
type BlockchainState struct {
        LastEthBlockUpdated  uint64    `json:"last_eth_block_updated"`
        LastBaseBlockUpdated uint64    `json:"last_base_block_updated"`
        LastRewardsUpdate   time.Time `json:"last_rewards_update"`
        UpdatedAt           time.Time `json:"updated_at"`
}

// NewStateManager creates a new Redis-backed state manager
func NewStateManager(redis *redis.Client, logger logging.Logger) *StateManager <span class="cov0" title="0">{
        return &amp;StateManager{
                redis:  redis,
                logger: logger,
        }
}</span>

// InitializeState initializes the state in Redis with current blockchain data
func (sm *StateManager) InitializeState(ctx context.Context, ethBlock uint64, baseBlock uint64, optBlock uint64, rewardsUpdate time.Time) error <span class="cov0" title="0">{
        sm.logger.Info("Initializing blockchain state in Redis")

        // Set initial block numbers if they don't exist
        if err := sm.setBlockIfNotExists(ctx, KeyLastEthBlockUpdated, ethBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize ETH block: %w", err)
        }</span>

        <span class="cov0" title="0">if err := sm.setBlockIfNotExists(ctx, KeyLastBaseBlockUpdated, baseBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize BASE block: %w", err)
        }</span>

        // Set initial rewards update time if it doesn't exist
        <span class="cov0" title="0">if err := sm.setTimeIfNotExists(ctx, KeyLastRewardsUpdate, rewardsUpdate); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rewards update time: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Blockchain state initialized successfully",
                "eth_block", ethBlock,
                "base_block", baseBlock,
                "last_rewards_update", rewardsUpdate,
        )

        return nil</span>
}

// GetLastPolledEthBlock gets the last polled Ethereum block number
func (sm *StateManager) GetLastEthBlockUpdated(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        return sm.getBlockNumber(ctx, KeyLastEthBlockUpdated)
}</span>

// SetLastPolledEthBlock sets the last polled Ethereum block number
func (sm *StateManager) SetLastEthBlockUpdated(ctx context.Context, blockNumber uint64) error <span class="cov0" title="0">{
        return sm.setBlockNumber(ctx, KeyLastEthBlockUpdated, blockNumber)
}</span>

// GetLastPolledBaseBlock gets the last polled Base block number
func (sm *StateManager) GetLastBaseBlockUpdated(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        return sm.getBlockNumber(ctx, KeyLastBaseBlockUpdated)
}</span>

// SetLastPolledBaseBlock sets the last polled Base block number
func (sm *StateManager) SetLastBaseBlockUpdated(ctx context.Context, blockNumber uint64) error <span class="cov0" title="0">{
        return sm.setBlockNumber(ctx, KeyLastBaseBlockUpdated, blockNumber)
}</span>

// GetLastRewardsUpdate gets the last rewards update timestamp
func (sm *StateManager) GetLastRewardsUpdate(ctx context.Context) (time.Time, error) <span class="cov0" title="0">{
        timestampStr, err := sm.redis.Get(ctx, KeyLastRewardsUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to get last rewards update: %w", err)
        }</span>

        <span class="cov0" title="0">if timestampStr == "" </span><span class="cov0" title="0">{
                // Return previous day's 6:30 AM UTC
                return time.Now().AddDate(0, 0, -1).Add(6*time.Hour + 30*time.Minute).UTC(), nil
        }</span>

        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, timestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to parse rewards update timestamp: %w", err)
        }</span>

        <span class="cov0" title="0">return timestamp, nil</span>
}

// SetLastRewardsUpdate sets the last rewards update timestamp
func (sm *StateManager) SetLastRewardsUpdate(ctx context.Context, timestamp time.Time) error <span class="cov0" title="0">{
        timestampStr := timestamp.UTC().Format(time.RFC3339)

        if err := sm.redis.Set(ctx, KeyLastRewardsUpdate, timestampStr, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set last rewards update: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debugf("Updated last rewards update to %s", timestampStr)
        return nil</span>
}

// GetFullState gets the complete blockchain state
func (sm *StateManager) GetFullState(ctx context.Context) (*BlockchainState, error) <span class="cov0" title="0">{
        ethBlock, err := sm.GetLastEthBlockUpdated(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ETH block: %w", err)
        }</span>

        <span class="cov0" title="0">baseBlock, err := sm.GetLastBaseBlockUpdated(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get BASE block: %w", err)
        }</span>

        <span class="cov0" title="0">rewardsUpdate, err := sm.GetLastRewardsUpdate(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get rewards update: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;BlockchainState{
                LastEthBlockUpdated:  ethBlock,
                LastBaseBlockUpdated: baseBlock,
                LastRewardsUpdate:   rewardsUpdate,
                UpdatedAt:           time.Now().UTC(),
        }, nil</span>
}

// UpdateBlockchainProgress updates multiple blockchain states atomically
func (sm *StateManager) UpdateBlockchainProgress(ctx context.Context, ethBlock, baseBlock *uint64) error <span class="cov0" title="0">{
        // Use Redis pipeline for atomic updates
        pipe := sm.redis.Client().Pipeline()

        if ethBlock != nil </span><span class="cov0" title="0">{
                pipe.Set(ctx, KeyLastEthBlockUpdated, strconv.FormatUint(*ethBlock, 10), 0)
        }</span>

        <span class="cov0" title="0">if baseBlock != nil </span><span class="cov0" title="0">{
                pipe.Set(ctx, KeyLastBaseBlockUpdated, strconv.FormatUint(*baseBlock, 10), 0)
        }</span>

        <span class="cov0" title="0">_, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update blockchain progress: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debugf("Updated blockchain progress - ETH: %v, BASE: %v",
                formatBlockPtr(ethBlock), formatBlockPtr(baseBlock))

        return nil</span>
}

// ResetState resets all state to initial values
func (sm *StateManager) ResetState(ctx context.Context) error <span class="cov0" title="0">{
        keys := []string{
                KeyLastEthBlockUpdated,
                KeyLastBaseBlockUpdated,
                KeyLastRewardsUpdate,
        }

        if err := sm.redis.Del(ctx, keys...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reset state: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Blockchain state reset successfully")
        return nil</span>
}

// GetStateHealth returns health information about the state
func (sm *StateManager) GetStateHealth(ctx context.Context) map[string]interface{} <span class="cov0" title="0">{
        health := map[string]interface{}{
                "redis_connected": true,
                "state_keys":      make(map[string]interface{}),
        }

        // Check if Redis is accessible
        if err := sm.redis.CheckConnection(ctx); err != nil </span><span class="cov0" title="0">{
                health["redis_connected"] = false
                health["error"] = err.Error()
                return health
        }</span>

        // Check each state key
        <span class="cov0" title="0">keys := map[string]string{
                "eth_block":      KeyLastEthBlockUpdated,
                "base_block":     KeyLastBaseBlockUpdated,
                "rewards_update": KeyLastRewardsUpdate,
        }

        for name, key := range keys </span><span class="cov0" title="0">{
                value, err := sm.redis.Get(ctx, key)
                ttl, ttlErr := sm.redis.TTL(ctx, key)

                keyHealth := map[string]interface{}{
                        "exists": err == nil &amp;&amp; value != "",
                        "value":  value,
                }

                if ttlErr == nil </span><span class="cov0" title="0">{
                        keyHealth["ttl"] = ttl.String()
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        keyHealth["error"] = err.Error()
                }</span>

                <span class="cov0" title="0">health["state_keys"].(map[string]interface{})[name] = keyHealth</span>
        }

        <span class="cov0" title="0">return health</span>
}

// Helper methods
func (sm *StateManager) getBlockNumber(ctx context.Context, key string) (uint64, error) <span class="cov0" title="0">{
        blockStr, err := sm.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get block number for key %s: %w", key, err)
        }</span>

        <span class="cov0" title="0">if blockStr == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">blockNumber, err := strconv.ParseUint(blockStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse block number %s: %w", blockStr, err)
        }</span>

        <span class="cov0" title="0">return blockNumber, nil</span>
}

func (sm *StateManager) setBlockNumber(ctx context.Context, key string, blockNumber uint64) error <span class="cov0" title="0">{
        blockStr := strconv.FormatUint(blockNumber, 10)

        if err := sm.redis.Set(ctx, key, blockStr, 0); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set block number for key %s: %w", key, err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debugf("Updated %s to block %d", key, blockNumber)
        return nil</span>
}

func (sm *StateManager) setBlockIfNotExists(ctx context.Context, key string, blockNumber uint64) error <span class="cov0" title="0">{
        existing, err := sm.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only set if key doesn't exist or is empty
        <span class="cov0" title="0">if existing == "" </span><span class="cov0" title="0">{
                return sm.setBlockNumber(ctx, key, blockNumber)
        }</span>

        <span class="cov0" title="0">sm.logger.Debugf("Key %s already exists with value %s, skipping initialization", key, existing)
        return nil</span>
}

func (sm *StateManager) setTimeIfNotExists(ctx context.Context, key string, timestamp time.Time) error <span class="cov0" title="0">{
        existing, err := sm.redis.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only set if key doesn't exist or is empty
        <span class="cov0" title="0">if existing == "" </span><span class="cov0" title="0">{
                timestampStr := timestamp.UTC().Format(time.RFC3339)
                return sm.redis.Set(ctx, key, timestampStr, 0)
        }</span>

        <span class="cov0" title="0">sm.logger.Debugf("Key %s already exists with value %s, skipping initialization", key, existing)
        return nil</span>
}

func formatBlockPtr(block *uint64) interface{} <span class="cov0" title="0">{
        if block == nil </span><span class="cov0" title="0">{
                return "unchanged"
        }</span>
        <span class="cov0" title="0">return *block</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type MetricsHandler struct {
        logger    logging.Logger
        collector *metrics.Collector
}

func NewMetricsHandler(logger logging.Logger) *MetricsHandler <span class="cov0" title="0">{
        return &amp;MetricsHandler{
                logger:    logger,
                collector: metrics.NewCollector(),
        }
}</span>

// Metrics serves Prometheus metrics
func (h *MetricsHandler) Metrics(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[Metrics] trace_id=" + traceID + " - Serving metrics")
        h.collector.Handler().ServeHTTP(c.Writer, c.Request)
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package handlers

import (
        "fmt"
        "math/big"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type SchedulerHandler struct {
        logger    logging.Logger
        scheduler *scheduler.ConditionBasedScheduler
}

func NewSchedulerHandler(logger logging.Logger, scheduler *scheduler.ConditionBasedScheduler) *SchedulerHandler <span class="cov0" title="0">{
        return &amp;SchedulerHandler{
                logger:    logger,
                scheduler: scheduler,
        }
}</span>

// getTraceID retrieves the trace ID from the Gin context
func getTraceID(c *gin.Context) string <span class="cov0" title="0">{
        traceID, exists := c.Get("trace_id")
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return traceID.(string)</span>
}

// ScheduleJob schedules a new condition-based job
func (h *SchedulerHandler) ScheduleJob(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[ScheduleJob] trace_id=" + traceID + " - Scheduling job")

        var jobData types.ScheduleConditionJobData
        if err := c.ShouldBindJSON(&amp;jobData); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid request payload", "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "status":    "error",
                        "message":   "Invalid request payload",
                        "error":     err.Error(),
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        // Schedule the job
        <span class="cov0" title="0">if err := h.scheduler.ScheduleJob(&amp;jobData); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to schedule condition job", "job_id", jobData.JobID, "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "status":    "error",
                        "message":   "Failed to schedule condition job",
                        "error":     err.Error(),
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Condition job scheduled successfully", "job_id", jobData.JobID)

        response := gin.H{
                "status":    "success",
                "message":   "Condition job scheduled successfully",
                "job_id":    jobData.JobID,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, response)</span>
}

// UnscheduleJob unschedules a condition-based job
func (h *SchedulerHandler) UnscheduleJob(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[UnscheduleJob] trace_id=" + traceID + " - Unscheduling job")

        jobIDStr := c.Param("job_id")
        jobID := new(big.Int)
        _, ok := jobID.SetString(jobIDStr, 10)
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid job ID: %s", jobIDStr)
                h.logger.Error("Invalid job ID", "job_id", jobIDStr, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "status":    "error",
                        "message":   "Invalid job ID",
                        "error":     err.Error(),
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        // Unschedule the job
        <span class="cov0" title="0">if err := h.scheduler.UnscheduleJob(jobID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to unschedule condition job", "job_id", jobID, "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                        "status":    "error",
                        "message":   "Failed to unschedule condition job",
                        "error":     err.Error(),
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("Condition job unscheduled successfully", "job_id", jobID)

        response := gin.H{
                "status":    "success",
                "message":   "Condition job unscheduled successfully",
                "job_id":    jobID,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetJobStats returns statistics for a specific condition job
func (h *SchedulerHandler) GetJobStats(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[GetJobStats] trace_id=" + traceID + " - Getting job stats")

        jobIDStr := c.Param("job_id")
        jobID := new(big.Int)
        _, ok := jobID.SetString(jobIDStr, 10)
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid job ID: %s", jobIDStr)
                h.logger.Error("Invalid job ID", "job_id", jobIDStr, "error", err)
                c.JSON(http.StatusBadRequest, gin.H{
                        "status":    "error",
                        "message":   "Invalid job ID",
                        "error":     err.Error(),
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        <span class="cov0" title="0">stats := h.scheduler.GetStats()
        if stats == nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get condition job stats", "job_id", jobID)
                c.JSON(http.StatusNotFound, gin.H{
                        "status":    "error",
                        "message":   "Condition job not found",
                        "error":     "condition job not found",
                        "timestamp": time.Now().UTC(),
                })
                return
        }</span>

        <span class="cov0" title="0">response := gin.H{
                "status":    "success",
                "data":      stats,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetStats returns current scheduler statistics
func (h *SchedulerHandler) GetStats(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[GetStats] trace_id=" + traceID + " - Getting scheduler stats")

        stats := h.scheduler.GetStats()

        response := gin.H{
                "status":    "success",
                "data":      stats,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type StatusHandler struct {
        logger logging.Logger
}

func NewStatusHandler(logger logging.Logger) *StatusHandler <span class="cov0" title="0">{
        return &amp;StatusHandler{
                logger: logger,
        }
}</span>

// Status returns the health status of the condition scheduler service
func (h *StatusHandler) Status(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[Status] trace_id=" + traceID + " - Checking service health")

        response := gin.H{
                "status":    "healthy",
                "service":   "condition-scheduler",
                "timestamp": time.Now().UTC(),
                "uptime":    time.Since(time.Now()).String(), // This would be calculated from startup time
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">package api

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "go.opentelemetry.io/otel"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

const TraceIDHeader = "X-Trace-ID"
const TraceIDKey = "trace_id"

// TraceMiddleware adds trace ID to requests and starts an OpenTelemetry span
func TraceMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tracer := otel.Tracer("triggerx-backend")
                ctx, span := tracer.Start(c.Request.Context(), c.Request.URL.Path)
                defer span.End()

                span.SetAttributes(
                        semconv.HTTPMethodKey.String(c.Request.Method),
                        semconv.HTTPURLKey.String(c.Request.URL.String()),
                        semconv.HTTPUserAgentKey.String(c.Request.UserAgent()),
                )

                traceID := c.GetHeader(TraceIDHeader)
                if traceID == "" </span><span class="cov0" title="0">{
                        spanContext := span.SpanContext()
                        if spanContext.HasTraceID() </span><span class="cov0" title="0">{
                                traceID = spanContext.TraceID().String()
                        }</span> else<span class="cov0" title="0"> {
                                traceID = uuid.New().String()
                        }</span>
                }

                <span class="cov0" title="0">c.Set(TraceIDKey, traceID)
                c.Header(TraceIDHeader, traceID)
                c.Request = c.Request.WithContext(ctx)
                c.Next()
                span.SetAttributes(semconv.HTTPStatusCodeKey.Int(c.Writer.Status()))</span>
        }
}

// MetricsMiddleware tracks HTTP request metrics
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                startTime := time.Now()

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(startTime)

                // Collect HTTP metrics
                statusCode := strconv.Itoa(c.Writer.Status())
                method := c.Request.Method
                endpoint := c.Request.URL.Path

                // Track HTTP request
                metrics.TrackHTTPRequest(method, endpoint, statusCode)

                // Log slow requests (optional)
                if duration &gt; 10*time.Second </span><span class="cov0" title="0">{
                        metrics.TrackTimeout("http_request")
                }</span>
        }
}

// LoggerMiddleware creates a gin middleware for logging API group requests only
func LoggerMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Only log requests under the /api/ path
                if len(c.Request.URL.Path) &lt; 5 || c.Request.URL.Path[:5] != "/api/" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">startTime := time.Now()
                path := c.Request.URL.Path
                rawQuery := c.Request.URL.RawQuery
                traceID, _ := c.Get(TraceIDKey)

                // Process request
                c.Next()

                duration := time.Since(startTime)
                statusCode := c.Writer.Status()

                logger.Info("Request processed",
                        "trace_id", traceID,
                        "status", statusCode,
                        "method", c.Request.Method,
                        "path", path,
                        "query", rawQuery,
                        "ip", c.ClientIP(),
                        "latency", duration,
                        "user-agent", c.Request.UserAgent(),
                )</span>
        }
}

// ErrorMiddleware handles errors in a consistent way
func ErrorMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check if there are any errors
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Get the last error
                        err := c.Errors.Last()
                        traceID, _ := c.Get(TraceIDKey)

                        logger.Error("Error",
                                "trace_id", traceID,
                                "error", err.Error(),
                                "path", c.Request.URL.Path,
                        )

                        // If the response hasn't been written yet
                        if !c.Writer.Written() </span><span class="cov0" title="0">{
                                c.JSON(c.Writer.Status(), gin.H{
                                        "error":    err.Error(),
                                        "trace_id": traceID,
                                })
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"

        "os"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/api/handlers"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        gootel "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

// Server represents the API server
type Server struct {
        router     *gin.Engine
        httpServer *http.Server
        logger     logging.Logger
}

// Config holds the server configuration
type Config struct {
        Port string
}

// Dependencies holds the server dependencies
type Dependencies struct {
        Logger    logging.Logger
        Scheduler *scheduler.ConditionBasedScheduler
}

// NewServer creates a new API server
func NewServer(cfg Config, deps Dependencies) *Server <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        router := gin.New()

        // Add trace middleware before all others
        router.Use(TraceMiddleware())

        // Initialize OpenTelemetry tracer
        _, err := InitTracer()
        if err != nil </span><span class="cov0" title="0">{
                deps.Logger.Error("Failed to initialize OpenTelemetry tracer", "error", err)
        }</span>

        // Create server instance
        <span class="cov0" title="0">srv := &amp;Server{
                router: router,
                logger: deps.Logger,
                httpServer: &amp;http.Server{
                        Addr:    fmt.Sprintf(":%s", cfg.Port),
                        Handler: router,
                },
        }

        // Setup routes
        srv.setupRoutes(deps)

        return srv</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting API server", "addr", s.httpServer.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Stopping API server")
        return s.httpServer.Shutdown(ctx)
}</span>

// setupRoutes sets up the routes for the server
func (s *Server) setupRoutes(deps Dependencies) <span class="cov0" title="0">{
        // Apply metrics middleware to all routes
        s.router.Use(MetricsMiddleware())

        // Create handlers
        statusHandler := handlers.NewStatusHandler(deps.Logger)
        metricsHandler := handlers.NewMetricsHandler(deps.Logger)
        schedulerHandler := handlers.NewSchedulerHandler(deps.Logger, deps.Scheduler)

        // Health and monitoring endpoints
        s.router.GET("/status", statusHandler.Status)
        s.router.GET("/metrics", metricsHandler.Metrics)

        // Scheduler management endpoints
        api := s.router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                api.GET("/scheduler/stats", schedulerHandler.GetStats)

                // Job management endpoints
                api.POST("/job/schedule", schedulerHandler.ScheduleJob)
                api.POST("/job/pause", schedulerHandler.UnscheduleJob)
                api.GET("/job/stats/:job_id", schedulerHandler.GetJobStats)
        }</span>
}

// InitTracer sets up OpenTelemetry tracing with OTLP exporter for Tempo
// Set TEMPO_OTLP_ENDPOINT env var to override the default (localhost:4318)
func InitTracer() (func(context.Context) error, error) <span class="cov0" title="0">{
        endpoint := os.Getenv("TEMPO_OTLP_ENDPOINT")
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "localhost:4318" // default to local Tempo
        }</span>
        <span class="cov0" title="0">exporter, err := otlptracehttp.New(context.Background(),
                otlptracehttp.WithEndpoint(endpoint),
                otlptracehttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tp := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String("triggerx-scheduler-condition"),
                )),
        )
        gootel.SetTracerProvider(tp)
        return tp.Shutdown, nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package config

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Scheduler RPC Port
        conditionSchedulerRPCPort string

        // Database RPC URL
        dbServerURL string
        // Aggregator RPC URL
        aggregatorRPCURL string
        // Task Dispatcher RPC URL
        taskDispatcherRPCUrl string

        // Scheduler ID for consumer groups
        conditionSchedulerID int

        // Maximum number of workers
        maxWorkers int

        // API Keys for Alchemy
        alchemyAPIKey string
}

var cfg Config

// Helper to detect test environment
func isTestEnv() bool <span class="cov0" title="0">{
        return env.GetEnvString("APP_ENV", "") == "test"
}</span>

// Init initializes the configuration
func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                   env.GetEnvBool("DEV_MODE", false),
                conditionSchedulerRPCPort: env.GetEnvString("CONDITION_SCHEDULER_RPC_PORT", "9006"),
                dbServerURL:               env.GetEnvString("DBSERVER_RPC_URL", "http://localhost:9002"),
                aggregatorRPCURL:          env.GetEnvString("AGGREGATOR_RPC_URL", "http://localhost:9001"),
                taskDispatcherRPCUrl:      env.GetEnvString("TASK_DISPATCHER_RPC_URL", "localhost:9003"),
                conditionSchedulerID:      env.GetEnvInt("CONDITION_SCHEDULER_ID", 5678),
                maxWorkers:                env.GetEnvInt("CONDITION_SCHEDULER_MAX_WORKERS", 100),
                alchemyAPIKey:             env.GetEnvString("ALCHEMY_API_KEY", ""),
        }
        if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig() error <span class="cov0" title="0">{
        if !env.IsValidPort(cfg.conditionSchedulerRPCPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid condition scheduler RPC port: %s", cfg.conditionSchedulerRPCPort)
        }</span>
        <span class="cov0" title="0">if !env.IsValidURL(cfg.dbServerURL) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database server URL: %s", cfg.dbServerURL)
        }</span>
        <span class="cov0" title="0">if !env.IsValidURL(cfg.aggregatorRPCURL) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid aggregator RPC URL: %s", cfg.aggregatorRPCURL)
        }</span>
        // Note: taskDispatcherRPCUrl is a gRPC endpoint (host:port format), not an HTTP URL
        // so we don't validate it as a URL
        <span class="cov0" title="0">return nil</span>
}

// IsDevMode returns whether the service is running in development mode
func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

// GetSchedulerRPCPort returns the scheduler RPC port
func GetSchedulerRPCPort() string <span class="cov0" title="0">{
        return cfg.conditionSchedulerRPCPort
}</span>

// GetDBServerURL returns the database server URL
func GetDBServerURL() string <span class="cov0" title="0">{
        return cfg.dbServerURL
}</span>

// GetAggregatorRPCURL returns the aggregator RPC URL
func GetAggregatorRPCURL() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCURL
}</span>

// GetTaskDispatcherRPCUrl returns the task dispatcher RPC URL
func GetTaskDispatcherRPCUrl() string <span class="cov0" title="0">{
        return cfg.taskDispatcherRPCUrl
}</span>

// GetMaxWorkers returns the maximum number of concurrent workers allowed
func GetMaxWorkers() int <span class="cov0" title="0">{
        return cfg.maxWorkers
}</span>

func GetSchedulerID() int <span class="cov0" title="0">{
        return cfg.conditionSchedulerID
}</span>

// GetChainRPCUrlsTest returns local/test chain RPC URLs
func GetChainRPCUrlsTest() map[string]string <span class="cov0" title="0">{
        local := "http://127.0.0.1:8545"
        return map[string]string{
                "11155420": local,
                "84532":    local,
                "11155111": local,
        }
}</span>

// GetChainRPCUrls returns chain RPC URLs for production or test
func GetChainRPCUrls() map[string]string <span class="cov0" title="0">{
        if isTestEnv() </span><span class="cov0" title="0">{
                return GetChainRPCUrlsTest()
        }</span>

        <span class="cov0" title="0">if cfg.alchemyAPIKey == "" </span><span class="cov0" title="0">{
                // Fallback to public endpoints if no Alchemy key
                return map[string]string{
                        "11155420": "https://sepolia.optimism.io",
                        "84532":    "https://sepolia.base.org",
                        "11155111": "https://ethereum-sepolia.publicnode.com",
                }
        }</span>

        <span class="cov0" title="0">return map[string]string{
                "11155420": fmt.Sprintf("https://opt-sepolia.g.alchemy.com/v2/%s", cfg.alchemyAPIKey),  // OP Sepolia
                "84532":    fmt.Sprintf("https://base-sepolia.g.alchemy.com/v2/%s", cfg.alchemyAPIKey), // Base Sepolia
                "11155111": fmt.Sprintf("https://eth-sepolia.g.alchemy.com/v2/%s", cfg.alchemyAPIKey),  // Ethereum Sepolia
        }</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package metrics

import (
        "runtime"
        "sync"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
)

const (
        // DuplicateEventWindow is the window to prevent duplicate event processing
        // This matches the value in scheduler/worker package to avoid circular import
        DuplicateEventWindow = 30 * time.Second
)

var (
        // Internal tracking variables for performance calculations
        conditionStatsLock       sync.RWMutex
        conditionCheckTimes      []float64
        conditionsLastMinute     map[string]int64 // chain_id -&gt; count
        lastMinuteReset          time.Time
        workerStartTimes         map[string]time.Time // job_id -&gt; start_time
        workerMemoryUsage        map[string]int64     // job_id -&gt; memory_bytes
        totalConditions          int64
        successfulConditions     int64
        totalActions             int64
        successfulActions        int64
        lastConfigUpdate         time.Time
        configUpdateInterval     = 30 * time.Second
        conditionEvaluationTimes []float64
        actionExecutionTimes     map[string][]float64 // job_id -&gt; execution times
)

func init() <span class="cov0" title="0">{
        conditionsLastMinute = make(map[string]int64)
        workerStartTimes = make(map[string]time.Time)
        workerMemoryUsage = make(map[string]int64)
        actionExecutionTimes = make(map[string][]float64)
        lastMinuteReset = time.Now()
        lastConfigUpdate = time.Now()
}</span>

// Collects system resource metrics
func collectSystemMetrics() <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Update memory usage (current allocated bytes)
        MemoryUsageBytes.Set(float64(memStats.Alloc))

        // Update CPU usage (using system memory as a proxy)
        cpuPercent, err := cpu.Percent(0, false)
        if err == nil &amp;&amp; len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                CPUUsagePercent.Set(cpuPercent[0])
        }</span> else<span class="cov0" title="0"> {
                // Fallback to 0.0 if CPU monitoring fails
                CPUUsagePercent.Set(0.0)
        }</span>

        // Update active goroutines count
        <span class="cov0" title="0">GoroutinesActive.Set(float64(runtime.NumGoroutine()))

        // Update garbage collection duration (total pause time in seconds)
        GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)</span>
}

// Collects configuration-based metrics
func collectConfigurationMetrics() <span class="cov0" title="0">{
        now := time.Now()
        if now.Sub(lastConfigUpdate) &lt; configUpdateInterval </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lastConfigUpdate = now

        // Set duplicate condition window from configuration
        DuplicateConditionWindowSeconds.Set(getDuplicateConditionWindowSeconds())</span>
}

// Collects performance-related metrics
func collectPerformanceMetrics() <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()

        // Update conditions per minute for each chain
        now := time.Now()
        if now.Sub(lastMinuteReset) &gt;= time.Minute </span><span class="cov0" title="0">{
                // Take a snapshot of current counts before resetting
                conditionsSnapshot := make(map[string]int64)
                for chainID, count := range conditionsLastMinute </span><span class="cov0" title="0">{
                        conditionsSnapshot[chainID] = count
                        EventsPerMinute.WithLabelValues(chainID).Set(float64(count))
                }</span>

                // Reset for next minute in a separate goroutine to avoid blocking
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        conditionStatsLock.Lock()
                        defer conditionStatsLock.Unlock()

                        // Only reset if enough time has passed (prevent race conditions)
                        if time.Since(lastMinuteReset) &gt;= time.Minute </span><span class="cov0" title="0">{
                                conditionsLastMinute = make(map[string]int64)
                                lastMinuteReset = time.Now()
                        }</span>
                }()
        }

        // Calculate average condition check time
        <span class="cov0" title="0">if len(conditionCheckTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, duration := range conditionCheckTimes </span><span class="cov0" title="0">{
                        sum += duration
                }</span>
                <span class="cov0" title="0">avgTime := sum / float64(len(conditionCheckTimes))
                AverageConditionCheckTimeSeconds.Set(avgTime)</span>
        }
}

// Collects worker-related metrics
func collectWorkerMetrics() <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()

        // Update worker uptime for each active worker
        now := time.Now()
        for jobID, startTime := range workerStartTimes </span><span class="cov0" title="0">{
                uptime := now.Sub(startTime).Seconds()
                WorkerUptimeSeconds.WithLabelValues(jobID).Set(uptime)
        }</span>

        // Update worker memory usage
        <span class="cov0" title="0">for jobID, memUsage := range workerMemoryUsage </span><span class="cov0" title="0">{
                WorkerMemoryUsageBytes.WithLabelValues(jobID).Set(float64(memUsage))
        }</span>
}

// Resets metrics that should be reset daily
func resetDailyMetrics() <span class="cov0" title="0">{
        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()

        // Reset daily counters
        for chainID := range conditionsLastMinute </span><span class="cov0" title="0">{
                EventsPerMinute.WithLabelValues(chainID).Set(0)
        }</span>
        <span class="cov0" title="0">AverageConditionCheckTimeSeconds.Set(0)

        // Reset tracking variables
        conditionCheckTimes = nil
        conditionsLastMinute = make(map[string]int64)
        conditionEvaluationTimes = nil
        actionExecutionTimes = make(map[string][]float64)
        totalConditions = 0
        successfulConditions = 0
        totalActions = 0
        successfulActions = 0
        lastMinuteReset = time.Now()</span>
}

// Helper functions to get configuration values
func getDuplicateConditionWindowSeconds() float64 <span class="cov0" title="0">{
        // Use the local constant to avoid circular import
        return DuplicateEventWindow.Seconds()
}</span>

// HTTP and API tracking functions

// TrackHTTPRequest tracks HTTP request metrics
func TrackHTTPRequest(method, endpoint, statusCode string) <span class="cov0" title="0">{
        HTTPRequestsTotal.WithLabelValues(method, endpoint, statusCode).Inc()
}</span>

// TrackHTTPClientConnectionError tracks HTTP client connection errors
func TrackHTTPClientConnectionError() <span class="cov0" title="0">{
        HTTPClientConnectionErrorsTotal.Inc()
}</span>

// Database tracking functions

// TrackDBRequest tracks database request metrics
func TrackDBRequest(method, endpoint, status string) <span class="cov0" title="0">{
        DBRequestsTotal.WithLabelValues(method, endpoint, status).Inc()
}</span>

// TrackDBConnectionError tracks database connection errors
func TrackDBConnectionError() <span class="cov0" title="0">{
        DBConnectionErrorsTotal.Inc()
}</span>

// TrackDBRetry tracks database retry attempts
func TrackDBRetry(endpoint string) <span class="cov0" title="0">{
        DBRetriesTotal.WithLabelValues(endpoint).Inc()
}</span>

// Job and Worker tracking functions

// TrackJobScheduled tracks when a job is scheduled
func TrackJobScheduled() <span class="cov0" title="0">{
        JobsScheduled.Inc()
}</span>

// TrackJobCompleted tracks when a job completes
func TrackJobCompleted(status string) <span class="cov0" title="0">{
        JobsCompleted.WithLabelValues(status).Inc()
}</span>

// UpdateActiveWorkers updates the count of active workers
func UpdateActiveWorkers(count int) <span class="cov0" title="0">{
        ActiveWorkers.Set(float64(count))
}</span>

// TrackWorkerStart tracks when a worker starts
func TrackWorkerStart(jobID string) <span class="cov0" title="0">{
        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()
        workerStartTimes[jobID] = time.Now()
}</span>

// TrackWorkerStop tracks when a worker stops
func TrackWorkerStop(jobID string) <span class="cov0" title="0">{
        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()
        delete(workerStartTimes, jobID)
        delete(workerMemoryUsage, jobID)
        delete(actionExecutionTimes, jobID)
}</span>

// TrackWorkerMemoryUsage updates worker memory usage
func TrackWorkerMemoryUsage(jobID string, memoryBytes int64) <span class="cov0" title="0">{
        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()
        workerMemoryUsage[jobID] = memoryBytes
}</span>

// Condition-specific tracking functions

// TrackConditionEvaluation tracks condition evaluation metrics
func TrackConditionEvaluation(duration time.Duration) <span class="cov0" title="0">{
        ConditionEvaluationDuration.Observe(duration.Seconds())

        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()
        conditionEvaluationTimes = append(conditionEvaluationTimes, duration.Seconds())
}</span>

// TrackConditionByType tracks conditions by their type
func TrackConditionByType(conditionType string) <span class="cov0" title="0">{
        ConditionsByTypeTotal.WithLabelValues(conditionType).Inc()
}</span>

// TrackConditionBySource tracks conditions by their source type
func TrackConditionBySource(sourceType string) <span class="cov0" title="0">{
        ConditionsBySourceTotal.WithLabelValues(sourceType).Inc()
}</span>

// TrackAPIResponse tracks API response status
func TrackAPIResponse(sourceURL, statusCode string) <span class="cov0" title="0">{
        APIResponseStatusTotal.WithLabelValues(sourceURL, statusCode).Inc()
}</span>

// TrackValueParsingError tracks value parsing errors
func TrackValueParsingError(sourceType string) <span class="cov0" title="0">{
        ValueParsingErrorsTotal.WithLabelValues(sourceType).Inc()
}</span>

// TrackInvalidValue tracks invalid values received
func TrackInvalidValue(source string) <span class="cov0" title="0">{
        InvalidValuesTotal.WithLabelValues(source).Inc()
}</span>

// Action execution tracking functions

// TrackActionExecution tracks action execution with duration
func TrackActionExecution(jobID string, duration time.Duration) <span class="cov0" title="0">{
        ActionExecutionDuration.WithLabelValues(jobID).Observe(duration.Seconds())

        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()
        if actionExecutionTimes[jobID] == nil </span><span class="cov0" title="0">{
                actionExecutionTimes[jobID] = make([]float64, 0)
        }</span>
        <span class="cov0" title="0">actionExecutionTimes[jobID] = append(actionExecutionTimes[jobID], duration.Seconds())</span>
}

// Error and recovery tracking functions

// TrackTimeout tracks operation timeouts
func TrackTimeout(operation string) <span class="cov0" title="0">{
        TimeoutsTotal.WithLabelValues(operation).Inc()
}</span>

// TrackCriticalError tracks critical system errors
func TrackCriticalError(errorType string) <span class="cov0" title="0">{
        CriticalErrorsTotal.WithLabelValues(errorType).Inc()
}</span>

// Condition processing tracking functions

// TrackConditionCheck tracks condition checks with duration and success
func TrackConditionCheck(chainID string, duration time.Duration, success bool) <span class="cov0" title="0">{
        conditionStatsLock.Lock()
        defer conditionStatsLock.Unlock()

        // Update conditions per minute
        if conditionsLastMinute[chainID] == 0 </span><span class="cov0" title="0">{
                conditionsLastMinute[chainID] = 0
        }</span>
        <span class="cov0" title="0">conditionsLastMinute[chainID]++

        // Track condition check time
        conditionCheckTimes = append(conditionCheckTimes, duration.Seconds())

        // Update totals
        totalConditions++
        if success </span><span class="cov0" title="0">{
                successfulConditions++
        }</span>
}

// Statistics and reporting functions

// GetConditionStats returns condition processing statistics
func GetConditionStats() (total, successful int64, avgCheckTime float64) <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()

        total = totalConditions
        successful = successfulConditions

        if len(conditionCheckTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, duration := range conditionCheckTimes </span><span class="cov0" title="0">{
                        sum += duration
                }</span>
                <span class="cov0" title="0">avgCheckTime = sum / float64(len(conditionCheckTimes))</span>
        }

        <span class="cov0" title="0">return total, successful, avgCheckTime</span>
}

// GetActionStats returns action execution statistics
func GetActionStats() (total, successful int64) <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()
        return totalActions, successfulActions
}</span>

// GetWorkerCount returns the current number of active workers
func GetWorkerCount() int <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()
        return len(workerStartTimes)
}</span>

// GetConditionEvaluationStats returns condition evaluation performance statistics
func GetConditionEvaluationStats() (count int, avgDuration float64, maxDuration float64) <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()

        count = len(conditionEvaluationTimes)
        if count == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>

        <span class="cov0" title="0">var sum, max float64
        for _, duration := range conditionEvaluationTimes </span><span class="cov0" title="0">{
                sum += duration
                if duration &gt; max </span><span class="cov0" title="0">{
                        max = duration
                }</span>
        }

        <span class="cov0" title="0">avgDuration = sum / float64(count)
        maxDuration = max

        return count, avgDuration, maxDuration</span>
}

// GetSchedulerHealthStatus returns overall scheduler health status
func GetSchedulerHealthStatus() map[string]interface{} <span class="cov0" title="0">{
        conditionStatsLock.RLock()
        defer conditionStatsLock.RUnlock()

        total, successful, avgCheckTime := GetConditionStats()
        totalActions, successfulActions := GetActionStats()
        workerCount := GetWorkerCount()
        evalCount, avgEvalDuration, maxEvalDuration := GetConditionEvaluationStats()

        return map[string]interface{}{
                "total_conditions":        total,
                "successful_conditions":   successful,
                "condition_success_rate":  float64(successful) / float64(total) * 100,
                "average_check_time":      avgCheckTime,
                "total_actions":           totalActions,
                "successful_actions":      successfulActions,
                "action_success_rate":     float64(successfulActions) / float64(totalActions) * 100,
                "active_workers":          workerCount,
                "evaluations_count":       evalCount,
                "average_evaluation_time": avgEvalDuration,
                "max_evaluation_time":     maxEvalDuration,
                "conditions_last_minute":  len(conditionsLastMinute),
        }
}</span>

var (
        // Internal tracking variables for performance calculations
        eventStatsLock       sync.RWMutex
        eventProcessingTimes []float64
        eventsLastMinute     map[string]int64 // chain_id -&gt; count
        totalEvents          int64
        successfulEvents     int64
)

func init() <span class="cov0" title="0">{
        eventsLastMinute = make(map[string]int64)
        workerStartTimes = make(map[string]time.Time)
        workerMemoryUsage = make(map[string]int64)
        lastMinuteReset = time.Now()
        lastConfigUpdate = time.Now()
}</span>

// Blockchain and RPC tracking functions

// TrackChainConnection tracks blockchain connection attempts
func TrackChainConnection(chainID, status string) <span class="cov0" title="0">{
        ChainConnectionsTotal.WithLabelValues(chainID, status).Inc()
}</span>

// TrackRPCRequest tracks RPC requests to blockchain nodes
func TrackRPCRequest(chainID, method, status string) <span class="cov0" title="0">{
        RPCRequestsTotal.WithLabelValues(chainID, method, status).Inc()
}</span>

// TrackConnectionFailure tracks blockchain connection failures
func TrackConnectionFailure(chainID string) <span class="cov0" title="0">{
        ConnectionFailuresTotal.WithLabelValues(chainID).Inc()
}</span>

// TrackWorkerError tracks worker errors
func TrackWorkerError(jobID, errorType string) <span class="cov0" title="0">{
        WorkerErrorsTotal.WithLabelValues(jobID, errorType).Inc()
}</span>

// Event tracking functions

// TrackEvent tracks when an event is detected
func TrackEvent(chainID string, processingTime time.Duration) <span class="cov0" title="0">{
        eventStatsLock.Lock()
        defer eventStatsLock.Unlock()

        // Update events per minute counter
        eventsLastMinute[chainID]++
        totalEvents++

        // Track processing time (keep last 1000 entries to avoid memory growth)
        eventProcessingTimes = append(eventProcessingTimes, processingTime.Seconds())
        if len(eventProcessingTimes) &gt; 1000 </span><span class="cov0" title="0">{
                eventProcessingTimes = eventProcessingTimes[1:]
        }</span>
}

// TrackEventSuccess tracks successful event processing
func TrackEventSuccess(chainID string) <span class="cov0" title="0">{
        eventStatsLock.Lock()
        defer eventStatsLock.Unlock()
        successfulEvents++
}</span>

// Stats and utility functions

// GetEventStats returns current event statistics
func GetEventStats() (total, successful int64, avgProcessingTime float64) <span class="cov0" title="0">{
        eventStatsLock.RLock()
        defer eventStatsLock.RUnlock()

        total = totalEvents
        successful = successfulEvents

        if len(eventProcessingTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, duration := range eventProcessingTimes </span><span class="cov0" title="0">{
                        sum += duration
                }</span>
                <span class="cov0" title="0">avgProcessingTime = sum / float64(len(eventProcessingTimes))</span>
        }

        <span class="cov0" title="0">return</span>
}

// TrackEventWithDuration tracks event processing with comprehensive metrics
func TrackEventWithDuration(chainID string, duration time.Duration, success bool) <span class="cov0" title="0">{
        // Track the basic event
        TrackEvent(chainID, duration)

        // Track success/failure
        if success </span><span class="cov0" title="0">{
                TrackEventSuccess(chainID)
        }</span>

        // Update average processing time immediately for real-time accuracy
        <span class="cov0" title="0">eventStatsLock.RLock()
        if len(eventProcessingTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, processingTime := range eventProcessingTimes </span><span class="cov0" title="0">{
                        sum += processingTime
                }</span>
                <span class="cov0" title="0">avgTime := sum / float64(len(eventProcessingTimes))
                AverageEventProcessingTimeSeconds.Set(avgTime)</span>
        }
        <span class="cov0" title="0">eventStatsLock.RUnlock()</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "uptime_seconds",
                Help:      "Time passed since Event Scheduler started in seconds",
        })

        // Memory usage metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "memory_usage_bytes",
                Help:      "Total memory consumption",
        })

        // CPU usage metrics
        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        // Goroutines active metrics
        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "goroutines_active",
                Help:      "Number of active goroutines",
        })

        // Garbage collection duration metrics
        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Events per minute by chain
        EventsPerMinute = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "events_per_minute",
                Help:      "Event detection rate per chain",
        }, []string{"chain_id"})

        // Jobs scheduled
        JobsScheduled = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "scheduler_jobs_scheduled",
                Help:      "Total number of jobs scheduled",
        })

        // Jobs completed
        JobsCompleted = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "scheduler_jobs_completed",
                Help:      "Total number of jobs completed successfully or failed",
        }, []string{"status"})

        // Active workers
        ActiveWorkers = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "active_workers",
                Help:      "Number of active job workers currently running",
        })

        // Chain connections
        ChainConnectionsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "chain_connections_total",
                Help:      "Blockchain connection attempts",
        }, []string{"chain_id", "status"})

        // RPC requests
        RPCRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "rpc_requests_total",
                Help:      "RPC requests to blockchain nodes",
        }, []string{"chain_id", "method", "status"})

        // Condition evaluation duration
        ConditionEvaluationDuration = promauto.NewHistogram(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "condition_evaluation_duration_seconds",
                Help:      "Time taken to evaluate conditions",
        })

        // Conditions by type
        ConditionsByTypeTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "conditions_by_type_total",
                Help:      "Conditions monitored by type",
        }, []string{"condition_type"})

        // Conditions by source
        ConditionsBySourceTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "conditions_by_source_total",
                Help:      "Conditions monitored by source type",
        }, []string{"source_type"})

        // API response status
        APIResponseStatusTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "api_response_status_total",
                Help:      "API response status codes",
        }, []string{"source_url", "status_code"})

        // Value parsing errors
        ValueParsingErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "value_parsing_errors_total",
                Help:      "Value parsing errors by source type",
        }, []string{"source_type"})

        // DB requests
        DBRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "db_requests_total",
                Help:      "Database client HTTP requests",
        }, []string{"method", "endpoint", "status"})

        // DB connection errors
        DBConnectionErrorsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "db_connection_errors_total",
                Help:      "Database connection failures",
        })

        // DB retries
        DBRetriesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "db_retries_total",
                Help:      "Database request retry attempts",
        }, []string{"endpoint"})

        // Action executions
        ActionExecutionsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "action_executions_total",
                Help:      "Action executions triggered by events",
        }, []string{"job_id", "status"})

        // Action execution duration
        ActionExecutionDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "action_execution_duration_seconds",
                Help:      "Time taken to execute actions",
        }, []string{"job_id"})

        // Worker uptime
        WorkerUptimeSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "worker_uptime_seconds",
                Help:      "Individual worker uptime",
        }, []string{"job_id"})

        // Worker errors
        WorkerErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "worker_errors_total",
                Help:      "Worker errors by type",
        }, []string{"job_id", "error_type"})

        // Worker memory usage
        WorkerMemoryUsageBytes = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "worker_memory_usage_bytes",
                Help:      "Memory usage per worker",
        }, []string{"job_id"})

        // HTTP requests
        HTTPRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "http_requests_total",
                Help:      "HTTP API requests received",
        }, []string{"method", "endpoint", "status_code"})

        // HTTP client connection errors
        HTTPClientConnectionErrorsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "http_client_connection_errors_total",
                Help:      "HTTP client connection errors",
        })

        // Duplicate condition window
        DuplicateConditionWindowSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "duplicate_condition_window_seconds",
                Help:      "Duplicate condition detection window",
        })

        // Duplicate event window
        DuplicateEventWindowSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "duplicate_event_window_seconds",
                Help:      "Duplicate event detection window",
        })

        // Average condition check time
        AverageConditionCheckTimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "average_condition_check_time_seconds",
                Help:      "Mean condition check time",
        })

        // Connection failures
        ConnectionFailuresTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "connection_failures_total",
                Help:      "Blockchain connection failures",
        }, []string{"chain_id"})

        // Average event processing time
        AverageEventProcessingTimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "event_scheduler",
                Name:      "average_event_processing_time_seconds",
                Help:      "Mean event processing time",
        })

        // Timeouts
        TimeoutsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "timeouts_total",
                Help:      "Operation timeouts",
        }, []string{"operation"})

        // Critical errors
        CriticalErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "critical_errors_total",
                Help:      "Critical system errors",
        }, []string{"error_type"})

        // Invalid values
        InvalidValuesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "condition_scheduler",
                Name:      "invalid_values_total",
                Help:      "Invalid/unparseable values received",
        }, []string{"source"})
)

// StartMetricsCollection starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                        collectSystemMetrics()
                        collectConfigurationMetrics()
                        collectPerformanceMetrics()
                        collectWorkerMetrics()
                }</span>
        }()

        // Reset daily metrics every day at midnight
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        resetDailyMetrics()
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "sync"
        "time"

        "math/big"

        "github.com/ethereum/go-ethereum/ethclient"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/config"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker"
        "github.com/trigg3rX/triggerx-backend/pkg/client/dbserver"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcclient "github.com/trigg3rX/triggerx-backend/pkg/rpc/client"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// ConditionBasedScheduler manages individual job workers for condition monitoring and event watching
type ConditionBasedScheduler struct {
        ctx                     context.Context
        cancel                  context.CancelFunc
        logger                  logging.Logger
        conditionWorkers        map[*big.Int]*worker.ConditionWorker         // jobID -&gt; condition worker
        eventWorkers            map[*big.Int]*worker.EventWorker             // jobID -&gt; event worker
        jobDataStore            map[string]*types.ScheduleConditionJobData // jobID -&gt; job data for trigger notifications
        workersMutex            sync.RWMutex
        notificationMutex       sync.Mutex // Protect job data during notification processing
        chainClients            map[string]*ethclient.Client // chainID -&gt; client
        HTTPClient              *httppkg.HTTPClient
        dbClient                *dbserver.DBServerClient
        taskDispatcherClient    *rpcclient.Client // RPC client for task dispatcher
        metrics                 *metrics.Collector
        maxWorkers              int
        schedulerID             int
}

// NewConditionBasedScheduler creates a new instance of ConditionBasedScheduler
func NewConditionBasedScheduler(managerID string, logger logging.Logger, dbClient *dbserver.DBServerClient) (*ConditionBasedScheduler, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize RPC client for task dispatcher
        taskDispatcherClient := rpcclient.NewClient(rpcclient.Config{
                ServiceName: config.GetTaskDispatcherRPCUrl(),
                Timeout:     30 * time.Second,
                MaxRetries:  3,
                RetryDelay:  time.Second,
                PoolSize:    10,
                PoolTimeout: 5 * time.Second,
        }, logger)

        scheduler := &amp;ConditionBasedScheduler{
                ctx:                     ctx,
                cancel:                  cancel,
                logger:                  logger,
                conditionWorkers:        make(map[*big.Int]*worker.ConditionWorker),
                eventWorkers:            make(map[*big.Int]*worker.EventWorker),
                jobDataStore:            make(map[string]*types.ScheduleConditionJobData),
                chainClients:            make(map[string]*ethclient.Client),
                dbClient:                dbClient,
                taskDispatcherClient:    taskDispatcherClient,
                metrics:                 metrics.NewCollector(),
                maxWorkers:              config.GetMaxWorkers(),
                schedulerID:             config.GetSchedulerID(),
        }

        // Initialize chain clients for event workers
        if err := scheduler.initChainClients(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize chain clients: %w", err)
        }</span>

        <span class="cov0" title="0">if err := scheduler.initRetryClient(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize retry client: %w", err)
        }</span>

        // Start metrics collection
        <span class="cov0" title="0">scheduler.metrics.Start()

        scheduler.logger.Info("Condition-based scheduler initialized",
                "max_workers", scheduler.maxWorkers,
                "scheduler_id", scheduler.schedulerID,
                "task_dispatcher_url", config.GetTaskDispatcherRPCUrl(),
                "connected_chains", len(scheduler.chainClients),
        )

        return scheduler, nil</span>
}

// Start begins the scheduler's main loop (for compatibility)
func (s *ConditionBasedScheduler) Start(ctx context.Context) <span class="cov0" title="0">{
        s.logger.Info("Condition-based scheduler ready for job scheduling",
                "scheduler_id", s.schedulerID)

        // Keep the service alive
        &lt;-ctx.Done()
        s.logger.Info("Scheduler context cancelled, stopping all workers")
        s.Stop()
}</span>

// Stop gracefully stops all condition workers
func (s *ConditionBasedScheduler) Stop() <span class="cov0" title="0">{
        startTime := time.Now()
        s.logger.Info("Stopping condition-based scheduler")

        // Capture statistics before shutdown
        s.workersMutex.RLock()
        totalConditionWorkers := len(s.conditionWorkers)
        totalEventWorkers := len(s.eventWorkers)
        s.workersMutex.RUnlock()

        connectedChains := len(s.chainClients)

        s.cancel()

        // Stop all workers
        s.workersMutex.Lock()
        for jobID, worker := range s.conditionWorkers </span><span class="cov0" title="0">{
                worker.Stop()
                s.logger.Info("Stopped condition worker", "job_id", jobID)
        }</span>
        <span class="cov0" title="0">for jobID, worker := range s.eventWorkers </span><span class="cov0" title="0">{
                worker.Stop()
                s.logger.Info("Stopped event worker", "job_id", jobID)
        }</span>
        <span class="cov0" title="0">s.conditionWorkers = make(map[*big.Int]*worker.ConditionWorker)
        s.eventWorkers = make(map[*big.Int]*worker.EventWorker)
        s.jobDataStore = make(map[string]*types.ScheduleConditionJobData)
        s.workersMutex.Unlock()

        // Close chain clients
        for chainID, client := range s.chainClients </span><span class="cov0" title="0">{
                client.Close()
                s.logger.Info("Closed chain client", "chain_id", chainID)
        }</span>
        <span class="cov0" title="0">s.chainClients = make(map[string]*ethclient.Client)

        // Close task dispatcher RPC client
        if s.taskDispatcherClient != nil </span><span class="cov0" title="0">{
                if err := s.taskDispatcherClient.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Failed to close task dispatcher RPC client", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Info("Closed task dispatcher RPC client")
                }</span>
        }

        <span class="cov0" title="0">duration := time.Since(startTime)

        s.logger.Info("Condition-based scheduler stopped",
                "duration", duration,
                "total_condition_workers_stopped", totalConditionWorkers,
                "total_event_workers_stopped", totalEventWorkers,
                "chains_disconnected", connectedChains,
        )</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "math/big"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// handleTriggerNotification processes trigger notifications and submits individual tasks to Redis API
func (s *ConditionBasedScheduler) handleTriggerNotification(notification *worker.TriggerNotification) error <span class="cov0" title="0">{
        startTime := time.Now()

        s.logger.Info("Processing trigger notification - submitting task to task dispatcher",
                "job_id", notification.JobID,
                "trigger_value", notification.TriggerValue,
                "trigger_tx_hash", notification.TriggerTxHash,
                "triggered_at", notification.TriggeredAt,
        )

        // Acquire notification mutex to prevent cleanup during processing
        s.notificationMutex.Lock()
        defer s.notificationMutex.Unlock()

        // Get the job data from storage
        s.workersMutex.RLock()
        jobData, exists := s.jobDataStore[notification.JobID.String()]
        s.workersMutex.RUnlock()

        if !exists || jobData == nil </span><span class="cov0" title="0">{
                s.logger.Error("Job data not found", "job_id", notification.JobID)
                return fmt.Errorf("job data not found for job %d", notification.JobID)
        }</span>

        <span class="cov0" title="0">createTaskRequest := types.CreateTaskRequest{
                JobID:            jobData.JobID,
                TaskDefinitionID: jobData.TaskDefinitionID,
        }

        // Create Task in Database
        taskID, err := s.dbClient.CreateTask(createTaskRequest)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create task in database", "job_id", notification.JobID, "error", err)
                return fmt.Errorf("failed to create task in database: %w", err)
        }</span>
        <span class="cov0" title="0">jobData.TaskTargetData.TaskID = taskID

        // Create individual task and submit to task dispatcher
        success, err := s.submitTriggeredTaskToTaskDispatcher(jobData, notification)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to submit triggered task to task dispatcher",
                        "job_id", notification.JobID,
                        "error", err,
                )
                metrics.TrackCriticalError("task_dispatcher_submission_failed")
                return err
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)
        if success </span><span class="cov0" title="0">{
                s.logger.Info("Successfully submitted triggered task to task dispatcher",
                        "job_id", notification.JobID,
                        "duration", duration,
                )
                metrics.TrackActionExecution(fmt.Sprintf("%d", notification.JobID), duration)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Error("Failed to submit triggered task to task dispatcher",
                        "job_id", notification.JobID,
                        "duration", duration,
                )
                metrics.TrackCriticalError("task_dispatcher_submission_failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// submitTriggeredTaskToTaskManager creates and submits a single task to TaskManager when triggers occur
func (s *ConditionBasedScheduler) submitTriggeredTaskToTaskDispatcher(jobData *types.ScheduleConditionJobData, notification *worker.TriggerNotification) (bool, error) <span class="cov0" title="0">{
        s.logger.Info("Creating triggered task for task dispatcher submission",
                "job_id", jobData.JobID,
                "task_definition_id", jobData.TaskDefinitionID,
                "trigger_value", notification.TriggerValue)

        // Create single task data (not batch like time scheduler)
        targetData := types.TaskTargetData{
                JobID:                     jobData.JobID,
                TaskID:                    jobData.TaskTargetData.TaskID,
                TaskDefinitionID:          jobData.TaskDefinitionID,
                TargetChainID:             jobData.TaskTargetData.TargetChainID,
                TargetContractAddress:     jobData.TaskTargetData.TargetContractAddress,
                TargetFunction:            jobData.TaskTargetData.TargetFunction,
                ABI:                       jobData.TaskTargetData.ABI,
                ArgType:                   jobData.TaskTargetData.ArgType,
                Arguments:                 jobData.TaskTargetData.Arguments,
                DynamicArgumentsScriptUrl: jobData.TaskTargetData.DynamicArgumentsScriptUrl,
                IsImua:                    jobData.IsImua,
        }

        // Create trigger data based on job type
        triggerData := s.createTriggerDataFromNotification(jobData, notification)

        // Create single task data for keeper
        sendTaskData := types.SendTaskDataToKeeper{
                TaskID:           []int64{jobData.TaskTargetData.TaskID},
                TargetData:       []types.TaskTargetData{targetData}, // Single task, not batch
                TriggerData:      []types.TaskTriggerData{triggerData},
                SchedulerID:      s.schedulerID,
                ManagerSignature: "",
        }

        // Create request for Redis API
        request := types.SchedulerTaskRequest{
                SendTaskDataToKeeper: sendTaskData,
                Source:               "condition_scheduler",
        }

        // Submit to TaskManager
        return s.submitTaskToTaskManager(request, notification.JobID)
}</span>

// createTriggerDataFromNotification creates appropriate trigger data based on job type
func (s *ConditionBasedScheduler) createTriggerDataFromNotification(jobData *types.ScheduleConditionJobData, notification *worker.TriggerNotification) types.TaskTriggerData <span class="cov0" title="0">{
        baseTriggerData := types.TaskTriggerData{
                TaskID:                  jobData.TaskTargetData.TaskID,
                TaskDefinitionID:        jobData.TaskDefinitionID,
                CurrentTriggerTimestamp: notification.TriggeredAt,
        }

        switch jobData.TaskDefinitionID </span>{
        case 5, 6:<span class="cov0" title="0"> // Condition-based
                baseTriggerData.ExpirationTime = jobData.ConditionWorkerData.ExpirationTime
                baseTriggerData.ConditionSatisfiedValue = int(notification.TriggerValue)
                baseTriggerData.ConditionType = jobData.ConditionWorkerData.ConditionType
                baseTriggerData.ConditionSourceType = jobData.ConditionWorkerData.ValueSourceType
                baseTriggerData.ConditionSourceUrl = jobData.ConditionWorkerData.ValueSourceUrl
                baseTriggerData.ConditionUpperLimit = int(jobData.ConditionWorkerData.UpperLimit)
                baseTriggerData.ConditionLowerLimit = int(jobData.ConditionWorkerData.LowerLimit)
                s.logger.Info("Condition job expiration time", "expiration_time", jobData.ConditionWorkerData.ExpirationTime)</span>

        case 3, 4:<span class="cov0" title="0"> // Event-based
                baseTriggerData.ExpirationTime = jobData.EventWorkerData.ExpirationTime
                baseTriggerData.EventTxHash = notification.TriggerTxHash
                baseTriggerData.EventChainId = jobData.EventWorkerData.TriggerChainID
                baseTriggerData.EventTriggerContractAddress = jobData.EventWorkerData.TriggerContractAddress
                baseTriggerData.EventTriggerName = jobData.EventWorkerData.TriggerEvent
                s.logger.Info("Event job expiration time", "expiration_time", jobData.EventWorkerData.ExpirationTime)</span>
        }

        <span class="cov0" title="0">return baseTriggerData</span>
}

// submitTaskToTaskManager submits the task to Task Dispatcher via RPC
func (s *ConditionBasedScheduler) submitTaskToTaskManager(request types.SchedulerTaskRequest, taskID *big.Int) (bool, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Make RPC call to task dispatcher
        var response types.TaskManagerAPIResponse
        err := s.taskDispatcherClient.Call(ctx, "submit-task", &amp;request, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to submit task to task dispatcher via RPC",
                        "task_id", taskID,
                        "error", err)
                return false, fmt.Errorf("failed to submit task to task dispatcher: %w", err)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)

        if !response.Success </span><span class="cov0" title="0">{
                s.logger.Error("Task dispatcher processing failed",
                        "task_id", taskID,
                        "message", response.Message,
                        "error", response.Error,
                        "duration", duration)
                return false, fmt.Errorf("task dispatcher processing failed: %s", response.Error)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully submitted task to task dispatcher",
                "task_id", taskID,
                "response_task_ids", response.TaskID,
                "duration", duration,
                "message", response.Message)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/ethclient"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// ScheduleJob creates and starts a new condition worker for monitoring
func (s *ConditionBasedScheduler) ScheduleJob(jobData *types.ScheduleConditionJobData) error <span class="cov0" title="0">{
        s.workersMutex.Lock()
        defer s.workersMutex.Unlock()

        startTime := time.Now()

        switch jobData.TaskDefinitionID </span>{
        case 3, 4:<span class="cov0" title="0"> // Event-based jobs
                if err := s.scheduleEventJob(jobData, startTime); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case 5, 6:<span class="cov0" title="0"> // Condition-based jobs
                if err := s.scheduleConditionJob(jobData, startTime); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported task definition id: %d", jobData.TaskDefinitionID)</span>
        }

        // Update metrics
        <span class="cov0" title="0">metrics.TrackJobScheduled()
        metrics.UpdateActiveWorkers(len(s.eventWorkers) + len(s.conditionWorkers))
        metrics.TrackWorkerStart(fmt.Sprintf("%d", jobData.JobID))

        return nil</span>
}

// scheduleConditionJob handles condition-based job scheduling
func (s *ConditionBasedScheduler) scheduleConditionJob(jobData *types.ScheduleConditionJobData, startTime time.Time) error <span class="cov0" title="0">{
        // Check if job is already scheduled
        if _, exists := s.conditionWorkers[jobData.JobID]; exists </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("duplicate_job_schedule")
                return fmt.Errorf("job %d is already scheduled", jobData.JobID)
        }</span>

        // Validate condition type
        <span class="cov0" title="0">if !isValidConditionType(jobData.ConditionWorkerData.ConditionType) </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("invalid_condition_type")
                return fmt.Errorf("unsupported condition type: %s", jobData.ConditionWorkerData.ConditionType)
        }</span>

        // Validate value source type
        <span class="cov0" title="0">if !isValidSourceType(jobData.ConditionWorkerData.ValueSourceType) </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("invalid_source_type")
                return fmt.Errorf("unsupported value source type: %s", jobData.ConditionWorkerData.ValueSourceType)
        }</span>

        // Create condition worker with Redis callback
        <span class="cov0" title="0">conditionWorker, err := s.createConditionWorker(&amp;jobData.ConditionWorkerData, s.HTTPClient)
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("worker_creation_failed")
                return fmt.Errorf("failed to create condition worker: %w", err)
        }</span>

        // Store worker and job data separately for Redis integration
        <span class="cov0" title="0">s.conditionWorkers[jobData.JobID] = conditionWorker
        s.jobDataStore[jobData.JobID.String()] = jobData

        // Start worker
        go conditionWorker.Start()

        duration := time.Since(startTime)

        // Track condition by type and source
        metrics.TrackConditionByType(jobData.ConditionWorkerData.ConditionType)
        metrics.TrackConditionBySource(jobData.ConditionWorkerData.ValueSourceType)

        s.logger.Info("Condition job monitoring started",
                "job_id", jobData.JobID,
                "condition_type", jobData.ConditionWorkerData.ConditionType,
                "value_source", jobData.ConditionWorkerData.ValueSourceUrl,
                "upper_limit", jobData.ConditionWorkerData.UpperLimit,
                "lower_limit", jobData.ConditionWorkerData.LowerLimit,
                "active_workers", len(s.eventWorkers)+len(s.conditionWorkers),
                "max_workers", s.maxWorkers,
                "duration", duration,
        )

        return nil</span>
}

// scheduleEventJob handles event-based job scheduling
func (s *ConditionBasedScheduler) scheduleEventJob(jobData *types.ScheduleConditionJobData, startTime time.Time) error <span class="cov0" title="0">{
        // Check if job is already scheduled
        if _, exists := s.eventWorkers[jobData.JobID]; exists </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("duplicate_job_schedule")
                return fmt.Errorf("job %d is already scheduled", jobData.JobID)
        }</span>

        // Check if chain client is available
        <span class="cov0" title="0">if _, exists := s.chainClients[jobData.EventWorkerData.TriggerChainID]; !exists </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("chain_client_not_found")
                return fmt.Errorf("chain client not found for chain %s", jobData.EventWorkerData.TriggerChainID)
        }</span>

        // Validate contract address
        <span class="cov0" title="0">if !common.IsHexAddress(jobData.EventWorkerData.TriggerContractAddress) </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("invalid_contract_address")
                return fmt.Errorf("invalid contract address: %s", jobData.EventWorkerData.TriggerContractAddress)
        }</span>

        // Create event worker with Redis callback
        <span class="cov0" title="0">eventWorker, err := s.createEventWorker(&amp;jobData.EventWorkerData, s.chainClients[jobData.EventWorkerData.TriggerChainID])
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("worker_creation_failed")
                return fmt.Errorf("failed to create event worker: %w", err)
        }</span>

        // Store worker and job data separately for Redis integration
        <span class="cov0" title="0">s.eventWorkers[jobData.JobID] = eventWorker
        s.jobDataStore[jobData.JobID.String()] = jobData

        // Start worker
        go eventWorker.Start()

        duration := time.Since(startTime)

        s.logger.Info("Event job monitoring started",
                "job_id", jobData.JobID,
                "trigger_chain", jobData.EventWorkerData.TriggerChainID,
                "contract", jobData.EventWorkerData.TriggerContractAddress,
                "event", jobData.EventWorkerData.TriggerEvent,
                "target_chain", jobData.TaskTargetData.TargetChainID,
                "target_contract", jobData.TaskTargetData.TargetContractAddress,
                "target_function", jobData.TaskTargetData.TargetFunction,
                "active_workers", len(s.eventWorkers)+len(s.conditionWorkers),
                "max_workers", s.maxWorkers,
                "duration", duration,
        )

        return nil</span>
}

// createConditionWorker creates a new condition worker instance
func (s *ConditionBasedScheduler) createConditionWorker(conditionWorkerData *types.ConditionWorkerData, httpClient *httppkg.HTTPClient) (*worker.ConditionWorker, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(s.ctx)

        worker := &amp;worker.ConditionWorker{
                ConditionWorkerData: conditionWorkerData,
                Logger:              s.logger,
                HttpClient:          httpClient,
                Ctx:                 ctx,
                Cancel:              cancel,
                IsActive:            false,
                LastCheckTimestamp:  time.Now(),
                TriggerCallback:     s.handleTriggerNotification,
                CleanupCallback:     s.cleanupJobData,
        }

        return worker, nil
}</span>

// createEventWorker creates a new event worker instance
func (s *ConditionBasedScheduler) createEventWorker(eventWorkerData *types.EventWorkerData, client *ethclient.Client) (*worker.EventWorker, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(s.ctx)

        // Get current block number
        currentBlock, err := client.BlockNumber(ctx)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to get current block number: %w", err)
        }</span>

        <span class="cov0" title="0">worker := &amp;worker.EventWorker{
                EventWorkerData: eventWorkerData,
                ChainClient:     client,
                Logger:          s.logger,
                Ctx:             ctx,
                Cancel:          cancel,
                LastBlock:       currentBlock,
                IsActive:        false,
                TriggerCallback: s.handleTriggerNotification,
                CleanupCallback: s.cleanupJobData,
        }

        return worker, nil</span>
}

// cleanupJobData removes job data from the scheduler's store when a worker stops
func (s *ConditionBasedScheduler) cleanupJobData(jobID *big.Int) error <span class="cov0" title="0">{
        s.notificationMutex.Lock()
        defer s.notificationMutex.Unlock()

        s.workersMutex.Lock()
        defer s.workersMutex.Unlock()

        // Remove job data from store
        delete(s.jobDataStore, jobID.String())

        s.logger.Debug("Cleaned up job data from store", "job_id", jobID)
        return nil
}</span>

// UnscheduleJob stops and removes a condition worker
func (s *ConditionBasedScheduler) UnscheduleJob(jobID *big.Int) error <span class="cov0" title="0">{
        s.notificationMutex.Lock()
        defer s.notificationMutex.Unlock()

        s.workersMutex.Lock()
        defer s.workersMutex.Unlock()

        // Try condition workers first
        if conditionWorker, exists := s.conditionWorkers[jobID]; exists </span><span class="cov0" title="0">{
                conditionWorker.Stop()
                delete(s.conditionWorkers, jobID)
                delete(s.jobDataStore, jobID.String()) // Clean up job data
        }</span> else<span class="cov0" title="0"> if eventWorker, exists := s.eventWorkers[jobID]; exists </span><span class="cov0" title="0">{
                eventWorker.Stop()
                delete(s.eventWorkers, jobID)
                delete(s.jobDataStore, jobID.String()) // Clean up job data
        }</span> else<span class="cov0" title="0"> {
                metrics.TrackCriticalError("job_not_found")
                return fmt.Errorf("job %d is not scheduled", jobID)
        }</span>

        // Update active workers count
        <span class="cov0" title="0">totalWorkers := len(s.conditionWorkers) + len(s.eventWorkers)
        metrics.UpdateActiveWorkers(totalWorkers)

        // Track job completion
        metrics.TrackJobCompleted("unscheduled")

        s.logger.Info("Job unscheduled successfully", "job_id", jobID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package scheduler

import (
        "fmt"
        "math/big"
)

// GetStats returns current scheduler statistics
func (s *ConditionBasedScheduler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        s.workersMutex.RLock()
        runningConditionWorkers := 0
        runningEventWorkers := 0

        // Create a slice of condition worker details
        conditionWorkerDetails := make([]map[string]interface{}, 0, len(s.conditionWorkers))
        for jobID, worker := range s.conditionWorkers </span><span class="cov0" title="0">{
                conditionWorkerDetails = append(conditionWorkerDetails, map[string]interface{}{
                        "job_id":              jobID,
                        "is_running":          worker.IsRunning(),
                        "condition_type":      worker.ConditionWorkerData.ConditionType,
                        "upper_limit":         worker.ConditionWorkerData.UpperLimit,
                        "lower_limit":         worker.ConditionWorkerData.LowerLimit,
                        "value_source_type":   worker.ConditionWorkerData.ValueSourceType,
                        "value_source_url":    worker.ConditionWorkerData.ValueSourceUrl,
                        "last_value":          worker.LastValue,
                        "last_check":          worker.LastCheckTimestamp,
                        "condition_met_count": worker.ConditionMet,
                        "recurring":           worker.ConditionWorkerData.Recurring,
                        "expiration_time":     worker.ConditionWorkerData.ExpirationTime,
                })
                if worker.IsRunning() </span><span class="cov0" title="0">{
                        runningConditionWorkers++
                }</span>
        }

        // Create a slice of event worker details
        <span class="cov0" title="0">eventWorkerDetails := make([]map[string]interface{}, 0, len(s.eventWorkers))
        for jobID, worker := range s.eventWorkers </span><span class="cov0" title="0">{
                eventWorkerDetails = append(eventWorkerDetails, map[string]interface{}{
                        "job_id":               jobID,
                        "is_running":           worker.IsRunning(),
                        "trigger_chain_id":     worker.EventWorkerData.TriggerChainID,
                        "trigger_contract":     worker.EventWorkerData.TriggerContractAddress,
                        "trigger_event":        worker.EventWorkerData.TriggerEvent,
                        "last_processed_block": worker.LastBlock,
                        "recurring":            worker.EventWorkerData.Recurring,
                        "expiration_time":      worker.EventWorkerData.ExpirationTime,
                })
                if worker.IsRunning() </span><span class="cov0" title="0">{
                        runningEventWorkers++
                }</span>
        }
        <span class="cov0" title="0">s.workersMutex.RUnlock()

        // Calculate total workers and active workers
        totalConditionWorkers := len(s.conditionWorkers)
        totalEventWorkers := len(s.eventWorkers)
        totalWorkers := totalConditionWorkers + totalEventWorkers
        activeWorkers := runningConditionWorkers + runningEventWorkers

        // Get connected chains information
        connectedChains := len(s.chainClients)
        chainIDs := make([]string, 0, connectedChains)
        for chainID := range s.chainClients </span><span class="cov0" title="0">{
                chainIDs = append(chainIDs, chainID)
        }</span>

        // Get performance metrics (using placeholder values since some metrics functions may not exist)
        <span class="cov0" title="0">var totalEvents, successfulEvents int64
        var avgProcessingTime float64
        var totalActions, successfulActions int64
        var workerCount int64

        // These may not exist yet, so we'll use safe defaults
        totalEvents = 0
        successfulEvents = 0
        avgProcessingTime = 0.0
        totalActions = 0
        successfulActions = 0
        workerCount = int64(totalWorkers)

        return map[string]interface{}{
                "scheduler_info": map[string]interface{}{
                        "max_workers":               s.maxWorkers,
                        "supported_chains":          []string{"11155420", "84532", "11155111"}, // OP Sepolia, Base Sepolia, Ethereum Sepolia
                },

                "worker_summary": map[string]interface{}{
                        "total_workers":             totalWorkers,
                        "active_workers":            activeWorkers,
                        "condition_workers":         totalConditionWorkers,
                        "event_workers":             totalEventWorkers,
                        "running_condition_workers": runningConditionWorkers,
                        "running_event_workers":     runningEventWorkers,
                },

                "chain_info": map[string]interface{}{
                        "connected_chains": connectedChains,
                        "chain_ids":        chainIDs,
                },

                "condition_workers": conditionWorkerDetails,
                "event_workers":     eventWorkerDetails,

                // Performance metrics
                "event_stats": map[string]interface{}{
                        "total_events":      totalEvents,
                        "successful_events": successfulEvents,
                        "failed_events":     totalEvents - successfulEvents,
                        "success_rate_percent": func() float64 </span><span class="cov0" title="0">{
                                if totalEvents &gt; 0 </span><span class="cov0" title="0">{
                                        return (float64(successfulEvents) / float64(totalEvents)) * 100
                                }</span>
                                <span class="cov0" title="0">return 0</span>
                        }(),
                        "average_processing_time_seconds": avgProcessingTime,
                },

                "action_stats": map[string]interface{}{
                        "total_actions":      totalActions,
                        "successful_actions": successfulActions,
                        "failed_actions":     totalActions - successfulActions,
                        "action_success_rate_percent": func() float64 <span class="cov0" title="0">{
                                if totalActions &gt; 0 </span><span class="cov0" title="0">{
                                        return (float64(successfulActions) / float64(totalActions)) * 100
                                }</span>
                                <span class="cov0" title="0">return 0</span>
                        }(),
                },

                "system_stats": map[string]interface{}{
                        "metric_tracked_workers": workerCount,
                        "uptime_tracked":         true,
                        "metrics_enabled":        true,
                },
        }
}

// GetConditionWorkerStats returns statistics for a specific condition worker
func (s *ConditionBasedScheduler) GetConditionWorkerStats(jobID *big.Int) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.workersMutex.RLock()
        defer s.workersMutex.RUnlock()

        worker, exists := s.conditionWorkers[jobID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("condition worker for job %d not found", jobID)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "job_id":              worker.ConditionWorkerData.JobID,
                "is_running":          worker.IsRunning(),
                "condition_type":      worker.ConditionWorkerData.ConditionType,
                "upper_limit":         worker.ConditionWorkerData.UpperLimit,
                "lower_limit":         worker.ConditionWorkerData.LowerLimit,
                "value_source_type":   worker.ConditionWorkerData.ValueSourceType,
                "value_source_url":    worker.ConditionWorkerData.ValueSourceUrl,
                "last_value":          worker.LastValue,
                "last_check":          worker.LastCheckTimestamp,
                "condition_met_count": worker.ConditionMet,
                "recurring":           worker.ConditionWorkerData.Recurring,
                "expiration_time":     worker.ConditionWorkerData.ExpirationTime,
        }, nil</span>
}

// GetEventWorkerStats returns statistics for a specific event worker
func (s *ConditionBasedScheduler) GetEventWorkerStats(jobID *big.Int) (map[string]interface{}, error) <span class="cov0" title="0">{
        s.workersMutex.RLock()
        defer s.workersMutex.RUnlock()

        worker, exists := s.eventWorkers[jobID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event worker for job %d not found", jobID)
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "job_id":               worker.EventWorkerData.JobID,
                "is_running":           worker.IsRunning(),
                "trigger_chain_id":     worker.EventWorkerData.TriggerChainID,
                "trigger_contract":     worker.EventWorkerData.TriggerContractAddress,
                "trigger_event":        worker.EventWorkerData.TriggerEvent,
                "last_processed_block": worker.LastBlock,
                "recurring":            worker.EventWorkerData.Recurring,
                "expiration_time":      worker.EventWorkerData.ExpirationTime,
        }, nil</span>
}

// GetAllWorkerStats returns statistics for all workers
func (s *ConditionBasedScheduler) GetAllWorkerStats() map[string]interface{} <span class="cov0" title="0">{
        s.workersMutex.RLock()
        defer s.workersMutex.RUnlock()

        conditionStats := make(map[string]interface{})
        eventStats := make(map[string]interface{})

        // Get condition worker stats
        for jobID, worker := range s.conditionWorkers </span><span class="cov0" title="0">{
                conditionStats[fmt.Sprintf("job_%d", jobID)] = map[string]interface{}{
                        "job_id":              worker.ConditionWorkerData.JobID,
                        "is_running":          worker.IsRunning(),
                        "condition_type":      worker.ConditionWorkerData.ConditionType,
                        "last_value":          worker.LastValue,
                        "condition_met_count": worker.ConditionMet,
                        "last_check":          worker.LastCheckTimestamp,
                }
        }</span>

        // Get event worker stats
        <span class="cov0" title="0">for jobID, worker := range s.eventWorkers </span><span class="cov0" title="0">{
                eventStats[fmt.Sprintf("job_%d", jobID)] = map[string]interface{}{
                        "job_id":               worker.EventWorkerData.JobID,
                        "is_running":           worker.IsRunning(),
                        "trigger_chain_id":     worker.EventWorkerData.TriggerChainID,
                        "last_processed_block": worker.LastBlock,
                }
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "condition_workers": conditionStats,
                "event_workers":     eventStats,
                "summary": map[string]interface{}{
                        "total_condition_workers": len(s.conditionWorkers),
                        "total_event_workers":     len(s.eventWorkers),
                        "total_workers":           len(s.conditionWorkers) + len(s.eventWorkers),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package scheduler

import (
        "fmt"

        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/config"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/scheduler/worker"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
)

// Helper functions
func isValidConditionType(conditionType string) bool <span class="cov0" title="0">{
        validTypes := []string{
                worker.ConditionGreaterThan, worker.ConditionLessThan, worker.ConditionBetween,
                worker.ConditionEquals, worker.ConditionNotEquals, worker.ConditionGreaterEqual, worker.ConditionLessEqual,
        }
        for _, valid := range validTypes </span><span class="cov0" title="0">{
                if conditionType == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isValidSourceType(sourceType string) bool <span class="cov0" title="0">{
        validTypes := []string{worker.SourceTypeAPI, worker.SourceTypeOracle, worker.SourceTypeStatic}
        for _, valid := range validTypes </span><span class="cov0" title="0">{
                if sourceType == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *ConditionBasedScheduler) initRetryClient() error <span class="cov0" title="0">{
        retryConfig := httppkg.DefaultHTTPRetryConfig()
        var err error
        s.HTTPClient, err = httppkg.NewHTTPClient(retryConfig, s.logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize retry client: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// initChainClients initializes blockchain clients for different chains
func (s *ConditionBasedScheduler) initChainClients() error <span class="cov0" title="0">{
        // Get chain RPC URLs from config
        chainRPCs := config.GetChainRPCUrls()

        for chainID, rpcURL := range chainRPCs </span><span class="cov0" title="0">{
                client, err := ethclient.Dial(rpcURL)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to connect to chain",
                                "chain_id", chainID,
                                "rpc_url", rpcURL,
                                "error", err,
                        )
                        continue</span>
                }

                <span class="cov0" title="0">s.chainClients[chainID] = client
                s.logger.Info("Connected to chain",
                        "chain_id", chainID,
                        "rpc_url", rpcURL,
                )</span>
        }

        <span class="cov0" title="0">if len(s.chainClients) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to any blockchain networks")
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file160" style="display: none">// init_condition.go
package worker

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// ConditionWorker represents an individual worker monitoring a specific condition
type ConditionWorker struct {
        ConditionWorkerData *types.ConditionWorkerData
        Logger          logging.Logger
        HttpClient      *httppkg.HTTPClient
        Ctx             context.Context
        Cancel          context.CancelFunc
        IsActive        bool
        Mutex           sync.RWMutex
        LastValue       float64
        LastCheckTimestamp time.Time
        ConditionMet       int64 // Count of consecutive condition met checks
        TriggerCallback    WorkerTriggerCallback
        CleanupCallback    WorkerCleanupCallback
}

// Start begins the condition worker's monitoring loop
func (w *ConditionWorker) Start() <span class="cov0" title="0">{
        startTime := time.Now()

        w.Mutex.Lock()
        w.IsActive = true
        w.Mutex.Unlock()

        metrics.TrackWorkerStart(fmt.Sprintf("%d", w.ConditionWorkerData.JobID))

        w.Logger.Info("Starting condition worker",
                "job_id", w.ConditionWorkerData.JobID,
                "condition_type", w.ConditionWorkerData.ConditionType,
                "value_source", w.ConditionWorkerData.ValueSourceUrl,
                "selected_key_route", w.ConditionWorkerData.SelectedKeyRoute,
                "upper_limit", w.ConditionWorkerData.UpperLimit,
                "lower_limit", w.ConditionWorkerData.LowerLimit,
                "expiration_time", w.ConditionWorkerData.ExpirationTime,
        )

        ticker := time.NewTicker(ConditionPollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.Ctx.Done():<span class="cov0" title="0">
                        stopTime := time.Now()
                        duration := stopTime.Sub(startTime)

                        w.Logger.Info("Condition worker stopped",
                                "job_id", w.ConditionWorkerData.JobID,
                                "runtime", duration,
                                "last_value", w.LastValue,
                                "condition_met_count", w.ConditionMet,
                        )
                        metrics.JobsCompleted.WithLabelValues("success").Inc()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Now().After(w.ConditionWorkerData.ExpirationTime) </span><span class="cov0" title="0">{
                                w.Logger.Info("Job has expired, stopping worker",
                                        "job_id", w.ConditionWorkerData.JobID,
                                        "expiration_time", w.ConditionWorkerData.ExpirationTime,
                                )
                                go w.Stop()
                                return
                        }</span>

                        <span class="cov0" title="0">if err := w.checkCondition(); err != nil </span><span class="cov0" title="0">{
                                w.Logger.Error("Error checking condition", 
                                        "job_id", w.ConditionWorkerData.JobID, 
                                        "error", err)
                                metrics.JobsCompleted.WithLabelValues("failed").Inc()
                        }</span>
                }
        }
}

// Stop gracefully stops the condition worker
func (w *ConditionWorker) Stop() <span class="cov0" title="0">{
        w.Mutex.Lock()
        defer w.Mutex.Unlock()

        if w.IsActive </span><span class="cov0" title="0">{
                w.Cancel()
                w.IsActive = false

                metrics.TrackWorkerStop(fmt.Sprintf("%d", w.ConditionWorkerData.JobID))

                if w.CleanupCallback != nil </span><span class="cov0" title="0">{
                        if err := w.CleanupCallback(w.ConditionWorkerData.JobID); err != nil </span><span class="cov0" title="0">{
                                w.Logger.Error("Failed to clean up job data",
                                        "job_id", w.ConditionWorkerData.JobID,
                                        "error", err)
                        }</span>
                }

                <span class="cov0" title="0">w.Logger.Info("Condition worker stopped", "job_id", w.ConditionWorkerData.JobID)</span>
        }
}

// IsRunning returns whether the worker is currently running
func (w *ConditionWorker) IsRunning() bool <span class="cov0" title="0">{
        w.Mutex.RLock()
        defer w.Mutex.RUnlock()
        return w.IsActive
}</pre>
		
		<pre class="file" id="file161" style="display: none">package worker

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// EventWorker monitors blockchain events for specific contracts
type EventWorker struct {
        EventWorkerData *types.EventWorkerData
        ChainClient     *ethclient.Client
        Logger          logging.Logger
        Ctx             context.Context
        Cancel          context.CancelFunc
        IsActive        bool
        Mutex           sync.RWMutex
        LastBlock       uint64
        LastBlockTimestamp time.Time
        TriggerCallback WorkerTriggerCallback // Callback to notify scheduler when event is detected
        CleanupCallback WorkerCleanupCallback // Callback to clean up job data when worker stops
}


// Start begins the event worker's monitoring loop
func (w *EventWorker) Start() <span class="cov0" title="0">{
        startTime := time.Now()

        w.Mutex.Lock()
        w.IsActive = true
        w.Mutex.Unlock()

        // Track worker start
        metrics.TrackWorkerStart(fmt.Sprintf("%d", w.EventWorkerData.JobID))

        // Get current block number
        currentBlock, err := w.ChainClient.BlockNumber(w.Ctx)
        if err != nil </span><span class="cov0" title="0">{
                w.Logger.Error("Failed to get current block number", "error", err)
                return
        }</span>
        <span class="cov0" title="0">w.LastBlock = currentBlock

        w.Logger.Info("Starting event worker",
                "job_id", w.EventWorkerData.JobID,
                "chain_id", w.EventWorkerData.TriggerChainID,
                "contract", w.EventWorkerData.TriggerContractAddress,
                "event", w.EventWorkerData.TriggerEvent,
                "current_block", currentBlock,
                "expiration_time", w.EventWorkerData.ExpirationTime,
        )

        contractAddr := common.HexToAddress(w.EventWorkerData.TriggerContractAddress)
        eventSig := crypto.Keccak256Hash([]byte(w.EventWorkerData.TriggerEvent))

        ticker := time.NewTicker(EventPollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.Ctx.Done():<span class="cov0" title="0">
                        stopTime := time.Now()
                        duration := stopTime.Sub(startTime)

                        w.Logger.Info("Event worker stopped",
                                "job_id", w.EventWorkerData.JobID,
                                "runtime", duration,
                                "final_block", w.LastBlock,
                        )
                        metrics.JobsCompleted.WithLabelValues("success").Inc()
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if job has expired
                        if time.Now().After(w.EventWorkerData.ExpirationTime) </span><span class="cov0" title="0">{
                                w.Logger.Info("Job has expired, stopping worker",
                                        "job_id", w.EventWorkerData.JobID,
                                        "expiration_time", w.EventWorkerData.ExpirationTime,
                                )
                                go w.Stop() // Stop in a goroutine to avoid deadlock
                                return
                        }</span>

                        <span class="cov0" title="0">if err := w.checkForEvents(contractAddr, eventSig); err != nil </span><span class="cov0" title="0">{
                                w.Logger.Error("Error checking for events", "job_id", w.EventWorkerData.JobID, "error", err)
                                metrics.JobsCompleted.WithLabelValues("failed").Inc()
                        }</span>
                }
        }
}

// Stop gracefully stops the event worker
func (w *EventWorker) Stop() <span class="cov0" title="0">{
        w.Mutex.Lock()
        defer w.Mutex.Unlock()

        if w.IsActive </span><span class="cov0" title="0">{
                w.Cancel()
                w.IsActive = false

                // Track worker stop
                metrics.TrackWorkerStop(fmt.Sprintf("%d", w.EventWorkerData.JobID))

                // Clean up job data from scheduler store
                if w.CleanupCallback != nil </span><span class="cov0" title="0">{
                        if err := w.CleanupCallback(w.EventWorkerData.JobID); err != nil </span><span class="cov0" title="0">{
                                w.Logger.Error("Failed to clean up job data",
                                        "job_id", w.EventWorkerData.JobID,
                                        "error", err)
                        }</span>
                }

                <span class="cov0" title="0">w.Logger.Info("Event worker stopped", "job_id", w.EventWorkerData.JobID)</span>
        }
}

// IsRunning returns whether the worker is currently running
func (w *EventWorker) IsRunning() bool <span class="cov0" title="0">{
        w.Mutex.RLock()
        defer w.Mutex.RUnlock()
        return w.IsActive
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">// monitor_condition.go
package worker

import (
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
)

// checkCondition fetches the current value and checks if condition is satisfied
func (w *ConditionWorker) checkCondition() error <span class="cov0" title="0">{
        startTime := time.Now()

        // Track condition check by source type
        metrics.TrackConditionBySource(w.ConditionWorkerData.ValueSourceType)

        // Fetch current value from source (with caching)
        currentValue, err := w.fetchValueWithCache()
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackValueParsingError(w.ConditionWorkerData.ValueSourceType)
                return fmt.Errorf("failed to fetch value: %w", err)
        }</span>

        <span class="cov0" title="0">w.LastValue = currentValue
        w.LastCheckTimestamp = time.Now()

        // Create condition check context for Redis streaming
        conditionContext := map[string]interface{}{
                "job_id":         w.ConditionWorkerData.JobID,
                "current_value":  currentValue,
                "condition_type": w.ConditionWorkerData.ConditionType,
                "upper_limit":    w.ConditionWorkerData.UpperLimit,
                "lower_limit":    w.ConditionWorkerData.LowerLimit,
                "checked_at":     startTime.Unix(),
        }

        // Check if condition is satisfied
        satisfied, err := w.evaluateCondition(currentValue)
        if err != nil </span><span class="cov0" title="0">{
                conditionContext["status"] = "evaluation_error"
                conditionContext["error"] = err.Error()
                metrics.TrackCriticalError("condition_evaluation")
                return fmt.Errorf("failed to evaluate condition: %w", err)
        }</span>

        // Track condition evaluation
        <span class="cov0" title="0">evaluationDuration := time.Since(startTime)
        metrics.TrackConditionEvaluation(evaluationDuration)

        // Track condition check with success status
        chainID := fmt.Sprintf("%d", w.ConditionWorkerData.JobID) // Using job_id as chain identifier for consistency
        metrics.TrackConditionCheck(chainID, evaluationDuration, satisfied)

        if satisfied </span><span class="cov0" title="0">{
                w.ConditionMet++
                metrics.TrackConditionByType(w.ConditionWorkerData.ConditionType)

                conditionContext["status"] = "satisfied"
                conditionContext["consecutive_checks"] = w.ConditionMet

                w.Logger.Info("Condition satisfied",
                        "job_id", w.ConditionWorkerData.JobID,
                        "current_value", currentValue,
                        "condition_type", w.ConditionWorkerData.ConditionType,
                        "upper_limit", w.ConditionWorkerData.UpperLimit,
                        "lower_limit", w.ConditionWorkerData.LowerLimit,
                        "consecutive_checks", w.ConditionMet,
                )

                // Notify scheduler about the trigger
                if w.TriggerCallback != nil </span><span class="cov0" title="0">{
                        notification := &amp;TriggerNotification{
                                JobID:        w.ConditionWorkerData.JobID,
                                TriggerValue: currentValue,
                                TriggeredAt:  time.Now(),
                        }

                        if err := w.TriggerCallback(notification); err != nil </span><span class="cov0" title="0">{
                                w.Logger.Error("Failed to notify scheduler about trigger",
                                        "job_id", w.ConditionWorkerData.JobID,
                                        "error", err,
                                )
                                metrics.TrackCriticalError("trigger_notification_failed")
                        }</span> else<span class="cov0" title="0"> {
                                w.Logger.Info("Successfully notified scheduler about trigger",
                                        "job_id", w.ConditionWorkerData.JobID,
                                        "trigger_value", currentValue,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        w.Logger.Warn("No trigger callback configured for worker",
                                "job_id", w.ConditionWorkerData.JobID,
                        )
                }</span>

                // For non-recurring jobs, stop the worker after triggering
                <span class="cov0" title="0">if !w.ConditionWorkerData.Recurring </span><span class="cov0" title="0">{
                        w.Logger.Info("Non-recurring job triggered, stopping worker", "job_id", w.ConditionWorkerData.JobID)
                        go w.Stop() // Stop in a goroutine to avoid deadlock
                }</span>

                <span class="cov0" title="0">duration := time.Since(startTime)
                conditionContext["duration_ms"] = duration.Milliseconds()
                conditionContext["completed_at"] = time.Now().Unix()
                conditionContext["action_status"] = "triggered"</span>
        } else<span class="cov0" title="0"> {
                w.ConditionMet = 0
                conditionContext["status"] = "not_satisfied"

                w.Logger.Debug("Condition not satisfied",
                        "job_id", w.ConditionWorkerData.JobID,
                        "current_value", currentValue,
                        "condition_type", w.ConditionWorkerData.ConditionType,
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// fetchValueWithCache retrieves the current value with caching support
func (w *ConditionWorker) fetchValueWithCache() (float64, error) <span class="cov0" title="0">{
        // Fetch fresh value
        currentValue, err := w.fetchValue()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return currentValue, nil</span>
}

// fetchValue retrieves the current value from the configured source
func (w *ConditionWorker) fetchValue() (float64, error) <span class="cov0" title="0">{
        switch w.ConditionWorkerData.ValueSourceType </span>{
        case SourceTypeAPI:<span class="cov0" title="0">
                return w.fetchFromAPI()</span>
        case SourceTypeOracle:<span class="cov0" title="0">
                return w.fetchFromOracle()</span>
        case SourceTypeStatic:<span class="cov0" title="0">
                return w.fetchStaticValue()</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported value source type: %s", w.ConditionWorkerData.ValueSourceType)</span>
        }
}

// isTimeoutError checks if an error is a timeout error
func isTimeoutError(err error) bool <span class="cov0" title="0">{
        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return strings.Contains(err.Error(), "timeout") ||
                strings.Contains(err.Error(), "deadline exceeded")</span>
}

// extractValueFromResponse extracts the numeric value from the response
func (w *ConditionWorker) extractValueFromResponse(body []byte) (float64, error) <span class="cov0" title="0">{
        // If key path is specified, use it to extract the value
        if w.ConditionWorkerData.SelectedKeyRoute != "" </span><span class="cov0" title="0">{
                value, err := w.extractValueByKeyPath(body, w.ConditionWorkerData.SelectedKeyRoute)
                if err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        // Try to parse response as ValueResponse struct
        <span class="cov0" title="0">var valueResp ValueResponse
        if err := json.Unmarshal(body, &amp;valueResp); err == nil </span><span class="cov0" title="0">{
                // If key path is specified in response, use it
                if valueResp.SelectedKeyRoute != "" </span><span class="cov0" title="0">{
                        return w.extractValueByKeyPath(body, w.ConditionWorkerData.SelectedKeyRoute)
                }</span>

                // Otherwise, use the original fallback logic
                <span class="cov0" title="0">if valueResp.Value != 0 </span><span class="cov0" title="0">{
                        return valueResp.Value, nil
                }</span>
                <span class="cov0" title="0">if valueResp.Price != 0 </span><span class="cov0" title="0">{
                        return valueResp.Price, nil
                }</span>
                <span class="cov0" title="0">if valueResp.USD != 0 </span><span class="cov0" title="0">{
                        return valueResp.USD, nil
                }</span>
                <span class="cov0" title="0">if valueResp.Rate != 0 </span><span class="cov0" title="0">{
                        return valueResp.Rate, nil
                }</span>
                <span class="cov0" title="0">if valueResp.Result != 0 </span><span class="cov0" title="0">{
                        return valueResp.Result, nil
                }</span>
                <span class="cov0" title="0">if valueResp.Data != 0 </span><span class="cov0" title="0">{
                        return valueResp.Data, nil
                }</span>
        }

        // If no key is specified or ValueResponse parsing failed, try other parsing methods
        <span class="cov0" title="0">return w.parseDirectValue(body)</span>
}

// extractValueByKeyPath extracts a value from JSON response using dot notation path
func (w *ConditionWorker) extractValueByKeyPath(body []byte, keyPath string) (float64, error) <span class="cov0" title="0">{
        var jsonData interface{}
        if err := json.Unmarshal(body, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse JSON response: %w", err)
        }</span>

        <span class="cov0" title="0">keys := strings.Split(keyPath, ".")
        var current = jsonData

        for _, k := range keys </span><span class="cov0" title="0">{
                switch v := current.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        if val, exists := v[k]; exists </span><span class="cov0" title="0">{
                                current = val
                        }</span> else<span class="cov0" title="0"> {
                                return 0, fmt.Errorf("key '%s' not found in response", k)
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        // Handle array indices
                        if idx, err := strconv.Atoi(k); err == nil &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; len(v) </span><span class="cov0" title="0">{
                                current = v[idx]
                        }</span> else<span class="cov0" title="0"> {
                                return 0, fmt.Errorf("invalid array index '%s'", k)
                        }</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("cannot navigate to key '%s': intermediate value is not an object or array", k)</span>
                }
        }

        <span class="cov0" title="0">return w.convertToFloat64(current)</span>
}

// convertToFloat64 converts various types to float64
func (w *ConditionWorker) convertToFloat64(value interface{}) (float64, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case string:<span class="cov0" title="0">
                if floatVal, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                        return floatVal, nil
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("cannot convert string '%s' to float64", v)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert value of type %s to float64", reflect.TypeOf(value))</span>
        }
}

// parseDirectValue tries to parse the response as direct numeric values
func (w *ConditionWorker) parseDirectValue(body []byte) (float64, error) <span class="cov0" title="0">{
        // Try to parse as a simple float
        var floatValue float64
        if err := json.Unmarshal(body, &amp;floatValue); err == nil </span><span class="cov0" title="0">{
                return floatValue, nil
        }</span>

        // Try to parse as a simple string and convert to float
        <span class="cov0" title="0">var stringValue string
        if err := json.Unmarshal(body, &amp;stringValue); err == nil </span><span class="cov0" title="0">{
                if floatVal, parseErr := strconv.ParseFloat(stringValue, 64); parseErr == nil </span><span class="cov0" title="0">{
                        return floatVal, nil
                }</span>
        }

        // Try to parse as a generic JSON object and look for common patterns
        // var jsonObj map[string]interface{}
        // if err := json.Unmarshal(body, &amp;jsonObj); err == nil {
        //         // Look for common nested patterns like {"ethereum":{"usd":3620.84}}
        //         for _, value := range jsonObj {
        //                 if nestedObj, ok := value.(map[string]interface{}); ok {
        //                         // Check for common price fields in nested objects
        //                         for fieldName, fieldValue := range nestedObj {
        //                                 if fieldName == "usd" || fieldName == "price" || fieldName == "value" || fieldName == "rate" {
        //                                         if floatVal, err := w.convertToFloat64(fieldValue); err == nil {
        //                                                 return floatVal, nil
        //                                         }
        //                                 }
        //                         }
        //                 }
        //         }
        // }

        <span class="cov0" title="0">return 0, fmt.Errorf("could not extract numeric value from response: %s", string(body))</span>
}

// fetchFromAPI fetches value from an HTTP API endpoint
func (w *ConditionWorker) fetchFromAPI() (float64, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", w.ConditionWorkerData.ValueSourceUrl, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := w.HttpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackHTTPRequest("GET", w.ConditionWorkerData.ValueSourceUrl, "error")
                metrics.TrackHTTPClientConnectionError()

                if isTimeoutError(err) </span><span class="cov0" title="0">{
                        metrics.TrackTimeout("http_api_request")
                }</span>

                <span class="cov0" title="0">return 0, fmt.Errorf("HTTP request failed: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        w.Logger.Errorf("Error closing response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">statusCode := strconv.Itoa(resp.StatusCode)
        metrics.TrackHTTPRequest("GET", w.ConditionWorkerData.ValueSourceUrl, statusCode)
        metrics.TrackAPIResponse(w.ConditionWorkerData.ValueSourceUrl, statusCode)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("HTTP request failed with status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackHTTPRequest("GET", w.ConditionWorkerData.ValueSourceUrl, "read_error")
                return 0, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">value, err := w.extractValueFromResponse(body)
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackInvalidValue(w.ConditionWorkerData.ValueSourceUrl)
                metrics.TrackValueParsingError(w.ConditionWorkerData.ValueSourceType)
                return 0, err
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

// fetchFromOracle fetches value from an oracle (placeholder implementation)
func (w *ConditionWorker) fetchFromOracle() (float64, error) <span class="cov0" title="0">{
        // TODO: Implement oracle-specific logic
        // For now, treat as API endpoint
        return w.fetchFromAPI()
}</span>

// fetchStaticValue returns a static value (for testing purposes)
func (w *ConditionWorker) fetchStaticValue() (float64, error) <span class="cov0" title="0">{
        value, err := strconv.ParseFloat(w.ConditionWorkerData.ValueSourceUrl, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid static value: %s", w.ConditionWorkerData.ValueSourceUrl)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// evaluateCondition checks if the current value satisfies the condition
func (w *ConditionWorker) evaluateCondition(currentValue float64) (bool, error) <span class="cov0" title="0">{
        switch w.ConditionWorkerData.ConditionType </span>{
        case ConditionGreaterThan:<span class="cov0" title="0">
                return currentValue &gt; w.ConditionWorkerData.LowerLimit, nil</span>
        case ConditionLessThan:<span class="cov0" title="0">
                return currentValue &lt; w.ConditionWorkerData.UpperLimit, nil</span>
        case ConditionBetween:<span class="cov0" title="0">
                return currentValue &gt;= w.ConditionWorkerData.LowerLimit &amp;&amp; currentValue &lt;= w.ConditionWorkerData.UpperLimit, nil</span>
        case ConditionEquals:<span class="cov0" title="0">
                return currentValue == w.ConditionWorkerData.LowerLimit, nil</span>
        case ConditionNotEquals:<span class="cov0" title="0">
                return currentValue != w.ConditionWorkerData.LowerLimit, nil</span>
        case ConditionGreaterEqual:<span class="cov0" title="0">
                return currentValue &gt;= w.ConditionWorkerData.LowerLimit, nil</span>
        case ConditionLessEqual:<span class="cov0" title="0">
                return currentValue &lt;= w.ConditionWorkerData.UpperLimit, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported condition type: %s", w.ConditionWorkerData.ConditionType)</span>
        }
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package worker

import (
        "context"
        "fmt"
        "math/big"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/condition/metrics"
)

// checkForEvents checks for new events since the last processed block
func (w *EventWorker) checkForEvents(contractAddr common.Address, eventSig common.Hash) error <span class="cov0" title="0">{
        // Get current block number
        currentBlock, err := w.ChainClient.BlockNumber(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("rpc_block_number_failed")
                return fmt.Errorf("failed to get current block number: %w", err)
        }</span>

        // Check if there are new blocks to process
        <span class="cov0" title="0">if currentBlock &lt;= w.LastBlock </span><span class="cov0" title="0">{
                return nil // No new blocks to process
        }</span>

        // Query logs for events
        <span class="cov0" title="0">query := ethereum.FilterQuery{
                FromBlock: new(big.Int).SetUint64(w.LastBlock + 1),
                ToBlock:   new(big.Int).SetUint64(currentBlock),
                Addresses: []common.Address{contractAddr},
                Topics:    [][]common.Hash{{eventSig}},
        }

        logs, err := w.ChainClient.FilterLogs(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                metrics.TrackCriticalError("rpc_filter_logs_failed")
                return fmt.Errorf("failed to filter logs: %w", err)
        }</span>

        // Process each event
        <span class="cov0" title="0">for _, log := range logs </span><span class="cov0" title="0">{
                if err := w.processEvent(log); err != nil </span><span class="cov0" title="0">{
                        w.Logger.Error("Failed to process event",
                                "job_id", w.EventWorkerData.JobID,
                                "tx_hash", log.TxHash.Hex(),
                                "block", log.BlockNumber,
                                "error", err,
                        )
                        metrics.TrackCriticalError("event_processing_failed")
                }</span>
        }

        // Update last processed block
        <span class="cov0" title="0">w.LastBlock = currentBlock

        w.Logger.Debug("Processed blocks",
                "job_id", w.EventWorkerData.JobID,
                "from_block", w.LastBlock+1-uint64(len(logs)),
                "to_block", currentBlock,
                "events_found", len(logs),
        )

        return nil</span>
}

// processEvent processes a single event and notifies the scheduler
func (w *EventWorker) processEvent(log types.Log) error <span class="cov0" title="0">{
        w.Logger.Info("Event detected",
                "job_id", w.EventWorkerData.JobID,
                "tx_hash", log.TxHash.Hex(),
                "block", log.BlockNumber,
                "log_index", log.Index,
                "chain_id", w.EventWorkerData.TriggerChainID,
                "event", w.EventWorkerData.TriggerEvent,
        )

        // Notify scheduler about the event
        if w.TriggerCallback != nil </span><span class="cov0" title="0">{
                notification := &amp;TriggerNotification{
                        JobID:       w.EventWorkerData.JobID,
                        TriggerTxHash:   log.TxHash.Hex(),
                        TriggeredAt: time.Now(),
                }

                if err := w.TriggerCallback(notification); err != nil </span><span class="cov0" title="0">{
                        w.Logger.Error("Failed to notify scheduler about event",
                                "job_id", w.EventWorkerData.JobID,
                                "tx_hash", log.TxHash.Hex(),
                                "error", err,
                        )
                        metrics.TrackCriticalError("event_notification_failed")
                        return err
                }</span> else<span class="cov0" title="0"> {
                        w.Logger.Info("Successfully notified scheduler about event",
                                "job_id", w.EventWorkerData.JobID,
                                "tx_hash", log.TxHash.Hex(),
                        )
                }</span>
        } else<span class="cov0" title="0"> {
                w.Logger.Warn("No trigger callback configured for event worker",
                        "job_id", w.EventWorkerData.JobID,
                )
        }</span>

        // For non-recurring jobs, stop the worker after triggering
        <span class="cov0" title="0">if !w.EventWorkerData.Recurring </span><span class="cov0" title="0">{
                w.Logger.Info("Non-recurring job triggered, stopping worker", "job_id", w.EventWorkerData.JobID)
                go w.Stop() // Stop in a goroutine to avoid deadlock
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// MetricsHandler handles metrics endpoint requests
type MetricsHandler struct {
        logger logging.Logger
}

// NewMetricsHandler creates a new metrics handler
func NewMetricsHandler(logger logging.Logger) *MetricsHandler <span class="cov0" title="0">{
        return &amp;MetricsHandler{
                logger: logger,
        }
}</span>

// Metrics exposes Prometheus metrics
func (h *MetricsHandler) Metrics(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[Metrics] trace_id=" + traceID + " - Serving metrics")
        promhttp.Handler().ServeHTTP(c.Writer, c.Request)
}</span>
</pre>
		
		<pre class="file" id="file165" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type SchedulerHandler struct {
        logger    logging.Logger
        scheduler *scheduler.TimeBasedScheduler
}

func NewSchedulerHandler(logger logging.Logger, scheduler *scheduler.TimeBasedScheduler) *SchedulerHandler <span class="cov0" title="0">{
        return &amp;SchedulerHandler{
                logger:    logger,
                scheduler: scheduler,
        }
}</span>

// getTraceID retrieves the trace ID from the Gin context
func getTraceID(c *gin.Context) string <span class="cov0" title="0">{
        traceID, exists := c.Get("trace_id")
        if !exists </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return traceID.(string)</span>
}

// GetStats returns current scheduler statistics
func (h *SchedulerHandler) GetStats(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[GetStats] trace_id=" + traceID + " - Getting scheduler statistics")
        stats := h.scheduler.GetStats()

        response := gin.H{
                "status":    "success",
                "data":      stats,
                "timestamp": time.Now().UTC(),
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// StatusHandler handles status endpoint requests
type StatusHandler struct {
        logger logging.Logger
}

// NewStatusHandler creates a new status handler
func NewStatusHandler(logger logging.Logger) *StatusHandler <span class="cov0" title="0">{
        return &amp;StatusHandler{
                logger: logger,
        }
}</span>

// Status handles status endpoint requests
func (h *StatusHandler) Status(c *gin.Context) <span class="cov0" title="0">{
        traceID := getTraceID(c)
        h.logger.Info("[Status] trace_id=" + traceID + " - Checking service health")
        response := gin.H{
                "status":    "healthy",
                "service":   "condition-scheduler",
                "timestamp": time.Now().UTC(),
                "uptime":    time.Since(time.Now()).String(), // This would be calculated from startup time
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">package api

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "go.opentelemetry.io/otel"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

const TraceIDHeader = "X-Trace-ID"
const TraceIDKey = "trace_id"

// TraceMiddleware adds trace ID to requests and starts an OpenTelemetry span
func TraceMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tracer := otel.Tracer("triggerx-backend")
                ctx, span := tracer.Start(c.Request.Context(), c.Request.URL.Path)
                defer span.End()

                span.SetAttributes(
                        semconv.HTTPMethodKey.String(c.Request.Method),
                        semconv.HTTPURLKey.String(c.Request.URL.String()),
                        semconv.HTTPUserAgentKey.String(c.Request.UserAgent()),
                )

                traceID := c.GetHeader(TraceIDHeader)
                if traceID == "" </span><span class="cov0" title="0">{
                        spanContext := span.SpanContext()
                        if spanContext.HasTraceID() </span><span class="cov0" title="0">{
                                traceID = spanContext.TraceID().String()
                        }</span> else<span class="cov0" title="0"> {
                                traceID = uuid.New().String()
                        }</span>
                }

                <span class="cov0" title="0">c.Set(TraceIDKey, traceID)
                c.Header(TraceIDHeader, traceID)
                c.Request = c.Request.WithContext(ctx)
                c.Next()
                span.SetAttributes(semconv.HTTPStatusCodeKey.Int(c.Writer.Status()))</span>
        }
}

// MetricsMiddleware collects HTTP request and system metrics
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Process request
                c.Next()

                // Collect HTTP metrics
                statusCode := strconv.Itoa(c.Writer.Status())
                method := c.Request.Method
                endpoint := c.Request.URL.Path

                metrics.TrackHTTPRequest(method, endpoint, statusCode)
        }</span>
}

// LoggerMiddleware creates a gin middleware for logging API group requests only
func LoggerMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Only log requests under the /api/ path
                if len(c.Request.URL.Path) &lt; 5 || c.Request.URL.Path[:5] != "/api/" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">startTime := time.Now()
                path := c.Request.URL.Path
                rawQuery := c.Request.URL.RawQuery
                traceID, _ := c.Get(TraceIDKey)

                // Process request
                c.Next()

                duration := time.Since(startTime)
                statusCode := c.Writer.Status()

                logger.Info("Request processed",
                        "trace_id", traceID,
                        "status", statusCode,
                        "method", c.Request.Method,
                        "path", path,
                        "query", rawQuery,
                        "ip", c.ClientIP(),
                        "latency", duration,
                        "user-agent", c.Request.UserAgent(),
                )</span>
        }
}

// ErrorMiddleware handles errors in a consistent way
func ErrorMiddleware(logger logging.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                // Check if there are any errors
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        // Get the last error
                        err := c.Errors.Last()
                        traceID, _ := c.Get(TraceIDKey)

                        logger.Error("Error",
                                "trace_id", traceID,
                                "error", err.Error(),
                                "path", c.Request.URL.Path,
                        )

                        // If the response hasn't been written yet
                        if !c.Writer.Written() </span><span class="cov0" title="0">{
                                c.JSON(c.Writer.Status(), gin.H{
                                        "error":    err.Error(),
                                        "trace_id": traceID,
                                })
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"

        "os"

        "github.com/gin-gonic/gin"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/api/handlers"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/scheduler"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        gootel "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

// Server represents the API server
type Server struct {
        router     *gin.Engine
        httpServer *http.Server
        logger     logging.Logger
}

// Config holds the server configuration
type Config struct {
        Port string
}

// Dependencies holds the server dependencies
type Dependencies struct {
        Logger    logging.Logger
        Scheduler *scheduler.TimeBasedScheduler
}

// NewServer creates a new API server
func NewServer(cfg Config, deps Dependencies) *Server <span class="cov0" title="0">{
        gin.SetMode(gin.ReleaseMode)
        router := gin.New()

        // Initialize OpenTelemetry tracer
        _, err := InitTracer()
        if err != nil </span><span class="cov0" title="0">{
                deps.Logger.Error("Failed to initialize OpenTelemetry tracer", "error", err)
        }</span>

        // Create server instance
        <span class="cov0" title="0">srv := &amp;Server{
                router: router,
                logger: deps.Logger,
                httpServer: &amp;http.Server{
                        Addr:    fmt.Sprintf(":%s", cfg.Port),
                        Handler: router,
                },
        }

        // Setup middleware
        srv.setupMiddleware(deps)

        // Setup routes
        srv.setupRoutes(deps)

        return srv</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        s.logger.Info("Starting API server", "addr", s.httpServer.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info("Stopping API server")
        return s.httpServer.Shutdown(ctx)
}</span>

// setupMiddleware sets up the middleware for the server
func (s *Server) setupMiddleware(deps Dependencies) <span class="cov0" title="0">{
        s.router.Use(gin.Recovery())
        s.router.Use(TraceMiddleware())
        s.router.Use(MetricsMiddleware())
        s.router.Use(LoggerMiddleware(deps.Logger))
        s.router.Use(ErrorMiddleware(deps.Logger))
}</span>

// setupRoutes sets up the routes for the server
func (s *Server) setupRoutes(deps Dependencies) <span class="cov0" title="0">{
        // Create handlers
        statusHandler := handlers.NewStatusHandler(deps.Logger)
        metricsHandler := handlers.NewMetricsHandler(deps.Logger)
        schedulerHandler := handlers.NewSchedulerHandler(deps.Logger, deps.Scheduler)

        // Health and monitoring endpoints
        s.router.GET("/status", statusHandler.Status)
        s.router.GET("/metrics", metricsHandler.Metrics)

        // Scheduler management endpoints
        api := s.router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                api.GET("/scheduler/stats", schedulerHandler.GetStats)
        }</span>
}

// InitTracer sets up OpenTelemetry tracing with OTLP exporter for Tempo
// Set TEMPO_OTLP_ENDPOINT env var to override the default (localhost:4318)
func InitTracer() (func(context.Context) error, error) <span class="cov0" title="0">{
        endpoint := os.Getenv("TEMPO_OTLP_ENDPOINT")
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "localhost:4318" // default to local Tempo
        }</span>
        <span class="cov0" title="0">exporter, err := otlptracehttp.New(context.Background(),
                otlptracehttp.WithEndpoint(endpoint),
                otlptracehttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tp := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String("triggerx-scheduler-time"),
                )),
        )
        gootel.SetTracerProvider(tp)
        return tp.Shutdown, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"

        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Scheduler RPC Port
        timeSchedulerRPCPort string

        // Database RPC URL
        dbServerURL string
        // Aggregator RPC URL
        aggregatorRPCUrl string
        // Task Dispatcher RPC URL (renamed from Redis API URL)
        taskDispatcherRPCUrl string

        // Scheduler ID
        timeSchedulerID int

        // Time Durations
        pollingInterval     time.Duration
        pollingLookAhead    time.Duration
        taskBatchSize       int
        performerLockTTL    time.Duration
        taskCacheTTL        time.Duration
        duplicateTaskWindow time.Duration
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:              env.GetEnvBool("DEV_MODE", false),
                timeSchedulerRPCPort: env.GetEnvString("TIME_SCHEDULER_RPC_PORT", "9005"),
                taskDispatcherRPCUrl: env.GetEnvString("TASK_DISPATCHER_RPC_URL", "localhost:9003"),
                dbServerURL:          env.GetEnvString("DBSERVER_RPC_URL", "http://localhost:9002"),
                aggregatorRPCUrl:     env.GetEnvString("AGGREGATOR_RPC_URL", "http://localhost:9001"),
                pollingInterval:      env.GetEnvDuration("TIME_SCHEDULER_POLLING_INTERVAL", 30*time.Second),
                pollingLookAhead:     env.GetEnvDuration("TIME_SCHEDULER_POLLING_LOOKAHEAD", 40*time.Minute),
                taskBatchSize:        env.GetEnvInt("TIME_SCHEDULER_TASK_BATCH_SIZE", 15),
                performerLockTTL:     env.GetEnvDuration("TIME_SCHEDULER_PERFORMER_LOCK_TTL", 31*time.Second),
                taskCacheTTL:         env.GetEnvDuration("TIME_SCHEDULER_TASK_CACHE_TTL", 1*time.Minute),
                duplicateTaskWindow:  env.GetEnvDuration("TIME_SCHEDULER_DUPLICATE_TASK_WINDOW", 1*time.Minute),
        }
        if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateConfig() error <span class="cov0" title="0">{
        if !env.IsValidPort(cfg.timeSchedulerRPCPort) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid time scheduler RPC port: %s", cfg.timeSchedulerRPCPort)
        }</span>
        <span class="cov0" title="0">if !env.IsValidURL(cfg.dbServerURL) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database server URL: %s", cfg.dbServerURL)
        }</span>
        <span class="cov0" title="0">if !env.IsValidURL(cfg.aggregatorRPCUrl) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid aggregator RPC URL: %s", cfg.aggregatorRPCUrl)
        }</span>
        // Note: taskDispatcherRPCUrl is a gRPC endpoint (host:port format), not an HTTP URL
        // so we don't validate it as a URL
        <span class="cov0" title="0">return nil</span>
}

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetSchedulerRPCPort() string <span class="cov0" title="0">{
        return cfg.timeSchedulerRPCPort
}</span>

func GetDBServerURL() string <span class="cov0" title="0">{
        return cfg.dbServerURL
}</span>

func GetAggregatorRPCUrl() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCUrl
}</span>

func GetTaskDispatcherRPCUrl() string <span class="cov0" title="0">{
        return cfg.taskDispatcherRPCUrl
}</span>

func GetSchedulerID() int <span class="cov0" title="0">{
        return cfg.timeSchedulerID
}</span>

func GetPollingInterval() time.Duration <span class="cov0" title="0">{
        return cfg.pollingInterval
}</span>

func GetPollingLookAhead() time.Duration <span class="cov0" title="0">{
        return cfg.pollingLookAhead
}</span>

func GetTaskBatchSize() int <span class="cov0" title="0">{
        return cfg.taskBatchSize
}</span>

func GetPerformerLockTTL() time.Duration <span class="cov0" title="0">{
        return cfg.performerLockTTL
}</span>

func GetTaskCacheTTL() time.Duration <span class="cov0" title="0">{
        return cfg.taskCacheTTL
}</span>

func GetDuplicateTaskWindow() time.Duration <span class="cov0" title="0">{
        return cfg.duplicateTaskWindow
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">package metrics

import (
        "runtime"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/config"
)

// Collects system resource metrics
func collectSystemMetrics() <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        // Update memory usage (current allocated bytes)
        MemoryUsageBytes.Set(float64(memStats.Alloc))

        // Update CPU usage (using system memory as a proxy)
        cpuPercent, err := cpu.Percent(0, false)
        if err == nil &amp;&amp; len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                CPUUsagePercent.Set(cpuPercent[0])
        }</span> else<span class="cov0" title="0"> {
                // Fallback to 0.0 if CPU monitoring fails
                CPUUsagePercent.Set(0.0)
        }</span>

        // Update active goroutines count
        <span class="cov0" title="0">GoroutinesActive.Set(float64(runtime.NumGoroutine()))

        // Update garbage collection duration (total pause time in seconds)
        GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)</span>
}

// Collects configuration-based metrics
func collectConfigurationMetrics() <span class="cov0" title="0">{
        // Set job batch size from configuration
        TaskBatchSize.Set(float64(getTaskBatchSize()))

        // Set duplicate task window from configuration
        DuplicateTaskWindowSeconds.Set(getDuplicateTaskWindowSeconds())
}</span>

// Collects performance-related metrics
func collectPerformanceMetrics() <span class="cov0" title="0">{
        taskStatsLock.RLock()
        defer taskStatsLock.RUnlock()

        // Update tasks per minute
        if time.Since(lastMinuteReset) &gt;= time.Minute </span><span class="cov0" title="0">{
                TasksPerMinute.Set(float64(tasksLastMinute))
                // Reset for next minute in a separate goroutine to avoid blocking
                go func() </span><span class="cov0" title="0">{
                        taskStatsLock.Lock()
                        tasksLastMinute = 0
                        lastMinuteReset = time.Now()
                        taskStatsLock.Unlock()
                }</span>()
        }

        // Calculate success rate
        <span class="cov0" title="0">if totalTasks &gt; 0 </span><span class="cov0" title="0">{
                successRate := (float64(successfulTasks) / float64(totalTasks)) * 100
                TaskSuccessRatePercent.Set(successRate)
        }</span>

        // Calculate average task completion time
        <span class="cov0" title="0">if len(taskCompletionTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, duration := range taskCompletionTimes </span><span class="cov0" title="0">{
                        sum += duration
                }</span>
                <span class="cov0" title="0">avgTime := sum / float64(len(taskCompletionTimes))
                AverageTaskCompletionTimeSeconds.Set(avgTime)</span>
        }
}

// Resets metrics that should be reset daily
func resetDailyMetrics() <span class="cov0" title="0">{
        taskStatsLock.Lock()
        defer taskStatsLock.Unlock()

        // Reset daily counters
        TasksPerMinute.Set(0)
        TaskSuccessRatePercent.Set(0)
        AverageTaskCompletionTimeSeconds.Set(0)

        // Reset tracking variables
        taskCompletionTimes = nil
        successfulTasks = 0
        totalTasks = 0
        tasksLastMinute = 0
        lastMinuteReset = time.Now()
}</span>

// Helper functions to get configuration values
func getTaskBatchSize() int <span class="cov0" title="0">{
        return config.GetTaskBatchSize()
}</span>

func getDuplicateTaskWindowSeconds() float64 <span class="cov0" title="0">{
        return config.GetDuplicateTaskWindow().Seconds()
}</span>

// HTTP Middleware and tracking functions

// TrackHTTPRequest tracks HTTP request metrics
func TrackHTTPRequest(method, endpoint, statusCode string) <span class="cov0" title="0">{
        HTTPRequestsTotal.WithLabelValues(method, endpoint, statusCode).Inc()
}</span>

// TrackDBRequest tracks database request metrics
func TrackDBRequest(method, endpoint, status string) <span class="cov0" title="0">{
        DBRequestsTotal.WithLabelValues(method, endpoint, status).Inc()
}</span>

// TrackDBConnectionError tracks database connection errors
func TrackDBConnectionError() <span class="cov0" title="0">{
        DBConnectionErrorsTotal.Inc()
}</span>

// TrackDBRetry tracks database retry attempts
func TrackDBRetry(endpoint string) <span class="cov0" title="0">{
        DBRetriesTotal.WithLabelValues(endpoint).Inc()
}</span>

// TrackTaskBroadcast tracks task broadcasts to performers
func TrackTaskBroadcast(status string) <span class="cov0" title="0">{
        TaskBroadcastsTotal.WithLabelValues(status).Inc()
}</span>

// TrackTaskByScheduleType tracks tasks by their schedule type
func TrackTaskByScheduleType(scheduleType string) <span class="cov0" title="0">{
        TasksByScheduleTypeTotal.WithLabelValues(scheduleType).Inc()
}</span>

// TrackTaskExpired tracks expired tasks
func TrackTaskExpired() <span class="cov0" title="0">{
        TasksExpiredTotal.Inc()
}</span>

// UpdateTasksPerMinute updates the tasks per minute metric
func UpdateTasksPerMinute(count float64) <span class="cov0" title="0">{
        TasksPerMinute.Set(count)
}</span>

// UpdateAverageTaskCompletionTime updates the average task completion time
func UpdateAverageTaskCompletionTime(seconds float64) <span class="cov0" title="0">{
        AverageTaskCompletionTimeSeconds.Set(seconds)
}</span>

// UpdateTaskSuccessRate updates the task success rate percentage
func UpdateTaskSuccessRate(percentage float64) <span class="cov0" title="0">{
        TaskSuccessRatePercent.Set(percentage)
}</span>

// TrackTaskExecution tracks task execution with timing (use this when a task starts executing)
func TrackTaskExecution(duration float64, success bool) <span class="cov0" title="0">{
        taskStatsLock.Lock()
        defer taskStatsLock.Unlock()

        // Update total task count
        totalTasks++
        tasksLastMinute++

        // Track success/failure
        if success </span><span class="cov0" title="0">{
                successfulTasks++
        }</span>

        // Track completion time (keep last 1000 entries to avoid memory growth)
        <span class="cov0" title="0">taskCompletionTimes = append(taskCompletionTimes, duration)
        if len(taskCompletionTimes) &gt; 1000 </span><span class="cov0" title="0">{
                taskCompletionTimes = taskCompletionTimes[1:]
        }</span>

        // Observe execution time in histogram
        <span class="cov0" title="0">TaskExecutionTime.Observe(duration)</span>
}

// TrackTaskCompletion tracks when a task completes (wrapper for scheduler)
func TrackTaskCompletion(success bool, duration time.Duration) <span class="cov0" title="0">{
        status := "failed"
        if success </span><span class="cov0" title="0">{
                status = "success"
        }</span>

        <span class="cov0" title="0">TasksCompleted.WithLabelValues(status).Inc()
        TrackTaskExecution(duration.Seconds(), success)</span>
}

// GetTaskStats returns current task statistics (for debugging/monitoring)
func GetTaskStats() (total, successful int64, avgTime float64) <span class="cov0" title="0">{
        taskStatsLock.RLock()
        defer taskStatsLock.RUnlock()

        total = totalTasks
        successful = successfulTasks

        if len(taskCompletionTimes) &gt; 0 </span><span class="cov0" title="0">{
                var sum float64
                for _, duration := range taskCompletionTimes </span><span class="cov0" title="0">{
                        sum += duration
                }</span>
                <span class="cov0" title="0">avgTime = sum / float64(len(taskCompletionTimes))</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package metrics

import (
        "net/http"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        StartMetricsCollection()
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">package metrics

import (
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        startTime = time.Now()

        // UptimeSeconds tracks the service uptime in seconds
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "uptime_seconds",
                Help:      "Time passed since Time Scheduler started in seconds",
        })

        // Memory usage metrics
        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "memory_usage_bytes",
                Help:      "Memory consumption",
        })

        // CPU usage metrics
        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        // Goroutines active metrics
        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "goroutines_active",
                Help:      "Number of active goroutines",
        })

        // Garbage collection duration metrics
        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Database server status
        APIServerStatus = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "api_server_status",
                Help:      "Database server health status (1=healthy, 0=unhealthy)",
        })

        // Tasks per minute
        TasksPerMinute = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "tasks_per_minute",
                Help:      "Task throughput rate",
        })

        // Average task completion time
        AverageTaskCompletionTimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "average_task_completion_time_seconds",
                Help:      "Mean task completion time",
        })

        // Task success rate
        TaskSuccessRatePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "task_success_rate_percent",
                Help:      "Overall task success percentage",
        })

        // Tasks scheduled
        TasksScheduled = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "scheduler_tasks_scheduled",
                Help:      "Total number of jobs currently scheduled",
        })

        // Tasks completed
        TasksCompleted = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "scheduler_tasks_completed",
                Help:      "Total number of jobs completed (success/fail)",
        }, []string{"status"})

        // Task execution time
        TaskExecutionTime = promauto.NewHistogram(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "scheduler_task_execution_time",
                Help:      "Time taken to execute a task in seconds",
                Buckets:   []float64{1, 5, 10, 50, 100, 500},
        })

        // Tasks expired
        TasksExpiredTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "tasks_expired_total",
                Help:      "Tasks that expired before execution",
        })

        // Task batch size
        TaskBatchSize = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "job_batch_size",
                Help:      "Number of jobs processed per batch",
        })

        // DB requests
        DBRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "db_requests_total",
                Help:      "Database client requests",
        }, []string{"method", "endpoint", "status"})

        // HTTP requests
        HTTPRequestsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "http_requests_total",
                Help:      "HTTP API requests received",
        }, []string{"method", "endpoint", "status_code"})

        // DB connection errors
        DBConnectionErrorsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "db_connection_errors_total",
                Help:      "Database connection failures",
        })

        // DB retries
        DBRetriesTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "db_retries_total",
                Help:      "Database request retry attempts",
        }, []string{"endpoint"})

        // Task broadcasts
        TaskBroadcastsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "task_broadcasts_total",
                Help:      "Task broadcasts to performers",
        }, []string{"status"})

        // Tasks by schedule type
        TasksByScheduleTypeTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "tasks_by_schedule_type_total",
                Help:      "Tasks processed by schedule type",
        }, []string{"type"})

        // Duplicate task window
        DuplicateTaskWindowSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "time_scheduler",
                Name:      "duplicate_task_window_seconds",
                Help:      "Duplicate task detection window",
        })

        // Internal tracking variables for performance calculations
        taskStatsLock       sync.RWMutex
        taskCompletionTimes []float64
        successfulTasks     int64
        totalTasks          int64
        tasksLastMinute     int64
        lastMinuteReset     time.Time
)

// Starts collecting metrics
func StartMetricsCollection() <span class="cov0" title="0">{
        // Update uptime every 15 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(15 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                        collectSystemMetrics()
                        collectConfigurationMetrics()
                        collectPerformanceMetrics()
                }</span>
        }()

        // Reset daily metrics every day at midnight
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        resetDailyMetrics()
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package scheduler

import (
        "context"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/config"
        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/client/dbserver"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc/client"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

type TimeBasedScheduler struct {
        ctx                  context.Context
        cancel               context.CancelFunc
        logger               logging.Logger
        activeTasks          map[int64]*types.ScheduleTimeTaskData
        dbClient             *dbserver.DBServerClient
        taskDispatcherClient *client.Client // RPC client for task dispatcher
        metrics              *metrics.Collector
        schedulerID          int
        pollingInterval      time.Duration
        pollingLookAhead     time.Duration
        taskBatchSize        int
        performerLockTTL     time.Duration
        taskCacheTTL         time.Duration
        duplicateTaskWindow  time.Duration
}

// NewTimeBasedScheduler creates a new instance of TimeBasedScheduler
func NewTimeBasedScheduler(managerID string, logger logging.Logger, dbClient *dbserver.DBServerClient) (*TimeBasedScheduler, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize RPC client for task dispatcher
        taskDispatcherClient := client.NewClient(client.Config{
                ServiceName: config.GetTaskDispatcherRPCUrl(),
                Timeout:     30 * time.Second,
                MaxRetries:  3,
                RetryDelay:  time.Second,
                PoolSize:    10,
                PoolTimeout: 5 * time.Second,
        }, logger)

        scheduler := &amp;TimeBasedScheduler{
                ctx:                  ctx,
                cancel:               cancel,
                logger:               logger,
                activeTasks:          make(map[int64]*types.ScheduleTimeTaskData),
                dbClient:             dbClient,
                taskDispatcherClient: taskDispatcherClient,
                metrics:              metrics.NewCollector(),
                schedulerID:          config.GetSchedulerID(),
                pollingInterval:      config.GetPollingInterval(),
                pollingLookAhead:     config.GetPollingLookAhead(),
                taskBatchSize:        config.GetTaskBatchSize(),
                performerLockTTL:     config.GetPerformerLockTTL(),
                taskCacheTTL:         config.GetTaskCacheTTL(),
                duplicateTaskWindow:  config.GetDuplicateTaskWindow(),
        }

        // Start metrics collection
        scheduler.metrics.Start()

        scheduler.logger.Info("Time-based scheduler initialized",
                "scheduler_id", scheduler.schedulerID,
                "task_dispatcher_url", config.GetTaskDispatcherRPCUrl(),
                "polling_interval", scheduler.pollingInterval,
                "polling_look_ahead", scheduler.pollingLookAhead,
                "task_batch_size", scheduler.taskBatchSize,
                "performer_lock_ttl", scheduler.performerLockTTL,
                "task_cache_ttl", scheduler.taskCacheTTL,
                "duplicate_task_window", scheduler.duplicateTaskWindow,
        )

        return scheduler, nil
}</span>

// Start begins the scheduler's main polling and execution loop
func (s *TimeBasedScheduler) Start(ctx context.Context) <span class="cov0" title="0">{
        s.logger.Info("Starting time-based scheduler", "scheduler_id", s.schedulerID)

        ticker := time.NewTicker(s.pollingInterval)
        defer ticker.Stop()
        // Poll and schedule tasks immediately on startup
        s.pollAndScheduleTasks()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("Scheduler context cancelled, stopping")
                        return</span>
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("Scheduler stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        s.pollAndScheduleTasks()</span>
                }
        }
}

// Stop gracefully stops the scheduler
func (s *TimeBasedScheduler) Stop() <span class="cov0" title="0">{
        startTime := time.Now()
        s.logger.Info("Stopping time-based scheduler")

        // Capture statistics before shutdown
        activeTasksCount := len(s.activeTasks)

        s.cancel()

        duration := time.Since(startTime)

        s.logger.Info("Time-based scheduler stopped",
                "duration", duration,
                "active_tasks_stopped", activeTasksCount,
                "performer_lock_ttl", s.performerLockTTL,
                "task_cache_ttl", s.taskCacheTTL,
                "duplicate_task_window", s.duplicateTaskWindow,
        )
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// pollAndScheduleTasks fetches tasks from database and schedules them for execution
func (s *TimeBasedScheduler) pollAndScheduleTasks() <span class="cov0" title="0">{
        tasks, err := s.dbClient.GetTimeBasedTasks()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("Failed to fetch time-based tasks: %v", err)
                metrics.TrackDBConnectionError()
                return
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.logger.Infof("Found %d tasks to process", len(tasks))
        metrics.TasksScheduled.Set(float64(len(tasks)))
        metrics.TaskBatchSize.Set(float64(s.taskBatchSize))

        for i := 0; i &lt; len(tasks); i += s.taskBatchSize </span><span class="cov0" title="0">{
                end := i + s.taskBatchSize
                if end &gt; len(tasks) </span><span class="cov0" title="0">{
                        end = len(tasks)
                }</span>

                <span class="cov0" title="0">batch := tasks[i:end]
                s.processBatch(batch)</span>
        }
}

// processBatch processes a batch of tasks by submitting to task dispatcher
func (s *TimeBasedScheduler) processBatch(tasks []types.ScheduleTimeTaskData) <span class="cov0" title="0">{
        s.logger.Infof("Processing batch of %d time-based tasks", len(tasks))

        var targetDataList []types.TaskTargetData
        var triggerDataList []types.TaskTriggerData
        var validTaskIDs []int64

        for _, task := range tasks </span><span class="cov0" title="0">{
                // Check if ExpirationTime of the job has passed or not
                if task.ExpirationTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        s.logger.Infof("Task ID %d has expired, skipping execution", task.TaskID)
                        metrics.TrackTaskExpired()
                        continue</span>
                }

                // Track task by schedule type
                <span class="cov0" title="0">metrics.TrackTaskByScheduleType(task.ScheduleType)

                // Generate the task data to send to the performer
                targetData := types.TaskTargetData{
                        JobID:                     task.TaskTargetData.JobID,
                        TaskID:                    task.TaskID,
                        TaskDefinitionID:          task.TaskDefinitionID,
                        TargetChainID:             task.TaskTargetData.TargetChainID,
                        TargetContractAddress:     task.TaskTargetData.TargetContractAddress,
                        TargetFunction:            task.TaskTargetData.TargetFunction,
                        ABI:                       task.TaskTargetData.ABI,
                        ArgType:                   task.TaskTargetData.ArgType,
                        Arguments:                 task.TaskTargetData.Arguments,
                        DynamicArgumentsScriptUrl: task.TaskTargetData.DynamicArgumentsScriptUrl,
                        IsImua:                    task.IsImua,
                }
                triggerData := types.TaskTriggerData{
                        TaskID:                  task.TaskID,
                        TaskDefinitionID:        task.TaskDefinitionID,
                        ExpirationTime:          task.ExpirationTime,
                        CurrentTriggerTimestamp: task.LastExecutedAt,
                        NextTriggerTimestamp:    task.NextExecutionTimestamp,
                        TimeScheduleType:        task.ScheduleType,
                        TimeCronExpression:      task.CronExpression,
                        TimeSpecificSchedule:    task.SpecificSchedule,
                        TimeInterval:            task.TimeInterval,
                }

                targetDataList = append(targetDataList, targetData)
                triggerDataList = append(triggerDataList, triggerData)
                validTaskIDs = append(validTaskIDs, task.TaskID)</span>
        }

        // If no valid tasks, return early
        <span class="cov0" title="0">if len(validTaskIDs) == 0 </span><span class="cov0" title="0">{
                s.logger.Debug("No valid tasks in batch after filtering expired tasks")
                return
        }</span>

        // Create the batch task data
        <span class="cov0" title="0">sendTaskData := types.SendTaskDataToKeeper{
                TaskID:           validTaskIDs,
                TargetData:       targetDataList,
                TriggerData:      triggerDataList,
                SchedulerID:      s.schedulerID,
                ManagerSignature: "",
        }

        // Create request for task dispatcher
        request := types.SchedulerTaskRequest{
                SendTaskDataToKeeper: sendTaskData,
                Source:               "time_scheduler",
        }

        // Convert validTaskIDs ([]int64) to []string for joining
        taskIDStrs := make([]string, len(validTaskIDs))
        for i, id := range validTaskIDs </span><span class="cov0" title="0">{
                taskIDStrs[i] = fmt.Sprintf("%d", id)
        }</span>
        <span class="cov0" title="0">taskIDs := strings.Join(taskIDStrs, ", ")

        // Submit batch to task dispatcher
        success := s.submitBatchToTaskDispatcher(request, taskIDs, len(validTaskIDs))

        if success </span><span class="cov0" title="0">{
                s.logger.Infof("Batch processing completed successfully: %d tasks submitted", len(validTaskIDs))
                metrics.TrackTaskCompletion(true, time.Since(time.Now()))
                metrics.TrackTaskBroadcast("task_dispatcher_submitted")
        }</span> else<span class="cov0" title="0"> {
                s.logger.Errorf("Batch processing failed: %d tasks", len(validTaskIDs))
                metrics.TrackTaskBroadcast("failed")
        }</span>
}

// submitBatchToTaskDispatcher submits the batch task data to Task Dispatcher via RPC
func (s *TimeBasedScheduler) submitBatchToTaskDispatcher(request types.SchedulerTaskRequest, taskIDs string, taskCount int) bool <span class="cov0" title="0">{
        startTime := time.Now()

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Make RPC call to task dispatcher
        var response types.TaskManagerAPIResponse
        err := s.taskDispatcherClient.Call(ctx, "submit-task", &amp;request, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to submit batch to task dispatcher via RPC",
                        "task_ids", taskIDs,
                        "task_count", taskCount,
                        "error", err)
                return false
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)

        if !response.Success </span><span class="cov0" title="0">{
                s.logger.Error("Task dispatcher processing failed",
                        "task_ids", taskIDs,
                        "task_count", taskCount,
                        "message", response.Message,
                        "error", response.Error,
                        "duration", duration)
                return false
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully submitted batch to task dispatcher",
                "task_ids", taskIDs,
                "task_count", taskCount,
                "response_task_ids", response.TaskID,
                "duration", duration,
                "message", response.Message)

        return true</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package scheduler

import "github.com/trigg3rX/triggerx-backend/internal/schedulers/time/metrics"

// GetStats returns current scheduler statistics
func (s *TimeBasedScheduler) GetStats() map[string]interface{} <span class="cov0" title="0">{
        // Get task performance stats
        totalTasks, successfulTasks, avgTime := metrics.GetTaskStats()

        return map[string]interface{}{
                "scheduler_id": s.schedulerID,
                "active_tasks":              len(s.activeTasks),
                "performer_lock_ttl":        s.performerLockTTL,
                "task_cache_ttl":            s.taskCacheTTL,
                "duplicate_task_window":     s.duplicateTaskWindow,
                "polling_interval":          s.pollingInterval,
                "polling_look_ahead":        s.pollingLookAhead,

                // Performance metrics
                "task_stats": map[string]interface{}{
                        "total_tasks":      totalTasks,
                        "successful_tasks": successfulTasks,
                        "failed_tasks":     totalTasks - successfulTasks,
                        "success_rate_percent": func() float64 </span><span class="cov0" title="0">{
                                if totalTasks &gt; 0 </span><span class="cov0" title="0">{
                                        return (float64(successfulTasks) / float64(totalTasks)) * 100
                                }</span>
                                <span class="cov0" title="0">return 0</span>
                        }(),
                        "average_completion_time_seconds": avgTime,
                },
        }
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Task Dispatcher RPC port
        taskDispatcherRPCPort int

        // Health RPC URL
        healthRPCUrl string
        // Aggregator RPC URL
        aggregatorRPCUrl string

        // Task Dispatcher signing key
        signingKey     string
        signingAddress string

        // Redis (Upstash) connection settings
        upstashURL   string
        upstashToken string

        // OpenTelemetry endpoint
        ottempoEndpoint string

        // Common settings
        poolSize     int
        minIdleConns int
        maxRetries   int

        // Timeout settings
        dialTimeout  time.Duration
        readTimeout  time.Duration
        writeTimeout time.Duration
        poolTimeout  time.Duration

        // Metrics settings
        metricsUpdateInterval time.Duration

        // Timeout and retry settings
        retryDelay             time.Duration
        requestTimeout         time.Duration
        initializationTimeout  time.Duration
        maxRetryBackoff        time.Duration
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                env.GetEnvBool("DEV_MODE", false),
                taskDispatcherRPCPort:  env.GetEnvInt("TASK_DISPATCHER_RPC_PORT", 9003),
                healthRPCUrl:           env.GetEnvString("HEALTH_RPC_URL", "http://localhost:9004"),
                aggregatorRPCUrl:       env.GetEnvString("AGGREGATOR_RPC_URL", "http://localhost:9001"),
                signingKey:             env.GetEnvString("TASK_DISPATCHER_SIGNING_KEY", ""),
                signingAddress:         env.GetEnvString("TASK_DISPATCHER_SIGNING_ADDRESS", ""),
                upstashURL:             env.GetEnvString("UPSTASH_REDIS_URL", ""),
                upstashToken:           env.GetEnvString("UPSTASH_REDIS_REST_TOKEN", ""),
                poolSize:               env.GetEnvInt("REDIS_POOL_SIZE", 10),
                minIdleConns:           env.GetEnvInt("REDIS_MIN_IDLE_CONNS", 2),
                maxRetries:             env.GetEnvInt("REDIS_MAX_RETRIES", 3),
                dialTimeout:            env.GetEnvDuration("REDIS_DIAL_TIMEOUT", 5*time.Second),
                readTimeout:            env.GetEnvDuration("REDIS_READ_TIMEOUT", 3*time.Second),
                writeTimeout:           env.GetEnvDuration("REDIS_WRITE_TIMEOUT", 3*time.Second),
                poolTimeout:            env.GetEnvDuration("REDIS_POOL_TIMEOUT", 4*time.Second),
                metricsUpdateInterval:  env.GetEnvDuration("REDIS_METRICS_UPDATE_INTERVAL", 30*time.Second),
                retryDelay:             env.GetEnvDuration("REDIS_RETRY_DELAY", 2*time.Second),
                requestTimeout:         env.GetEnvDuration("REDIS_REQUEST_TIMEOUT", 10*time.Second),
                initializationTimeout:  env.GetEnvDuration("REDIS_INITIALIZATION_TIMEOUT", 10*time.Second),
                maxRetryBackoff:        env.GetEnvDuration("REDIS_MAX_RETRY_BACKOFF", 5*time.Minute),
                ottempoEndpoint:        env.GetEnvString("TEMPO_OTLP_ENDPOINT", "localhost:4318"),
        }

        if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetHealthRPCUrl() string <span class="cov0" title="0">{
        return cfg.healthRPCUrl
}</span>

func GetTaskDispatcherRPCPort() int <span class="cov0" title="0">{
        return cfg.taskDispatcherRPCPort
}</span>

func GetAggregatorRPCUrl() string <span class="cov0" title="0">{
        return cfg.aggregatorRPCUrl
}</span>

func GetTaskDispatcherSigningKey() string <span class="cov0" title="0">{
        return cfg.signingKey
}</span>

func GetTaskDispatcherSigningAddress() string <span class="cov0" title="0">{
        return cfg.signingAddress
}</span>

func GetUpstashURL() string <span class="cov0" title="0">{
        return cfg.upstashURL
}</span>

func GetUpstashToken() string <span class="cov0" title="0">{
        return cfg.upstashToken
}</span>

func GetPoolSize() int <span class="cov0" title="0">{
        return cfg.poolSize
}</span>

func GetMinIdleConns() int <span class="cov0" title="0">{
        return cfg.minIdleConns
}</span>

func GetMaxRetries() int <span class="cov0" title="0">{
        return cfg.maxRetries
}</span>

func GetDialTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.dialTimeout
}</span>

func GetReadTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.readTimeout
}</span>

func GetWriteTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.writeTimeout
}</span>

func GetPoolTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.poolTimeout
}</span>

func GetMetricsUpdateInterval() time.Duration <span class="cov0" title="0">{
        return cfg.metricsUpdateInterval
}</span>

func GetRetryDelay() time.Duration <span class="cov0" title="0">{
        return cfg.retryDelay
}</span>

func GetRequestTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.requestTimeout
}</span>

func GetInitializationTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.initializationTimeout
}</span>

func GetMaxRetryBackoff() time.Duration <span class="cov0" title="0">{
        return cfg.maxRetryBackoff
}</span>

func GetOTTempoEndpoint() string <span class="cov0" title="0">{
        return cfg.ottempoEndpoint
}</span>

// GetRedisClientConfig returns a RedisConfig for the new Redis client
func GetRedisClientConfig() redisClient.RedisConfig <span class="cov0" title="0">{
        return redisClient.RedisConfig{
                UpstashConfig: redisClient.UpstashConfig{
                        URL:   cfg.upstashURL,
                        Token: cfg.upstashToken,
                },
                ConnectionSettings: redisClient.ConnectionSettings{
                        PoolSize:         cfg.poolSize,
                        MaxIdleConns:     0, // Let Redis client manage this
                        MinIdleConns:     cfg.minIdleConns,
                        MaxRetries:       cfg.maxRetries,
                        DialTimeout:      cfg.dialTimeout,
                        ReadTimeout:      cfg.readTimeout,
                        WriteTimeout:     cfg.writeTimeout,
                        PoolTimeout:      cfg.poolTimeout,
                        PingTimeout:      2 * time.Second,  // Default ping timeout
                        HealthTimeout:    5 * time.Second,  // Default health check timeout
                        OperationTimeout: 10 * time.Second, // Default operation timeout
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">package taskdispatcher

import (
        "fmt"
        "net/http"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// HealthClient handles communication with the health service
type HealthClient struct {
        client  *http.Client
        logger  logging.Logger
        baseURL string
}

// PerformerResponse represents the response from health service
type PerformerResponse struct {
        Performers []types.PerformerData `json:"performers"`
        Count      int             `json:"count"`
        Timestamp  string          `json:"timestamp"`
}

// NewHealthClient creates a new health client
func NewHealthClient(logger logging.Logger, baseURL string) *HealthClient <span class="cov0" title="0">{
        return &amp;HealthClient{
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                logger:  logger,
                baseURL: baseURL,
        }
}</span>

// GetPerformerData gets a performer using the dynamic selection system
func (hc *HealthClient) GetPerformerData(isImua bool) (types.PerformerData, error) <span class="cov0" title="0">{
        hc.logger.Debug("Getting performer data from health service", "is_imua", isImua)

        // Refresh performers if needed
        // if time.Since(pm.lastRefresh) &gt; PerformerRefreshTTL {
        //         pm.logger.Debug("Refreshing performers from health service")
        //         ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        //         defer cancel()
        //         if err := pm.refreshPerformers(ctx); err != nil {
        //                 pm.logger.Error("Failed to refresh performers", "error", err)
        //                 // Fall back to cached performers
        //         }
        // }

        var availablePerformers []types.PerformerData
        // availablePerformers := pm.GetAvailablePerformers()
        // pm.logger.Debug("Available performers count", "count", len(availablePerformers))

        if len(availablePerformers) == 0 </span><span class="cov0" title="0">{
                hc.logger.Warn("No performers available from health service, using fallback")
                fallbackPerformers := []types.PerformerData{
                        {
                                OperatorID:    1,
                                KeeperAddress: "0x011fcbae5f306cd793456ab7d4c0cc86756c693d",
                                IsImua:        false,
                        },
                        {
                                OperatorID:    4,
                                KeeperAddress: "0x80ce5df21ef5e7c7bdaf52534f0e05e72fcfb9be",
                                IsImua:        true,
                        },
                }
                availablePerformers = fallbackPerformers
                hc.logger.Info("Using fallback performers", "count", len(availablePerformers))
        }</span>

        // Log available performers for debugging
        // for i, performer := range availablePerformers {
        //         hc.logger.Debug("Available performer",
        //                 "index", i,
        //                 "operator_id", performer.OperatorID,
        //                 "keeper_address", performer.KeeperAddress,
        //                 "is_imua", performer.IsImua)
        // }

        // Filter by Imua status
        <span class="cov0" title="0">var filteredPerformer types.PerformerData
        for _, performer := range availablePerformers </span><span class="cov0" title="0">{
                if performer.IsImua == isImua </span><span class="cov0" title="0">{
                        filteredPerformer = performer
                }</span>
        }

        <span class="cov0" title="0">hc.logger.Debug("Filtered performers by Imua status",
                "is_imua", isImua,
                "total_available", len(availablePerformers),
                "filtered_count", 1)

        if filteredPerformer == (types.PerformerData{}) </span><span class="cov0" title="0">{
                hc.logger.Error("No suitable performers available after Imua filtering",
                        "is_imua", isImua,
                        "total_available", len(availablePerformers))
                return types.PerformerData{}, fmt.Errorf("no suitable performers available for isImua=%v", isImua)
        }</span>

        <span class="cov0" title="0">hc.logger.Info("Selected performer from health service",
                "performer_id", filteredPerformer.OperatorID,
                "performer_address", filteredPerformer.KeeperAddress,
                "performer_is_imua", filteredPerformer.IsImua)

        return filteredPerformer, nil</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package metrics

import (
        "net/http"
        "runtime"
        "time"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        // Update uptime every 10 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                        UpdateSystemMetrics()
                }</span>
        }()
}

// UpdateSystemMetrics updates system metrics (similar to keeper's middleware)
func UpdateSystemMetrics() <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)
        MemoryUsageBytes.Set(float64(memStats.Alloc))
        CPUUsagePercent.Set(float64(memStats.Sys))
        GoroutinesActive.Set(float64(runtime.NumGoroutine()))
        GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)
}</pre>
		
		<pre class="file" id="file179" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
)

var (
        startTime = time.Now()

        // System metrics
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "uptime_seconds",
                Help:      "Time passed since Redis Service started in seconds",
        })

        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "memory_usage_bytes",
                Help:      "Service memory consumption",
        })

        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Service Health &amp; Availability
        ServiceStatus = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "service_status",
                Help:      "Service component health status (component=client/job_stream_manager/task_stream_manager)",
        }, []string{"component"})

        // Single flag to indicate which Redis is being used
        IsRedisUpstashAvailable = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "is_upstash_available",
                Help:      "Whether Upstash Redis is available and being used (1=Upstash, 0=Local)",
        })

        // Connection Management
        ClientConnectionsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "client_connections_total",
                Help:      "Redis client connections (status=success/failure)",
        }, []string{"status"})

        ClientConnectionErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "client_connection_errors_total",
                Help:      "Redis client connection errors",
        }, []string{"error_type"})

        PingOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "ping_operations_total",
                Help:      "Redis ping operations",
        }, []string{"status"})

        PingDuration = promauto.NewHistogram(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "ping_duration_seconds",
                Help:      "Redis ping response time",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1},
        })

        ConnectionChecksTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_checks_total",
                Help:      "Connection health checks",
        }, []string{"status"})

        // Core Stream Operations
        TaskStreamLengths = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_stream_lengths",
                Help:      "Current task stream lengths (stream=ready/retry/processing/completed/failed)",
        }, []string{"stream"})

        JobStreamLengths = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "job_stream_lengths",
                Help:      "Current job stream lengths (stream=running/completed)",
        }, []string{"stream"})

        TasksAddedToStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_added_to_stream_total",
                Help:      "Tasks added to streams",
        }, []string{"stream", "status"})

        TasksReadFromStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_read_from_stream_total",
                Help:      "Tasks read from streams",
        }, []string{"stream", "status"})

        JobsAddedToStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "jobs_added_to_stream_total",
                Help:      "Jobs added to streams",
        }, []string{"stream", "status"})

        JobsReadFromStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "jobs_read_from_stream_total",
                Help:      "Jobs read from streams",
        }, []string{"stream", "status"})

        // Task Lifecycle &amp; Performance
        TaskRetryOperationsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_retry_operations_total",
                Help:      "Task retry operations",
        })

        TaskMaxRetriesExceededTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_max_retries_exceeded_total",
                Help:      "Tasks exceeding max retry attempts",
        })

        TasksMovedToFailedStreamTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_moved_to_failed_stream_total",
                Help:      "Tasks permanently failed and moved to failed stream",
        })

        TaskReadyToProcessingTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_ready_to_processing_total",
                Help:      "Tasks moved from ready to processing stream",
        })

        TaskProcessingToCompletedTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_processing_to_completed_total",
                Help:      "Tasks moved from processing to completed stream",
        })

        // Updated buckets for longer task execution times (30+ seconds to several minutes)
        TaskLifecycleTransitionDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_lifecycle_transition_duration_seconds",
                Help:      "Task lifecycle transition time",
                Buckets:   []float64{0.1, 0.5, 1, 5, 10, 30, 60, 120, 300, 600}, // Up to 10 minutes
        }, []string{"from_stream", "to_stream"})

        // Redis Client Operation Metrics
        RedisOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "operations_total",
                Help:      "Total Redis operations performed",
        }, []string{"operation", "status"})

        RedisOperationDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "operation_duration_seconds",
                Help:      "Redis operation duration",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5},
        }, []string{"operation"})

        RedisRetryAttempts = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "retry_attempts_total",
                Help:      "Total Redis retry attempts",
        }, []string{"operation"})

        RedisConnectionRecoveries = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_recoveries_total",
                Help:      "Total Redis connection recovery attempts",
        }, []string{"status"})

        RedisConnectionHealth = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_health",
                Help:      "Redis connection health status",
        }, []string{"type"})
)

// CreateRedisMonitoringHooks creates monitoring hooks for the Redis client
func CreateRedisMonitoringHooks() *redisClient.MonitoringHooks <span class="cov0" title="0">{
        return &amp;redisClient.MonitoringHooks{
                OnOperationStart: func(operation string, key string) </span>{<span class="cov0" title="0">
                        // Optional: Could track operation starts if needed
                }</span>,

                OnOperationEnd: func(operation string, key string, duration time.Duration, err error) <span class="cov0" title="0">{
                        status := "success"
                        if err != nil </span><span class="cov0" title="0">{
                                status = "error"
                        }</span>

                        <span class="cov0" title="0">RedisOperationsTotal.WithLabelValues(operation, status).Inc()
                        RedisOperationDuration.WithLabelValues(operation).Observe(duration.Seconds())</span>
                },

                OnConnectionStatus: func(connected bool, latency time.Duration) <span class="cov0" title="0">{
                        healthValue := float64(0)
                        if connected </span><span class="cov0" title="0">{
                                healthValue = float64(1)
                        }</span>
                        <span class="cov0" title="0">RedisConnectionHealth.WithLabelValues("main").Set(healthValue)

                        // Update ping duration if connected
                        if connected </span><span class="cov0" title="0">{
                                PingDuration.Observe(latency.Seconds())
                                PingOperationsTotal.WithLabelValues("success").Inc()
                        }</span> else<span class="cov0" title="0"> {
                                PingOperationsTotal.WithLabelValues("failure").Inc()
                        }</span>
                },

                OnRecoveryStart: func(reason string) <span class="cov0" title="0">{
                        // Mark connection as unhealthy during recovery
                        RedisConnectionHealth.WithLabelValues("main").Set(float64(0))
                }</span>,

                OnRecoveryEnd: func(success bool, attempts int, duration time.Duration) <span class="cov0" title="0">{
                        status := "failure"
                        if success </span><span class="cov0" title="0">{
                                status = "success"
                                RedisConnectionHealth.WithLabelValues("main").Set(float64(1))
                        }</span>
                        <span class="cov0" title="0">RedisConnectionRecoveries.WithLabelValues(status).Inc()</span>
                },

                OnRetryAttempt: func(operation string, attempt int, err error) <span class="cov0" title="0">{
                        RedisRetryAttempts.WithLabelValues(operation).Inc()
                }</span>,
        }
}

// UpdateRedisClientMetrics updates metrics from Redis client operation metrics
func UpdateRedisClientMetrics(operationMetrics map[string]*redisClient.OperationMetrics) <span class="cov0" title="0">{
        for operation, metrics := range operationMetrics </span><span class="cov0" title="0">{
                // Update operation counters
                RedisOperationsTotal.WithLabelValues(operation, "success").Add(float64(metrics.SuccessCount))
                RedisOperationsTotal.WithLabelValues(operation, "error").Add(float64(metrics.ErrorCount))

                // Update retry attempts
                RedisRetryAttempts.WithLabelValues(operation).Add(float64(metrics.RetryCount))

                // Update average latency (as a gauge for monitoring)
                if metrics.AverageLatency &gt; 0 </span><span class="cov0" title="0">{
                        RedisOperationDuration.WithLabelValues(operation).Observe(metrics.AverageLatency.Seconds())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file180" style="display: none">package rpc

import (
        "context"
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcclient "github.com/trigg3rX/triggerx-backend/pkg/rpc/client"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TaskDispatcherClient provides a client for the task dispatcher service
type TaskDispatcherClient struct {
        client *rpcclient.Client
        logger logging.Logger
}

// NewTaskDispatcherClient creates a new TaskDispatcherClient
func NewTaskDispatcherClient(address string, logger logging.Logger) (*TaskDispatcherClient, error) <span class="cov0" title="0">{
        config := rpcclient.Config{
                ServiceName: "TaskDispatcher",
                Timeout:     30 * time.Second,
                MaxRetries:  3,
                RetryDelay:  time.Second,
                PoolSize:    10,
                PoolTimeout: 5 * time.Second,
        }

        client := rpcclient.NewClient(config, logger)

        return &amp;TaskDispatcherClient{
                client: client,
                logger: logger,
        }, nil
}</span>

// Close closes the client connection
func (c *TaskDispatcherClient) Close() error <span class="cov0" title="0">{
        return c.client.Close()
}</span>

// SubmitTask submits a task to the task dispatcher
func (c *TaskDispatcherClient) SubmitTask(ctx context.Context, req *types.SchedulerTaskRequest) (*types.TaskManagerAPIResponse, error) <span class="cov0" title="0">{
        c.logger.Debug("Submitting task via gRPC",
                "source", req.Source,
                "task_count", len(req.SendTaskDataToKeeper.TaskID))

        var response types.TaskManagerAPIResponse
        err := c.client.Call(ctx, "submit-task", req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("gRPC call failed",
                        "error", err)
                return nil, fmt.Errorf("gRPC call failed: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Task submission completed",
                "success", response.Success,
                "task_count", len(response.TaskID))

        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">package rpc

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcpkg "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TaskDispatcherHandler implements the generic RPC handler interface
type TaskDispatcherHandler struct {
        logger     logging.Logger
        dispatcher TaskDispatcherInterface
}

// TaskDispatcherInterface defines the interface for task dispatcher operations
type TaskDispatcherInterface interface {
        SubmitTaskFromScheduler(ctx context.Context, req *types.SchedulerTaskRequest) (*types.TaskManagerAPIResponse, error)
}

// NewTaskDispatcherHandler creates a new RPC handler
func NewTaskDispatcherHandler(logger logging.Logger, dispatcher TaskDispatcherInterface) *TaskDispatcherHandler <span class="cov8" title="1">{
        return &amp;TaskDispatcherHandler{
                logger:     logger,
                dispatcher: dispatcher,
        }
}</span>

// Handle routes incoming RPC requests based on the method name
func (h *TaskDispatcherHandler) Handle(ctx context.Context, method string, request interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch method </span>{
        case "submit-task":<span class="cov8" title="1">
                // Convert request to the expected type
                req, ok := request.(*types.SchedulerTaskRequest)
                if !ok </span><span class="cov8" title="1">{
                        // Try to convert from map if it's JSON-decoded
                        if reqMap, ok := request.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                var err error
                                req, err = h.convertMapToRequest(reqMap)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to convert request: %w", err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("invalid request type for submit-task: %T", request)
                        }</span>
                }

                <span class="cov8" title="1">resp, err := h.dispatcher.SubmitTaskFromScheduler(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return resp, nil</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unknown method: %s", method)</span>
        }
}

// GetMethods advertises the supported RPC methods for discovery/metrics
func (h *TaskDispatcherHandler) GetMethods() []rpcpkg.RPCMethod <span class="cov8" title="1">{
        return []rpcpkg.RPCMethod{
                {
                        Name:         "submit-task",
                        Description:  "Submit a task from schedulers to the dispatcher",
                        RequestType:  &amp;types.SchedulerTaskRequest{},
                        ResponseType: &amp;types.TaskManagerAPIResponse{},
                        Timeout:      30 * time.Second,
                },
        }
}</span>

// convertMapToRequest converts a map to SchedulerTaskRequest
// This is used when the request comes as JSON-decoded map
func (h *TaskDispatcherHandler) convertMapToRequest(reqMap map[string]interface{}) (*types.SchedulerTaskRequest, error) <span class="cov0" title="0">{
        // Convert map back to JSON and then unmarshal to proper struct
        jsonData, err := json.Marshal(reqMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request map: %w", err)
        }</span>

        <span class="cov0" title="0">var req types.SchedulerTaskRequest
        if err := json.Unmarshal(jsonData, &amp;req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal request: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;req, nil</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">package rpc

import (
        "context"
        "fmt"
        "strconv"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcserver "github.com/trigg3rX/triggerx-backend/pkg/rpc/server"
)

// StartRPCServer creates and starts the Task Dispatcher gRPC server using the generic approach.
// It registers the task dispatcher handler with the generic RPC server.
func StartRPCServer(ctx context.Context, logger logging.Logger, dispatcher TaskDispatcherInterface, addr string, portStr string) (*rpcserver.Server, error) <span class="cov0" title="0">{
        port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid port %q: %w", portStr, err)
        }</span>

        <span class="cov0" title="0">srv := rpcserver.NewServer(rpcserver.Config{
                Name:    "TaskDispatcher",
                Version: "1.0.0",
                Address: addr,
                Port:    port,
        }, logger)

        // Add useful middleware (logging)
        srv.AddInterceptor(rpcserver.LoggingInterceptor(logger))

        // Create and register the generic RPC handler
        handler := NewTaskDispatcherHandler(logger, dispatcher)
        srv.RegisterHandler("TaskDispatcher", handler)

        if err := srv.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return srv, nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">package taskdispatcher

import (
        "context"
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/tasks"
        "github.com/trigg3rX/triggerx-backend/pkg/cryptography"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TaskDispatcher encapsulates dependencies for handling scheduler submissions
// and forwarding them to the aggregator.
type TaskDispatcher struct {
        logger            logging.Logger
        taskStreamManager *tasks.TaskStreamManager
        healthClient      *HealthClient
        signingKey        string
        signingAddress    string
}

// NewTaskDispatcher constructs a new dispatcher with an initialized aggregator client.
func NewTaskDispatcher(
        logger logging.Logger,
        taskStreamManager *tasks.TaskStreamManager,
        healthClient *HealthClient,
        signingKey string,
        signingAddress string) (*TaskDispatcher, error) <span class="cov0" title="0">{

        return &amp;TaskDispatcher{
                logger:            logger,
                taskStreamManager: taskStreamManager,
                healthClient:      healthClient,
                signingKey:        signingKey,
                signingAddress:    signingAddress,
        }, nil
}</span>

// SubmitTaskFromScheduler is the core business method used by the RPC handler.
// It receives the scheduler request, optionally enqueues to Redis (skipped for now),
// and forwards the data to the aggregator using the same approach as send_task.go.
func (d *TaskDispatcher) SubmitTaskFromScheduler(ctx context.Context, req *types.SchedulerTaskRequest) (*types.TaskManagerAPIResponse, error) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil request")
        }</span>
        <span class="cov0" title="0">if len(req.SendTaskDataToKeeper.TaskID) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing task id")
        }</span>
        <span class="cov0" title="0">if len(req.SendTaskDataToKeeper.TriggerData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing trigger data")
        }</span>
        <span class="cov0" title="0">if len(req.SendTaskDataToKeeper.TargetData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing target data")
        }</span>

        <span class="cov0" title="0">taskCount := len(req.SendTaskDataToKeeper.TaskID)
        d.logger.Info("Receiving task from scheduler",
                "task_ids", req.SendTaskDataToKeeper.TaskID,
                "task_count", taskCount,
                "scheduler_id", req.SendTaskDataToKeeper.SchedulerID,
                "source", req.Source)

        // Use dynamic performer selection instead of hardcoded selection
        performer, err := d.healthClient.GetPerformerData(req.SendTaskDataToKeeper.TargetData[0].IsImua)
        if err != nil </span><span class="cov0" title="0">{
                d.logger.Error("Failed to get performer data dynamically",
                        "task_id", req.SendTaskDataToKeeper.TaskID[0],
                        "error", err)
                return nil, fmt.Errorf("failed to get performer: %w", err)
        }</span>
        // Update task with performer information
        <span class="cov0" title="0">req.SendTaskDataToKeeper.PerformerData = performer

        // Sign the task data with improved error handling
        signature, err := cryptography.SignJSONMessage(req.SendTaskDataToKeeper, d.signingKey)
        if err != nil </span><span class="cov0" title="0">{
                d.logger.Error("Failed to sign batch task data",
                        "task_id", req.SendTaskDataToKeeper.TaskID[0],
                        "error", err)
                return nil, fmt.Errorf("failed to sign task data: %w", err)
        }</span>
        <span class="cov0" title="0">req.SendTaskDataToKeeper.ManagerSignature = signature

        // Handle batch requests by creating individual task stream data for each task
        if taskCount &gt; 1 </span><span class="cov0" title="0">{
                // This is a batch request (likely from time scheduler)
                d.logger.Info("Processing batch request", "task_count", taskCount)

                for i := 0; i &lt; taskCount; i++ </span><span class="cov0" title="0">{
                        // Create individual task data for each task in the batch
                        individualTaskData := types.SendTaskDataToKeeper{
                                TaskID:           []int64{req.SendTaskDataToKeeper.TaskID[i]},
                                PerformerData:    req.SendTaskDataToKeeper.PerformerData,
                                TargetData:       []types.TaskTargetData{req.SendTaskDataToKeeper.TargetData[i]},
                                TriggerData:      []types.TaskTriggerData{req.SendTaskDataToKeeper.TriggerData[i]},
                                SchedulerID:      req.SendTaskDataToKeeper.SchedulerID,
                                ManagerSignature: req.SendTaskDataToKeeper.ManagerSignature,
                        }

                        taskStreamData := tasks.TaskStreamData{
                                JobID:                individualTaskData.TargetData[0].JobID,
                                TaskDefinitionID:     individualTaskData.TargetData[0].TaskDefinitionID,
                                CreatedAt:            time.Now(),
                                RetryCount:           0,
                                SendTaskDataToKeeper: individualTaskData,
                        }

                        // Add individual task to batch processor
                        _, err := d.taskStreamManager.AddTaskToDispatchedStream(ctx, taskStreamData)
                        if err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("Failed to add individual task to batch processor",
                                        "task_id", individualTaskData.TaskID[0],
                                        "batch_index", i,
                                        "source", req.Source,
                                        "error", err)
                                // Continue processing other tasks in the batch
                                continue</span>
                        }

                        <span class="cov0" title="0">d.logger.Debug("Individual task added to batch processor",
                                "task_id", individualTaskData.TaskID[0],
                                "batch_index", i)</span>
                }
        } else<span class="cov0" title="0"> {
                // This is a single task request (likely from condition scheduler)
                taskStreamData := tasks.TaskStreamData{
                        JobID:                req.SendTaskDataToKeeper.TargetData[0].JobID,
                        TaskDefinitionID:     req.SendTaskDataToKeeper.TargetData[0].TaskDefinitionID,
                        CreatedAt:            time.Now(),
                        RetryCount:           0,
                        SendTaskDataToKeeper: req.SendTaskDataToKeeper,
                }

                // Add task to batch processor for improved performance
                _, err := d.taskStreamManager.AddTaskToDispatchedStream(ctx, taskStreamData)
                if err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("Failed to add task to batch processor",
                                "task_id", req.SendTaskDataToKeeper.TaskID[0],
                                "source", req.Source,
                                "error", err)
                        return nil, fmt.Errorf("failed to add task to batch processor: %w", err)
                }</span>
        }

        <span class="cov0" title="0">d.logger.Info("[Dispatcher] Task forwarded to aggregator", "task_id", req.SendTaskDataToKeeper.TaskID[0])
        return &amp;types.TaskManagerAPIResponse{
                Success:   true,
                TaskID:    []int64{req.SendTaskDataToKeeper.TaskID[0]},
                Message:   "Task submitted successfully",
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }, nil</span>
}

func (d *TaskDispatcher) Close() error <span class="cov0" title="0">{
        return d.taskStreamManager.Close()
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">package tasks

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics"

        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/client/aggregator"
)

type TaskStreamManager struct {
        client           redisClient.RedisClientInterface
        logger           logging.Logger
        consumerGroups   map[string]bool
        mu               sync.RWMutex
        startTime        time.Time
        aggregatorClient *aggregator.AggregatorClient
}

func NewTaskStreamManager(client redisClient.RedisClientInterface, aggClient *aggregator.AggregatorClient, logger logging.Logger) (*TaskStreamManager, error) <span class="cov0" title="0">{
        logger.Info("Initializing TaskStreamManager...")

        tsm := &amp;TaskStreamManager{
                client:           client,
                logger:           logger,
                consumerGroups:   make(map[string]bool),
                startTime:        time.Now(),
                aggregatorClient: aggClient,
        }

        logger.Info("TaskStreamManager initialized successfully")
        metrics.ServiceStatus.WithLabelValues("task_stream_manager").Set(1)
        return tsm, nil
}</span>

func (tsm *TaskStreamManager) Initialize() error <span class="cov0" title="0">{
        tsm.logger.Info("Initializing task streams...")

        ctx, cancel := context.WithTimeout(context.Background(), config.GetInitializationTimeout())
        defer cancel()

        // Initialize task streams with specific expiration rules
        streamConfigs := map[string]time.Duration{
                StreamTaskDispatched:  TasksProcessingTTL,
                StreamTaskCompleted:   TasksCompletedTTL,
                StreamTaskFailed:      TasksFailedTTL,
                StreamTaskRetry:       TasksRetryTTL,
        }

        for stream, ttl := range streamConfigs </span><span class="cov0" title="0">{
                tsm.logger.Debug("Creating stream", "stream", stream, "ttl", ttl)
                if err := tsm.client.CreateStreamIfNotExists(ctx, stream, ttl); err != nil </span><span class="cov0" title="0">{
                        tsm.logger.Error("Failed to initialize stream",
                                "stream", stream,
                                "error", err,
                                "ttl", ttl)
                        return fmt.Errorf("failed to initialize stream %s: %w", stream, err)
                }</span>
                <span class="cov0" title="0">tsm.logger.Info("Stream initialized successfully", "stream", stream, "ttl", ttl)</span>
        }

        // Register consumer groups for task processing
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskDispatched, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task completion
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskCompleted, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task failure
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskFailed, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task retry
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskRetry, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        <span class="cov0" title="0">go tsm.StartStreamHealthMonitor(ctx)

        tsm.logger.Info("All task streams initialized successfully")

        return nil</span>
}

// RegisterConsumerGroup registers a consumer group for a stream
func (tsm *TaskStreamManager) RegisterConsumerGroup(stream string, group string) error <span class="cov0" title="0">{
        tsm.mu.Lock()
        defer tsm.mu.Unlock()

        key := fmt.Sprintf("%s:%s", stream, group)
        if _, exists := tsm.consumerGroups[key]; exists </span><span class="cov0" title="0">{
                tsm.logger.Debug("Consumer group already exists", "stream", stream, "group", group)
                return nil
        }</span>

        <span class="cov0" title="0">tsm.logger.Info("Registering consumer group", "stream", stream, "group", group)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := tsm.client.CreateConsumerGroup(ctx, stream, group); err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to create consumer group",
                        "stream", stream,
                        "group", group,
                        "error", err)
                return fmt.Errorf("failed to create consumer group for %s: %w", stream, err)
        }</span>

        <span class="cov0" title="0">tsm.consumerGroups[key] = true
        tsm.logger.Info("Consumer group created successfully", "stream", stream, "group", group)
        return nil</span>
}

// GetStreamInfo returns information about task streams
func (tsm *TaskStreamManager) GetStreamInfo() map[string]interface{} <span class="cov0" title="0">{
        tsm.logger.Debug("Getting stream information")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        streamLengths := make(map[string]int64)
        streams := []string{StreamTaskDispatched, StreamTaskRetry, StreamTaskCompleted, StreamTaskFailed}

        for _, stream := range streams </span><span class="cov0" title="0">{
        length, err := tsm.client.XLen(ctx, stream)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Warn("Failed to get stream length",
                        "stream", stream,
                        "error", err)
                length = -1
        }</span>
        <span class="cov0" title="0">streamLengths[stream] = length

        // Update stream length metrics
        switch stream </span>{
        case StreamTaskDispatched:<span class="cov0" title="0">
                metrics.TaskStreamLengths.WithLabelValues("dispatched").Set(float64(length))</span>
        case StreamTaskRetry:<span class="cov0" title="0">
                metrics.TaskStreamLengths.WithLabelValues("retry").Set(float64(length))</span>
        case StreamTaskCompleted:<span class="cov0" title="0">
                metrics.TaskStreamLengths.WithLabelValues("completed").Set(float64(length))</span>
        case StreamTaskFailed:<span class="cov0" title="0">
                metrics.TaskStreamLengths.WithLabelValues("failed").Set(float64(length))</span>
        }
        }

        <span class="cov0" title="0">info := map[string]interface{}{
                "available":            tsm.client != nil,
                "max_length":           10000, // Default value, can be made configurable
                "tasks_processing_ttl": TasksProcessingTTL.String(),
                "tasks_completed_ttl":  TasksCompletedTTL.String(),
                "tasks_failed_ttl":     TasksFailedTTL.String(),
                "tasks_retry_ttl":      TasksRetryTTL.String(),
                "stream_lengths":       streamLengths,
                "max_retries":          MaxRetryAttempts,
                "consumer_groups":      len(tsm.consumerGroups),
        }

        tsm.logger.Debug("Stream information retrieved", "info", info)
        return info</span>
}

func (tsm *TaskStreamManager) Close() error <span class="cov0" title="0">{
        tsm.logger.Info("Closing TaskStreamManager")

        err := tsm.client.Close()
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to close Redis client", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">tsm.logger.Info("TaskStreamManager closed successfully")
        return nil</span>
}

// startStreamHealthMonitor monitors the health of Redis streams
func (tsm *TaskStreamManager) StartStreamHealthMonitor(ctx context.Context) <span class="cov0" title="0">{
        tsm.logger.Info("Starting stream health monitor")

        ticker := time.NewTicker(30 * time.Second) // Check health every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        tsm.logger.Info("Stream health monitor shutting down")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Get stream information
                        taskInfo := tsm.GetStreamInfo()

                        // logger.Info("Stream health status",
                        //         "job_streams", jobInfo,
                        //         "task_streams", taskInfo)

                        // Log warnings for high stream length
                        if taskLengths, ok := taskInfo["stream_lengths"].(map[string]int64); ok </span><span class="cov0" title="0">{
                                for stream, length := range taskLengths </span><span class="cov0" title="0">{
                                        if length &gt; 50 &amp;&amp; stream != StreamTaskFailed </span><span class="cov0" title="0">{ // Warn if more than 50 tasks in any stream, ignore the StreamTaskFailed stream
                                                tsm.logger.Warn("High task stream length detected",
                                                        "stream", stream,
                                                        "length", length)
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file185" style="display: none">package tasks

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (tsm *TaskStreamManager) AddTaskToDispatchedStream(ctx context.Context, task TaskStreamData) (bool, error) <span class="cov0" title="0">{
        success, err := tsm.addTaskToStream(ctx, StreamTaskDispatched, &amp;task)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to add task to stream")
        }</span>

        // Prepare payload identical to previous implementation
        <span class="cov0" title="0">jsonData, err := json.Marshal(task.SendTaskDataToKeeper)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to marshal scheduler task data", "task_id", task.SendTaskDataToKeeper.TaskID[0], "error", err)
                return false, fmt.Errorf("failed to marshal task data: %w", err)
        }</span>

        <span class="cov0" title="0">broadcast := types.BroadcastDataForPerformer{
                TaskID:           task.SendTaskDataToKeeper.TaskID[0],
                TaskDefinitionID: task.SendTaskDataToKeeper.TargetData[0].TaskDefinitionID,
                PerformerAddress: task.SendTaskDataToKeeper.PerformerData.KeeperAddress,
                Data:             jsonData,
        }

        success, err = tsm.aggregatorClient.SendTaskToPerformer(ctx, &amp;broadcast)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to send task to aggregator", "task_id", task.SendTaskDataToKeeper.TaskID[0], "error", err)
                return false, err
        }</span>
        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                tsm.logger.Warn("Aggregator send returned unsuccessful", "task_id", task.SendTaskDataToKeeper.TaskID[0])
                return false, fmt.Errorf("aggregator send unsuccessful")
        }</span>
    <span class="cov0" title="0">return true, nil</span>
}

func (tsm *TaskStreamManager) addTaskToStream(ctx context.Context, stream string, task *TaskStreamData) (bool, error) <span class="cov0" title="0">{
        start := time.Now()
        ctx, cancel := context.WithTimeout(ctx, config.GetRequestTimeout())
        defer cancel()

        taskJSON, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to marshal task data",
                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                        "stream", stream,
                        "error", err)
                return false, fmt.Errorf("failed to marshal task data: %w", err)
        }</span>

        <span class="cov0" title="0">res, err := tsm.client.XAdd(ctx, &amp;redis.XAddArgs{
                Stream: stream,
                MaxLen: int64(10000),
                Approx: true,
                Values: map[string]interface{}{
                        "task":       taskJSON,
                        "created_at": time.Now().Unix(),
                },
        })
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                metrics.TasksAddedToStreamTotal.WithLabelValues(stream, "failure").Inc()
                tsm.logger.Error("Failed to add task to stream",
                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                        "stream", stream,
                        "duration", duration,
                        "error", err)
                return false, fmt.Errorf("failed to add task to stream: %w", err)
        }</span>

        <span class="cov0" title="0">metrics.TasksAddedToStreamTotal.WithLabelValues(stream, "success").Inc()
        tsm.logger.Debug("Task added to stream successfully",
                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                "stream", stream,
                "stream_id", res,
                "duration", duration,
                "task_json_size", len(taskJSON))

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package tasks

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskdispatcher/metrics"
)

func (tsm *TaskStreamManager) GetTaskDataFromStream(stream string, taskID int64) (*TaskStreamData, error) <span class="cov0" title="0">{
        taskStreamData, err := tsm.ReadTasksFromStream(stream, "task_stream_manager", "task_stream_manager", 10)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to read task stream data",
                        "task_id", taskID,
                        "error", err)
                return nil, fmt.Errorf("failed to read task stream data: %w", err)
        }</span>

        <span class="cov0" title="0">for _, task := range taskStreamData </span><span class="cov0" title="0">{
                if task.SendTaskDataToKeeper.TaskID[0] == taskID </span><span class="cov0" title="0">{
                        return &amp;task, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("task not found: %d", taskID)</span>
}

func (tsm *TaskStreamManager) ReadTasksFromStream(stream, consumerGroup, consumerName string, count int64) ([]TaskStreamData, error) <span class="cov0" title="0">{
        if err := tsm.RegisterConsumerGroup(stream, consumerGroup); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to register consumer group: %w", err)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        ctx, cancel := context.WithTimeout(context.Background(), config.GetRequestTimeout())
        defer cancel()

        streams, err := tsm.client.XReadGroup(ctx, &amp;redis.XReadGroupArgs{
                Group:    consumerGroup,
                Consumer: consumerName,
                Streams:  []string{stream, "&gt;"},
                Count:    count,
                Block:    time.Second,
        })

        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        metrics.TasksReadFromStreamTotal.WithLabelValues(stream, "empty").Inc()
                        tsm.logger.Debug("No tasks available in stream",
                                "stream", stream,
                                "consumer_group", consumerGroup,
                                "duration", duration)
                        return []TaskStreamData{}, nil
                }</span>
                <span class="cov0" title="0">tsm.logger.Error("Failed to read from stream",
                        "stream", stream,
                        "consumer_group", consumerGroup,
                        "duration", duration,
                        "error", err)
                return nil, fmt.Errorf("failed to read from stream: %w", err)</span>
        }

        <span class="cov0" title="0">metrics.TasksReadFromStreamTotal.WithLabelValues(stream, "success").Inc()

        // Pre-allocate slice for better performance
        var tasks []TaskStreamData
        totalMessages := 0
        for _, stream := range streams </span><span class="cov0" title="0">{
                totalMessages += len(stream.Messages)
        }</span>
        <span class="cov0" title="0">tasks = make([]TaskStreamData, 0, totalMessages)

        for _, stream := range streams </span><span class="cov0" title="0">{
                for _, message := range stream.Messages </span><span class="cov0" title="0">{
                        taskJSON, exists := message.Values["task"].(string)
                        if !exists </span><span class="cov0" title="0">{
                                tsm.logger.Warn("Message missing task data",
                                        "stream", stream.Stream,
                                        "message_id", message.ID)
                                continue</span>
                        }

                        <span class="cov0" title="0">var task TaskStreamData
                        if err := json.Unmarshal([]byte(taskJSON), &amp;task); err != nil </span><span class="cov0" title="0">{
                                tsm.logger.Error("Failed to unmarshal task data",
                                        "stream", stream.Stream,
                                        "message_id", message.ID,
                                        "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">tasks = append(tasks, task)
                        tsm.logger.Debug("Task read from stream",
                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                "stream", stream.Stream,
                                "message_id", message.ID)</span>
                }
        }

        <span class="cov0" title="0">tsm.logger.Info("Tasks read from stream successfully",
                "stream", stream,
                "task_count", len(tasks),
                "duration", duration)

        return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">package database

import (
        "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// DatabaseClient handles database operations
type DatabaseClient struct {
        logger logging.Logger
        db     *database.Connection
}

// NewDatabaseClient initializes the database manager with a logger
func NewDatabaseClient(logger logging.Logger, connection *database.Connection) *DatabaseClient <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                panic("logger cannot be nil")</span>
        }
        <span class="cov0" title="0">if connection == nil </span><span class="cov0" title="0">{
                panic("database connection cannot be nil")</span>
        }

        <span class="cov0" title="0">return &amp;DatabaseClient{
                logger: logger.With("component", "database"),
                db:     connection,
        }</span>
}

func (c *DatabaseClient) Close() <span class="cov0" title="0">{
        c.db.Close()
}</span>
</pre>
		
		<pre class="file" id="file188" style="display: none">package database

import (
        "fmt"
        "math/big"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database/queries"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/types"
)

// UpdateTaskSubmissionData updates task number, success status and execution details in database
func (dm *DatabaseClient) UpdateTaskSubmissionData(data types.TaskSubmissionData) error <span class="cov0" title="0">{
        // dm.logger.Infof("Updating task %d with task number %d and acceptance status %t", data.TaskID, data.TaskNumber, data.IsAccepted)

        performerId, err := dm.GetKeeperIds([]string{data.PerformerAddress})
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get performer ID: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">attesterIds := data.AttesterIds

        if err := dm.db.NewQuery(queries.UpdateTaskSubmissionData,
                data.TaskNumber,
                data.IsAccepted,
                data.TaskSubmissionTxHash,
                performerId[0],
                attesterIds,
                data.ExecutionTxHash,
                data.ExecutionTimestamp,
                data.TaskOpxCost,
                data.ProofOfTask,
                data.TaskID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Error updating task execution details for task ID %d: %v", data.TaskID, err)
                return err
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("Successfully updated task %d with submission details", data.TaskID)
        return nil</span>
}

// UpdatePointsInDatabase updates points for all involved parties in a task
func (dm *DatabaseClient) UpdateKeeperPointsInDatabase(data types.TaskSubmissionData) error <span class="cov0" title="0">{
        var jobID *big.Int
        var userID int64
        var userTasks int64
        var taskPredictedOpxCost float64

        var keeperId int64
        var keeperPoints float64
        var rewardsBooster float64
        var noAttestedTasks int64
        var noExecutedTasks int64

        // Get task cost and job ID
        iter := dm.db.NewQuery(queries.GetTaskCostAndJobId, data.TaskID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;taskPredictedOpxCost, &amp;jobID) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get task fee and job ID for task ID %d: no results found", data.TaskID)
                return fmt.Errorf("task not found for task ID %d", data.TaskID)
        }</span>

        // dm.logger.Debugf("Details: taskID: %d, taskPredictedOpxCost: %f, taskOpxCost: %f, jobID: %d", data.TaskID, taskPredictedOpxCost, data.TaskOpxCost, jobID)

        // TODO:
        // Alert if taskOpxCost is greater than taskPredictedOpxCost by a threshold

        // Update the Attester Points
        <span class="cov0" title="0">for _, operator_id := range data.AttesterIds </span><span class="cov0" title="0">{
                // Use RetryableIter since the query needs parameters
                iter := dm.db.NewQuery(queries.GetAttesterPointsAndNoOfTasks, operator_id).Iter()
                defer func() </span><span class="cov0" title="0">{
                        if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                                dm.logger.Errorf("Error closing iterator: %v", cerr)
                        }</span>
                }()

                <span class="cov0" title="0">if !iter.Scan(&amp;keeperId, &amp;keeperPoints, &amp;rewardsBooster, &amp;noAttestedTasks) </span><span class="cov0" title="0">{
                        dm.logger.Error(fmt.Sprintf("Failed to get keeper points for operator_id %d: no results found", operator_id))
                        return fmt.Errorf("keeper not found for operator_id %d", operator_id)
                }</span>
                <span class="cov0" title="0">keeperPoints = keeperPoints + float64(rewardsBooster)*data.TaskOpxCost
                noAttestedTasks = noAttestedTasks + 1

                // dm.logger.Infof("Keeper points: %f, Rewards booster: %f, No attested tasks: %d", keeperPoints, rewardsBooster, noAttestedTasks)

                if err := dm.db.NewQuery(queries.UpdateAttesterPointsAndNoOfTasks,
                        keeperPoints, noAttestedTasks, keeperId).Exec(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Error(fmt.Sprintf("Failed to update keeper points: %v", err))
                        return err
                }</span>
        }

        // Update the Performer Points
        <span class="cov0" title="0">performerId, err := dm.GetKeeperIds([]string{data.PerformerAddress})
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get performer ID: %v", err)
                return err
        }</span>
        // Use RetryableIter since the query needs parameters
        <span class="cov0" title="0">iter = dm.db.NewQuery(queries.GetPerformerPointsAndNoOfTasks, performerId[0]).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;keeperPoints, &amp;rewardsBooster, &amp;noExecutedTasks) </span><span class="cov0" title="0">{
                dm.logger.Error(fmt.Sprintf("Failed to get keeper points for performer_id %d: no results found", performerId[0]))
                return fmt.Errorf("keeper not found for performer_id %d", performerId[0])
        }</span>
        <span class="cov0" title="0">if data.IsAccepted </span><span class="cov0" title="0">{
                keeperPoints = keeperPoints + float64(rewardsBooster)*data.TaskOpxCost
        }</span> else<span class="cov0" title="0"> {
                keeperPoints = keeperPoints - float64(rewardsBooster)*data.TaskOpxCost*0.1
        }</span>
        <span class="cov0" title="0">noExecutedTasks = noExecutedTasks + 1

        if err := dm.db.NewQuery(queries.UpdatePerformerPointsAndNoOfTasks,
                keeperPoints, noExecutedTasks, performerId[0]).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Error(fmt.Sprintf("Failed to update keeper points: %v", err))
                return err
        }</span>

        // Update the User Points
        <span class="cov0" title="0">iter = dm.db.NewQuery(queries.GetUserIdByJobId, jobID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;userID) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get user ID for job ID %d: no results found", jobID)
                return fmt.Errorf("user not found for job ID %d", jobID)
        }</span>

        <span class="cov0" title="0">var userPoints float64
        iter = dm.db.NewQuery(queries.GetUserPoints, userID).Iter()
        defer func() </span><span class="cov0" title="0">{
                if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                        dm.logger.Errorf("Error closing iterator: %v", cerr)
                }</span>
        }()

        <span class="cov0" title="0">if !iter.Scan(&amp;userPoints, &amp;userTasks) </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to get user points for user ID %d: no results found", userID)
                return fmt.Errorf("user not found for user ID %d", userID)
        }</span>

        <span class="cov0" title="0">userTasks = userTasks + 1
        userPoints = userPoints + data.TaskOpxCost
        lastUpdatedAt := time.Now().UTC()

        if err := dm.db.NewQuery(queries.UpdateUserPoints,
                userPoints, userTasks, lastUpdatedAt, userID).Exec(); err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Failed to update user points for user ID %d: %v", userID, err)
                return err
        }</span>
        <span class="cov0" title="0">dm.logger.Infof("Successfully updated points for user ID %d: added %.2f points", userID, data.TaskOpxCost)
        return nil</span>
}

// GetKeeperIds gets keeper IDs from keeper addresses
func (dm *DatabaseClient) GetKeeperIds(keeperAddresses []string) ([]int64, error) <span class="cov0" title="0">{
        var keeperIds []int64
        for _, keeperAddress := range keeperAddresses </span><span class="cov0" title="0">{
                var keeperID int64
                keeperAddress = strings.ToLower(keeperAddress)

                // Use RetryableIter since the query needs parameters
                iter := dm.db.NewQuery(queries.GetKeeperIDByAddress, keeperAddress).Iter()
                defer func() </span><span class="cov0" title="0">{
                        if cerr := iter.Close(); cerr != nil </span><span class="cov0" title="0">{
                                dm.logger.Errorf("Error closing iterator: %v", cerr)
                        }</span>
                }()

                <span class="cov0" title="0">if iter.Scan(&amp;keeperID) </span><span class="cov0" title="0">{
                        dm.logger.Infof("Keeper ID for address %s: %d", keeperAddress, keeperID)
                        keeperIds = append(keeperIds, keeperID)
                }</span> else<span class="cov0" title="0"> {
                        dm.logger.Errorf("Failed to get keeper ID for address %s: no results found", keeperAddress)
                        return nil, fmt.Errorf("keeper not found for address %s", keeperAddress)
                }</span>
        }
        <span class="cov0" title="0">return keeperIds, nil</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">package websocket

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/gorilla/websocket"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Client manages WebSocket connections to multiple blockchains
type Client struct {
        logger    logging.Logger
        chains    map[string]*ChainConnection
        eventChan chan *ChainEvent
        mu        sync.RWMutex
        ctx       context.Context
        cancel    context.CancelFunc
        wg        sync.WaitGroup
}

// ChainConnection represents a WebSocket connection to a specific blockchain
type ChainConnection struct {
        chainID       string
        chainName     string
        ethClient     *ethclient.Client
        wsConn        *websocket.Conn
        subscriptions map[string]*Subscription
        subManager    *SubscriptionManager
        reconnectMgr  *ReconnectManager
        eventChan     chan *ChainEvent
        logger        logging.Logger
        mu            sync.RWMutex
        isConnected   bool
        lastMessage   time.Time
        websocketURL  string
}

// Subscription represents an event subscription
type Subscription struct {
        ID           string
        ChainID      string
        ContractAddr common.Address
        ContractType ContractType
        EventName    string
        Query        ethereum.FilterQuery
        Active       bool
        CreatedAt    time.Time
}

// ChainEvent represents an event from any blockchain
type ChainEvent struct {
        ChainID      string       `json:"chain_id"`
        ChainName    string       `json:"chain_name"`
        ContractAddr string       `json:"contract_address"`
        ContractType ContractType `json:"contract_type"`
        EventName    string       `json:"event_name"`
        BlockNumber  uint64       `json:"block_number"`
        TxHash       string       `json:"tx_hash"`
        LogIndex     uint         `json:"log_index"`
        Data         interface{}  `json:"data"`
        RawLog       types.Log    `json:"raw_log"`
        ProcessedAt  time.Time    `json:"processed_at"`
}

// NewClient creates a new multi-chain WebSocket client
func NewClient(logger logging.Logger) *Client <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;Client{
                logger:    logger,
                chains:    make(map[string]*ChainConnection),
                eventChan: make(chan *ChainEvent, 10000),
                ctx:       ctx,
                cancel:    cancel,
        }
}</span>

// AddChain adds a new blockchain to monitor
func (c *Client) AddChain(config ChainConfig) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, exists := c.chains[config.ChainID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s already exists", config.ChainID)
        }</span>

        // Create Ethereum client
        <span class="cov0" title="0">ethClient, err := ethclient.Dial(config.RPCURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to %s RPC: %w", config.Name, err)
        }</span>

        // Create subscription manager
        <span class="cov0" title="0">subManager := NewSubscriptionManager(config.ChainID, c.logger)

        // Create reconnection manager
        reconnectMgr := NewReconnectManagerWithConfig(config.WebSocketURL, config.Reconnect, c.logger)

        // Create chain connection
        chainConn := &amp;ChainConnection{
                chainID:       config.ChainID,
                chainName:     config.Name,
                ethClient:     ethClient,
                subscriptions: make(map[string]*Subscription),
                subManager:    subManager,
                reconnectMgr:  reconnectMgr,
                eventChan:     c.eventChan,
                logger:        c.logger,
                isConnected:   false,
                websocketURL:  config.WebSocketURL,
        }

        c.chains[config.ChainID] = chainConn

        // Auto-subscribe to contracts if specified in config
        if len(config.Contracts) &gt; 0 </span><span class="cov0" title="0">{
                for _, contractConfig := range config.Contracts </span><span class="cov0" title="0">{
                        if err := chainConn.subscribeToContractEvents(contractConfig); err != nil </span><span class="cov0" title="0">{
                                c.logger.Warnf("Failed to subscribe to contract %s: %v", contractConfig.Address, err)
                        }</span>
                }
        }

        // c.logger.Infof("Added chain %s (%s) for monitoring", config.Name, config.ChainID)
        <span class="cov0" title="0">return nil</span>
}

// Start begins monitoring all configured chains
func (c *Client) Start() error <span class="cov0" title="0">{
        // c.logger.Info("Starting multi-chain WebSocket client")

        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                c.wg.Add(1)
                go c.startChainConnection(chainID, chainConn)
        }</span>

        // c.logger.Infof("Started monitoring %d chains", len(c.chains))
        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops all chain connections
func (c *Client) Stop() error <span class="cov0" title="0">{
        // c.logger.Info("Stopping multi-chain WebSocket client")

        c.cancel()
        c.wg.Wait()

        // Close all connections
        c.mu.Lock()
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                if err := chainConn.close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Error closing connection for chain %s: %v", chainID, err)
                }</span>
        }
        <span class="cov0" title="0">c.mu.Unlock()

        close(c.eventChan)
        // c.logger.Info("Multi-chain WebSocket client stopped")
        return nil</span>
}

// SubscribeToContract subscribes to events from a specific contract using contract type
func (c *Client) SubscribeToContract(chainID string, contractAddr string, contractType ContractType, events []string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subscribeToContractWithType(contractAddr, contractType, events)</span>
}

// SubscribeToContractLegacy subscribes to events from a specific contract (legacy method)
func (c *Client) SubscribeToContractLegacy(chainID string, contractAddr string, events []string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subscribeToContract(contractAddr, events)</span>
}

// EventChannel returns the channel for receiving events from all chains
func (c *Client) EventChannel() &lt;-chan *ChainEvent <span class="cov0" title="0">{
        return c.eventChan
}</span>

// GetChainStatus returns the status of all chains
func (c *Client) GetChainStatus() map[string]ChainStatus <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        status := make(map[string]ChainStatus)
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                status[chainID] = chainConn.getStatus()
        }</span>
        <span class="cov0" title="0">return status</span>
}

// ChainStatus represents the status of a chain connection
type ChainStatus struct {
        ChainID        string    `json:"chain_id"`
        ChainName      string    `json:"chain_name"`
        Connected      bool      `json:"connected"`
        LastMessage    time.Time `json:"last_message"`
        Subscriptions  int       `json:"subscriptions"`
        ReconnectCount int       `json:"reconnect_count"`
        LatestBlock    uint64    `json:"latest_block,omitempty"`
}

// startChainConnection starts monitoring a specific chain
func (c *Client) startChainConnection(chainID string, chainConn *ChainConnection) <span class="cov0" title="0">{
        defer c.wg.Done()

        c.logger.Infof("Starting connection for chain %s", chainID)

        // Start the reconnection manager with the connect function
        chainConn.reconnectMgr.Start(c.ctx, chainConn.connect)

        // Start processing events from the subscription manager
        go chainConn.processEvents(c.ctx)

        // Keep the connection alive
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                        chainConn.mu.RLock()
                        isConnected := chainConn.isConnected
                        chainConn.mu.RUnlock()

                        if isConnected </span><span class="cov0" title="0">{
                                if err := chainConn.ping(); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Warnf("Ping failed for chain %s: %v", chainID, err)
                                        chainConn.markDisconnected()
                                        // Trigger reconnection
                                        chainConn.reconnectMgr.TriggerReconnect(c.ctx, chainConn.connect)
                                }</span>
                        }
                }
        }
}

// processEvents processes events from the WebSocket connection
func (cc *ChainConnection) processEvents(ctx context.Context) <span class="cov0" title="0">{
        cc.logger.Infof("Starting event processing for chain %s", cc.chainName)

        // Start ping ticker to keep connection alive
        pingTicker := time.NewTicker(30 * time.Second)
        defer pingTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        cc.logger.Infof("Stopping event processing for chain %s", cc.chainName)
                        return</span>
                case &lt;-pingTicker.C:<span class="cov0" title="0">
                        // Send ping to keep connection alive
                        if err := cc.ping(); err != nil </span><span class="cov0" title="0">{
                                cc.logger.Errorf("Failed to ping WebSocket for chain %s: %v", cc.chainName, err)
                                cc.markDisconnected()
                                // Trigger reconnection
                                cc.reconnectMgr.TriggerReconnect(ctx, cc.connect)
                                return
                        }</span>
                default:<span class="cov0" title="0">
                        // Read WebSocket messages
                        if err := cc.readMessage(); err != nil </span><span class="cov0" title="0">{
                                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                        cc.logger.Errorf("WebSocket connection closed unexpectedly for chain %s: %v", cc.chainName, err)
                                }</span> else<span class="cov0" title="0"> {
                                        cc.logger.Debugf("WebSocket read error for chain %s: %v", cc.chainName, err)
                                }</span>
                                <span class="cov0" title="0">cc.markDisconnected()
                                // Trigger reconnection
                                cc.reconnectMgr.TriggerReconnect(ctx, cc.connect)
                                return</span>
                        }
                }
        }
}

// readMessage reads and processes a single WebSocket message
func (cc *ChainConnection) readMessage() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Set read deadline
        <span class="cov0" title="0">err := conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        if err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to set read deadline: %v", err)
        }</span>

        // Read message
        <span class="cov0" title="0">_, message, err := conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update last message time
        <span class="cov0" title="0">cc.mu.Lock()
        cc.lastMessage = time.Now()
        cc.mu.Unlock()

        // Process the message using subscription manager
        if err := cc.subManager.ProcessWebSocketMessage(message, cc.eventChan); err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to process WebSocket message for chain %s: %v", cc.chainName, err)
                // Don't return error here as we want to continue processing other messages
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// connect establishes WebSocket connection for the chain
func (cc *ChainConnection) connect() error <span class="cov0" title="0">{
        cc.logger.Infof("Connecting to chain %s WebSocket at %s", cc.chainName, cc.websocketURL)

        if cc.websocketURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket URL not configured for chain %s", cc.chainName)
        }</span>

        // Create dialer with timeout and other options
        <span class="cov0" title="0">dialer := websocket.Dialer{
                HandshakeTimeout: 10 * time.Second,
                Proxy:            http.ProxyFromEnvironment,
        }

        // Connect to WebSocket
        conn, resp, err := dialer.Dial(cc.websocketURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to connect to WebSocket %s (status: %d): %w", cc.websocketURL, resp.StatusCode, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to connect to WebSocket %s: %w", cc.websocketURL, err)</span>
        }

        // Set connection parameters for reliability
        <span class="cov0" title="0">conn.SetReadLimit(512 * 1024) // 512KB max message size
        err = conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        if err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to set read deadline: %v", err)
        }</span>
        <span class="cov0" title="0">conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                err = conn.SetReadDeadline(time.Now().Add(60 * time.Second))
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to set read deadline: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        // Set ping handler to keep connection alive
        <span class="cov0" title="0">conn.SetPingHandler(func(appData string) error </span><span class="cov0" title="0">{
                // cc.logger.Debugf("Received ping from %s", cc.chainName)
                return conn.WriteControl(websocket.PongMessage, []byte(appData), time.Now().Add(30*time.Second))
        }</span>)

        <span class="cov0" title="0">cc.mu.Lock()
        cc.wsConn = conn
        cc.isConnected = true
        cc.lastMessage = time.Now()
        cc.mu.Unlock()

        cc.logger.Infof("Successfully connected to chain %s WebSocket", cc.chainName)

        // Send subscription message for all active subscriptions
        if err := cc.sendSubscription(); err != nil </span><span class="cov0" title="0">{
                cc.logger.Errorf("Failed to send subscription for chain %s: %v", cc.chainName, err)
                // Don't fail the connection for subscription errors
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// sendSubscription sends the WebSocket subscription message for all active subscriptions
func (cc *ChainConnection) sendSubscription() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Build subscription message
        <span class="cov0" title="0">subscriptionMsg, err := cc.subManager.BuildWebSocketSubscription()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build subscription message: %w", err)
        }</span>

        // Send subscription message
        <span class="cov0" title="0">err = conn.WriteMessage(websocket.TextMessage, subscriptionMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send subscription message: %w", err)
        }</span>

        <span class="cov0" title="0">cc.logger.Infof("Sent subscription message for chain %s", cc.chainName)
        return nil</span>
}

// subscribeToContractEvents subscribes to events from a contract using ContractConfig
func (cc *ChainConnection) subscribeToContractEvents(contractConfig ContractConfig) error <span class="cov0" title="0">{
        if contractConfig.ContractType != "" </span><span class="cov0" title="0">{
                return cc.subscribeToContractWithType(contractConfig.Address, contractConfig.ContractType, contractConfig.Events)
        }</span>
        <span class="cov0" title="0">return cc.subscribeToContract(contractConfig.Address, contractConfig.Events)</span>
}

// subscribeToContractWithType subscribes to events from a contract using contract type
func (cc *ChainConnection) subscribeToContractWithType(contractAddr string, contractType ContractType, events []string) error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        for _, eventName := range events </span><span class="cov0" title="0">{
                // Add subscription using the subscription manager
                _, err := cc.subManager.AddContractSubscription(contractAddr, contractType, eventName)
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to add contract subscription for %s.%s: %v", contractType, eventName, err)
                        continue</span>
                }

                // Also add to local subscriptions for tracking
                <span class="cov0" title="0">subID := fmt.Sprintf("%s_%s_%s_%s", cc.chainID, contractAddr, contractType, eventName)
                addr := common.HexToAddress(contractAddr)

                subscription := &amp;Subscription{
                        ID:           subID,
                        ChainID:      cc.chainID,
                        ContractAddr: addr,
                        ContractType: contractType,
                        EventName:    eventName,
                        Active:       true,
                        CreatedAt:    time.Now(),
                }

                cc.subscriptions[subID] = subscription</span>
                // cc.logger.Infof("Subscribed to %s.%s events from %s on chain %s", contractType, eventName, contractAddr, cc.chainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// subscribeToContract subscribes to events from a contract (legacy method)
func (cc *ChainConnection) subscribeToContract(contractAddr string, events []string) error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        addr := common.HexToAddress(contractAddr)

        for _, eventName := range events </span><span class="cov0" title="0">{
                subID := fmt.Sprintf("%s_%s_%s", cc.chainID, contractAddr, eventName)

                query := ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        // Add event signature filtering here
                }

                subscription := &amp;Subscription{
                        ID:           subID,
                        ChainID:      cc.chainID,
                        ContractAddr: addr,
                        EventName:    eventName,
                        Query:        query,
                        Active:       true,
                        CreatedAt:    time.Now(),
                }

                cc.subscriptions[subID] = subscription
                // cc.logger.Infof("Subscribed to %s events from %s on chain %s", eventName, contractAddr, cc.chainID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getStatus returns the current status of the chain connection
func (cc *ChainConnection) getStatus() ChainStatus <span class="cov0" title="0">{
        cc.mu.RLock()
        defer cc.mu.RUnlock()

        var latestBlock uint64
        if cc.ethClient != nil </span><span class="cov0" title="0">{
                if block, err := cc.ethClient.BlockNumber(context.Background()); err == nil </span><span class="cov0" title="0">{
                        latestBlock = block
                }</span>
        }

        <span class="cov0" title="0">return ChainStatus{
                ChainID:        cc.chainID,
                ChainName:      cc.chainName,
                Connected:      cc.isConnected,
                LastMessage:    cc.lastMessage,
                Subscriptions:  len(cc.subscriptions),
                ReconnectCount: cc.reconnectMgr.GetReconnectCount(),
                LatestBlock:    latestBlock,
        }</span>
}

// ping sends a ping to keep the connection alive
func (cc *ChainConnection) ping() error <span class="cov0" title="0">{
        cc.mu.RLock()
        conn := cc.wsConn
        cc.mu.RUnlock()

        if conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("WebSocket connection not established")
        }</span>

        // Send ping with current timestamp as data
        <span class="cov0" title="0">pingData := []byte(fmt.Sprintf("ping_%d", time.Now().Unix()))
        err := conn.WriteControl(websocket.PingMessage, pingData, time.Now().Add(10*time.Second))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send ping: %w", err)
        }</span>

        // cc.logger.Debugf("Sent ping to chain %s", cc.chainName)
        <span class="cov0" title="0">return nil</span>
}

// markDisconnected marks the connection as disconnected
func (cc *ChainConnection) markDisconnected() <span class="cov0" title="0">{
        cc.mu.Lock()
        cc.isConnected = false
        cc.mu.Unlock()
}</span>

// close closes the chain connection
func (cc *ChainConnection) close() error <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        cc.isConnected = false

        if cc.wsConn != nil </span><span class="cov0" title="0">{
                err := cc.wsConn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cc.logger.Errorf("Failed to close WebSocket connection: %v", err)
                }</span>
                <span class="cov0" title="0">cc.wsConn = nil</span>
        }

        <span class="cov0" title="0">if cc.ethClient != nil </span><span class="cov0" title="0">{
                cc.ethClient.Close()
        }</span>

        // Reset reconnection count when closing
        <span class="cov0" title="0">if cc.reconnectMgr != nil </span><span class="cov0" title="0">{
                cc.reconnectMgr.resetReconnectCount()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSubscriptionStats returns statistics for all subscriptions on a chain
func (c *Client) GetSubscriptionStats(chainID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">return chainConn.subManager.GetSubscriptionStats(), nil</span>
}

// GetAllSubscriptionStats returns statistics for all chains
func (c *Client) GetAllSubscriptionStats() map[string]interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := make(map[string]interface{})
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                stats[chainID] = chainConn.subManager.GetSubscriptionStats()
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// TriggerReconnect manually triggers reconnection for a specific chain
func (c *Client) TriggerReconnect(chainID string) error <span class="cov0" title="0">{
        c.mu.RLock()
        chainConn, exists := c.chains[chainID]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("chain %s not found", chainID)
        }</span>

        <span class="cov0" title="0">chainConn.logger.Infof("Manual reconnection triggered for chain %s", chainID)
        chainConn.reconnectMgr.TriggerReconnect(c.ctx, chainConn.connect)
        return nil</span>
}

// GetReconnectStats returns reconnection statistics for all chains
func (c *Client) GetReconnectStats() map[string]interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := make(map[string]interface{})
        for chainID, chainConn := range c.chains </span><span class="cov0" title="0">{
                stats[chainID] = map[string]interface{}{
                        "reconnect_count": chainConn.reconnectMgr.GetReconnectCount(),
                        "is_running":      chainConn.reconnectMgr.IsRunning(),
                        "config":          chainConn.reconnectMgr.GetConfig(),
                }
        }</span>

        <span class="cov0" title="0">return stats</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">package websocket

import (
        "context"
        "math"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// ReconnectManager handles WebSocket reconnection logic
type ReconnectManager struct {
        url            string
        logger         logging.Logger
        reconnectCount int
        maxRetries     int
        baseDelay      time.Duration
        maxDelay       time.Duration
        backoffFactor  float64
        jitter         bool
        mu             sync.RWMutex
        isRunning      bool
}

// ReconnectConfig holds reconnection configuration
type ReconnectConfig struct {
        MaxRetries    int           `default:"10"`
        BaseDelay     time.Duration `default:"5s"`
        MaxDelay      time.Duration `default:"300s"` // 5 minutes
        BackoffFactor float64       `default:"2.0"`
        Jitter        bool          `default:"true"`
}

// NewReconnectManager creates a new reconnection manager
func NewReconnectManager(url string, logger logging.Logger) *ReconnectManager <span class="cov0" title="0">{
        return &amp;ReconnectManager{
                url:           url,
                logger:        logger,
                maxRetries:    10,
                baseDelay:     5 * time.Second,
                maxDelay:      5 * time.Minute,
                backoffFactor: 2.0,
                jitter:        true,
        }
}</span>

// NewReconnectManagerWithConfig creates a new reconnection manager with custom config
func NewReconnectManagerWithConfig(url string, config ReconnectConfig, logger logging.Logger) *ReconnectManager <span class="cov0" title="0">{
        rm := NewReconnectManager(url, logger)

        if config.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                rm.maxRetries = config.MaxRetries
        }</span>
        <span class="cov0" title="0">if config.BaseDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.baseDelay = config.BaseDelay
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.maxDelay = config.MaxDelay
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &gt; 0 </span><span class="cov0" title="0">{
                rm.backoffFactor = config.BackoffFactor
        }</span>
        <span class="cov0" title="0">rm.jitter = config.Jitter

        return rm</span>
}

// Start begins the reconnection process
func (rm *ReconnectManager) Start(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        rm.mu.Lock()
        if rm.isRunning </span><span class="cov0" title="0">{
                rm.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">rm.isRunning = true
        rm.mu.Unlock()

        defer func() </span><span class="cov0" title="0">{
                rm.mu.Lock()
                rm.isRunning = false
                rm.mu.Unlock()
        }</span>()

        // Initial connection attempt
        <span class="cov0" title="0">if err := connectFunc(); err != nil </span><span class="cov0" title="0">{
                rm.logger.Errorf("Initial connection failed: %v", err)
                rm.startReconnectionLoop(ctx, connectFunc)
        }</span> else<span class="cov0" title="0"> {
                rm.logger.Info("Initial connection successful")
                rm.resetReconnectCount()
        }</span>
}

// startReconnectionLoop handles the reconnection attempts with exponential backoff
func (rm *ReconnectManager) startReconnectionLoop(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        rm.logger.Info("Reconnection cancelled by context")
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if rm.maxRetries &gt; 0 &amp;&amp; rm.GetReconnectCount() &gt;= rm.maxRetries </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Max reconnection attempts (%d) reached for %s", rm.maxRetries, rm.url)
                        return
                }</span>

                <span class="cov0" title="0">delay := rm.calculateDelay()
                rm.logger.Warnf("Reconnecting to %s in %v (attempt %d/%d)",
                        rm.url, delay, rm.GetReconnectCount()+1, rm.maxRetries)

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">rm.incrementReconnectCount()

                if err := connectFunc(); err != nil </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Reconnection attempt %d failed: %v", rm.GetReconnectCount(), err)
                        continue</span>
                }

                <span class="cov0" title="0">rm.logger.Infof("Reconnection successful after %d attempts", rm.GetReconnectCount())
                rm.resetReconnectCount()
                return</span>
        }
}

// calculateDelay calculates the delay for the next reconnection attempt
func (rm *ReconnectManager) calculateDelay() time.Duration <span class="cov0" title="0">{
        attempts := rm.GetReconnectCount()

        // Exponential backoff: baseDelay * (backoffFactor ^ attempts)
        delay := time.Duration(float64(rm.baseDelay) * math.Pow(rm.backoffFactor, float64(attempts)))

        // Cap at maxDelay
        if delay &gt; rm.maxDelay </span><span class="cov0" title="0">{
                delay = rm.maxDelay
        }</span>

        // Add jitter if enabled (±25% randomization)
        <span class="cov0" title="0">if rm.jitter </span><span class="cov0" title="0">{
                jitterRange := float64(delay) * 0.25
                jitterOffset := (2.0*time.Now().UnixNano()%int64(jitterRange) - int64(jitterRange)) / int64(time.Nanosecond)
                delay += time.Duration(jitterOffset)

                // Ensure delay is not negative
                if delay &lt; 0 </span><span class="cov0" title="0">{
                        delay = rm.baseDelay
                }</span>
        }

        <span class="cov0" title="0">return delay</span>
}

// GetReconnectCount returns the current reconnection count
func (rm *ReconnectManager) GetReconnectCount() int <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.reconnectCount
}</span>

// incrementReconnectCount increments the reconnection counter
func (rm *ReconnectManager) incrementReconnectCount() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.reconnectCount++
}</span>

// resetReconnectCount resets the reconnection counter
func (rm *ReconnectManager) resetReconnectCount() <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        rm.reconnectCount = 0
}</span>

// TriggerReconnect manually triggers a reconnection
func (rm *ReconnectManager) TriggerReconnect(ctx context.Context, connectFunc func() error) <span class="cov0" title="0">{
        rm.logger.Info("Manual reconnection triggered")
        go rm.startReconnectionLoop(ctx, connectFunc)
}</span>

// IsRunning returns whether the reconnection manager is currently running
func (rm *ReconnectManager) IsRunning() bool <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()
        return rm.isRunning
}</span>

// UpdateConfig updates the reconnection configuration
func (rm *ReconnectManager) UpdateConfig(config ReconnectConfig) <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if config.MaxRetries &gt; 0 </span><span class="cov0" title="0">{
                rm.maxRetries = config.MaxRetries
        }</span>
        <span class="cov0" title="0">if config.BaseDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.baseDelay = config.BaseDelay
        }</span>
        <span class="cov0" title="0">if config.MaxDelay &gt; 0 </span><span class="cov0" title="0">{
                rm.maxDelay = config.MaxDelay
        }</span>
        <span class="cov0" title="0">if config.BackoffFactor &gt; 0 </span><span class="cov0" title="0">{
                rm.backoffFactor = config.BackoffFactor
        }</span>
        <span class="cov0" title="0">rm.jitter = config.Jitter

        rm.logger.Info("Reconnection configuration updated")</span>
}

// GetConfig returns the current reconnection configuration
func (rm *ReconnectManager) GetConfig() ReconnectConfig <span class="cov0" title="0">{
        rm.mu.RLock()
        defer rm.mu.RUnlock()

        return ReconnectConfig{
                MaxRetries:    rm.maxRetries,
                BaseDelay:     rm.baseDelay,
                MaxDelay:      rm.maxDelay,
                BackoffFactor: rm.backoffFactor,
                Jitter:        rm.jitter,
        }
}</span>
</pre>
		
		<pre class="file" id="file191" style="display: none">package websocket

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/ethereum/go-ethereum"
        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"

        // Contract bindings
        contractAttestationCenter "github.com/trigg3rX/triggerx-contracts/bindings/contracts/AttestationCenter"
)

// ContractType represents the type of contract
type ContractType string

const (
        ContractTypeAttestationCenter ContractType = "attestation_center"
)

// ContractConfig represents a contract to monitor
type ContractConfig struct {
        Address      string
        ContractType ContractType
        ABI          string
        Events       []string // Event names to monitor
}

// ChainConfig represents configuration for a specific blockchain
type ChainConfig struct {
        ChainID      string
        Name         string
        RPCURL       string
        WebSocketURL string
        Contracts    []ContractConfig
        Reconnect    ReconnectConfig
}

// SubscriptionManager manages WebSocket event subscriptions for a chain
type SubscriptionManager struct {
        chainID       string
        subscriptions map[string]*EventSubscription
        eventFilters  map[string][]common.Hash // event name -&gt; topic hashes
        contractABIs  map[ContractType]abi.ABI
        logger        logging.Logger
        mu            sync.RWMutex
}

// EventSubscription represents a single event subscription
type EventSubscription struct {
        ID           string
        ChainID      string
        ContractAddr common.Address
        ContractType ContractType
        EventName    string
        EventSig     common.Hash
        FilterQuery  ethereum.FilterQuery
        Active       bool
        CreatedAt    time.Time
        LastEvent    time.Time
        EventCount   uint64
}

// ContractABI represents the ABI for a contract
type ContractABI struct {
        Address string           `json:"address"`
        Events  map[string]Event `json:"events"`
}

// Event represents an ABI event definition
type Event struct {
        Name      string       `json:"name"`
        Signature string       `json:"signature"`
        Inputs    []EventInput `json:"inputs"`
}

// EventInput represents an event input parameter
type EventInput struct {
        Name    string `json:"name"`
        Type    string `json:"type"`
        Indexed bool   `json:"indexed"`
}

// WebSocketMessage represents incoming WebSocket messages
type WebSocketMessage struct {
        ID     int         `json:"id"`
        Method string      `json:"method"`
        Params interface{} `json:"params"`
}

// SubscriptionResult represents a subscription result
type SubscriptionResult struct {
        Subscription string      `json:"subscription"`
        Result       interface{} `json:"result"`
}

// LogsSubscription represents the logs subscription parameters
type LogsSubscription struct {
        Address []string   `json:"address,omitempty"`
        Topics  [][]string `json:"topics,omitempty"`
}

// ContractEventData represents parsed contract event data
type ContractEventData struct {
        EventType    string                 `json:"event_type"`
        ContractType ContractType           `json:"contract_type"`
        ParsedData   map[string]interface{} `json:"parsed_data"`
        RawData      []byte                 `json:"raw_data"`
        Topics       []string               `json:"topics"`
        BlockNumber  uint64                 `json:"block_number"`
        TxHash       string                 `json:"tx_hash"`
        LogIndex     uint                   `json:"log_index"`
}

// NewSubscriptionManager creates a new subscription manager
func NewSubscriptionManager(chainID string, logger logging.Logger) *SubscriptionManager <span class="cov0" title="0">{
        sm := &amp;SubscriptionManager{
                chainID:       chainID,
                subscriptions: make(map[string]*EventSubscription),
                eventFilters:  make(map[string][]common.Hash),
                contractABIs:  make(map[ContractType]abi.ABI),
                logger:        logger,
        }

        // Initialize contract ABIs
        sm.initializeContractABIs()

        return sm
}</span>

// initializeContractABIs initializes the contract ABIs
func (sm *SubscriptionManager) initializeContractABIs() <span class="cov0" title="0">{
        // Initialize AttestationCenter ABI
        if attestationCenterABI, err := contractAttestationCenter.ContractAttestationCenterMetaData.GetAbi(); err == nil </span><span class="cov0" title="0">{
                sm.contractABIs[ContractTypeAttestationCenter] = *attestationCenterABI
        }</span> else<span class="cov0" title="0"> {
                sm.logger.Errorf("Failed to initialize AttestationCenter ABI: %v", err)
        }</span>
}

// AddContractSubscription adds a new contract event subscription
func (sm *SubscriptionManager) AddContractSubscription(contractAddr string, contractType ContractType, eventName string) (*EventSubscription, error) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Get the ABI for the contract
        contractABI, exists := sm.contractABIs[contractType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("contract type %s not found", contractType)
        }</span>

        // Get the event from the ABI
        <span class="cov0" title="0">event, exists := contractABI.Events[eventName]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event %s not found in contract %s", eventName, contractType)
        }</span>

        // Generate unique subscription ID
        <span class="cov0" title="0">subID := sm.generateSubscriptionID()

        addr := common.HexToAddress(contractAddr)
        eventSig := event.ID

        subscription := &amp;EventSubscription{
                ID:           subID,
                ChainID:      sm.chainID,
                ContractAddr: addr,
                ContractType: contractType,
                EventName:    eventName,
                EventSig:     eventSig,
                FilterQuery: ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        Topics:    [][]common.Hash{{eventSig}},
                },
                Active:    true,
                CreatedAt: time.Now(),
        }

        sm.subscriptions[subID] = subscription

        // Add to event filters
        if sm.eventFilters[eventName] == nil </span><span class="cov0" title="0">{
                sm.eventFilters[eventName] = make([]common.Hash, 0)
        }</span>
        <span class="cov0" title="0">sm.eventFilters[eventName] = append(sm.eventFilters[eventName], eventSig)

        // sm.logger.Infof("Added subscription %s for %s.%s events from %s on chain %s",
        //         subID, contractType, eventName, contractAddr, sm.chainID)

        return subscription, nil</span>
}

// AddEventSubscription adds a new event subscription (legacy method)
func (sm *SubscriptionManager) AddEventSubscription(contractAddr string, eventName string, eventSig string) (*EventSubscription, error) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        // Generate unique subscription ID
        subID := sm.generateSubscriptionID()

        addr := common.HexToAddress(contractAddr)
        sigHash := crypto.Keccak256Hash([]byte(eventSig))

        subscription := &amp;EventSubscription{
                ID:           subID,
                ChainID:      sm.chainID,
                ContractAddr: addr,
                EventName:    eventName,
                EventSig:     sigHash,
                FilterQuery: ethereum.FilterQuery{
                        Addresses: []common.Address{addr},
                        Topics:    [][]common.Hash{{sigHash}},
                },
                Active:    true,
                CreatedAt: time.Now(),
        }

        sm.subscriptions[subID] = subscription

        // Add to event filters
        if sm.eventFilters[eventName] == nil </span><span class="cov0" title="0">{
                sm.eventFilters[eventName] = make([]common.Hash, 0)
        }</span>
        <span class="cov0" title="0">sm.eventFilters[eventName] = append(sm.eventFilters[eventName], sigHash)

        // sm.logger.Infof("Added subscription %s for %s events from %s on chain %s",
        //         subID, eventName, contractAddr, sm.chainID)

        return subscription, nil</span>
}

// RemoveSubscription removes an event subscription
func (sm *SubscriptionManager) RemoveSubscription(subID string) error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        subscription, exists := sm.subscriptions[subID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("subscription %s not found", subID)
        }</span>

        <span class="cov0" title="0">subscription.Active = false
        delete(sm.subscriptions, subID)

        // sm.logger.Infof("Removed subscription %s for %s events on chain %s",
        //         subID, subscription.EventName, sm.chainID)

        return nil</span>
}

// GetActiveSubscriptions returns all active subscriptions
func (sm *SubscriptionManager) GetActiveSubscriptions() map[string]*EventSubscription <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        active := make(map[string]*EventSubscription)
        for id, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        active[id] = sub
                }</span>
        }
        <span class="cov0" title="0">return active</span>
}

// BuildWebSocketSubscription creates a WebSocket subscription message
func (sm *SubscriptionManager) BuildWebSocketSubscription() ([]byte, error) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        // Collect all contract addresses and topics
        addresses := make(map[common.Address]bool)
        var allTopics []common.Hash

        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        addresses[sub.ContractAddr] = true
                        allTopics = append(allTopics, sub.EventSig)
                }</span>
        }

        // Convert to string arrays for JSON
        <span class="cov0" title="0">addressStrings := make([]string, 0, len(addresses))
        for addr := range addresses </span><span class="cov0" title="0">{
                addressStrings = append(addressStrings, addr.Hex())
        }</span>

        <span class="cov0" title="0">topicStrings := make([]string, 0, len(allTopics))
        for _, topic := range allTopics </span><span class="cov0" title="0">{
                topicStrings = append(topicStrings, topic.Hex())
        }</span>

        // Build subscription parameters
        <span class="cov0" title="0">params := map[string]interface{}{
                "id":     1,
                "method": "eth_subscribe",
                "params": []interface{}{
                        "logs",
                        LogsSubscription{
                                Address: addressStrings,
                                Topics:  [][]string{topicStrings},
                        },
                },
        }

        return json.Marshal(params)</span>
}

// ProcessWebSocketMessage processes incoming WebSocket messages
func (sm *SubscriptionManager) ProcessWebSocketMessage(data []byte, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        var msg WebSocketMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal WebSocket message: %w", err)
        }</span>

        // Handle subscription notifications
        <span class="cov0" title="0">if msg.Method == "eth_subscription" </span><span class="cov0" title="0">{
                return sm.processSubscriptionNotification(msg.Params, eventChan)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSubscriptionStats returns statistics for all subscriptions
func (sm *SubscriptionManager) GetSubscriptionStats() map[string]interface{} <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        stats := map[string]interface{}{
                "chain_id":             sm.chainID,
                "total_subscriptions":  len(sm.subscriptions),
                "active_subscriptions": 0,
                "subscriptions":        make([]map[string]interface{}, 0),
        }

        activeCount := 0
        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active </span><span class="cov0" title="0">{
                        activeCount++
                }</span>

                <span class="cov0" title="0">subStats := map[string]interface{}{
                        "id":          sub.ID,
                        "event_name":  sub.EventName,
                        "contract":    sub.ContractAddr.Hex(),
                        "active":      sub.Active,
                        "created_at":  sub.CreatedAt,
                        "last_event":  sub.LastEvent,
                        "event_count": sub.EventCount,
                }

                stats["subscriptions"] = append(stats["subscriptions"].([]map[string]interface{}), subStats)</span>
        }

        <span class="cov0" title="0">stats["active_subscriptions"] = activeCount
        return stats</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package websocket

import (
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math/big"
        "crypto/rand"
        "time"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
)

// processSubscriptionNotification processes subscription notification messages
func (sm *SubscriptionManager) processSubscriptionNotification(params interface{}, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        paramsMap, ok := params.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid subscription params format")
        }</span>

        <span class="cov0" title="0">result, ok := paramsMap["result"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no result in subscription notification")
        }</span>

        // Parse the log entry
        <span class="cov0" title="0">logData, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal log data: %w", err)
        }</span>

        <span class="cov0" title="0">var log types.Log
        if err := json.Unmarshal(logData, &amp;log); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal log: %w", err)
        }</span>

        // Process the log entry
        <span class="cov0" title="0">return sm.processLogEntry(log, eventChan)</span>
}

// processLogEntry processes a single log entry and routes it to the appropriate handler
func (sm *SubscriptionManager) processLogEntry(log types.Log, eventChan chan&lt;- *ChainEvent) error <span class="cov0" title="0">{
        if len(log.Topics) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("log entry has no topics")
        }</span>

        <span class="cov0" title="0">eventSig := log.Topics[0]

        // Find matching subscription
        sm.mu.RLock()
        var matchedSub *EventSubscription
        for _, sub := range sm.subscriptions </span><span class="cov0" title="0">{
                if sub.Active &amp;&amp; sub.EventSig == eventSig &amp;&amp; sub.ContractAddr == log.Address </span><span class="cov0" title="0">{
                        matchedSub = sub
                        break</span>
                }
        }
        <span class="cov0" title="0">sm.mu.RUnlock()

        if matchedSub == nil </span><span class="cov0" title="0">{
                sm.logger.Debugf("No subscription found for event %s from %s", eventSig.Hex(), log.Address.Hex())
                return nil
        }</span>

        // Update subscription stats
        <span class="cov0" title="0">sm.updateSubscriptionStats(matchedSub.ID)

        // Create chain event
        chainEvent := &amp;ChainEvent{
                ChainID:      sm.chainID,
                ChainName:    sm.getChainName(sm.chainID),
                ContractAddr: log.Address.Hex(),
                ContractType: matchedSub.ContractType,
                EventName:    matchedSub.EventName,
                BlockNumber:  log.BlockNumber,
                TxHash:       log.TxHash.Hex(),
                LogIndex:     log.Index,
                Data:         sm.parseEventData(matchedSub, log),
                RawLog:       log,
                ProcessedAt:  time.Now(),
        }

        // Send to event channel (non-blocking)
        select </span>{
        case eventChan &lt;- chainEvent:<span class="cov0" title="0">
                sm.logger.Debugf("Processed %s event from %s at block %d",
                        matchedSub.EventName, log.Address.Hex(), log.BlockNumber)</span>
        default:<span class="cov0" title="0">
                sm.logger.Warnf("Event channel full, dropping event %s from %s",
                        matchedSub.EventName, log.Address.Hex())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parseEventData parses event data based on the contract type and event
func (sm *SubscriptionManager) parseEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        // Check if we have a contract type for proper parsing
        if sub.ContractType != "" </span><span class="cov0" title="0">{
                return sm.parseContractEventData(sub, log)
        }</span>

        // Fallback to basic parsing for legacy subscriptions
        <span class="cov0" title="0">eventData := map[string]interface{}{
                "event_signature": sub.EventSig.Hex(),
                "topics":          make([]string, len(log.Topics)),
                "data":            log.Data,
                "block_number":    log.BlockNumber,
                "tx_hash":         log.TxHash.Hex(),
                "log_index":       log.Index,
        }

        for i, topic := range log.Topics </span><span class="cov0" title="0">{
                eventData["topics"].([]string)[i] = topic.Hex()
        }</span>

        <span class="cov0" title="0">return eventData</span>
}

// parseContractEventData parses contract event data using the proper ABI
func (sm *SubscriptionManager) parseContractEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        contractABI, exists := sm.contractABIs[sub.ContractType]
        if !exists </span><span class="cov0" title="0">{
                sm.logger.Errorf("Contract ABI not found for type %s", sub.ContractType)
                return sm.parseBasicEventData(sub, log)
        }</span>

        <span class="cov0" title="0">event, exists := contractABI.Events[sub.EventName]
        if !exists </span><span class="cov0" title="0">{
                sm.logger.Errorf("Event %s not found in contract %s ABI", sub.EventName, sub.ContractType)
                return sm.parseBasicEventData(sub, log)
        }</span>

        // Parse the event data
        <span class="cov0" title="0">parsedData := make(map[string]interface{})

        // Parse indexed parameters from topics
        topicIndex := 1 // Skip the event signature (topics[0])
        for _, input := range event.Inputs </span><span class="cov0" title="0">{
                if input.Indexed </span><span class="cov0" title="0">{
                        if topicIndex &lt; len(log.Topics) </span><span class="cov0" title="0">{
                                parsedData[input.Name] = sm.parseTopicData(input, log.Topics[topicIndex])
                                topicIndex++
                        }</span>
                }
        }

        // Parse non-indexed parameters from data
        <span class="cov0" title="0">if len(log.Data) &gt; 0 </span><span class="cov0" title="0">{
                nonIndexedInputs := make([]abi.Argument, 0)
                for _, input := range event.Inputs </span><span class="cov0" title="0">{
                        if !input.Indexed </span><span class="cov0" title="0">{
                                nonIndexedInputs = append(nonIndexedInputs, input)
                        }</span>
                }

                <span class="cov0" title="0">if len(nonIndexedInputs) &gt; 0 </span><span class="cov0" title="0">{
                        values, err := contractABI.Unpack(sub.EventName, log.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Errorf("Failed to unpack event data for %s: %v", sub.EventName, err)
                        }</span> else<span class="cov0" title="0"> {
                                for i, input := range nonIndexedInputs </span><span class="cov0" title="0">{
                                        if i &lt; len(values) </span><span class="cov0" title="0">{
                                                parsedData[input.Name] = sm.formatValue(values[i])
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return &amp;ContractEventData{
                EventType:    sub.EventName,
                ContractType: sub.ContractType,
                ParsedData:   parsedData,
                RawData:      log.Data,
                Topics:       sm.formatTopics(log.Topics),
                BlockNumber:  log.BlockNumber,
                TxHash:       log.TxHash.Hex(),
                LogIndex:     log.Index,
        }</span>
}

// parseBasicEventData provides basic event data parsing as fallback
func (sm *SubscriptionManager) parseBasicEventData(sub *EventSubscription, log types.Log) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "event_type":      sub.EventName,
                "contract_type":   sub.ContractType,
                "event_signature": sub.EventSig.Hex(),
                "topics":          sm.formatTopics(log.Topics),
                "data":            hex.EncodeToString(log.Data),
                "block_number":    log.BlockNumber,
                "tx_hash":         log.TxHash.Hex(),
                "log_index":       log.Index,
        }
}</span>

// parseTopicData parses topic data based on the input type
func (sm *SubscriptionManager) parseTopicData(input abi.Argument, topic common.Hash) interface{} <span class="cov0" title="0">{
        switch input.Type.String() </span>{
        case "address":<span class="cov0" title="0">
                return common.HexToAddress(topic.Hex()).Hex()</span>
        case "uint256", "uint128", "uint64", "uint32", "uint16", "uint8":<span class="cov0" title="0">
                return new(big.Int).SetBytes(topic.Bytes()).String()</span>
        case "int256", "int128", "int64", "int32", "int16", "int8":<span class="cov0" title="0">
                // For signed integers, we need to handle two's complement
                value := new(big.Int).SetBytes(topic.Bytes())
                if value.Bit(255) == 1 </span><span class="cov0" title="0">{ // Check if the sign bit is set
                        // Convert from two's complement
                        max := new(big.Int).Lsh(big.NewInt(1), 256)
                        value.Sub(value, max)
                }</span>
                <span class="cov0" title="0">return value.String()</span>
        case "bytes32":<span class="cov0" title="0">
                return topic.Hex()</span>
        case "bool":<span class="cov0" title="0">
                return topic.Big().Cmp(big.NewInt(0)) != 0</span>
        default:<span class="cov0" title="0">
                return topic.Hex()</span>
        }
}

// formatValue formats values for JSON serialization
func (sm *SubscriptionManager) formatValue(value interface{}) interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case *big.Int:<span class="cov0" title="0">
                return v.String()</span>
        case common.Address:<span class="cov0" title="0">
                return v.Hex()</span>
        case common.Hash:<span class="cov0" title="0">
                return v.Hex()</span>
        case []byte:<span class="cov0" title="0">
                return hex.EncodeToString(v)</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

// formatTopics formats topic slice for JSON serialization
func (sm *SubscriptionManager) formatTopics(topics []common.Hash) []string <span class="cov0" title="0">{
        result := make([]string, len(topics))
        for i, topic := range topics </span><span class="cov0" title="0">{
                result[i] = topic.Hex()
        }</span>
        <span class="cov0" title="0">return result</span>
}

// updateSubscriptionStats updates statistics for a subscription
func (sm *SubscriptionManager) updateSubscriptionStats(subID string) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        if sub, exists := sm.subscriptions[subID]; exists </span><span class="cov0" title="0">{
                sub.EventCount++
                sub.LastEvent = time.Now()
        }</span>
}

// generateSubscriptionID generates a unique subscription ID
func (sm *SubscriptionManager) generateSubscriptionID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Errorf("Failed to generate subscription ID: %v", err)
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s_%s", sm.chainID, hex.EncodeToString(bytes))</span>
}

// getChainName returns a human-readable chain name
func (sm *SubscriptionManager) getChainName(chainID string) string <span class="cov0" title="0">{
        chainNames := map[string]string{
                "17000":    "Ethereum Holesky",
                "11155111": "Ethereum Sepolia",
                "11155420": "Optimism Sepolia",
                "84532":    "Base Sepolia",
        }

        if name, exists := chainNames[chainID]; exists </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Chain %s", chainID)</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/joho/godotenv"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/env"
)

type Config struct {
        devMode bool

        // Task Monitor RPC port
        taskMonitorRPCPort string

        // Contract Addresses to listen for events
        attestationCenterAddress string

        // RPC URLs for Ethereum and Base
        rpcProvider string
        rpcAPIKey   string

        // ScyllaDB Host and Port
        databaseHostAddress string
        databaseHostPort    string

        // Upstash Redis URL and Rest Token
        upstashRedisUrl       string
        upstashRedisRestToken string

        // Sync Configs Update
        lastBaseBlockUpdated uint64

        // Pinata JWT and Host
        pinataJWT  string
        pinataHost string

        // OpenTelemetry endpoint
        ottempoEndpoint string

        // Common settings
        poolSize     int
        minIdleConns int
        maxRetries   int

        // Timeout settings
        dialTimeout  time.Duration
        readTimeout  time.Duration
        writeTimeout time.Duration
        poolTimeout  time.Duration

        // Stream settings
        streamMaxLen    int
        jobStreamTTL    time.Duration
        taskStreamTTL   time.Duration
        cacheTTL        time.Duration
        cleanupInterval time.Duration

        // Metrics settings
        metricsUpdateInterval time.Duration

        // Timeout and retry settings
        retryDelay            time.Duration
        requestTimeout        time.Duration
        initializationTimeout time.Duration
        maxRetryBackoff       time.Duration
}

var cfg Config

func Init() error <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading .env file: %w", err)
        }</span>
        <span class="cov0" title="0">cfg = Config{
                devMode:                  env.GetEnvBool("DEV_MODE", false),
                taskMonitorRPCPort:       env.GetEnvString("TASK_MONITOR_RPC_PORT", "9003"),
                attestationCenterAddress: env.GetEnvString("ATTESTATION_CENTER_ADDRESS", ""),
                rpcProvider:              env.GetEnvString("RPC_PROVIDER", ""),
                rpcAPIKey:                env.GetEnvString("RPC_API_KEY", ""),
                databaseHostAddress:      env.GetEnvString("DATABASE_HOST_ADDRESS", ""),
                databaseHostPort:         env.GetEnvString("DATABASE_HOST_PORT", ""),
                upstashRedisUrl:          env.GetEnvString("UPSTASH_REDIS_URL", ""),
                upstashRedisRestToken:    env.GetEnvString("UPSTASH_REDIS_REST_TOKEN", ""),
                pinataJWT:                env.GetEnvString("PINATA_JWT", ""),
                pinataHost:               env.GetEnvString("PINATA_HOST", ""),
                poolSize:                 env.GetEnvInt("REDIS_POOL_SIZE", 10),
                minIdleConns:             env.GetEnvInt("REDIS_MIN_IDLE_CONNS", 2),
                maxRetries:               env.GetEnvInt("REDIS_MAX_RETRIES", 3),
                dialTimeout:              env.GetEnvDuration("REDIS_DIAL_TIMEOUT", 5*time.Second),
                readTimeout:              env.GetEnvDuration("REDIS_READ_TIMEOUT", 3*time.Second),
                writeTimeout:             env.GetEnvDuration("REDIS_WRITE_TIMEOUT", 3*time.Second),
                poolTimeout:              env.GetEnvDuration("REDIS_POOL_TIMEOUT", 4*time.Second),
                streamMaxLen:             env.GetEnvInt("REDIS_STREAM_MAX_LEN", 10000),
                jobStreamTTL:             env.GetEnvDuration("REDIS_JOB_STREAM_TTL", 120*time.Hour),
                taskStreamTTL:            env.GetEnvDuration("REDIS_TASK_STREAM_TTL", 1*time.Hour),
                cacheTTL:                 env.GetEnvDuration("REDIS_CACHE_TTL", 24*time.Hour),
                cleanupInterval:          env.GetEnvDuration("REDIS_CLEANUP_INTERVAL", 10*time.Minute),
                metricsUpdateInterval:    env.GetEnvDuration("REDIS_METRICS_UPDATE_INTERVAL", 30*time.Second),
                retryDelay:               env.GetEnvDuration("REDIS_RETRY_DELAY", 2*time.Second),
                requestTimeout:           env.GetEnvDuration("REDIS_REQUEST_TIMEOUT", 10*time.Second),
                initializationTimeout:    env.GetEnvDuration("REDIS_INITIALIZATION_TIMEOUT", 10*time.Second),
                maxRetryBackoff:          env.GetEnvDuration("REDIS_MAX_RETRY_BACKOFF", 5*time.Minute),
                ottempoEndpoint:          env.GetEnvString("TEMPO_OTLP_ENDPOINT", "localhost:4318"),
        }

        if !cfg.devMode </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func IsDevMode() bool <span class="cov0" title="0">{
        return cfg.devMode
}</span>

func GetDatabaseHostAddress() string <span class="cov0" title="0">{
        return cfg.databaseHostAddress
}</span>

func GetDatabaseHostPort() string <span class="cov0" title="0">{
        return cfg.databaseHostPort
}</span>

func SetLastBaseBlockUpdated(blockNumber uint64) <span class="cov0" title="0">{
        cfg.lastBaseBlockUpdated = blockNumber
}</span>

func GetLastBaseBlockUpdated() uint64 <span class="cov0" title="0">{
        return cfg.lastBaseBlockUpdated
}</span>

func GetAttestationCenterAddress() string <span class="cov0" title="0">{
        return cfg.attestationCenterAddress
}</span>

func GetRPCProvider() string <span class="cov0" title="0">{
        return cfg.rpcProvider
}</span>

func GetRPCAPIKey() string <span class="cov0" title="0">{
        return cfg.rpcAPIKey
}</span>

func GetPinataHost() string <span class="cov0" title="0">{
        return cfg.pinataHost
}</span>

func GetPinataJWT() string <span class="cov0" title="0">{
        return cfg.pinataJWT
}</span>

func GetTaskMonitorRPCPort() string <span class="cov0" title="0">{
        return cfg.taskMonitorRPCPort
}</span>

func GetUpstashRedisUrl() string <span class="cov0" title="0">{
        return cfg.upstashRedisUrl
}</span>

func GetUpstashRedisRestToken() string <span class="cov0" title="0">{
        return cfg.upstashRedisRestToken
}</span>

func GetStreamMaxLen() int <span class="cov0" title="0">{
        return cfg.streamMaxLen
}</span>

func GetJobStreamTTL() time.Duration <span class="cov0" title="0">{
        return cfg.jobStreamTTL
}</span>

func GetTaskStreamTTL() time.Duration <span class="cov0" title="0">{
        return cfg.taskStreamTTL
}</span>

func GetPoolSize() int <span class="cov0" title="0">{
        return cfg.poolSize
}</span>

func GetMinIdleConns() int <span class="cov0" title="0">{
        return cfg.minIdleConns
}</span>

func GetMaxRetries() int <span class="cov0" title="0">{
        return cfg.maxRetries
}</span>

func GetDialTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.dialTimeout
}</span>

func GetReadTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.readTimeout
}</span>

func GetWriteTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.writeTimeout
}</span>

func GetPoolTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.poolTimeout
}</span>

func GetCacheTTL() time.Duration <span class="cov0" title="0">{
        return cfg.cacheTTL
}</span>

func GetCleanupInterval() time.Duration <span class="cov0" title="0">{
        return cfg.cleanupInterval
}</span>

func GetMetricsUpdateInterval() time.Duration <span class="cov0" title="0">{
        return cfg.metricsUpdateInterval
}</span>

func GetRetryDelay() time.Duration <span class="cov0" title="0">{
        return cfg.retryDelay
}</span>

func GetRequestTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.requestTimeout
}</span>

func GetInitializationTimeout() time.Duration <span class="cov0" title="0">{
        return cfg.initializationTimeout
}</span>

func GetMaxRetryBackoff() time.Duration <span class="cov0" title="0">{
        return cfg.maxRetryBackoff
}</span>

func GetOTTempoEndpoint() string <span class="cov0" title="0">{
        return cfg.ottempoEndpoint
}</span>

// GetRedisClientConfig returns a RedisConfig for the new Redis client
func GetRedisClientConfig() redisClient.RedisConfig <span class="cov0" title="0">{
        return redisClient.RedisConfig{
                UpstashConfig: redisClient.UpstashConfig{
                        URL:   cfg.upstashRedisUrl,
                        Token: cfg.upstashRedisRestToken,
                },
                ConnectionSettings: redisClient.ConnectionSettings{
                        PoolSize:         cfg.poolSize,
                        MaxIdleConns:     0, // Let Redis client manage this
                        MinIdleConns:     cfg.minIdleConns,
                        MaxRetries:       cfg.maxRetries,
                        DialTimeout:      cfg.dialTimeout,
                        ReadTimeout:      cfg.readTimeout,
                        WriteTimeout:     cfg.writeTimeout,
                        PoolTimeout:      cfg.poolTimeout,
                        PingTimeout:      2 * time.Second,  // Default ping timeout
                        HealthTimeout:    5 * time.Second,  // Default health check timeout
                        OperationTimeout: 10 * time.Second, // Default operation timeout
                },
        }
}</span>

// Get Chain Configs
func GetChainRPCUrl(isRPC bool, chainID string) string <span class="cov0" title="0">{
        var protocol string
        if isRPC </span><span class="cov0" title="0">{
                protocol = "https://"
        }</span> else<span class="cov0" title="0"> {
                protocol = "wss://"
        }</span>
        <span class="cov0" title="0">var domain string
        if cfg.rpcProvider == "alchemy" </span><span class="cov0" title="0">{
                switch chainID </span>{
                case "17000":<span class="cov0" title="0">
                        domain = "eth-holesky.g.alchemy.com/v2/"</span>
                case "11155111":<span class="cov0" title="0">
                        domain = "eth-sepolia.g.alchemy.com/v2/"</span>
                case "11155420":<span class="cov0" title="0">
                        domain = "opt-sepolia.g.alchemy.com/v2/"</span>
                case "84532":<span class="cov0" title="0">
                        domain = "base-sepolia.g.alchemy.com/v2/"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }
        <span class="cov0" title="0">if cfg.rpcProvider == "blast" </span><span class="cov0" title="0">{
                switch chainID </span>{
                case "17000":<span class="cov0" title="0">
                        domain = "eth-holesky.blastapi.io/"</span>
                case "11155111":<span class="cov0" title="0">
                        domain = "eth-sepolia.blastapi.io/"</span>
                case "11155420":<span class="cov0" title="0">
                        domain = "optimism-sepolia.blastapi.io/"</span>
                case "84532":<span class="cov0" title="0">
                        domain = "base-sepolia.blastapi.io/"</span>
                default:<span class="cov0" title="0">
                        return ""</span>
                }
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s%s%s", protocol, domain, cfg.rpcAPIKey)</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package events

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// ContractEventListener handles listening to contract events across multiple chains
type ContractEventListener struct {
        logger            logging.Logger
        client            *websocket.Client
        config            *ListenerConfig
        ctx               context.Context
        cancel            context.CancelFunc
        wg                sync.WaitGroup
        isRunning         bool
        mu                sync.RWMutex
        eventChan         chan *websocket.ChainEvent
        processingWg      sync.WaitGroup
        dbClient          *database.DatabaseClient
        ipfsClient        ipfs.IPFSClient
        taskStreamManager *tasks.TaskStreamManager
}

// ListenerConfig holds configuration for the event listener
type ListenerConfig struct {
        Chains            []ChainConfig                `json:"chains"`
        ReconnectConfig   ReconnectConfig              `json:"reconnect"`
        ProcessingWorkers int                          `json:"processing_workers"`
        EventBufferSize   int                          `json:"event_buffer_size"`
        ProcessingTimeout time.Duration                `json:"processing_timeout"`
        ContractAddresses map[string]map[string]string `json:"contract_addresses"` // chainID -&gt; contractType -&gt; address
}

// ChainConfig represents blockchain configuration for event listening
type ChainConfig struct {
        ChainID      string `json:"chain_id"`
        Name         string `json:"name"`
        RPCURL       string `json:"rpc_url"`
        WebSocketURL string `json:"websocket_url"`
        Enabled      bool   `json:"enabled"`
}

// ReconnectConfig holds reconnection settings
type ReconnectConfig struct {
        MaxRetries    int           `json:"max_retries"`
        BaseDelay     time.Duration `json:"base_delay"`
        MaxDelay      time.Duration `json:"max_delay"`
        BackoffFactor float64       `json:"backoff_factor"`
}

// EventProcessor handles individual event processing
type EventProcessor struct {
        logger          logging.Logger
        operatorHandler *OperatorEventHandler
        taskHandler     *TaskEventHandler
}

// OperatorEventHandler handles operator-related events
type OperatorEventHandler struct {
        logger logging.Logger
}

// TaskEventHandler handles task-related events
type TaskEventHandler struct {
        logger            logging.Logger
        db                *database.DatabaseClient
        ipfsClient        ipfs.IPFSClient
        taskStreamManager *tasks.TaskStreamManager
}

// NewContractEventListener creates a new contract event listener
func NewContractEventListener(logger logging.Logger, config *ListenerConfig, dbClient *database.DatabaseClient, ipfsClient ipfs.IPFSClient, taskStreamManager *tasks.TaskStreamManager) *ContractEventListener <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        client := websocket.NewClient(logger)

        return &amp;ContractEventListener{
                logger:            logger,
                client:            client,
                config:            config,
                ctx:               ctx,
                cancel:            cancel,
                eventChan:         make(chan *websocket.ChainEvent, config.EventBufferSize),
                dbClient:          dbClient,
                ipfsClient:        ipfsClient,
                taskStreamManager: taskStreamManager,
        }
}</span>

// Start begins listening for contract events
func (l *ContractEventListener) Start() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if l.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("event listener is already running")
        }</span>

        // l.logger.Info("Starting contract event listener")

        // Set up chain connections and subscriptions
        <span class="cov0" title="0">if err := l.setupChainConnections(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup chain connections: %w", err)
        }</span>

        // Start the websocket client
        <span class="cov0" title="0">if err := l.client.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start websocket client: %w", err)
        }</span>

        // Start event processing workers
        <span class="cov0" title="0">l.startEventProcessors()

        // Start the main event listening loop
        l.wg.Add(1)
        go l.eventListeningLoop()

        l.isRunning = true
        l.logger.Info("Contract event listener started successfully")

        return nil</span>
}

// Stop gracefully stops the event listener
func (l *ContractEventListener) Stop() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if !l.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("event listener is not running")
        }</span>

        <span class="cov0" title="0">l.logger.Info("Stopping contract event listener")

        // Cancel context to stop all goroutines
        l.cancel()

        // Stop the websocket client
        if err := l.client.Stop(); err != nil </span><span class="cov0" title="0">{
                l.logger.Errorf("Error stopping websocket client: %v", err)
        }</span>

        // Wait for all goroutines to finish
        <span class="cov0" title="0">l.wg.Wait()
        l.processingWg.Wait()

        l.isRunning = false
        l.logger.Info("Contract event listener stopped")

        return nil</span>
}

// setupChainConnections sets up blockchain connections and subscriptions
func (l *ContractEventListener) setupChainConnections() error <span class="cov0" title="0">{
        for _, chainConfig := range l.config.Chains </span><span class="cov0" title="0">{
                if !chainConfig.Enabled </span><span class="cov0" title="0">{
                        // l.logger.Infof("Skipping disabled chain: %s", chainConfig.Name)
                        continue</span>
                }

                // Add chain to websocket client
                <span class="cov0" title="0">wsConfig := websocket.ChainConfig{
                        ChainID:      chainConfig.ChainID,
                        Name:         chainConfig.Name,
                        RPCURL:       chainConfig.RPCURL,
                        WebSocketURL: chainConfig.WebSocketURL,
                        Contracts:    l.getContractConfigsForChain(chainConfig.ChainID),
                        Reconnect: websocket.ReconnectConfig{
                                MaxRetries:    l.config.ReconnectConfig.MaxRetries,
                                BaseDelay:     l.config.ReconnectConfig.BaseDelay,
                                MaxDelay:      l.config.ReconnectConfig.MaxDelay,
                                BackoffFactor: l.config.ReconnectConfig.BackoffFactor,
                                Jitter:        true,
                        },
                }

                if err := l.client.AddChain(wsConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add chain %s: %w", chainConfig.Name, err)
                }</span>

                // Set up specific contract subscriptions
                <span class="cov0" title="0">if err := l.setupContractSubscriptions(chainConfig.ChainID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to setup subscriptions for chain %s: %w", chainConfig.Name, err)
                }</span>

                // l.logger.Infof("Successfully configured chain: %s (%s)", chainConfig.Name, chainConfig.ChainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// getContractConfigsForChain returns contract configurations for a specific chain
func (l *ContractEventListener) getContractConfigsForChain(chainID string) []websocket.ContractConfig <span class="cov0" title="0">{
        var configs []websocket.ContractConfig

        chainAddresses, exists := l.config.ContractAddresses[chainID]
        if !exists </span><span class="cov0" title="0">{
                l.logger.Warnf("No contract addresses configured for chain %s", chainID)
                return configs
        }</span>

        // AttestationCenter contract
        <span class="cov0" title="0">if addr, exists := chainAddresses["attestation_center"]; exists </span><span class="cov0" title="0">{
                configs = append(configs, websocket.ContractConfig{
                        Address:      addr,
                        ContractType: websocket.ContractTypeAttestationCenter,
                        Events:       []string{"TaskSubmitted", "TaskRejected"},
                })
        }</span>

        <span class="cov0" title="0">return configs</span>
}

// setupContractSubscriptions sets up specific contract event subscriptions
func (l *ContractEventListener) setupContractSubscriptions(chainID string) error <span class="cov0" title="0">{
        chainAddresses, exists := l.config.ContractAddresses[chainID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no contract addresses configured for chain %s", chainID)
        }</span>

        // Subscribe to AttestationCenter events
        <span class="cov0" title="0">if addr, exists := chainAddresses["attestation_center"]; exists </span><span class="cov0" title="0">{
                if err := l.client.SubscribeToContract(
                        chainID,
                        addr,
                        websocket.ContractTypeAttestationCenter,
                        []string{"TaskSubmitted", "TaskRejected"},
                ); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to subscribe to AttestationCenter events: %w", err)
                }</span>
                // l.logger.Infof("Subscribed to AttestationCenter events on chain %s", chainID)
        }

        <span class="cov0" title="0">return nil</span>
}

// startEventProcessors starts worker goroutines for event processing
func (l *ContractEventListener) startEventProcessors() <span class="cov0" title="0">{
        processor := &amp;EventProcessor{
                logger:          l.logger,
                operatorHandler: &amp;OperatorEventHandler{logger: l.logger},
                taskHandler:     &amp;TaskEventHandler{logger: l.logger, db: l.dbClient, ipfsClient: l.ipfsClient, taskStreamManager: l.taskStreamManager},
        }

        // Start multiple processing workers
        for i := 0; i &lt; l.config.ProcessingWorkers; i++ </span><span class="cov0" title="0">{
                l.processingWg.Add(1)
                go l.eventProcessorWorker(processor, i)
        }</span>

        // l.logger.Infof("Started %d event processing workers", l.config.ProcessingWorkers)
}

// eventListeningLoop is the main event listening loop
func (l *ContractEventListener) eventListeningLoop() <span class="cov0" title="0">{
        defer l.wg.Done()

        l.logger.Info("Starting event listening loop")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov0" title="0">
                        l.logger.Info("Event listening loop stopped")
                        return</span>
                case event := &lt;-l.client.EventChannel():<span class="cov0" title="0">
                        // Forward event to processing workers
                        select </span>{
                        case l.eventChan &lt;- event:<span class="cov0" title="0"></span>
                                // Event queued successfully
                        default:<span class="cov0" title="0">
                                // Event channel is full, log warning
                                l.logger.Warnf("Event channel full, dropping event: %s from %s",
                                        event.EventName, event.ContractAddr)</span>
                        }
                }
        }
}

// eventProcessorWorker processes events from the event channel
func (l *ContractEventListener) eventProcessorWorker(processor *EventProcessor, workerID int) <span class="cov0" title="0">{
        defer l.processingWg.Done()

        l.logger.Debugf("Event processor worker %d started", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.ctx.Done():<span class="cov0" title="0">
                        // l.logger.Infof("Event processor worker %d stopped", workerID)
                        return</span>
                case event := &lt;-l.eventChan:<span class="cov0" title="0">
                        l.processEvent(processor, event)</span>
                }
        }
}

// processEvent processes a single contract event
func (l *ContractEventListener) processEvent(processor *EventProcessor, event *websocket.ChainEvent) <span class="cov0" title="0">{
        // Set processing timeout
        // ctx, cancel := context.WithTimeout(l.ctx, l.config.ProcessingTimeout)
        // defer cancel()

        // l.logger.Debugf("Worker %d processing %s event from %s contract at %s",
        //         workerID, event.EventName, event.ContractType, event.ContractAddr)

        // Process event based on contract type
        switch event.ContractType </span>{
        case websocket.ContractTypeAttestationCenter:<span class="cov0" title="0">
                l.logger.Debugf("Processing %s event from AttestationCenter contract on chain %s", event.EventName, event.ChainID)
                processor.taskHandler.ProcessTaskEvent(event)</span>
        default:<span class="cov0" title="0">
                l.logger.Warnf("Unknown contract type: %s for event %s from contract %s on chain %s",
                        event.ContractType, event.EventName, event.ContractAddr, event.ChainID)</span>
        }
}

// GetStatus returns the current status of the event listener
func (l *ContractEventListener) GetStatus() map[string]interface{} <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        status := map[string]interface{}{
                "running":            l.isRunning,
                "processing_workers": l.config.ProcessingWorkers,
                "event_buffer_size":  l.config.EventBufferSize,
                "event_buffer_used":  len(l.eventChan),
                "chains":             make(map[string]interface{}),
        }

        // Get chain-specific status
        chainStatus := l.client.GetChainStatus()
        status["chains"] = chainStatus

        return status
}</span>

// GetDefaultConfig returns a default configuration for the event listener
func GetDefaultConfig() *ListenerConfig <span class="cov0" title="0">{
        return &amp;ListenerConfig{
                Chains: []ChainConfig{
                        {
                                ChainID:      "84532",
                                Name:         "Base Sepolia",
                                RPCURL:       config.GetChainRPCUrl(true, "84532"),
                                WebSocketURL: config.GetChainRPCUrl(false, "84532"),
                                Enabled:      true,
                        },
                },
                ReconnectConfig: ReconnectConfig{
                        MaxRetries:    10,
                        BaseDelay:     5 * time.Second,
                        MaxDelay:      5 * time.Minute,
                        BackoffFactor: 2.0,
                },
                ProcessingWorkers: 4,
                EventBufferSize:   1000,
                ProcessingTimeout: 30 * time.Second,
                ContractAddresses: map[string]map[string]string{
                        "84532": { // Base Sepolia
                                "attestation_center": config.GetAttestationCenterAddress(),
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file195" style="display: none">package events

import (
        "context"
        "encoding/hex"
        "fmt"
        "math/big"
        "strconv"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/websocket"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/types"
)

// ProcessTaskEvent processes task-related events
func (h *TaskEventHandler) ProcessTaskEvent(event *websocket.ChainEvent) <span class="cov0" title="0">{
        if eventData, ok := event.Data.(*websocket.ContractEventData); ok </span><span class="cov0" title="0">{
                // Parse the event data to TaskSubmissionData
                taskData, err := h.parseTaskSubmissionData(eventData.ParsedData, event.TxHash)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Errorf("Failed to parse TaskSubmitted event data: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">if event.EventName == "TaskRejected" </span><span class="cov0" title="0">{
                        taskData.IsAccepted = false
                }</span>

                <span class="cov0" title="0">if taskData.TaskID != 0 </span><span class="cov0" title="0">{
                        // First, move the task from dispatched to completed based on onchain result
                        h.logger.Info("Task accepted onchain, moving to completed stream",
                                "task_id", taskData.TaskID,
                                "task_number", taskData.TaskNumber,
                                "tx_hash", event.TxHash)

                        // Move task from dispatched to completed stream
                        if err := h.moveTaskToCompleted(taskData.TaskID); err != nil </span><span class="cov0" title="0">{
                                h.logger.Errorf("Failed to move task to completed stream: %v", err)
                                return
                        }</span>

                        // Then update the database with parsed data (like registrar was doing)
                        <span class="cov0" title="0">if err := h.db.UpdateTaskSubmissionData(*taskData); err != nil </span><span class="cov0" title="0">{
                                h.logger.Errorf("Failed to update task submission data in database: %v", err)
                                return
                        }</span>

                        // Update keeper points in database
                        <span class="cov0" title="0">if err := h.db.UpdateKeeperPointsInDatabase(*taskData); err != nil </span><span class="cov0" title="0">{
                                h.logger.Errorf("Failed to update keeper points in database: %v", err)
                                return
                        }</span>
                }
        }
}

// moveTaskToCompleted moves a task from dispatched to completed stream
func (h *TaskEventHandler) moveTaskToCompleted(taskID int64) error <span class="cov0" title="0">{
        h.logger.Info("Moving task to completed stream", "task_id", taskID)

        // Find the task in the dispatched stream
        task, err := h.taskStreamManager.FindTaskInDispatched(taskID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to find task in dispatched stream", "task_id", taskID, "error", err)
                return err
        }</span>

        // Mark task as completed
        <span class="cov0" title="0">task.CompletedAt = &amp;[]time.Time{time.Now()}[0]

        // Add to completed stream
        err = h.taskStreamManager.AddTaskToStream(context.Background(), tasks.StreamTaskCompleted, task)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to add task to completed stream", "task_id", taskID, "error", err)
                return err
        }</span>

        // Remove from dispatched stream (acknowledge)
        // Note: In a real implementation, we'd need to track the dispatched message ID
        <span class="cov0" title="0">h.logger.Info("Task moved to completed stream successfully", "task_id", taskID)

        return nil</span>
}

// parseTaskSubmissionData parses the event data into TaskSubmissionData
func (h *TaskEventHandler) parseTaskSubmissionData(parsedData map[string]interface{}, txHash string) (*types.TaskSubmissionData, error) <span class="cov0" title="0">{
        // Extract taskDefinitionId - it's indexed, so it comes as a string (hex-encoded)
        taskDefinitionIdStr, ok := parsedData["taskDefinitionId"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("taskDefinitionId not found or invalid type")
        }</span>

        // Convert hex string to integer
        <span class="cov0" title="0">taskDefinitionIdInt64, err := strconv.ParseInt(taskDefinitionIdStr, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse taskDefinitionId: %v", err)
        }</span>
        <span class="cov0" title="0">taskDefinitionId := int(taskDefinitionIdInt64)

        if taskDefinitionId == 10001 || taskDefinitionId == 10002 </span><span class="cov0" title="0">{
                taskData := &amp;types.TaskSubmissionData{
                        TaskID: 0,
                }
                return taskData, nil
        }</span>

        // Extract task number - it's already parsed as uint32, so we need to handle it as a number
        <span class="cov0" title="0">var taskNumber int64
        switch v := parsedData["taskNumber"].(type) </span>{
        case string:<span class="cov0" title="0">
                // If it's a string, parse it
                var err error
                taskNumber, err = strconv.ParseInt(v, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse taskNumber: %v", err)
                }</span>
        case float64:<span class="cov0" title="0">
                // If it's a float64 (from JSON unmarshaling), convert to int64
                taskNumber = int64(v)</span>
        case int64:<span class="cov0" title="0">
                taskNumber = v</span>
        case int:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        case uint32:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        case uint64:<span class="cov0" title="0">
                taskNumber = int64(v)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("taskNumber has unexpected type: %T", v)</span>
        }

        // Extract proof of task
        <span class="cov0" title="0">proofOfTask, ok := parsedData["proofOfTask"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proofOfTask not found or invalid type")
        }</span>

        // Extract operator address
        <span class="cov0" title="0">performerAddress, ok := parsedData["operator"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operator not found or invalid type")
        }</span>

        // Extract attesters IDs
        <span class="cov0" title="0">attestersIdsInterface, ok := parsedData["attestersIds"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("attestersIds not found")
        }</span>

        // Convert attestersIds to string slice
        <span class="cov0" title="0">var attestersIds []int64
        switch v := attestersIdsInterface.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                for _, id := range v </span><span class="cov0" title="0">{
                        switch idVal := id.(type) </span>{
                        case *big.Int:<span class="cov0" title="0">
                                attestersIds = append(attestersIds, idVal.Int64())</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("invalid attester ID type: %T", id)</span>
                        }
                }
        case []*big.Int:<span class="cov0" title="0">
                for _, id := range v </span><span class="cov0" title="0">{
                        attestersIds = append(attestersIds, id.Int64())
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("attestersIds is not a slice: %T", v)</span>
        }

        <span class="cov0" title="0">data, ok := parsedData["data"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data not found or invalid type")
        }</span>

        <span class="cov0" title="0">var decodedData string
        dataBytes, err := hex.DecodeString(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hex-decode data: %v", err)
        }</span>
        <span class="cov0" title="0">decodedData = string(dataBytes)

        ipfsData, err := h.ipfsClient.Fetch(decodedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch IPFS content: %v", err)
        }</span>

        <span class="cov0" title="0">taskData := &amp;types.TaskSubmissionData{
                TaskID:               ipfsData.ActionData.TaskID,
                TaskNumber:           taskNumber,
                TaskDefinitionID:     taskDefinitionId,
                IsAccepted:           true,
                TaskSubmissionTxHash: txHash,
                PerformerAddress:     performerAddress,
                AttesterIds:          attestersIds,
                ExecutionTxHash:      ipfsData.ActionData.ActionTxHash,
                ExecutionTimestamp:   ipfsData.ActionData.ExecutionTimestamp,
                TaskOpxCost:          ipfsData.ActionData.TotalFee,
                ProofOfTask:          proofOfTask,
        }

        return taskData, nil</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">package metrics

import (
        "net/http"
        "runtime"
        "time"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Collector manages metrics collection
type Collector struct {
        handler http.Handler
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                handler: promhttp.Handler(),
        }
}</span>

// Handler returns the HTTP handler for metrics endpoint
func (c *Collector) Handler() http.Handler <span class="cov0" title="0">{
        return c.handler
}</span>

// Start starts metrics collection
func (c *Collector) Start() <span class="cov0" title="0">{
        // Update uptime every 10 seconds
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        UptimeSeconds.Set(time.Since(startTime).Seconds())
                        UpdateSystemMetrics()
                }</span>
        }()
}

// UpdateSystemMetrics updates system metrics (similar to keeper's middleware)
func UpdateSystemMetrics() <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)
        MemoryUsageBytes.Set(float64(memStats.Alloc))
        CPUUsagePercent.Set(float64(memStats.Sys))
        GoroutinesActive.Set(float64(runtime.NumGoroutine()))
        GCDurationSeconds.Set(float64(memStats.PauseTotalNs) / 1e9)
}</pre>
		
		<pre class="file" id="file197" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
)

var (
        startTime = time.Now()

        // System metrics
        UptimeSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "uptime_seconds",
                Help:      "Time passed since Redis Service started in seconds",
        })

        MemoryUsageBytes = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "memory_usage_bytes",
                Help:      "Service memory consumption",
        })

        CPUUsagePercent = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "cpu_usage_percent",
                Help:      "CPU utilization percentage",
        })

        GoroutinesActive = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "goroutines_active",
                Help:      "Active Go routines",
        })

        GCDurationSeconds = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "gc_duration_seconds",
                Help:      "Garbage collection time",
        })

        // Service Health &amp; Availability
        ServiceStatus = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "service_status",
                Help:      "Service component health status (component=client/job_stream_manager/task_stream_manager)",
        }, []string{"component"})

        // Single flag to indicate which Redis is being used
        IsRedisUpstashAvailable = promauto.NewGauge(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "is_upstash_available",
                Help:      "Whether Upstash Redis is available and being used (1=Upstash, 0=Local)",
        })

        // Connection Management
        ClientConnectionsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "client_connections_total",
                Help:      "Redis client connections (status=success/failure)",
        }, []string{"status"})

        ClientConnectionErrorsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "client_connection_errors_total",
                Help:      "Redis client connection errors",
        }, []string{"error_type"})

        PingOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "ping_operations_total",
                Help:      "Redis ping operations",
        }, []string{"status"})

        PingDuration = promauto.NewHistogram(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "ping_duration_seconds",
                Help:      "Redis ping response time",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1},
        })

        ConnectionChecksTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_checks_total",
                Help:      "Connection health checks",
        }, []string{"status"})

        // Core Stream Operations
        TaskStreamLengths = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_stream_lengths",
                Help:      "Current task stream lengths (stream=ready/retry/processing/completed/failed)",
        }, []string{"stream"})

        JobStreamLengths = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "job_stream_lengths",
                Help:      "Current job stream lengths (stream=running/completed)",
        }, []string{"stream"})

        TasksAddedToStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_added_to_stream_total",
                Help:      "Tasks added to streams",
        }, []string{"stream", "status"})

        TasksReadFromStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_read_from_stream_total",
                Help:      "Tasks read from streams",
        }, []string{"stream", "status"})

        JobsAddedToStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "jobs_added_to_stream_total",
                Help:      "Jobs added to streams",
        }, []string{"stream", "status"})

        JobsReadFromStreamTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "jobs_read_from_stream_total",
                Help:      "Jobs read from streams",
        }, []string{"stream", "status"})

        // Task Lifecycle &amp; Performance
        TaskRetryOperationsTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_retry_operations_total",
                Help:      "Task retry operations",
        })

        TaskMaxRetriesExceededTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_max_retries_exceeded_total",
                Help:      "Tasks exceeding max retry attempts",
        })

        TasksMovedToFailedStreamTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "tasks_moved_to_failed_stream_total",
                Help:      "Tasks permanently failed and moved to failed stream",
        })

        TaskReadyToProcessingTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_ready_to_processing_total",
                Help:      "Tasks moved from ready to processing stream",
        })

        TaskProcessingToCompletedTotal = promauto.NewCounter(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_processing_to_completed_total",
                Help:      "Tasks moved from processing to completed stream",
        })

        // Updated buckets for longer task execution times (30+ seconds to several minutes)
        TaskLifecycleTransitionDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "task_lifecycle_transition_duration_seconds",
                Help:      "Task lifecycle transition time",
                Buckets:   []float64{0.1, 0.5, 1, 5, 10, 30, 60, 120, 300, 600}, // Up to 10 minutes
        }, []string{"from_stream", "to_stream"})

        // Redis Client Operation Metrics
        RedisOperationsTotal = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "operations_total",
                Help:      "Total Redis operations performed",
        }, []string{"operation", "status"})

        RedisOperationDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "operation_duration_seconds",
                Help:      "Redis operation duration",
                Buckets:   []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5},
        }, []string{"operation"})

        RedisRetryAttempts = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "retry_attempts_total",
                Help:      "Total Redis retry attempts",
        }, []string{"operation"})

        RedisConnectionRecoveries = promauto.NewCounterVec(prometheus.CounterOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_recoveries_total",
                Help:      "Total Redis connection recovery attempts",
        }, []string{"status"})

        RedisConnectionHealth = promauto.NewGaugeVec(prometheus.GaugeOpts{
                Namespace: "triggerx",
                Subsystem: "redis",
                Name:      "connection_health",
                Help:      "Redis connection health status",
        }, []string{"type"})
)

// CreateRedisMonitoringHooks creates monitoring hooks for the Redis client
func CreateRedisMonitoringHooks() *redisClient.MonitoringHooks <span class="cov0" title="0">{
        return &amp;redisClient.MonitoringHooks{
                OnOperationStart: func(operation string, key string) </span>{<span class="cov0" title="0">
                        // Optional: Could track operation starts if needed
                }</span>,

                OnOperationEnd: func(operation string, key string, duration time.Duration, err error) <span class="cov0" title="0">{
                        status := "success"
                        if err != nil </span><span class="cov0" title="0">{
                                status = "error"
                        }</span>

                        <span class="cov0" title="0">RedisOperationsTotal.WithLabelValues(operation, status).Inc()
                        RedisOperationDuration.WithLabelValues(operation).Observe(duration.Seconds())</span>
                },

                OnConnectionStatus: func(connected bool, latency time.Duration) <span class="cov0" title="0">{
                        healthValue := float64(0)
                        if connected </span><span class="cov0" title="0">{
                                healthValue = float64(1)
                        }</span>
                        <span class="cov0" title="0">RedisConnectionHealth.WithLabelValues("main").Set(healthValue)

                        // Update ping duration if connected
                        if connected </span><span class="cov0" title="0">{
                                PingDuration.Observe(latency.Seconds())
                                PingOperationsTotal.WithLabelValues("success").Inc()
                        }</span> else<span class="cov0" title="0"> {
                                PingOperationsTotal.WithLabelValues("failure").Inc()
                        }</span>
                },

                OnRecoveryStart: func(reason string) <span class="cov0" title="0">{
                        // Mark connection as unhealthy during recovery
                        RedisConnectionHealth.WithLabelValues("main").Set(float64(0))
                }</span>,

                OnRecoveryEnd: func(success bool, attempts int, duration time.Duration) <span class="cov0" title="0">{
                        status := "failure"
                        if success </span><span class="cov0" title="0">{
                                status = "success"
                                RedisConnectionHealth.WithLabelValues("main").Set(float64(1))
                        }</span>
                        <span class="cov0" title="0">RedisConnectionRecoveries.WithLabelValues(status).Inc()</span>
                },

                OnRetryAttempt: func(operation string, attempt int, err error) <span class="cov0" title="0">{
                        RedisRetryAttempts.WithLabelValues(operation).Inc()
                }</span>,
        }
}

// UpdateRedisClientMetrics updates metrics from Redis client operation metrics
func UpdateRedisClientMetrics(operationMetrics map[string]*redisClient.OperationMetrics) <span class="cov0" title="0">{
        for operation, metrics := range operationMetrics </span><span class="cov0" title="0">{
                // Update operation counters
                RedisOperationsTotal.WithLabelValues(operation, "success").Add(float64(metrics.SuccessCount))
                RedisOperationsTotal.WithLabelValues(operation, "error").Add(float64(metrics.ErrorCount))

                // Update retry attempts
                RedisRetryAttempts.WithLabelValues(operation).Add(float64(metrics.RetryCount))

                // Update average latency (as a gauge for monitoring)
                if metrics.AverageLatency &gt; 0 </span><span class="cov0" title="0">{
                        RedisOperationDuration.WithLabelValues(operation).Observe(metrics.AverageLatency.Seconds())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file198" style="display: none">package taskmonitor

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/events"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/tasks"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        dbClient "github.com/trigg3rX/triggerx-backend/pkg/database"
        "github.com/trigg3rX/triggerx-backend/pkg/ipfs"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

const (
// defaultConnectTimeout = 30 * time.Second
// defaultBlockOverlap   = uint64(5)
)

// TaskManager orchestrates all Redis-based task management components
type TaskManager struct {
        logger              logging.Logger
        redisClient         *redisClient.Client
        taskStreamManager   *tasks.TaskStreamManager
        eventListener       *events.ContractEventListener
        metricsUpdateTicker *time.Ticker
        ctx                 context.Context
        cancel              context.CancelFunc
        shutdownWg          sync.WaitGroup
        startTime           time.Time
}

// NewTaskManager creates a new TaskManager instance
func NewTaskManager(logger logging.Logger) (*TaskManager, error) <span class="cov8" title="1">{
        logger.Info("Initializing TaskManager...")

        // Create context for managing background workers
        ctx, cancel := context.WithCancel(context.Background())

        // Create Redis client with monitoring
        redisConfig := config.GetRedisClientConfig()
        client, err := redisClient.NewRedisClient(logger, redisConfig)
        if err != nil </span><span class="cov8" title="1">{
                cancel() // Clean up context on error
                logger.Error("Failed to create Redis client for TaskManager", "error", err)
                metrics.ServiceStatus.WithLabelValues("task_manager").Set(0)
                return nil, fmt.Errorf("failed to create redis client: %w", err)
        }</span>

        // Set up monitoring hooks
        <span class="cov0" title="0">monitoringHooks := metrics.CreateRedisMonitoringHooks()
        client.SetMonitoringHooks(monitoringHooks)

        // Initialize database client
        dbCfg := &amp;dbClient.Config{
                Hosts:       []string{config.GetDatabaseHostAddress() + ":" + config.GetDatabaseHostPort()},
                Keyspace:    "triggerx",
                Consistency: gocql.Quorum,
                Timeout:     10 * time.Second,
                Retries:     3,
                ConnectWait: 5 * time.Second,
                RetryConfig: retry.DefaultRetryConfig(),
        }
        dbConn, err := dbClient.NewConnection(dbCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize database client: %w", err)
        }</span>

        // Initialize database client
        <span class="cov0" title="0">databaseClient := database.NewDatabaseClient(logger, dbConn)

        // Initialize IPFS client
        ipfsCfg := ipfs.NewConfig(config.GetPinataHost(), config.GetPinataJWT())
        ipfsClient, err := ipfs.NewClient(ipfsCfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize IPFS client: %w", err)
        }</span>

        // Initialize task stream manager
        <span class="cov0" title="0">taskStreamManager, err := tasks.NewTaskStreamManager(client, databaseClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                // Clean up resources on error
                cancel()
                if closeErr := client.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close Redis client during error cleanup", "error", closeErr)
                }</span>
                <span class="cov0" title="0">logger.Error("Failed to create TaskStreamManager", "error", err)
                return nil, fmt.Errorf("failed to create task stream manager: %w", err)</span>
        }

        // Initialize event listener
        <span class="cov0" title="0">eventListener := events.NewContractEventListener(logger, events.GetDefaultConfig(), databaseClient, ipfsClient, taskStreamManager)

        tm := &amp;TaskManager{
                logger:              logger,
                redisClient:         client,
                taskStreamManager:   taskStreamManager,
                eventListener:       eventListener,
                metricsUpdateTicker: time.NewTicker(config.GetMetricsUpdateInterval()),
                ctx:                 ctx,
                cancel:              cancel,
                startTime:           time.Now(),
        }

        logger.Info("TaskManager initialized successfully",
                "metrics_update_interval", config.GetMetricsUpdateInterval())

        metrics.ServiceStatus.WithLabelValues("task_manager").Set(1)
        return tm, nil</span>
}

// Initialize initializes all stream managers and starts background workers
func (tm *TaskManager) Initialize() error <span class="cov0" title="0">{
        tm.logger.Info("Initializing TaskManager components...")

        // Initialize task streams
        if err := tm.taskStreamManager.Initialize(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize task stream manager: %w", err)
        }</span>

        // Start event listener
        <span class="cov0" title="0">if err := tm.eventListener.Start(); err != nil </span><span class="cov0" title="0">{
                tm.logger.Errorf("Failed to start event listener: %v", err)
                tm.logger.Info("Falling back to polling mode")
        }</span>

        // Start background workers with proper synchronization
        <span class="cov0" title="0">tm.shutdownWg.Add(2) // Track all background goroutines

        go func() </span><span class="cov0" title="0">{
                defer tm.shutdownWg.Done()
                tm.startMetricsUpdateWorker()
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer tm.shutdownWg.Done()
                tm.taskStreamManager.StartTimeoutWorker(tm.ctx)
        }</span>()

        <span class="cov0" title="0">tm.logger.Info("TaskManager initialization completed successfully")
        return nil</span>
}

// startMetricsUpdateWorker periodically updates metrics from Redis client
func (tm *TaskManager) startMetricsUpdateWorker() <span class="cov0" title="0">{
        tm.logger.Info("Starting metrics update worker")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-tm.ctx.Done():<span class="cov0" title="0">
                        tm.logger.Info("Metrics update worker stopping")
                        return</span>
                case &lt;-tm.metricsUpdateTicker.C:<span class="cov0" title="0">
                        tm.updateMetrics()</span>
                }
        }
}

// updateMetrics updates Prometheus metrics from Redis client
func (tm *TaskManager) updateMetrics() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Panic in metrics update", "panic", r)
                }</span>
        }()

        // Update Redis client metrics
        <span class="cov0" title="0">operationMetrics := tm.redisClient.GetOperationMetrics()
        metrics.UpdateRedisClientMetrics(operationMetrics)

        // Update stream length metrics
        taskStreamInfo := tm.taskStreamManager.GetStreamInfo()
        if lengths, ok := taskStreamInfo["stream_lengths"].(map[string]int64); ok </span><span class="cov0" title="0">{
                for stream, length := range lengths </span><span class="cov0" title="0">{
                        switch stream </span>{
                        case "tasks:ready":<span class="cov0" title="0">
                                metrics.TaskStreamLengths.WithLabelValues("ready").Set(float64(length))</span>
                        case "tasks:processing":<span class="cov0" title="0">
                                metrics.TaskStreamLengths.WithLabelValues("processing").Set(float64(length))</span>
                        case "tasks:completed":<span class="cov0" title="0">
                                metrics.TaskStreamLengths.WithLabelValues("completed").Set(float64(length))</span>
                        case "tasks:failed":<span class="cov0" title="0">
                                metrics.TaskStreamLengths.WithLabelValues("failed").Set(float64(length))</span>
                        case "tasks:retry":<span class="cov0" title="0">
                                metrics.TaskStreamLengths.WithLabelValues("retry").Set(float64(length))</span>
                        }
                }
        }

        // Update connection status
        <span class="cov0" title="0">connectionStatus := tm.redisClient.GetConnectionStatus()
        if connectionStatus != nil &amp;&amp; !connectionStatus.IsRecovering </span><span class="cov0" title="0">{
                metrics.RedisConnectionHealth.WithLabelValues("main").Set(1)
        }</span>
}

// GetTaskStreamManager returns the task stream manager
func (tm *TaskManager) GetTaskStreamManager() *tasks.TaskStreamManager <span class="cov0" title="0">{
        return tm.taskStreamManager
}</span>

// HealthCheck performs a comprehensive health check
func (tm *TaskManager) HealthCheck() map[string]interface{} <span class="cov0" title="0">{
        tm.logger.Debug("Performing TaskManager health check")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        healthStatus := map[string]interface{}{
                "timestamp":      time.Now(),
                "uptime_seconds": time.Since(tm.startTime).Seconds(),
                "start_time":     tm.startTime.Format(time.RFC3339),
        }

        // Check Redis connection
        if tm.redisClient != nil </span><span class="cov0" title="0">{
                redisHealth := tm.redisClient.GetHealthStatus(ctx)
                healthStatus["redis_connection"] = map[string]interface{}{
                        "connected":    redisHealth.Connected,
                        "last_ping":    redisHealth.LastPing,
                        "ping_latency": redisHealth.PingLatency,
                        "errors":       redisHealth.Errors,
                }
        }</span>

        // Get stream information
        <span class="cov0" title="0">if tm.taskStreamManager != nil </span><span class="cov0" title="0">{
                healthStatus["task_streams"] = tm.taskStreamManager.GetStreamInfo()
        }</span>

        <span class="cov0" title="0">return healthStatus</span>
}

// Close gracefully shuts down the TaskManager
func (tm *TaskManager) Close() error <span class="cov0" title="0">{
        tm.logger.Info("Closing TaskManager...")

        // Cancel context to stop all workers
        if tm.cancel != nil </span><span class="cov0" title="0">{
                tm.cancel()
        }</span>

        // Wait for background workers to finish with timeout
        <span class="cov0" title="0">shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        shutdownDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                tm.shutdownWg.Wait()
                close(shutdownDone)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-shutdownDone:<span class="cov0" title="0">
                tm.logger.Info("All background workers stopped successfully")</span>
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                tm.logger.Warn("Timeout waiting for background workers to stop")</span>
        }

        // Stop event listener
        <span class="cov0" title="0">if err := tm.eventListener.Stop(); err != nil </span><span class="cov0" title="0">{
                tm.logger.Errorf("Error stopping event listener: %v", err)
        }</span>

        // Stop metrics ticker
        <span class="cov0" title="0">if tm.metricsUpdateTicker != nil </span><span class="cov0" title="0">{
                tm.metricsUpdateTicker.Stop()
        }</span>

        // Close stream managers
        <span class="cov0" title="0">var errors []error

        if tm.taskStreamManager != nil </span><span class="cov0" title="0">{
                if err := tm.taskStreamManager.Close(); err != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to close TaskStreamManager", "error", err)
                        errors = append(errors, fmt.Errorf("task stream manager: %w", err))
                }</span>
        }

        // Close Redis client
        <span class="cov0" title="0">if tm.redisClient != nil </span><span class="cov0" title="0">{
                if err := tm.redisClient.Close(); err != nil </span><span class="cov0" title="0">{
                        tm.logger.Error("Failed to close Redis client", "error", err)
                        errors = append(errors, fmt.Errorf("redis client: %w", err))
                }</span>
        }

        <span class="cov0" title="0">metrics.ServiceStatus.WithLabelValues("task_manager").Set(0)

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors during TaskManager shutdown: %v", errors)
        }</span>

        <span class="cov0" title="0">tm.logger.Info("TaskManager closed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file199" style="display: none">package tasks

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/clients/database"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics"
        redisClient "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type TaskStreamManager struct {
        redisClient    redisClient.RedisClientInterface
        dbClient       *database.DatabaseClient
        logger         logging.Logger
        consumerGroups map[string]bool
        mu             sync.RWMutex
        startTime      time.Time
}

func NewTaskStreamManager(redisClient redisClient.RedisClientInterface, dbClient *database.DatabaseClient, logger logging.Logger) (*TaskStreamManager, error) <span class="cov0" title="0">{
        tsm := &amp;TaskStreamManager{
                redisClient:    redisClient,
                dbClient:       dbClient,
                logger:         logger,
                consumerGroups: make(map[string]bool),
                startTime:      time.Now(),
        }

        logger.Info("TaskStreamManager initialized successfully")
        metrics.ServiceStatus.WithLabelValues("task_stream_manager").Set(1)
        return tsm, nil
}</span>

func (tsm *TaskStreamManager) Initialize() error <span class="cov0" title="0">{
        tsm.logger.Info("Initializing task streams...")

        ctx, cancel := context.WithTimeout(context.Background(), config.GetInitializationTimeout())
        defer cancel()

        // Initialize task streams with specific expiration rules
        streamConfigs := map[string]time.Duration{
                StreamTaskDispatched: TasksProcessingTTL,
                StreamTaskCompleted:  TasksCompletedTTL,
                StreamTaskFailed:     TasksFailedTTL,
                StreamTaskRetry:      TasksRetryTTL,
        }

        for stream, ttl := range streamConfigs </span><span class="cov0" title="0">{
                tsm.logger.Debug("Creating stream", "stream", stream, "ttl", ttl)
                if err := tsm.redisClient.CreateStreamIfNotExists(ctx, stream, ttl); err != nil </span><span class="cov0" title="0">{
                        tsm.logger.Error("Failed to initialize stream",
                                "stream", stream,
                                "error", err,
                                "ttl", ttl)
                        return fmt.Errorf("failed to initialize stream %s: %w", stream, err)
                }</span>
                <span class="cov0" title="0">tsm.logger.Info("Stream initialized successfully", "stream", stream, "ttl", ttl)</span>
        }

        // Register consumer groups for task processing
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskDispatched, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task completion
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskCompleted, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task failure
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskFailed, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for task retry
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskRetry, "task-processors"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-processors group: %w", err)
        }</span>

        // Register consumer groups for timeout checking
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskDispatched, "timeout-checker"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register timeout-checker group: %w", err)
        }</span>

        // Register consumer groups for task finding
        <span class="cov0" title="0">if err := tsm.RegisterConsumerGroup(StreamTaskDispatched, "task-finder"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task-finder group: %w", err)
        }</span>

        // go tsm.StartStreamHealthMonitor(ctx)

        <span class="cov0" title="0">tsm.logger.Info("All task streams initialized successfully")

        return nil</span>
}

// RegisterConsumerGroup registers a consumer group for a stream
func (tsm *TaskStreamManager) RegisterConsumerGroup(stream string, group string) error <span class="cov0" title="0">{
        tsm.mu.Lock()
        defer tsm.mu.Unlock()

        key := fmt.Sprintf("%s:%s", stream, group)
        if _, exists := tsm.consumerGroups[key]; exists </span><span class="cov0" title="0">{
                // tsm.logger.Debug("Consumer group already exists", "stream", stream, "group", group)
                return nil
        }</span>

        <span class="cov0" title="0">tsm.logger.Info("Registering consumer group", "stream", stream, "group", group)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := tsm.redisClient.CreateConsumerGroup(ctx, stream, group); err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to create consumer group",
                        "stream", stream,
                        "group", group,
                        "error", err)
                return fmt.Errorf("failed to create consumer group for %s: %w", stream, err)
        }</span>

        <span class="cov0" title="0">tsm.consumerGroups[key] = true
        tsm.logger.Info("Consumer group created successfully", "stream", stream, "group", group)
        return nil</span>
}

// GetStreamInfo returns information about task streams
func (tsm *TaskStreamManager) GetStreamInfo() map[string]interface{} <span class="cov0" title="0">{
        // tsm.logger.Debug("Getting stream information")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        streamLengths := make(map[string]int64)
        streams := []string{StreamTaskDispatched, StreamTaskRetry, StreamTaskCompleted, StreamTaskFailed}

        for _, stream := range streams </span><span class="cov0" title="0">{
                length, err := tsm.redisClient.XLen(ctx, stream)
                if err != nil </span><span class="cov0" title="0">{
                        tsm.logger.Warn("Failed to get stream length",
                                "stream", stream,
                                "error", err)
                        length = -1
                }</span>
                <span class="cov0" title="0">streamLengths[stream] = length

                // Update stream length metrics
                switch stream </span>{
                case StreamTaskDispatched:<span class="cov0" title="0">
                        metrics.TaskStreamLengths.WithLabelValues("ready").Set(float64(length))</span>
                case StreamTaskRetry:<span class="cov0" title="0">
                        metrics.TaskStreamLengths.WithLabelValues("retry").Set(float64(length))</span>
                case StreamTaskCompleted:<span class="cov0" title="0">
                        metrics.TaskStreamLengths.WithLabelValues("completed").Set(float64(length))</span>
                case StreamTaskFailed:<span class="cov0" title="0">
                        metrics.TaskStreamLengths.WithLabelValues("failed").Set(float64(length))</span>
                }
        }

        <span class="cov0" title="0">info := map[string]interface{}{
                "available":            tsm.redisClient != nil,
                "max_length":           10000, // Default value, can be made configurable
                "tasks_processing_ttl": TasksProcessingTTL.String(),
                "tasks_completed_ttl":  TasksCompletedTTL.String(),
                "tasks_failed_ttl":     TasksFailedTTL.String(),
                "tasks_retry_ttl":      TasksRetryTTL.String(),
                "stream_lengths":       streamLengths,
                "max_retries":          MaxRetryAttempts,
                "consumer_groups":      len(tsm.consumerGroups),
        }

        tsm.logger.Debug("Stream information retrieved", "info", info)
        return info</span>
}

// GetDatabaseClient returns the database client
func (tsm *TaskStreamManager) GetDatabaseClient() *database.DatabaseClient <span class="cov0" title="0">{
        return tsm.dbClient
}</span>

// FindTaskInDispatched finds a specific task in the dispatched stream
func (tsm *TaskStreamManager) FindTaskInDispatched(taskID int64) (*TaskStreamData, error) <span class="cov0" title="0">{
        tasks, _, err := tsm.ReadTasksFromStream(StreamTaskDispatched, "task-finder", "finder", 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                if task.SendTaskDataToKeeper.TaskID[0] == taskID </span><span class="cov0" title="0">{
                        return &amp;task, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("task %d not found in dispatched stream", taskID)</span>
}

// AddTaskToStream adds a task to a specific stream
func (tsm *TaskStreamManager) AddTaskToStream(ctx context.Context, stream string, task *TaskStreamData) error <span class="cov0" title="0">{
        return tsm.addTaskToStream(ctx, stream, task)
}</span>

func (tsm *TaskStreamManager) Close() error <span class="cov0" title="0">{
        tsm.logger.Info("Closing TaskStreamManager")

        err := tsm.redisClient.Close()
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to close Redis client", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">tsm.logger.Info("TaskStreamManager closed successfully")
        return nil</span>
}

// startStreamHealthMonitor monitors the health of Redis streams
func (tsm *TaskStreamManager) StartStreamHealthMonitor(ctx context.Context) <span class="cov0" title="0">{
        tsm.logger.Info("Starting stream health monitor")

        ticker := time.NewTicker(30 * time.Second) // Check health every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        tsm.logger.Info("Stream health monitor shutting down")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Get stream information
                        taskInfo := tsm.GetStreamInfo()

                        // Log warnings for high stream lengths
                        if taskLengths, ok := taskInfo["stream_lengths"].(map[string]int64); ok </span><span class="cov0" title="0">{
                                for stream, length := range taskLengths </span><span class="cov0" title="0">{
                                        if length &gt; 50 </span><span class="cov0" title="0">{ // Warn if more than 50 tasks in any stream
                                                tsm.logger.Warn("High task stream length detected",
                                                        "stream", stream,
                                                        "length", length)
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file200" style="display: none">package tasks

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics"
)

// MarkTaskCompleted marks a task as completed
func (tsm *TaskStreamManager) MarkTaskCompleted(ctx context.Context, taskID int64) error <span class="cov0" title="0">{
        tsm.logger.Info("Marking task as completed",
                "task_id", taskID)

        // Find and move task from processing to completed
        task, err := tsm.findTaskInDispatched(taskID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find task in processing: %w", err)
        }</span>

        <span class="cov0" title="0">task.CompletedAt = &amp;[]time.Time{time.Now()}[0]

        // Add to completed stream
        err = tsm.addTaskToStream(ctx, StreamTaskCompleted, task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add to completed stream: %w", err)
        }</span>

        // Remove from processing stream (acknowledge)
        // Note: In a real implementation, we'd need to track the processing message ID
        <span class="cov0" title="0">tsm.logger.Info("Task marked as completed successfully", "task_id", taskID)
        metrics.TasksAddedToStreamTotal.WithLabelValues("completed", "success").Inc()

        return nil</span>
}

// findTaskInDispatched finds a specific task in the dispatched stream
func (tsm *TaskStreamManager) findTaskInDispatched(taskID int64) (*TaskStreamData, error) <span class="cov0" title="0">{
        tasks, _, err := tsm.ReadTasksFromStream(StreamTaskDispatched, "task-finder", "finder", 100)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                if task.SendTaskDataToKeeper.TaskID[0] == taskID </span><span class="cov0" title="0">{
                        return &amp;task, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("task %d not found in processing stream", taskID)</span>
}

func (tsm *TaskStreamManager) addTaskToStream(ctx context.Context, stream string, task *TaskStreamData) error <span class="cov0" title="0">{
        start := time.Now()
        ctx, cancel := context.WithTimeout(ctx, config.GetReadTimeout())
        defer cancel()

        taskJSON, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to marshal task data",
                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                        "stream", stream,
                        "error", err)
                return fmt.Errorf("failed to marshal task data: %w", err)
        }</span>

        <span class="cov0" title="0">res, err := tsm.redisClient.XAdd(ctx, &amp;redis.XAddArgs{
                Stream: stream,
                MaxLen: int64(config.GetStreamMaxLen()),
                Approx: true,
                Values: map[string]interface{}{
                        "task":       taskJSON,
                        "created_at": time.Now().Unix(),
                },
        })
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                metrics.TasksAddedToStreamTotal.WithLabelValues(stream, "failure").Inc()
                tsm.logger.Error("Failed to add task to stream",
                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                        "stream", stream,
                        "duration", duration,
                        "error", err)
                return fmt.Errorf("failed to add task to stream: %w", err)
        }</span>

        <span class="cov0" title="0">metrics.TasksAddedToStreamTotal.WithLabelValues(stream, "success").Inc()
        tsm.logger.Debug("Task added to stream successfully",
                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                "stream", stream,
                "stream_id", res,
                "duration", duration,
                "task_json_size", len(taskJSON))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">package tasks

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/config"
        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics"
)

func (tsm *TaskStreamManager) GetTaskDataFromStream(stream string, taskID int64) (*TaskStreamData, error) <span class="cov0" title="0">{
        taskStreamData, _, err := tsm.ReadTasksFromStream(stream, "task_stream_manager", "task_stream_manager", 10)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to read task stream data",
                        "task_id", taskID,
                        "error", err)
                return nil, fmt.Errorf("failed to read task stream data: %w", err)
        }</span>

        <span class="cov0" title="0">for _, task := range taskStreamData </span><span class="cov0" title="0">{
                if task.SendTaskDataToKeeper.TaskID[0] == taskID </span><span class="cov0" title="0">{
                        return &amp;task, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("task not found: %d", taskID)</span>
}

func (tsm *TaskStreamManager) ReadTasksFromStream(stream, consumerGroup, consumerName string, count int64) ([]TaskStreamData, []string, error) <span class="cov0" title="0">{
        if err := tsm.RegisterConsumerGroup(stream, consumerGroup); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to register consumer group: %w", err)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        ctx, cancel := context.WithTimeout(context.Background(), config.GetRequestTimeout())
        defer cancel()

        streams, err := tsm.redisClient.XReadGroup(ctx, &amp;redis.XReadGroupArgs{
                Group:    consumerGroup,
                Consumer: consumerName,
                Streams:  []string{stream, "&gt;"},
                Count:    count,
                Block:    time.Second,
        })

        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        metrics.TasksReadFromStreamTotal.WithLabelValues(stream, "empty").Inc()
                        // tsm.logger.Debug("No tasks available in stream",
                        //         "stream", stream,
                        //         "consumer_group", consumerGroup,
                        //         "duration", duration)
                        return []TaskStreamData{}, []string{}, nil
                }</span>
                <span class="cov0" title="0">tsm.logger.Error("Failed to read from stream",
                        "stream", stream,
                        "consumer_group", consumerGroup,
                        "duration", duration,
                        "error", err)
                return nil, nil, fmt.Errorf("failed to read from stream: %w", err)</span>
        }

        <span class="cov0" title="0">metrics.TasksReadFromStreamTotal.WithLabelValues(stream, "success").Inc()

        // Pre-allocate slice for better performance
        var tasks []TaskStreamData
        var messageIDs []string
        totalMessages := 0
        for _, stream := range streams </span><span class="cov0" title="0">{
                totalMessages += len(stream.Messages)
        }</span>
        <span class="cov0" title="0">tasks = make([]TaskStreamData, 0, totalMessages)

        for _, stream := range streams </span><span class="cov0" title="0">{
                for _, message := range stream.Messages </span><span class="cov0" title="0">{
                        taskJSON, exists := message.Values["task"].(string)
                        if !exists </span><span class="cov0" title="0">{
                                tsm.logger.Warn("Message missing task data",
                                        "stream", stream.Stream,
                                        "message_id", message.ID)
                                continue</span>
                        }

                        <span class="cov0" title="0">var task TaskStreamData
                        if err := json.Unmarshal([]byte(taskJSON), &amp;task); err != nil </span><span class="cov0" title="0">{
                                tsm.logger.Error("Failed to unmarshal task data",
                                        "stream", stream.Stream,
                                        "message_id", message.ID,
                                        "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">tasks = append(tasks, task)
                        messageIDs = append(messageIDs, message.ID)

                        tsm.logger.Debug("Task read from stream",
                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                "stream", stream.Stream,
                                "message_id", message.ID)</span>
                }
        }

        <span class="cov0" title="0">tsm.logger.Info("Tasks read from stream successfully",
                "stream", stream,
                "task_count", len(tasks),
                "duration", duration)

        return tasks, messageIDs, nil</span>
}
</pre>
		
		<pre class="file" id="file202" style="display: none">package tasks

import (
        "context"
        "fmt"
        "time"

        "github.com/trigg3rX/triggerx-backend/internal/taskmonitor/metrics"
)

// StartTimeoutWorker monitors processing tasks for timeouts
func (tsm *TaskStreamManager) StartTimeoutWorker(ctx context.Context) <span class="cov0" title="0">{
        tsm.logger.Info("Starting task timeout worker")

        ticker := time.NewTicker(30 * time.Second) // Check timeouts every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        tsm.logger.Info("Timeout worker stopping")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // tsm.logger.Debug("Timeout worker checking for timed out tasks")
                        tsm.checkDispatchedTimeouts(ctx)</span>
                }
        }
}

// checkDispatchedTimeouts checks for tasks that have been dispatched too long
func (tsm *TaskStreamManager) checkDispatchedTimeouts(ctx context.Context) <span class="cov0" title="0">{
        // tsm.logger.Debug("Checking for dispatched timeouts")

        // Read all dispatched tasks (simplified - in production would use consumer groups)
        tasks, messageIDs, err := tsm.ReadTasksFromStream(StreamTaskDispatched, "timeout-checker", "timeout-worker", 100)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to read dispatched tasks for timeout check", "error", err)
                return
        }</span>

        <span class="cov0" title="0">if len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                tsm.logger.Debug("Timeout worker found tasks to check", "task_count", len(tasks))
        }</span>

        <span class="cov0" title="0">now := time.Now()
        timeoutCount := 0

        for i, task := range tasks </span><span class="cov0" title="0">{
                if task.DispatchedAt != nil </span><span class="cov0" title="0">{
                        dispatchedDuration := now.Sub(*task.DispatchedAt)
                        if dispatchedDuration &gt; TasksProcessingTTL </span><span class="cov0" title="0">{
                                tsm.logger.Warn("Task dispatched timeout detected",
                                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                        "dispatched_duration", dispatchedDuration,
                                        "timeout_threshold", TasksProcessingTTL)

                                // Move to failed stream
                                if err := tsm.moveTaskToFailed(ctx, task, "dispatched timeout"); err != nil </span><span class="cov0" title="0">{
                                        tsm.logger.Error("Failed to handle timeout task",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "error", err)
                                        continue</span> // Don't acknowledge if we failed to move to failed stream
                                }

                                // Acknowledge the timed-out task
                                <span class="cov0" title="0">err := tsm.AckTaskProcessed(ctx, StreamTaskDispatched, "timeout-checker", messageIDs[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        tsm.logger.Error("Failed to acknowledge timed-out task",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        timeoutCount++
                                        tsm.logger.Info("Task timeout processed successfully",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "message_id", messageIDs[i])
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // If task has no DispatchedAt timestamp, it might be a stale task
                        // Check if it's been in the stream for too long based on CreatedAt
                        if task.CreatedAt.Add(TasksProcessingTTL).Before(now) </span><span class="cov0" title="0">{
                                tsm.logger.Warn("Task without dispatched timestamp timed out",
                                        "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                        "created_at", task.CreatedAt,
                                        "age", now.Sub(task.CreatedAt))

                                // Move to failed stream
                                if err := tsm.moveTaskToFailed(ctx, task, "stale task timeout"); err != nil </span><span class="cov0" title="0">{
                                        tsm.logger.Error("Failed to handle stale timeout task",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "error", err)
                                        continue</span>
                                }

                                // Acknowledge the timed-out task
                                <span class="cov0" title="0">err := tsm.AckTaskProcessed(ctx, StreamTaskDispatched, "timeout-checker", messageIDs[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        tsm.logger.Error("Failed to acknowledge stale timed-out task",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        timeoutCount++
                                        tsm.logger.Info("Stale task timeout processed successfully",
                                                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                                                "message_id", messageIDs[i])
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if timeoutCount &gt; 0 </span><span class="cov0" title="0">{
                tsm.logger.Info("Processed task timeouts", "timeout_count", timeoutCount)
        }</span>
}

// AckTaskProcessed acknowledges that a task has been processed
func (tsm *TaskStreamManager) AckTaskProcessed(ctx context.Context, stream, consumerGroup, messageID string) error <span class="cov0" title="0">{
        tsm.logger.Debug("Acknowledging task processed",
                "stream", stream,
                "consumer_group", consumerGroup,
                "message_id", messageID)

        // Increase timeout for acknowledgment operations
        ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        err := tsm.redisClient.XAck(ctx, stream, consumerGroup, messageID)
        if err != nil </span><span class="cov0" title="0">{
                tsm.logger.Error("Failed to acknowledge task",
                        "stream", stream,
                        "consumer_group", consumerGroup,
                        "message_id", messageID,
                        "error", err)
                return err
        }</span>

        <span class="cov0" title="0">tsm.logger.Debug("Task acknowledged successfully",
                "stream", stream,
                "message_id", messageID)

        return nil</span>
}

// moveTaskToFailed moves a task to the failed stream or retry stream
func (tsm *TaskStreamManager) moveTaskToFailed(ctx context.Context, task TaskStreamData, errorMsg string) error <span class="cov0" title="0">{
        task.LastError = errorMsg
        task.RetryCount++

        // Move to failed stream permanently
        err := tsm.addTaskToStream(ctx, StreamTaskFailed, &amp;task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add to failed stream: %w", err)
        }</span>

        <span class="cov0" title="0">tsm.logger.Error("Task permanently failed",
                "task_id", task.SendTaskDataToKeeper.TaskID[0],
                "retry_count", task.RetryCount,
                "error", errorMsg)

        metrics.TasksAddedToStreamTotal.WithLabelValues("failed", "success").Inc()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">package aggregator

import (
        "context"
        "crypto/ecdsa"
        "errors"
        "fmt"
        "net"
        "syscall"

        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/rpc"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// AggregatorClient handles communication with the aggregator service
type AggregatorClient struct {
        logger     logging.Logger
        config     AggregatorClientConfig
        privateKey *ecdsa.PrivateKey
        publicKey  *ecdsa.PublicKey
        httpClient *httppkg.HTTPClient
        rpcClient  *rpc.Client
}

// NewAggregatorClient creates a new instance of AggregatorClient
func NewAggregatorClient(logger logging.Logger, cfg AggregatorClientConfig) (*AggregatorClient, error) <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>
        <span class="cov8" title="1">if cfg.AggregatorRPCUrl == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("RPC address cannot be empty")
        }</span>
        <span class="cov8" title="1">if cfg.SenderPrivateKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sender private key cannot be empty")
        }</span>

        <span class="cov8" title="1">privateKey, err := crypto.HexToECDSA(cfg.SenderPrivateKey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: failed to convert private key: %v", ErrInvalidKey, err)
        }</span>

        <span class="cov8" title="1">publicKey, ok := privateKey.Public().(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: invalid public key type", ErrInvalidKey)
        }</span>

        // Create retry client with configuration
        <span class="cov8" title="1">retryConfig := httppkg.DefaultHTTPRetryConfig()

        httpClient, err := httppkg.NewHTTPClient(retryConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        // Create RPC client using the HTTP client's underlying http.Client for persistent connections
        <span class="cov8" title="1">rpcClient, err := rpc.DialHTTP(cfg.AggregatorRPCUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create RPC client: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;AggregatorClient{
                logger:     logger,
                config:     cfg,
                privateKey: privateKey,
                publicKey:  publicKey,
                httpClient: httpClient,
                rpcClient:  rpcClient,
        }, nil</span>
}

// executeWithRetry executes an RPC call with retry logic using the retry package
func (c *AggregatorClient) executeWithRetry(ctx context.Context, method string, result interface{}, params CallParams) error <span class="cov8" title="1">{
        // Use the persistent RPC client for all attempts
        operation := func() (interface{}, error) </span><span class="cov8" title="1">{
                var err error
                switch method </span>{
                case "sendTask":<span class="cov8" title="1">
                        err = c.rpcClient.Call(
                                result,
                                method,
                                params.ProofOfTask,
                                params.Data,
                                params.TaskDefinitionID,
                                params.PerformerAddress,
                                params.Signature,
                                params.SignatureType,
                                params.TargetChainID,
                        )</span>
                case "sendCustomMessage":<span class="cov8" title="1">
                        err = c.rpcClient.Call(
                                result,
                                method,
                                params.Data,
                                params.TaskDefinitionID,
                        )</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        // Classify network errors as dial failures for clearer diagnostics
                        if isDialError(err) </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to dial aggregator RPC: %w", err)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("RPC call failed: %w", err)</span>
                }

                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">_, err := retry.Retry(ctx, operation, &amp;retry.RetryConfig{
                MaxRetries:      c.httpClient.HTTPConfig.RetryConfig.MaxRetries,
                InitialDelay:    c.httpClient.HTTPConfig.RetryConfig.InitialDelay,
                MaxDelay:        c.httpClient.HTTPConfig.RetryConfig.MaxDelay,
                BackoffFactor:   2.0,
                JitterFactor:    0.1,
                LogRetryAttempt: true,
        }, c.logger)

        return err</span>
}

func (c *AggregatorClient) Close() <span class="cov8" title="1">{
        if c.rpcClient != nil </span><span class="cov8" title="1">{
                c.rpcClient.Close()
        }</span>
        <span class="cov8" title="1">c.httpClient.Close()</span>
}

// isDialError inspects an error to determine if it represents a network dialing error
// such as connection refused, host unreachable, or DNS resolution failures.
func isDialError(err error) bool <span class="cov8" title="1">{
        // Unwrap common network errors
        var opErr *net.OpError
        if errors.As(err, &amp;opErr) </span><span class="cov8" title="1">{
                // Check for syscall-level connection refused / network unreachable
                if opErr.Err == syscall.ECONNREFUSED || opErr.Err == syscall.ENETUNREACH || opErr.Err == syscall.EHOSTUNREACH </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Sometimes nested errors wrap syscall.Errno
                <span class="cov8" title="1">var errno syscall.Errno
                if errors.As(opErr.Err, &amp;errno) </span><span class="cov8" title="1">{
                        switch errno </span>{
                        case syscall.ECONNREFUSED, syscall.ENETUNREACH, syscall.EHOSTUNREACH, syscall.ETIMEDOUT:<span class="cov8" title="1">
                                return true</span>
                        }
                }
                // DNS resolution failures
                <span class="cov8" title="1">var dnserr *net.DNSError
                if errors.As(opErr.Err, &amp;dnserr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        // Direct DNS errors
        <span class="cov8" title="1">var dnserr *net.DNSError
        return errors.As(err, &amp;dnserr)</span>
}
</pre>
		
		<pre class="file" id="file204" style="display: none">package aggregator

import (
        "context"
        "encoding/hex"
        "fmt"

        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// SendTaskToPerformer sends a task to the specified performer through the aggregator
func (c *AggregatorClient) SendTaskToPerformer(ctx context.Context, taskData *types.BroadcastDataForPerformer) (bool, error) <span class="cov8" title="1">{
        c.logger.Debug("Sending task to performer",
                "TaskID", taskData.TaskID,
                "PerformerAddress", taskData.PerformerAddress)

        // Prepare parameters using consistent structure
        params := CallParams{
                Data:             "0x" + hex.EncodeToString(taskData.Data),
                TaskDefinitionID: taskData.TaskDefinitionID,
        }

        var result interface{}
        err := c.executeWithRetry(ctx, "sendCustomMessage", &amp;result, params)
        if err != nil </span><span class="cov8" title="1">{
                c.logger.Error("Failed to send custom task", "error", err)
                return false, fmt.Errorf("failed to send custom task: %w", err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Task sent successfully",
                "TaskID", taskData.TaskID,
                "result", result)
        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">package aggregator

import (
        "context"
        "time"

        "github.com/stretchr/testify/mock"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// MockAggregatorClient is a mock implementation of the AggregatorClient
type MockAggregatorClient struct {
        mock.Mock
}

func NewMockAggregatorClient(logger logging.Logger, cfg AggregatorClientConfig) (*MockAggregatorClient, error) <span class="cov0" title="0">{
        return &amp;MockAggregatorClient{}, nil
}</span>

// SendTaskToPerformer mocks the SendTaskToPerformer method
func (m *MockAggregatorClient) SendTaskToPerformer(ctx context.Context, taskData *types.BroadcastDataForPerformer) (bool, error) <span class="cov8" title="1">{
        args := m.Called(ctx, taskData)
        return args.Bool(0), args.Error(1)
}</span>

// SendTaskToValidators mocks the SendTaskToValidators method
func (m *MockAggregatorClient) SendTaskToValidators(ctx context.Context, taskResult *types.BroadcastDataForValidators) (bool, error) <span class="cov8" title="1">{
        args := m.Called(ctx, taskResult)
        return args.Bool(0), args.Error(1)
}</span>

// Close mocks the Close method
func (m *MockAggregatorClient) Close() <span class="cov8" title="1">{
        m.Called()
}</span>

// MockAggregatorClientBuilder provides a fluent interface for building mock aggregator clients
type MockAggregatorClientBuilder struct {
        client *MockAggregatorClient
}

// NewMockAggregatorClientBuilder creates a new mock aggregator client builder
func NewMockAggregatorClientBuilder() *MockAggregatorClientBuilder <span class="cov8" title="1">{
        return &amp;MockAggregatorClientBuilder{
                client: &amp;MockAggregatorClient{},
        }
}</span>

// ExpectSendTaskToPerformer sets up an expectation for a SendTaskToPerformer call
func (b *MockAggregatorClientBuilder) ExpectSendTaskToPerformer(ctx context.Context, taskData *types.BroadcastDataForPerformer, success bool, err error) *MockAggregatorClientBuilder <span class="cov8" title="1">{
        b.client.On("SendTaskToPerformer", ctx, taskData).Return(success, err)
        return b
}</span>

// ExpectSendTaskToPerformerAny sets up an expectation for any SendTaskToPerformer call
func (b *MockAggregatorClientBuilder) ExpectSendTaskToPerformerAny(success bool, err error) *MockAggregatorClientBuilder <span class="cov0" title="0">{
        b.client.On("SendTaskToPerformer", mock.Anything, mock.Anything).Return(success, err)
        return b
}</span>

// ExpectSendTaskToValidators sets up an expectation for a SendTaskToValidators call
func (b *MockAggregatorClientBuilder) ExpectSendTaskToValidators(ctx context.Context, taskResult *types.BroadcastDataForValidators, success bool, err error) *MockAggregatorClientBuilder <span class="cov8" title="1">{
        b.client.On("SendTaskToValidators", ctx, taskResult).Return(success, err)
        return b
}</span>

// ExpectSendTaskToValidatorsAny sets up an expectation for any SendTaskToValidators call
func (b *MockAggregatorClientBuilder) ExpectSendTaskToValidatorsAny(success bool, err error) *MockAggregatorClientBuilder <span class="cov0" title="0">{
        b.client.On("SendTaskToValidators", mock.Anything, mock.Anything).Return(success, err)
        return b
}</span>

// ExpectClose sets up an expectation for a Close call
func (b *MockAggregatorClientBuilder) ExpectClose() *MockAggregatorClientBuilder <span class="cov8" title="1">{
        b.client.On("Close").Return()
        return b
}</span>

// Build returns the configured mock aggregator client
func (b *MockAggregatorClientBuilder) Build() *MockAggregatorClient <span class="cov8" title="1">{
        return b.client
}</span>

// AssertExpectations asserts that all expected calls were made
func (b *MockAggregatorClientBuilder) AssertExpectations(t mock.TestingT) bool <span class="cov8" title="1">{
        return b.client.AssertExpectations(t)
}</span>

// AssertNumberOfCalls asserts the number of calls to a specific method
func (b *MockAggregatorClientBuilder) AssertNumberOfCalls(t mock.TestingT, methodName string, expectedCalls int) bool <span class="cov8" title="1">{
        return b.client.AssertNumberOfCalls(t, methodName, expectedCalls)
}</span>

// MockAggregatorClientFactory is a factory for creating mock aggregator clients
type MockAggregatorClientFactory struct {
        mock.Mock
}

// NewMockAggregatorClientFactory creates a new mock aggregator client factory
func NewMockAggregatorClientFactory() *MockAggregatorClientFactory <span class="cov8" title="1">{
        return &amp;MockAggregatorClientFactory{}
}</span>

// CreateAggregatorClient mocks the aggregator client creation process
func (f *MockAggregatorClientFactory) CreateAggregatorClient(logger logging.Logger, cfg AggregatorClientConfig) (*MockAggregatorClient, error) <span class="cov8" title="1">{
        args := f.Called(logger, cfg)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*MockAggregatorClient), args.Error(1)</span>
}

// Test utilities for common mock setups

// NewNoOpAggregatorClient creates an aggregator client that does nothing (useful for tests that don't care about aggregator operations)
func NewNoOpAggregatorClient() *MockAggregatorClient <span class="cov8" title="1">{
        client := &amp;MockAggregatorClient{}

        // Set up default no-op behavior
        client.On("SendTaskToPerformer", mock.Anything, mock.Anything).Return(true, nil)
        client.On("SendTaskToValidators", mock.Anything, mock.Anything).Return(true, nil)
        client.On("Close").Return()

        return client
}</span>

// NewFailingAggregatorClient creates an aggregator client that always fails (useful for testing error scenarios)
func NewFailingAggregatorClient(err error) *MockAggregatorClient <span class="cov8" title="1">{
        client := &amp;MockAggregatorClient{}

        // Set up default failing behavior
        client.On("SendTaskToPerformer", mock.Anything, mock.Anything).Return(false, err)
        client.On("SendTaskToValidators", mock.Anything, mock.Anything).Return(false, err)
        client.On("Close").Return()

        return client
}</span>

// NewMockAggregatorClientConfig creates a new mock aggregator client config
func NewMockAggregatorClientConfig() AggregatorClientConfig <span class="cov8" title="1">{
        return AggregatorClientConfig{
                AggregatorRPCUrl: "http://localhost:9007",
                SenderPrivateKey: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                SenderAddress:    "0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6",
                RetryAttempts:    3,
                RetryDelay:       1000 * time.Millisecond,
                RequestTimeout:   10000 * time.Millisecond,
        }
}</span>

// Mock utilities for testing with real HTTP servers

// NewMockAggregatorClientWithHTTP creates a mock client that can be used with real HTTP servers
// This is useful for integration tests where you want to test the actual HTTP interaction
func NewMockAggregatorClientWithHTTP(logger logging.Logger, cfg AggregatorClientConfig) (*MockAggregatorClient, error) <span class="cov0" title="0">{
        client := &amp;MockAggregatorClient{}

        // Set up expectations that will be called by the real client
        client.On("SendTaskToPerformer", mock.Anything, mock.Anything).Return(true, nil)
        client.On("SendTaskToValidators", mock.Anything, mock.Anything).Return(true, nil)
        client.On("Close").Return()

        return client, nil
}</span>

// NewMockAggregatorClientForHTTPTest creates a mock client specifically for HTTP testing
// This sets up the mock to work with real HTTP servers in tests
func NewMockAggregatorClientForHTTPTest(logger logging.Logger, cfg AggregatorClientConfig, expectedSuccess bool, expectedError error) (*MockAggregatorClient, error) <span class="cov0" title="0">{
        client := &amp;MockAggregatorClient{}

        // Set up expectations for HTTP testing
        client.On("SendTaskToPerformer", mock.Anything, mock.Anything).Return(expectedSuccess, expectedError)
        client.On("SendTaskToValidators", mock.Anything, mock.Anything).Return(expectedSuccess, expectedError)
        client.On("Close").Return()

        return client, nil
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">package aggregator

import (
        "context"
        "crypto/ecdsa"
        "encoding/hex"
        "fmt"
        "math/big"

        "github.com/ethereum/go-ethereum/accounts/abi"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/hexutil"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// SendTaskToValidators sends a task result to the validators
func (c *AggregatorClient) SendTaskToValidators(ctx context.Context, taskResult *types.BroadcastDataForValidators) (bool, error) <span class="cov8" title="1">{
        c.logger.Debug("Sending task result to aggregator",
                "taskDefinitionId", taskResult.TaskDefinitionID,
                "proofOfTask", taskResult.ProofOfTask)

        privateKey, err := crypto.HexToECDSA(c.config.SenderPrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to convert private key to ECDSA", "error", err)
                return false, fmt.Errorf("failed to convert private key to ECDSA: %w", err)
        }</span>
        <span class="cov8" title="1">publicKey, ok := privateKey.Public().(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                c.logger.Error("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
        }</span>
        <span class="cov8" title="1">performerAddress := crypto.PubkeyToAddress(*publicKey).Hex()

        // Prepare ABI arguments
        arguments := abi.Arguments{
                {Type: abi.Type{T: abi.StringTy}},
                {Type: abi.Type{T: abi.BytesTy}},
                {Type: abi.Type{T: abi.AddressTy}},
                {Type: abi.Type{T: abi.UintTy}},
        }

        dataPacked, err := arguments.Pack(
                taskResult.ProofOfTask,
                taskResult.Data,
                common.HexToAddress(c.config.SenderAddress),
                big.NewInt(int64(taskResult.TaskDefinitionID)),
        )
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to encode task data", "error", err)
                return false, fmt.Errorf("failed to encode task data: %w", err)
        }</span>
        <span class="cov8" title="1">messageHash := crypto.Keccak256(dataPacked)

        sig, err := crypto.Sign(messageHash, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("Failed to sign task data", "error", err)
                return false, fmt.Errorf("failed to sign task data: %w", err)
        }</span>
        <span class="cov8" title="1">sig[64] += 27
        serializedSignature := hexutil.Encode(sig)

        c.logger.Debug("Task data signed successfully", "signature", sig)

        // Prepare parameters using consistent structure
        params := CallParams{
                ProofOfTask:      taskResult.ProofOfTask,
                Data:             "0x" + hex.EncodeToString(taskResult.Data),
                TaskDefinitionID: taskResult.TaskDefinitionID,
                PerformerAddress: performerAddress,
                Signature:        serializedSignature,
                SignatureType:    "ecdsa",
                TargetChainID:    84532,
        }

        var response interface{}
        err = c.executeWithRetry(ctx, "sendTask", &amp;response, params)
        if err != nil </span><span class="cov8" title="1">{
                c.logger.Error("Failed to send task result", "error", err)
                return false, fmt.Errorf("failed to send task result: %w", err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Successfully sent task result to aggregator",
                "taskDefinitionId", taskResult.TaskDefinitionID,
                "proofOfTask", taskResult.ProofOfTask,
                "response", response)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file207" style="display: none">package dbserver

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (c *DBServerClient) CreateTask(createTaskData types.CreateTaskRequest) (int64, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/tasks", c.dbserverUrl)

        jsonPayload, err := json.Marshal(createTaskData)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to marshal create task data: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to create task: %v", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to create task: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Failed to close response body: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return -1, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                TaskID int64 `json:"task_id"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to decode response body: %v", err)
        }</span>

        <span class="cov0" title="0">return response.TaskID, nil</span>
}
</pre>
		
		<pre class="file" id="file208" style="display: none">package dbserver

import (
        "context"
        "fmt"
        "net/http"
        "time"

        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// DBServerClient handles communication with the DBServer service
type DBServerClient struct {
        logger            logging.Logger
        dbserverUrl       string
        httpClient        *httppkg.HTTPClient
}

// NewDBServerClient creates a new instance of DBServerClient
func NewDBServerClient(logger logging.Logger, dbserverUrl string) (*DBServerClient, error) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>
        <span class="cov0" title="0">if dbserverUrl == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RPC address cannot be empty")
        }</span>

        <span class="cov0" title="0">httpClient, err := httppkg.NewHTTPClient(httppkg.DefaultHTTPRetryConfig(), logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DBServerClient{
                logger:            logger,
                dbserverUrl:       dbserverUrl,
                httpClient:        httpClient,
        }, nil</span>
}

// HealthCheck checks if the database server is healthy
func (c *DBServerClient) HealthCheck() error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/health", c.dbserverUrl)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create health check request: %v", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check request failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed: status code %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the HTTP client
func (c *DBServerClient) Close() <span class="cov0" title="0">{
        c.httpClient.Close()
}</span>
</pre>
		
		<pre class="file" id="file209" style="display: none">package dbserver

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

func (c *DBServerClient) UpdateTaskExecutionData(taskExecutionData types.UpdateTaskExecutionDataRequest) (bool, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/tasks/execution/%d", c.dbserverUrl, taskExecutionData.TaskID)

        jsonPayload, err := json.Marshal(taskExecutionData)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to marshal task execution data: %v", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to update task execution data: %v", err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file210" style="display: none">package dbserver

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// GetTimeBasedTasks fetches tasks that need to be executed in the next window
func (c *DBServerClient) GetTimeBasedTasks() ([]types.ScheduleTimeTaskData, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/jobs/time", c.dbserverUrl)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch time-based tasks: %v", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch time-based tasks: %v", err)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">var tasks []types.ScheduleTimeTaskData
        err = json.Unmarshal(body, &amp;tasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response body: %v", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debugf("Fetched %d time-based tasks", len(tasks))
        return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file211" style="display: none">package redis

import (
        "context"
        "fmt"
        "sync"
        "time"

        redis "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Client represents a Redis client with logging capabilities
type Client struct {
        redisClient      *redis.Client
        config           RedisConfig
        logger           logging.Logger
        mu               sync.Mutex
        retryConfig      *RetryConfig
        recoveryConfig   *ConnectionRecoveryConfig
        isRecovering     bool
        lastHealthCheck  time.Time
        monitoringHooks  *MonitoringHooks
        operationMetrics map[string]*OperationMetrics
}

// NewRedisClient creates a new Redis client instance with enhanced features
func NewRedisClient(logger logging.Logger, config RedisConfig) (*Client, error) <span class="cov8" title="1">{
        var opt *redis.Options

        opt, err := parseRedisConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Redis configuration: %w", err)
        }</span>

        <span class="cov8" title="1">if opt == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid Redis configuration found")
        }</span>

        <span class="cov8" title="1">client := redis.NewClient(opt)
        redisClient := &amp;Client{
                redisClient:     client,
                config:          config,
                logger:          logger,
                retryConfig:     DefaultRetryConfig(),
                recoveryConfig:  DefaultConnectionRecoveryConfig(),
                isRecovering:    false,
                lastHealthCheck: time.Now(),
        }

        // Use a background context for the initial check. The timeout is handled by the client's config.
        if err := redisClient.CheckConnection(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        // Start connection recovery goroutine if enabled
        <span class="cov8" title="1">if redisClient.recoveryConfig.Enabled </span><span class="cov8" title="1">{
                go redisClient.connectionRecoveryLoop()
        }</span>

        <span class="cov8" title="1">logger.Infof("Successfully connected to Redis")
        return redisClient, nil</span>
}

// parseRedisConfig parses Redis configuration for both Upstash and local Redis
func parseRedisConfig(config RedisConfig) (*redis.Options, error) <span class="cov8" title="1">{
        var opt *redis.Options
        var err error

        opt, err = redis.ParseURL(config.UpstashConfig.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Upstash Redis URL: %w", err)
        }</span>

        <span class="cov8" title="1">if config.UpstashConfig.Token != "" </span><span class="cov0" title="0">{
                opt.Password = config.UpstashConfig.Token
        }</span>

        <span class="cov8" title="1">applyConnectionSettings(opt, config)
        return opt, nil</span>
}

// applyConnectionSettings applies common connection settings
func applyConnectionSettings(opt *redis.Options, config RedisConfig) <span class="cov8" title="1">{
        opt.PoolSize = config.ConnectionSettings.PoolSize
        opt.MinIdleConns = config.ConnectionSettings.MinIdleConns
        opt.MaxRetries = config.ConnectionSettings.MaxRetries
        opt.DialTimeout = config.ConnectionSettings.DialTimeout
        opt.ReadTimeout = config.ConnectionSettings.ReadTimeout
        opt.WriteTimeout = config.ConnectionSettings.WriteTimeout
        opt.PoolTimeout = config.ConnectionSettings.PoolTimeout
}</span>

// CheckConnection validates the Redis connection.
// It now uses the passed context and relies on the client's Read/Write timeouts.
func (c *Client) CheckConnection(ctx context.Context) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                _, err := c.redisClient.Ping(ctx).Result()
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Redis connection failed: %v", err)
                        return fmt.Errorf("redis connection failed: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, "CheckConnection")
}

// Ping checks if Redis is reachable.
// It now uses a background context, relying on the client's configured Read/Write timeouts
// instead of creating its own timeout context.
func (c *Client) Ping(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        // The timeout for the actual Ping command is now governed by the client's ReadTimeout.
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                return c.redisClient.Ping(ctx).Err()
        }</span>, "Ping")

        // Track connection status
        <span class="cov8" title="1">latency := time.Since(start)
        c.trackConnectionStatus(err == nil, latency)

        return err</span>
}

// ExecutePipeline executes a series of commands in a single network round-trip.
// It wraps the entire pipeline execution within the client's retry logic,
// making batch operations resilient.
// The provided PipelineFunc is responsible for queuing commands on the pipeline.
func (c *Client) ExecutePipeline(ctx context.Context, fn PipelineFunc) ([]redis.Cmder, error) <span class="cov8" title="1">{
        var cmds []redis.Cmder

        // Wrap the entire pipeline execution in our robust retry mechanism.
        // If the connection drops, it will retry the entire batch of commands.
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                pipe := c.redisClient.Pipeline()

                // The user's function queues the commands.
                if err := fn(pipe); err != nil </span><span class="cov0" title="0">{
                        // This is a non-retryable error from the user's logic, not a Redis error.
                        return fmt.Errorf("pipeline setup function failed: %w", err)
                }</span>

                // Exec sends all queued commands to Redis and returns their results.
                <span class="cov8" title="1">var execErr error
                cmds, execErr = pipe.Exec(ctx)
                // This is the error we check for retry eligibility (e.g., network issues).
                return execErr</span>
        }, "ExecutePipeline")

        <span class="cov8" title="1">return cmds, err</span>
}

// Core Redis operations with retry logic and monitoring
func (c *Client) Get(ctx context.Context, key string) (string, error) <span class="cov8" title="1">{
        var result string
        err := c.executeWithRetryAndKey(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.Get(ctx, key).Result()
                if err == redis.Nil </span><span class="cov8" title="1">{
                        return redis.Nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "Get", key)
        <span class="cov8" title="1">return result, err</span>
}

// GetWithExists returns both the value and existence status for a key
// This leverages the GET command's return value to provide existence information
// without requiring a separate EXISTS check
func (c *Client) GetWithExists(ctx context.Context, key string) (value string, exists bool, err error) <span class="cov8" title="1">{
        err = c.executeWithRetryAndKey(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.Get(ctx, key).Result()
                if err == redis.Nil </span><span class="cov8" title="1">{
                        // Key does not exist
                        value = ""
                        exists = false
                        return nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Key exists
                <span class="cov8" title="1">value = val
                exists = true
                return nil</span>
        }, "GetWithExists", key)
        <span class="cov8" title="1">return value, exists, err</span>
}

func (c *Client) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov8" title="1">{
        return c.executeWithRetryAndKey(ctx, func() error </span><span class="cov8" title="1">{
                return c.redisClient.Set(ctx, key, value, expiration).Err()
        }</span>, "Set", key)
}

func (c *Client) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) (bool, error) <span class="cov8" title="1">{
        var result bool
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.SetNX(ctx, key, value, expiration).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "SetNX")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) Del(ctx context.Context, keys ...string) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                return c.redisClient.Del(ctx, keys...).Err()
        }</span>, "Del")
}

// DelWithCount deletes keys and returns the number of keys that were deleted
// This leverages the DEL command's return value to provide deletion count information
// without requiring separate EXISTS checks
func (c *Client) DelWithCount(ctx context.Context, keys ...string) (deletedCount int64, err error) <span class="cov8" title="1">{
        err = c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                count, err := c.redisClient.Del(ctx, keys...).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">deletedCount = count
                return nil</span>
        }, "DelWithCount")
        <span class="cov8" title="1">return deletedCount, err</span>
}

// TTL returns the time-to-live for a key with retry logic
func (c *Client) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov8" title="1">{
        var result time.Duration
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.TTL(ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "TTL")
        <span class="cov8" title="1">return result, err</span>
}

// Eval executes a Lua script on the server.
func (c *Client) Eval(ctx context.Context, script string, keys []string, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        var result interface{}
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.Eval(ctx, script, keys, args...).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "Eval")
        <span class="cov8" title="1">return result, err</span>
}

// Client returns the underlying Redis client for advanced operations like pipelines
func (c *Client) Client() *redis.Client <span class="cov8" title="1">{
        return c.redisClient
}</span>

func (c *Client) Close() error <span class="cov0" title="0">{
        return c.redisClient.Close()
}</span>
</pre>
		
		<pre class="file" id="file212" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"
)

// GetHealthStatus returns detailed health status of the Redis connection
func (c *Client) GetHealthStatus(ctx context.Context) *HealthStatus <span class="cov0" title="0">{
        status := &amp;HealthStatus{
                Connected: false,
                LastPing:  time.Time{},
                Errors:    []string{},
        }

        // Test ping with latency measurement
        start := time.Now()
        err := c.Ping(ctx)
        latency := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                status.Errors = append(status.Errors, err.Error())
                status.Connected = false
        }</span> else<span class="cov0" title="0"> {
                status.Connected = true
                status.LastPing = time.Now()
                status.PingLatency = latency
        }</span>

        // Get server info if connected
        <span class="cov0" title="0">if status.Connected </span><span class="cov0" title="0">{
                if info, err := c.getServerInfo(ctx); err == nil </span><span class="cov0" title="0">{
                        status.ServerInfo = info
                }</span> else<span class="cov0" title="0"> {
                        status.Errors = append(status.Errors, fmt.Sprintf("failed to get server info: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return status</span>
}

// getServerInfo retrieves Redis server information into a strongly-typed struct in one round trip.
func (c *Client) getServerInfo(ctx context.Context) (*ServerInfo, error) <span class="cov0" title="0">{
        var info *ServerInfo
        err := c.executeWithRetry(ctx, func() error </span><span class="cov0" title="0">{
                // Fetch all info sections at once to minimize network round trips.
                result, err := c.redisClient.Info(ctx, "all").Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">info = &amp;ServerInfo{
                        RawInfo:   result,
                        Timestamp: time.Now(),
                }

                // The full result string already contains memory and stats info,
                // but if you need them separated for the struct, you can still
                // issue specific commands or parse the main string.
                // For efficiency, storing the raw result is often enough.
                // Let's assume for now the RawInfo is the primary goal.
                // If you absolutely need them as separate fields, the original way is fine,
                // but this single 'all' call is faster.

                return nil</span>
        }, "GetServerInfo")

        <span class="cov0" title="0">return info, err</span>
}

// IsHealthy performs a comprehensive health check
func (c *Client) IsHealthy(ctx context.Context) bool <span class="cov0" title="0">{
        status := c.GetHealthStatus(ctx)
        return status.Connected &amp;&amp; len(status.Errors) == 0
}</span>

// PerformHealthCheck performs a detailed health check and returns a strongly-typed result.
func (c *Client) PerformHealthCheck(ctx context.Context) (*HealthCheckResult, error) <span class="cov0" title="0">{
        results := &amp;HealthCheckResult{}

        // Test 1: Basic ping
        start := time.Now()
        pingErr := c.Ping(ctx)
        results.Ping.Latency = time.Since(start)
        results.Ping.Success = pingErr == nil
        if pingErr != nil </span><span class="cov0" title="0">{
                results.Ping.Error = pingErr.Error()
        }</span>

        // Test 2 &amp; 3: Atomic Set/Get/Delete operation using Lua script
        // This reduces network round trips from 3 (Set + Get + Del) to 1 (Lua script)
        <span class="cov0" title="0">testKey := fmt.Sprintf("health_check_%d", time.Now().Unix())
        testValue := "health_test_value"

        start = time.Now()
        setSuccess, getSuccess, valueMatch, cleanupErr := c.performAtomicHealthTest(ctx, testKey, testValue, 30*time.Second)
        results.Set.Latency = time.Since(start)
        results.Set.Success = setSuccess

        results.Get.Latency = time.Since(start) // Same latency as Set since it's atomic
        results.Get.Success = getSuccess
        results.Get.ValueMatch = valueMatch

        if cleanupErr != "" </span><span class="cov0" title="0">{
                results.Cleanup.Error = cleanupErr
        }</span>

        // Test 4: Connection pool status
        <span class="cov0" title="0">stats := c.redisClient.PoolStats()
        results.PoolStats = PoolHealthStats{
                Hits:       stats.Hits,
                Misses:     stats.Misses,
                Timeouts:   stats.Timeouts,
                TotalConns: stats.TotalConns,
                IdleConns:  stats.IdleConns,
                StaleConns: stats.StaleConns,
        }

        // Overall health status
        results.Overall.Healthy = (pingErr == nil &amp;&amp; setSuccess)
        results.Overall.Timestamp = time.Now()

        return results, nil</span>
}

// performAtomicHealthTest performs Set/Get/Delete operations atomically using Lua script
// Returns: setSuccess, getSuccess, valueMatch, cleanupError
func (c *Client) performAtomicHealthTest(ctx context.Context, key, value string, ttl time.Duration) (bool, bool, bool, string) <span class="cov0" title="0">{
        // Lua script that atomically sets a key, gets its value, and deletes it
        // Returns: [set_result, get_result, delete_result]
        // set_result: 1 if key was set, 0 if failed
        // get_result: the value that was retrieved, or nil if failed
        // delete_result: 1 if key was deleted, 0 if failed
        script := `
        local set_result = redis.call("set", KEYS[1], ARGV[1], "ex", ARGV[2])
        if set_result == "OK" then
                local get_result = redis.call("get", KEYS[1])
                local delete_result = redis.call("del", KEYS[1])
                return {1, get_result, delete_result}
        else
                return {0, nil, 0}
        end`

        ttlSeconds := int(ttl.Seconds())

        result, err := c.Eval(ctx, script, []string{key}, value, ttlSeconds)
        if err != nil </span><span class="cov0" title="0">{
                return false, false, false, err.Error()
        }</span>

        // Parse the result array
        <span class="cov0" title="0">if resultArray, ok := result.([]interface{}); ok &amp;&amp; len(resultArray) &gt;= 3 </span><span class="cov0" title="0">{
                setSuccess := resultArray[0] == int64(1)
                getValue := resultArray[1]
                deleteSuccess := resultArray[2] == int64(1)

                getSuccess := getValue != nil
                valueMatch := getSuccess &amp;&amp; getValue == value

                var cleanupErr string
                if !deleteSuccess </span><span class="cov0" title="0">{
                        cleanupErr = "failed to delete test key"
                }</span>

                <span class="cov0" title="0">return setSuccess, getSuccess, valueMatch, cleanupErr</span>
        }

        <span class="cov0" title="0">return false, false, false, "invalid script result format"</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">package redis

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// ErrLockNotAcquired is returned when an attempt to release a lock that was not acquired fails.
var ErrLockNotAcquired = errors.New("cannot release a lock that is not acquired")

// ErrLockContention is returned when a lock cannot be acquired due to contention (not network errors).
var ErrLockContention = errors.New("lock is held by another client")

// RetryStrategy defines the retry behavior for acquiring a lock.
type RetryStrategy struct {
        MaxRetries int
        Delay      time.Duration
}

// NoRetry is a strategy that does not attempt to retry.
func NoRetry() *RetryStrategy <span class="cov8" title="1">{
        return &amp;RetryStrategy{MaxRetries: 0, Delay: 0}
}</span>

// FixedRetry is a strategy that retries a fixed number of times with a constant delay.
func FixedRetry(maxRetries int, delay time.Duration) *RetryStrategy <span class="cov8" title="1">{
        return &amp;RetryStrategy{MaxRetries: maxRetries, Delay: delay}
}</span>

// Lock represents a distributed lock object.
type Lock struct {
        client        *Client
        key           string
        token         string
        ttl           time.Duration
        retryStrategy *RetryStrategy
}

// NewLock creates a new distributed lock instance.
// key: The Redis key to use for the lock.
// ttl: The time-to-live for the lock. It must be greater than zero.
// retryStrategy: The strategy for retrying to acquire the lock if it's already held.
func (c *Client) NewLock(key string, ttl time.Duration, retryStrategy *RetryStrategy) (*Lock, error) <span class="cov8" title="1">{
        if ttl &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("lock TTL must be greater than zero")
        }</span>
        <span class="cov8" title="1">if retryStrategy == nil </span><span class="cov8" title="1">{
                retryStrategy = NoRetry()
        }</span>
        <span class="cov8" title="1">return &amp;Lock{
                client: c,
                key:    key,
                // The token is a unique value for this specific lock attempt (fencing token).
                token:         uuid.NewString(),
                ttl:           ttl,
                retryStrategy: retryStrategy,
        }, nil</span>
}

// Acquire attempts to acquire the lock. It will retry based on the configured RetryStrategy.
func (l *Lock) Acquire(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        // For NoRetry, handle it directly without the retry package
        if l.retryStrategy.MaxRetries == 0 </span><span class="cov8" title="1">{
                // Attempt to set the key with our unique token, only if it does not exist (NX).
                acquired, err := l.client.SetNX(ctx, l.key, l.token, l.ttl)
                if err != nil </span><span class="cov0" title="0">{
                        // This is a network or Redis error, not a lock contention issue.
                        return false, fmt.Errorf("failed to acquire lock: %w", err)
                }</span>
                <span class="cov8" title="1">return acquired, nil</span>
        }

        // Convert RetryStrategy to generic RetryConfig for retry cases
        <span class="cov8" title="1">retryConfig := &amp;retry.RetryConfig{
                MaxRetries:      l.retryStrategy.MaxRetries,
                InitialDelay:    l.retryStrategy.Delay,
                MaxDelay:        l.retryStrategy.Delay, // Use the same delay for all retries
                BackoffFactor:   1.0,                   // No exponential backoff for locks
                JitterFactor:    0.0,                   // No jitter for locks
                LogRetryAttempt: false,                 // Don't log retry attempts for locks
                ShouldRetry:     l.shouldRetryLockAcquisition,
        }

        // Create the lock acquisition operation
        operation := func() (bool, error) </span><span class="cov8" title="1">{
                // Attempt to set the key with our unique token, only if it does not exist (NX).
                acquired, err := l.client.SetNX(ctx, l.key, l.token, l.ttl)
                if err != nil </span><span class="cov0" title="0">{
                        // This is a network or Redis error, not a lock contention issue.
                        return false, fmt.Errorf("failed to acquire lock: %w", err)
                }</span>

                <span class="cov8" title="1">if acquired </span><span class="cov8" title="1">{
                        // We got the lock.
                        return true, nil
                }</span>

                // Lock is held by another client - this is expected contention
                <span class="cov8" title="1">return false, ErrLockContention</span>
        }

        // Use the generic retry package
        <span class="cov8" title="1">result, err := retry.Retry(ctx, operation, retryConfig, l.client.logger)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrLockContention) </span><span class="cov0" title="0">{
                        // Lock contention after all retries - this is not an error, just couldn't acquire
                        return false, nil
                }</span>
                // Network or other error
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// shouldRetryLockAcquisition determines if we should retry lock acquisition
func (l *Lock) shouldRetryLockAcquisition(err error) bool <span class="cov8" title="1">{
        // Only retry on lock contention, not on network errors
        return errors.Is(err, ErrLockContention)
}</span>

// Release safely releases the lock. It uses a Lua script to ensure that it only
// deletes the lock if it is still the owner (i.e., the token matches).
func (l *Lock) Release(ctx context.Context) error <span class="cov8" title="1">{
        // This Lua script atomically gets the key, compares its value to our token,
        // and deletes it if they match. This prevents deleting a lock acquired by another client.
        script := `
        if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
        else
                return 0
        end`

        // We use Eval to run the script. It is wrapped in our client's retry logic for network errors.
        res, err := l.client.Eval(ctx, script, []string{l.key}, l.token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute lock release script: %w", err)
        }</span>

        // The script returns 1 if the key was deleted, 0 otherwise.
        <span class="cov8" title="1">if val, ok := res.(int64); !ok || val == 0 </span><span class="cov8" title="1">{
                return ErrLockNotAcquired
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">package redis

import "time"

// MonitoringHooks defines callbacks for monitoring Redis operations
type MonitoringHooks struct {
        OnOperationStart   func(operation string, key string)
        OnOperationEnd     func(operation string, key string, duration time.Duration, err error)
        OnConnectionStatus func(connected bool, latency time.Duration)
        OnRecoveryStart    func(reason string)
        OnRecoveryEnd      func(success bool, attempts int, duration time.Duration)
        OnRetryAttempt     func(operation string, attempt int, err error)
}

// OperationMetrics tracks metrics for Redis operations
type OperationMetrics struct {
        TotalCalls     int64
        TotalDuration  time.Duration
        ErrorCount     int64
        LastError      error
        LastErrorTime  time.Time
        SuccessCount   int64
        RetryCount     int64
        AverageLatency time.Duration
}

// SetMonitoringHooks sets the monitoring hooks for the client
func (c *Client) SetMonitoringHooks(hooks *MonitoringHooks) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.monitoringHooks = hooks
}</span>

// trackOperationStart tracks the start of an operation
func (c *Client) trackOperationStart(operation string, key string) <span class="cov8" title="1">{
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnOperationStart != nil </span><span class="cov8" title="1">{
                c.monitoringHooks.OnOperationStart(operation, key)
        }</span>
}

// trackOperationEnd tracks the end of an operation
func (c *Client) trackOperationEnd(operation string, key string, duration time.Duration, err error) <span class="cov8" title="1">{
        // Update internal metrics
        c.mu.Lock()
        if c.operationMetrics == nil </span><span class="cov8" title="1">{
                c.operationMetrics = make(map[string]*OperationMetrics)
        }</span>

        <span class="cov8" title="1">metrics, exists := c.operationMetrics[operation]
        if !exists </span><span class="cov8" title="1">{
                metrics = &amp;OperationMetrics{}
                c.operationMetrics[operation] = metrics
        }</span>

        <span class="cov8" title="1">metrics.TotalCalls++
        metrics.TotalDuration += duration
        metrics.AverageLatency = time.Duration(int64(metrics.TotalDuration) / metrics.TotalCalls)

        if err != nil </span><span class="cov8" title="1">{
                metrics.ErrorCount++
                metrics.LastError = err
                metrics.LastErrorTime = time.Now()
        }</span> else<span class="cov8" title="1"> {
                metrics.SuccessCount++
        }</span>
        <span class="cov8" title="1">c.mu.Unlock()

        // Call external monitoring hook
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnOperationEnd != nil </span><span class="cov8" title="1">{
                c.monitoringHooks.OnOperationEnd(operation, key, duration, err)
        }</span>
}

// trackConnectionStatus tracks connection status changes
func (c *Client) trackConnectionStatus(connected bool, latency time.Duration) <span class="cov8" title="1">{
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnConnectionStatus != nil </span><span class="cov0" title="0">{
                c.monitoringHooks.OnConnectionStatus(connected, latency)
        }</span>
}

// trackRecoveryStart tracks the start of connection recovery
func (c *Client) trackRecoveryStart(reason string) <span class="cov0" title="0">{
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnRecoveryStart != nil </span><span class="cov0" title="0">{
                c.monitoringHooks.OnRecoveryStart(reason)
        }</span>
}

// trackRecoveryEnd tracks the end of connection recovery
func (c *Client) trackRecoveryEnd(success bool, attempts int, duration time.Duration) <span class="cov0" title="0">{
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnRecoveryEnd != nil </span><span class="cov0" title="0">{
                c.monitoringHooks.OnRecoveryEnd(success, attempts, duration)
        }</span>
}

// trackRetryAttempt tracks retry attempts
func (c *Client) trackRetryAttempt(operation string, attempt int, err error) <span class="cov8" title="1">{
        // Update internal metrics
        c.mu.Lock()
        if c.operationMetrics == nil </span><span class="cov0" title="0">{
                c.operationMetrics = make(map[string]*OperationMetrics)
        }</span>

        <span class="cov8" title="1">metrics, exists := c.operationMetrics[operation]
        if !exists </span><span class="cov0" title="0">{
                metrics = &amp;OperationMetrics{}
                c.operationMetrics[operation] = metrics
        }</span>

        <span class="cov8" title="1">metrics.RetryCount++
        c.mu.Unlock()

        // Call external monitoring hook
        if c.monitoringHooks != nil &amp;&amp; c.monitoringHooks.OnRetryAttempt != nil </span><span class="cov8" title="1">{
                c.monitoringHooks.OnRetryAttempt(operation, attempt, err)
        }</span>
}

// GetOperationMetrics returns current operation metrics
func (c *Client) GetOperationMetrics() map[string]*OperationMetrics <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Create a copy to avoid race conditions
        result := make(map[string]*OperationMetrics)
        for op, metrics := range c.operationMetrics </span><span class="cov8" title="1">{
                result[op] = &amp;OperationMetrics{
                        TotalCalls:     metrics.TotalCalls,
                        TotalDuration:  metrics.TotalDuration,
                        ErrorCount:     metrics.ErrorCount,
                        LastError:      metrics.LastError,
                        LastErrorTime:  metrics.LastErrorTime,
                        SuccessCount:   metrics.SuccessCount,
                        RetryCount:     metrics.RetryCount,
                        AverageLatency: metrics.AverageLatency,
                }
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ResetOperationMetrics resets all operation metrics
func (c *Client) ResetOperationMetrics() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.operationMetrics = make(map[string]*OperationMetrics)
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"

        redis "github.com/redis/go-redis/v9"
)

// connectionRecoveryLoop monitors connection health and attempts recovery
func (c *Client) connectionRecoveryLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(c.recoveryConfig.CheckInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.checkAndRecoverConnection(context.Background())
        }</span>
}

// checkAndRecoverConnection checks connection health and attempts recovery if needed
func (c *Client) checkAndRecoverConnection(ctx context.Context) <span class="cov0" title="0">{
        c.mu.Lock()
        if c.isRecovering </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return // Already in recovery mode
        }</span>
        <span class="cov0" title="0">c.mu.Unlock()

        // Quick health check
        if err := c.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                c.logger.Warnf("Redis connection unhealthy, starting recovery: %v", err)
                c.mu.Lock()
                c.isRecovering = true
                c.mu.Unlock()
                go c.performConnectionRecovery()
        }</span> else<span class="cov0" title="0"> {
                c.mu.Lock()
                c.lastHealthCheck = time.Now()
                c.mu.Unlock()
        }</span>
}


// performConnectionRecovery attempts to recover the Redis connection
func (c *Client) performConnectionRecovery() <span class="cov0" title="0">{
        start := time.Now()
        c.trackRecoveryStart("connection_failed")

        defer func() </span><span class="cov0" title="0">{
                c.mu.Lock()
                c.isRecovering = false
                c.mu.Unlock()
        }</span>()

        <span class="cov0" title="0">config := c.recoveryConfig
        backoff := time.Second

        ctx := context.Background()

        for attempt := 0; attempt &lt; config.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        c.logger.Infof("Redis connection recovery attempt %d/%d after %v",
                                attempt+1, config.MaxRetries, backoff)
                        time.Sleep(backoff)
                }</span>

                // Try to recreate connection
                <span class="cov0" title="0">if err := c.recreateConnection(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Redis connection recovery attempt %d failed: %v", attempt+1, err)

                        // Exponential backoff with jitter
                        backoff = time.Duration(float64(backoff) * config.BackoffFactor)
                        if backoff &gt; config.MaxBackoffDelay </span><span class="cov0" title="0">{
                                backoff = config.MaxBackoffDelay
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Test the new connection
                <span class="cov0" title="0">if err := c.CheckConnection(ctx); err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Redis connection recovery test failed: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">c.logger.Infof("Redis connection recovery successful after %d attempts", attempt+1)
                c.mu.Lock()
                c.lastHealthCheck = time.Now()
                c.mu.Unlock()


                // Track successful recovery
                duration := time.Since(start)
                c.trackRecoveryEnd(true, attempt+1, duration)
                return</span>
        }

        <span class="cov0" title="0">c.logger.Errorf("Redis connection recovery failed after %d attempts", config.MaxRetries)

        // Track failed recovery
        duration := time.Since(start)
        c.trackRecoveryEnd(false, config.MaxRetries, duration)</span>
}

// recreateConnection recreates the Redis connection
func (c *Client) recreateConnection() error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Close existing connection
        if c.redisClient != nil </span><span class="cov0" title="0">{
                err := c.redisClient.Close()
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorf("Failed to close Redis client: %v", err)
                }</span>
        }

        // Parse config and create new connection
        <span class="cov0" title="0">opt, err := parseRedisConfig(c.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse Redis configuration: %w", err)
        }</span>

        <span class="cov0" title="0">c.redisClient = redis.NewClient(opt)
        return nil</span>
}

// GetConnectionStatus returns the current connection status in a strongly-typed struct.
func (c *Client) GetConnectionStatus() *ConnectionStatus <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        stats := c.redisClient.PoolStats()
        return &amp;ConnectionStatus{
                IsRecovering:     c.isRecovering,
                LastHealthCheck:  c.lastHealthCheck,
                RecoveryEnabled:  c.recoveryConfig.Enabled,
                RecoveryInterval: c.recoveryConfig.CheckInterval,
                PoolStats: PoolHealthStats{
                        Hits:       stats.Hits,
                        Misses:     stats.Misses,
                        Timeouts:   stats.Timeouts,
                        TotalConns: stats.TotalConns,
                        IdleConns:  stats.IdleConns,
                        StaleConns: stats.StaleConns,
                },
        }
}</pre>
		
		<pre class="file" id="file216" style="display: none">package redis

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "syscall"
        "time"

        redis "github.com/redis/go-redis/v9"
)

// SetRetryConfig sets custom retry configuration
func (c *Client) SetRetryConfig(config *RetryConfig) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.retryConfig = config
}</span>

// SetConnectionRecoveryConfig sets custom connection recovery configuration
func (c *Client) SetConnectionRecoveryConfig(config *ConnectionRecoveryConfig) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.recoveryConfig = config
}</span>

// executeWithRetry executes an operation with retry logic
func (c *Client) executeWithRetry(ctx context.Context, operation func() error, operationName string) error <span class="cov8" title="1">{
        return c.executeWithRetryAndKey(ctx, operation, operationName, "")
}</span>

// executeWithRetryAndKey executes an operation with retry logic and tracks by key
func (c *Client) executeWithRetryAndKey(ctx context.Context, operation func() error, operationName string, key string) error <span class="cov8" title="1">{
        config := c.retryConfig
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRetryConfig()
        }</span>

        <span class="cov8" title="1">delay := config.InitialDelay
        var lastErr error

        for attempt := 0; attempt &lt; config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Execute the operation with monitoring
                <span class="cov8" title="1">start := time.Now()
                c.trackOperationStart(operationName, key)

                err := operation()

                duration := time.Since(start)
                c.trackOperationEnd(operationName, key, duration, err)

                // If operation succeeded, return immediately
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if we should retry based on custom predicate
                if !c.isRetryableError(err) </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Track retry attempt
                <span class="cov8" title="1">c.trackRetryAttempt(operationName, attempt+1, err)

                // Calculate delay with jitter
                sleepDuration := c.calculateDelayWithJitter(delay, config.JitterFactor)

                if config.LogRetryAttempt </span><span class="cov8" title="1">{
                        c.logger.Warnf("Attempt %d/%d failed: %v. Retrying in %v...", attempt+1, config.MaxRetries, err, sleepDuration)
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-time.After(sleepDuration):<span class="cov8" title="1">
                        // Calculate next delay using exponential backoff
                        delay = c.calculateNextDelay(delay, config.BackoffFactor, config.MaxDelay)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }

        <span class="cov8" title="1">return fmt.Errorf("operation failed after %d attempts: %w", config.MaxRetries, lastErr)</span>
}

// calculateDelayWithJitter calculates the sleep duration with jitter applied
func (c *Client) calculateDelayWithJitter(baseDelay time.Duration, jitterFactor float64) time.Duration <span class="cov8" title="1">{
        sleepDuration := baseDelay
        if jitterFactor &gt; 0 </span><span class="cov8" title="1">{
                // Use a simple jitter calculation
                jitter := time.Duration(jitterFactor * float64(baseDelay) * c.secureFloat64())
                sleepDuration += jitter
        }</span>
        <span class="cov8" title="1">return sleepDuration</span>
}

// calculateNextDelay calculates the next delay value using exponential backoff
func (c *Client) calculateNextDelay(currentDelay time.Duration, backoffFactor float64, maxDelay time.Duration) time.Duration <span class="cov8" title="1">{
        nextDelay := time.Duration(float64(currentDelay) * backoffFactor)
        if nextDelay &gt; maxDelay </span><span class="cov0" title="0">{
                nextDelay = maxDelay
        }</span>
        <span class="cov8" title="1">return nextDelay</span>
}

// secureFloat64 returns a secure random float64 in [0.0,1.0)
func (c *Client) secureFloat64() float64 <span class="cov8" title="1">{
        // Use time-based random for simplicity, but could be enhanced with crypto/rand
        return float64(time.Now().UnixNano()%1000) / 1000.0
}</span>

// isRetryableError determines if an error is retryable using type assertions and specific checks
// instead of relying solely on string matching.
func (c *Client) isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Case 1: redis.Nil is a "not found" error, which is never retryable.
        <span class="cov8" title="1">if errors.Is(err, redis.Nil) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Case 2: The context was canceled or its deadline was exceeded. Not retryable.
        <span class="cov8" title="1">if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Case 3: Check for common network error types.
        <span class="cov8" title="1">var netErr net.Error
        if errors.As(err, &amp;netErr) </span><span class="cov8" title="1">{
                if netErr.Timeout() </span><span class="cov8" title="1">{
                        c.logger.Debugf("Redis error is a retryable network timeout: %v", err)
                        return true // It's a timeout, so we should retry.
                }</span>
        }

        // Case 4: Check for specific system-level errors (e.g., connection refused).
        <span class="cov8" title="1">var opErr *net.OpError
        if errors.As(err, &amp;opErr) </span><span class="cov8" title="1">{
                var sysErr syscall.Errno
                if errors.As(opErr.Err, &amp;sysErr) </span><span class="cov8" title="1">{
                        if sysErr == syscall.ECONNREFUSED || sysErr == syscall.ECONNRESET </span><span class="cov8" title="1">{
                                c.logger.Debugf("Redis error is a retryable syscall error (%s): %v", sysErr.Error(), err)
                                return true
                        }</span>
                }
        }

        // Case 5: EOF often indicates a connection was closed by the other side, which is retryable.
        <span class="cov8" title="1">if errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                c.logger.Debugf("Redis error is a retryable EOF: %v", err)
                return true
        }</span>

        // Default to non-retryable for unknown errors.
        <span class="cov8" title="1">c.logger.Debugf("Redis error is considered non-retryable by default: %v (type: %T)", err, err)
        return false</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">package redis

import (
        "context"

        redis "github.com/redis/go-redis/v9"
)

// Scan performs a cursor-based scan of keys matching a pattern.
// This is a safe alternative to the KEYS command that doesn't block the Redis server.
// It returns keys in batches, allowing for non-blocking iteration through large keyspaces.
func (c *Client) Scan(ctx context.Context, cursor uint64, options *ScanOptions) (*ScanResult, error) <span class="cov8" title="1">{
        var result *ScanResult
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                var cmd *redis.ScanCmd

                if options == nil </span><span class="cov8" title="1">{
                        options = &amp;ScanOptions{}
                }</span>

                // Use SCAN with pattern and count
                <span class="cov8" title="1">cmd = c.redisClient.Scan(ctx, cursor, options.Pattern, options.Count)

                // If type filter is specified, use SCAN with TYPE option
                if options.Type != "" </span><span class="cov8" title="1">{
                        cmd = c.redisClient.ScanType(ctx, cursor, options.Pattern, options.Count, options.Type)
                }</span>

                <span class="cov8" title="1">keys, nextCursor, err := cmd.Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">result = &amp;ScanResult{
                        Cursor:  nextCursor,
                        Keys:    keys,
                        HasMore: nextCursor != 0,
                }

                return nil</span>
        }, "Scan")

        <span class="cov8" title="1">return result, err</span>
}

// ScanAll performs a complete scan of all keys matching a pattern.
// This method iterates through all keys using the cursor-based SCAN command
// and returns all matching keys. Use with caution for large keyspaces.
func (c *Client) ScanAll(ctx context.Context, options *ScanOptions) ([]string, error) <span class="cov8" title="1">{
        var allKeys []string
        var cursor uint64 = 0

        for </span><span class="cov8" title="1">{
                result, err := c.Scan(ctx, cursor, options)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allKeys = append(allKeys, result.Keys...)

                if !result.HasMore </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">cursor = result.Cursor</span>
        }

        <span class="cov8" title="1">return allKeys, nil</span>
}

// ScanKeysByPattern scans keys matching a specific pattern with a default count.
// This is a convenience method for common pattern-based scanning.
func (c *Client) ScanKeysByPattern(ctx context.Context, pattern string, count int64) (*ScanResult, error) <span class="cov8" title="1">{
        options := &amp;ScanOptions{
                Pattern: pattern,
                Count:   count,
        }
        return c.Scan(ctx, 0, options)
}</span>

// ScanKeysByType scans keys of a specific type (string, list, set, zset, hash, stream).
// This is useful for finding keys of a particular data structure type.
func (c *Client) ScanKeysByType(ctx context.Context, keyType string, count int64) (*ScanResult, error) <span class="cov8" title="1">{
        options := &amp;ScanOptions{
                Pattern: "*",
                Count:   count,
                Type:    keyType,
        }
        return c.Scan(ctx, 0, options)
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">package redis

import (
        "context"

        redis "github.com/redis/go-redis/v9"
)

// ZAdd adds one or more members to a sorted set, or updates its score if it already exists
func (c *Client) ZAdd(ctx context.Context, key string, members ...redis.Z) (int64, error) <span class="cov0" title="0">{
        var result int64
        err := c.executeWithRetryAndKey(ctx, func() error </span><span class="cov0" title="0">{
                val, err := c.redisClient.ZAdd(ctx, key, members...).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">result = val
                return nil</span>
        }, "ZAdd", key)
        <span class="cov0" title="0">return result, err</span>
}

// ZAddWithExists adds members to a sorted set and returns both the number of new elements added
// and whether the key existed before the operation
func (c *Client) ZAddWithExists(ctx context.Context, key string, members ...redis.Z) (newElements int64, keyExisted bool, err error) <span class="cov0" title="0">{
        err = c.executeWithRetryAndKey(ctx, func() error </span><span class="cov0" title="0">{
                // First check if the key exists
                exists, err := c.redisClient.Exists(ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">keyExisted = exists &gt; 0

                // Add the members
                val, err := c.redisClient.ZAdd(ctx, key, members...).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">newElements = val
                return nil</span>
        }, "ZAddWithExists", key)
        <span class="cov0" title="0">return newElements, keyExisted, err</span>
}

// ZRevRange returns a range of members in a sorted set, by index, with scores ordered from high to low
func (c *Client) ZRevRange(ctx context.Context, key string, start, stop int64) ([]string, error) <span class="cov0" title="0">{
        var result []string
        err := c.executeWithRetryAndKey(ctx, func() error </span><span class="cov0" title="0">{
                val, err := c.redisClient.ZRevRange(ctx, key, start, stop).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">result = val
                return nil</span>
        }, "ZRevRange", key)
        <span class="cov0" title="0">return result, err</span>
}

// ZRemRangeByScore removes all members in a sorted set within the given scores
func (c *Client) ZRemRangeByScore(ctx context.Context, key, min, max string) (int64, error) <span class="cov0" title="0">{
        var result int64
        err := c.executeWithRetryAndKey(ctx, func() error </span><span class="cov0" title="0">{
                val, err := c.redisClient.ZRemRangeByScore(ctx, key, min, max).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">result = val
                return nil</span>
        }, "ZRemRangeByScore", key)
        <span class="cov0" title="0">return result, err</span>
}

// ZCard returns the sorted set cardinality (number of elements) of the sorted set stored at key
func (c *Client) ZCard(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        var result int64
        err := c.executeWithRetryAndKey(ctx, func() error </span><span class="cov0" title="0">{
                val, err := c.redisClient.ZCard(ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">result = val
                return nil</span>
        }, "ZCard", key)
        <span class="cov0" title="0">return result, err</span>
}
</pre>
		
		<pre class="file" id="file219" style="display: none">package redis

import (
        "context"
        "time"

        redis "github.com/redis/go-redis/v9"
)

func (c *Client) CreateStreamIfNotExists(ctx context.Context, stream string, ttl time.Duration) error <span class="cov8" title="1">{
        // This Lua script checks for the stream's existence. If it doesn't exist,
        // it creates it with an initial message and sets its TTL.
        // It returns 1 if it created the stream, and 0 if it already existed.
        // The use of PEXPIRE ensures we can handle TTLs with millisecond precision if needed.
        script := `
        if redis.call("exists", KEYS[1]) == 0 then
                redis.call("xadd", KEYS[1], "*", "init", "stream_created")
                redis.call("pexpire", KEYS[1], ARGV[1])
                return 1
        else
                return 0
        end`

        // TTL needs to be in milliseconds for PEXPIRE.
        ttlMs := ttl.Milliseconds()

        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                // Eval runs the script atomically on the server.
                _, err := c.redisClient.Eval(ctx, script, []string{stream}, ttlMs).Result()
                return err
        }</span>, "CreateStreamIfNotExists")
}

func (c *Client) CreateConsumerGroup(ctx context.Context, stream, group string) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                err := c.redisClient.XGroupCreateMkStream(ctx, stream, group, "0").Err()
                if err != nil &amp;&amp; err.Error() != "BUSYGROUP Consumer Group name already exists" </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, "CreateConsumerGroup")
}

// CreateConsumerGroupAtomic creates a consumer group atomically using Lua script
// This handles the "already exists" case more efficiently and provides better error handling
func (c *Client) CreateConsumerGroupAtomic(ctx context.Context, stream, group string) (created bool, err error) <span class="cov8" title="1">{
        err = c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                err := c.redisClient.XGroupCreateMkStream(ctx, stream, group, "0").Err()
                if err != nil </span><span class="cov8" title="1">{
                        if err.Error() == "BUSYGROUP Consumer Group name already exists" </span><span class="cov8" title="1">{
                                created = false
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">created = true
                return nil</span>
        }, "CreateConsumerGroupAtomic")

        <span class="cov8" title="1">return created, err</span>
}

// CreateStreamWithConsumerGroup creates a stream and consumer group in a single operation
// This is more efficient than calling CreateStreamIfNotExists + CreateConsumerGroup separately
func (c *Client) CreateStreamWithConsumerGroup(ctx context.Context, stream, group string, ttl time.Duration) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                // Use pipeline to combine all operations into a single network round trip
                pipe := c.redisClient.Pipeline()

                // Create stream and consumer group in one operation
                groupCmd := pipe.XGroupCreateMkStream(ctx, stream, group, "0")

                // Add EXPIRE command if TTL is specified
                var expireCmd *redis.BoolCmd
                if ttl &gt; 0 </span><span class="cov8" title="1">{
                        expireCmd = pipe.Expire(ctx, stream, ttl)
                }</span>

                // Execute all commands in a single network round trip
                <span class="cov8" title="1">_, err := pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Check if it's just a "group already exists" error, which is not a problem
                        if err.Error() == "BUSYGROUP Consumer Group name already exists" </span><span class="cov0" title="0">{
                                // Group exists, but we still need to set TTL if specified
                                if ttl &gt; 0 </span><span class="cov0" title="0">{
                                        return c.redisClient.Expire(ctx, stream, ttl).Err()
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                // Check if group creation was successful
                <span class="cov8" title="1">if err := groupCmd.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check if EXPIRE was successful (if it was executed)
                <span class="cov8" title="1">if expireCmd != nil </span><span class="cov8" title="1">{
                        if _, err := expireCmd.Result(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }, "CreateStreamWithConsumerGroup")
}
</pre>
		
		<pre class="file" id="file220" style="display: none">package redis

import (
        "context"

        redis "github.com/redis/go-redis/v9"
)

func (c *Client) XAdd(ctx context.Context, args *redis.XAddArgs) (string, error) <span class="cov8" title="1">{
        var result string
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.XAdd(ctx, args).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "XAdd")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) XLen(ctx context.Context, stream string) (int64, error) <span class="cov8" title="1">{
        var result int64
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.XLen(ctx, stream).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "XLen")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) XReadGroup(ctx context.Context, args *redis.XReadGroupArgs) ([]redis.XStream, error) <span class="cov8" title="1">{
        var result []redis.XStream
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.XReadGroup(ctx, args).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "XReadGroup")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) XAck(ctx context.Context, stream, group, id string) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                return c.redisClient.XAck(ctx, stream, group, id).Err()
        }</span>, "XAck")
}

func (c *Client) XPending(ctx context.Context, stream, group string) (*redis.XPending, error) <span class="cov8" title="1">{
        var result *redis.XPending
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.XPending(ctx, stream, group).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "XPending")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) XPendingExt(ctx context.Context, args *redis.XPendingExtArgs) ([]redis.XPendingExt, error) <span class="cov8" title="1">{
        var result []redis.XPendingExt
        err := c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                val, err := c.redisClient.XPendingExt(ctx, args).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">result = val
                return nil</span>
        }, "XPendingExt")
        <span class="cov8" title="1">return result, err</span>
}

func (c *Client) XClaim(ctx context.Context, args *redis.XClaimArgs) *redis.XMessageSliceCmd <span class="cov8" title="1">{
        return c.redisClient.XClaim(ctx, args)
}</span>
</pre>
		
		<pre class="file" id="file221" style="display: none">package redis

import (
        "context"
        "time"
)

// RefreshTTL refreshes the TTL for a key if it exists
// Optimized to use EXPIRE XX option to reduce network round trips
func (c *Client) RefreshTTL(ctx context.Context, key string, ttl time.Duration) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                // Use EXPIRE XX to only set expiry if the key exists
                // This eliminates the need for a separate EXISTS check
                result, err := c.redisClient.ExpireXX(ctx, key, ttl).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If result is false, the key doesn't exist, which is not an error
                // for this operation (we only want to refresh TTL if it exists)
                <span class="cov8" title="1">if !result </span><span class="cov8" title="1">{
                        // Key doesn't exist, which is fine for refresh operations
                        return nil
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, "RefreshTTL")
}

// RefreshStreamTTL refreshes the TTL for a stream and ensures it stays active
// Optimized to use EXPIRE XX option to reduce network round trips
func (c *Client) RefreshStreamTTL(ctx context.Context, stream string, ttl time.Duration) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                // Use EXPIRE XX to only set expiry if the stream exists
                // This eliminates the need for a separate EXISTS check
                result, err := c.redisClient.ExpireXX(ctx, stream, ttl).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If result is false, the stream doesn't exist, which is not an error
                // for this operation (we only want to refresh TTL if it exists)
                <span class="cov8" title="1">if !result </span><span class="cov8" title="1">{
                        // Stream doesn't exist, which is fine for refresh operations
                        return nil
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, "RefreshStreamTTL")
}

// SetTTL sets TTL for a key
func (c *Client) SetTTL(ctx context.Context, key string, ttl time.Duration) error <span class="cov8" title="1">{
        return c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                return c.redisClient.Expire(ctx, key, ttl).Err()
        }</span>, "SetTTL")
}

// GetTTLStatus returns TTL status for a key
func (c *Client) GetTTLStatus(ctx context.Context, key string) (ttl time.Duration, exists bool, err error) <span class="cov8" title="1">{
        err = c.executeWithRetry(ctx, func() error </span><span class="cov8" title="1">{
                // TTL command is sufficient to determine both existence and expiry.
                ttlResult, err := c.redisClient.TTL(ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if ttlResult == -2 </span><span class="cov8" title="1">{
                        // Key does not exist.
                        exists = false
                        ttl = 0
                }</span> else<span class="cov8" title="1"> {
                        // Key exists. It may or may not have an expiry.
                        exists = true
                        ttl = ttlResult
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, "GetTTLStatus")

        <span class="cov8" title="1">return ttl, exists, err</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">package redis

import (
        "time"

        redis "github.com/redis/go-redis/v9"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// PipelineFunc is a function that accepts a Redis pipeline object.
// Users will queue their commands (e.g., pipe.Get, pipe.Set) inside this function.
type PipelineFunc func(pipe redis.Pipeliner) error

type ConnectionSettings struct {
        PoolSize     int
        MaxIdleConns int
        MinIdleConns int
        MaxRetries   int
        DialTimeout  time.Duration
        ReadTimeout  time.Duration // Used for socket reads, including for PING. This is the preferred way to set command timeouts.
        WriteTimeout time.Duration // Used for socket writes.
        PoolTimeout  time.Duration

        // The fields below are now DEPRECATED for creating timeouts, as using Read/Write timeouts
        // is better for connection pool health. They are kept for reference but are no longer
        // used to create a context.WithTimeout in the Ping or CheckConnection methods.
        PingTimeout      time.Duration
        HealthTimeout    time.Duration
        OperationTimeout time.Duration
}

type UpstashConfig struct {
        URL   string
        Token string
}

type RedisConfig struct {
        UpstashConfig      UpstashConfig
        ConnectionSettings ConnectionSettings
}

// RetryConfig is an alias for the generic retry configuration
type RetryConfig = retry.RetryConfig

// DefaultRetryConfig returns default retry configuration
func DefaultRetryConfig() *RetryConfig <span class="cov8" title="1">{
        config := retry.DefaultRetryConfig()
        // Override with Redis-specific defaults
        config.MaxRetries = 3
        config.InitialDelay = 100 * time.Millisecond
        config.MaxDelay = 5 * time.Second
        config.JitterFactor = 0.1
        return config
}</span>

// ServerInfo holds parsed information from the Redis server.
type ServerInfo struct {
        RawInfo         string    `json:"raw_info"`
        Timestamp       time.Time `json:"timestamp"`
        MemoryInfo      string    `json:"memory_info,omitempty"`
        StatsInfo       string    `json:"stats_info,omitempty"`
        MemoryInfoError string    `json:"memory_info_error,omitempty"`
        StatsInfoError  string    `json:"stats_info_error,omitempty"`
}

// HealthStatus represents the health status of Redis connection
type HealthStatus struct {
        Connected   bool
        LastPing    time.Time
        PingLatency time.Duration
        Errors      []string
        ServerInfo  *ServerInfo
}

// ConnectionRecoveryConfig defines configuration for connection recovery
type ConnectionRecoveryConfig struct {
        Enabled         bool
        CheckInterval   time.Duration
        MaxRetries      int
        BackoffFactor   float64
        MaxBackoffDelay time.Duration
}

// DefaultConnectionRecoveryConfig returns default connection recovery configuration
func DefaultConnectionRecoveryConfig() *ConnectionRecoveryConfig <span class="cov8" title="1">{
        return &amp;ConnectionRecoveryConfig{
                Enabled:         true,
                CheckInterval:   30 * time.Second,
                MaxRetries:      5,
                BackoffFactor:   2.0,
                MaxBackoffDelay: 5 * time.Minute,
        }
}</span>

// PoolHealthStats holds the statistics of the connection pool.
type PoolHealthStats struct {
        Hits       uint32 `json:"hits"`
        Misses     uint32 `json:"misses"`
        Timeouts   uint32 `json:"timeouts"`
        TotalConns uint32 `json:"total_conns"`
        IdleConns  uint32 `json:"idle_conns"`
        StaleConns uint32 `json:"stale_conns"`
}

// ConnectionStatus represents the current state of the client's connection.
type ConnectionStatus struct {
        IsRecovering     bool            `json:"is_recovering"`
        LastHealthCheck  time.Time       `json:"last_health_check"`
        RecoveryEnabled  bool            `json:"recovery_enabled"`
        RecoveryInterval time.Duration   `json:"recovery_interval"`
        PoolStats        PoolHealthStats `json:"pool_stats"`
}

// HealthCheckResult represents the detailed outcome of a full health check.
type HealthCheckResult struct {
        Ping      PingCheckResult      `json:"ping"`
        Set       OperationCheckResult `json:"set"`
        Get       GetCheckResult       `json:"get"`
        Cleanup   CleanupCheckResult   `json:"cleanup,omitempty"`
        PoolStats PoolHealthStats      `json:"pool_stats"`
        Overall   OverallHealth        `json:"overall"`
}

// PingCheckResult holds the result of a ping test.
type PingCheckResult struct {
        Success bool          `json:"success"`
        Latency time.Duration `json:"latency"`
        Error   string        `json:"error,omitempty"`
}

// OperationCheckResult holds the result of a generic operation test (like SET).
type OperationCheckResult struct {
        Success bool          `json:"success"`
        Latency time.Duration `json:"latency"`
        Error   string        `json:"error,omitempty"`
}

// GetCheckResult holds the result of a GET test.
type GetCheckResult struct {
        Success    bool          `json:"success"`
        Latency    time.Duration `json:"latency"`
        Error      string        `json:"error,omitempty"`
        ValueMatch bool          `json:"value_match"`
}

// CleanupCheckResult holds the result of the cleanup operation.
type CleanupCheckResult struct {
        Error string `json:"error,omitempty"`
}

// OverallHealth holds the summary of the health check.
type OverallHealth struct {
        Healthy   bool      `json:"healthy"`
        Timestamp time.Time `json:"timestamp"`
}

// ScanOptions defines options for the Scan operation
type ScanOptions struct {
        Pattern string `json:"pattern"` // Redis pattern for key matching (e.g., "user:*", "*:active")
        Count   int64  `json:"count"`   // Number of keys to scan per iteration (suggested: 100-1000)
        Type    string `json:"type"`    // Optional: filter by type (string, list, set, zset, hash, stream)
}

// ScanResult represents the result of a scan operation
type ScanResult struct {
        Cursor  uint64   `json:"cursor"`   // Next cursor position for continuation
        Keys    []string `json:"keys"`     // Keys found in this iteration
        HasMore bool     `json:"has_more"` // Whether there are more keys to scan
}
</pre>
		
		<pre class="file" id="file223" style="display: none">package cryptography

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/common/hexutil"
        "github.com/ethereum/go-ethereum/crypto"
)

func SignMessage(message string, privateKey string) (string, error) <span class="cov8" title="1">{
        privateKeyECDSA, err := crypto.HexToECDSA(privateKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid private key: %w", err)
        }</span>

        <span class="cov8" title="1">messageHash := crypto.Keccak256Hash([]byte(fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(message), message)))
        messageBytes := messageHash.Bytes()

        signature, err := crypto.Sign(messageBytes, privateKeyECDSA)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign message: %w", err)
        }</span>

        <span class="cov8" title="1">signature[64] += 27

        return hexutil.Encode(signature), nil</span>
}

func SignJSONMessage(jsonData interface{}, privateKey string) (string, error) <span class="cov8" title="1">{
        jsonDataMap := make(map[string]interface{})

        jsonBytes, err := json.Marshal(jsonData)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to marshal input data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonBytes, &amp;jsonDataMap); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal to map: %w", err)
        }</span>

        <span class="cov8" title="1">convertToLower(jsonDataMap)

        jsonDataBytes, err := json.Marshal(jsonDataMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal json data: %w", err)
        }</span>

        <span class="cov8" title="1">message := string(jsonDataBytes)

        return SignMessage(message, privateKey)</span>
}

func VerifySignature(message string, signature string, signerAddress string) (bool, error) <span class="cov8" title="1">{
        messageHash := crypto.Keccak256Hash([]byte(fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(message), message)))
        messageBytes := messageHash.Bytes()

        signatureBytes, err := hexutil.Decode(signature)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid signature: %w", err)
        }</span>

        <span class="cov8" title="1">if len(signatureBytes) != 65 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid signature length")
        }</span>

        <span class="cov8" title="1">if signatureBytes[64] &gt;= 27 </span><span class="cov8" title="1">{
                signatureBytes[64] -= 27
        }</span>

        <span class="cov8" title="1">pubKeyRaw, err := crypto.Ecrecover(messageBytes, signatureBytes)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to recover public key: %w", err)
        }</span>

        <span class="cov8" title="1">pubKey, err := crypto.UnmarshalPubkey(pubKeyRaw)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to unmarshal public key: %w", err)
        }</span>

        <span class="cov8" title="1">recoveredAddr := crypto.PubkeyToAddress(*pubKey)

        checksumAddr := common.HexToAddress(signerAddress)

        return checksumAddr == recoveredAddr, nil</span>
}

func VerifySignatureFromJSON(jsonData interface{}, signature string, signerAddress string) (bool, error) <span class="cov8" title="1">{
        jsonDataMap := make(map[string]interface{})

        jsonBytes, err := json.Marshal(jsonData)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to marshal input data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonBytes, &amp;jsonDataMap); err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to unmarshal to map: %w", err)
        }</span>

        <span class="cov8" title="1">convertToLower(jsonDataMap)

        jsonDataBytes, err := json.Marshal(jsonDataMap)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to marshal json data: %w", err)
        }</span>

        <span class="cov8" title="1">message := string(jsonDataBytes)

        return VerifySignature(message, signature, signerAddress)</span>
}

func convertToLower(data map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                if s, ok := v.(string); ok </span><span class="cov8" title="1">{
                        data[k] = strings.ToLower(s)
                }</span> else<span class="cov8" title="1"> if m, ok := v.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        convertToLower(m)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file224" style="display: none">package cryptography

import (
        "fmt"

        "crypto/rand"

        "github.com/ethereum/go-ethereum/common/hexutil"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/crypto/ecies"
)

func EncryptMessage(publicKeyHex string, message string) (string, error) <span class="cov8" title="1">{
        // Ensure the hex string has 0x prefix
        if len(publicKeyHex) &gt;= 2 &amp;&amp; publicKeyHex[:2] != "0x" </span><span class="cov8" title="1">{
                publicKeyHex = "0x" + publicKeyHex
        }</span>

        <span class="cov8" title="1">publicKeyBytes, err := hexutil.Decode(publicKeyHex)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid public key hex: %w", err)
        }</span>

        <span class="cov8" title="1">pubKey, err := crypto.UnmarshalPubkey(publicKeyBytes)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to unmarshal public key: %w", err)
        }</span>

        <span class="cov8" title="1">eciesPubKey := ecies.ImportECDSAPublic(pubKey)

        encryptedBytes, err := ecies.Encrypt(rand.Reader, eciesPubKey, []byte(message), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("encryption failed: %w", err)
        }</span>

        <span class="cov8" title="1">return hexutil.Encode(encryptedBytes), nil</span>
}

func DecryptMessage(privateKey string, encryptedHex string) (string, error) <span class="cov8" title="1">{
        // Ensure the encrypted hex has 0x prefix
        if len(encryptedHex) &gt;= 2 &amp;&amp; encryptedHex[:2] != "0x" </span><span class="cov8" title="1">{
                encryptedHex = "0x" + encryptedHex
        }</span>

        <span class="cov8" title="1">encryptedBytes, err := hexutil.Decode(encryptedHex)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid encrypted hex: %w", err)
        }</span>

        // Remove 0x prefix from private key if present (crypto.HexToECDSA doesn't accept it)
        <span class="cov8" title="1">if len(privateKey) &gt;= 2 &amp;&amp; privateKey[:2] == "0x" </span><span class="cov8" title="1">{
                privateKey = privateKey[2:]
        }</span>

        <span class="cov8" title="1">privateKeyECDSA, err := crypto.HexToECDSA(privateKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid private key: %w", err)
        }</span>

        <span class="cov8" title="1">eciesPrivKey := ecies.ImportECDSA(privateKeyECDSA)
        decrypted, err := eciesPrivKey.Decrypt(encryptedBytes, nil, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("decryption failed: %w", err)
        }</span>

        <span class="cov8" title="1">return string(decrypted), nil</span>
}
</pre>
		
		<pre class="file" id="file225" style="display: none">package database

import (
        "time"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// Config holds the configuration for the ScyllaDB connection.
type Config struct {
        Hosts       []string
        Keyspace    string
        Timeout     time.Duration
        Retries     int
        ConnectWait time.Duration
        Consistency       gocql.Consistency
        ProtoVersion      int
        SocketKeepalive   time.Duration
        MaxPreparedStmts  int
        DefaultIdempotence bool
        RetryConfig       *retry.RetryConfig
}

func NewConfig(DatabaseHost string, DatabaseHostPort string) *Config <span class="cov0" title="0">{
        return &amp;Config{
                Hosts:       []string{DatabaseHost + ":" + DatabaseHostPort},
                Keyspace:    "triggerx",
                Timeout:     time.Second * 30,
                Retries:     5,
                ConnectWait: time.Second * 10,
                Consistency:       gocql.Quorum,
                ProtoVersion:      4,
                SocketKeepalive:   15 * time.Second,
                MaxPreparedStmts:  1000,
                DefaultIdempotence: true,
                RetryConfig:       retry.DefaultRetryConfig(),
        }
}</span>

// WithHosts sets the hosts for the database connection.
func (c *Config) WithHosts(hosts []string) *Config <span class="cov0" title="0">{
        c.Hosts = hosts
        return c
}</span>

// WithKeyspace sets the keyspace for the database connection.
func (c *Config) WithKeyspace(keyspace string) *Config <span class="cov0" title="0">{
        c.Keyspace = keyspace
        return c
}</span>

// WithTimeout sets the timeout for queries.
func (c *Config) WithTimeout(timeout time.Duration) *Config <span class="cov0" title="0">{
        c.Timeout = timeout
        return c
}</span>

// WithRetries sets the number of retries for a query.
func (c *Config) WithRetries(retries int) *Config <span class="cov0" title="0">{
        c.Retries = retries
        return c
}</span>

// WithRetryConfig sets the retry configuration.
func (c *Config) WithRetryConfig(retryConfig *retry.RetryConfig) *Config <span class="cov0" title="0">{
        c.RetryConfig = retryConfig
        return c
}</span>
</pre>
		
		<pre class="file" id="file226" style="display: none">package database

import (
        "context"
        "sync"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Connection holds the database session and configuration.
type Connection struct {
        session Sessioner
        config  *Config
        logger  logging.Logger
}

var (
        once     sync.Once
        instance *Connection
)

// NewConnection creates a new ScyllaDB connection.
// It uses a singleton pattern to ensure only one connection is created.
func NewConnection(config *Config, logger logging.Logger) (*Connection, error) <span class="cov0" title="0">{
        var err error
        once.Do(func() </span><span class="cov0" title="0">{
                cluster := gocql.NewCluster(config.Hosts...)
                cluster.Keyspace = config.Keyspace
                cluster.Timeout = config.Timeout
                cluster.RetryPolicy = &amp;gocql.SimpleRetryPolicy{NumRetries: config.Retries}
                cluster.ConnectTimeout = config.ConnectWait
                cluster.Consistency = config.Consistency
                cluster.ProtoVersion = config.ProtoVersion
                cluster.SocketKeepalive = config.SocketKeepalive
                cluster.MaxPreparedStmts = config.MaxPreparedStmts
                cluster.DefaultIdempotence = config.DefaultIdempotence

                session, sessionErr := cluster.CreateSession()
                if sessionErr != nil </span><span class="cov0" title="0">{
                        err = sessionErr
                        return
                }</span>

                <span class="cov0" title="0">instance = &amp;Connection{
                        session: session,
                        config:  config,
                        logger:  logger,
                }</span>
        })

        <span class="cov0" title="0">return instance, err</span>
}

// Session returns the underlying gocql session.

func (c *Connection) Session() Sessioner <span class="cov0" title="0">{
        return c.session
}</span>

// Session returns the underlying gocql session.
func (c *Connection) Close() <span class="cov0" title="0">{
        if c.session != nil </span><span class="cov0" title="0">{
                c.session.Close()
        }</span>
}

// HealthCheck performs a simple query to check the database connection.
func (c *Connection) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return c.session.Query("SELECT release_version FROM system.local").WithContext(ctx).Exec()
}</span>

// SetSession sets the session for the connection.
func (c *Connection) SetSession(session Sessioner) <span class="cov0" title="0">{
        c.session = session
}</span>

// SetConfig sets the config for the connection.
func (c *Connection) SetConfig(config *Config) <span class="cov0" title="0">{
        c.config = config
}</span>

// SetLogger sets the logger for the connection.
func (c *Connection) SetLogger(logger logging.Logger) <span class="cov0" title="0">{
        c.logger = logger
}</span>
</pre>
		
		<pre class="file" id="file227" style="display: none">package database

import (
        "context"
        "reflect"

        "github.com/gocql/gocql"
)

// --- Mock Query ---

// MockQuery implements the methods of gocql.Query that our Queryx wrapper uses.
type MockQuery struct {
        ctx          context.Context
        scanArgs     []interface{} // Data to populate Scan's destination args with
        execErr      error         // Error to return on Exec()
        scanErr      error         // Error to return on Scan()
        callCount    int           // How many times Exec() or Scan() was called
        maxCalls     int           // How many times to fail before succeeding
        isIdempotent bool
}

func (m *MockQuery) Exec() error <span class="cov8" title="1">{
        m.callCount++
        if m.callCount &gt; m.maxCalls </span><span class="cov8" title="1">{
                return nil // Success after N failures
        }</span>
        <span class="cov8" title="1">return m.execErr</span>
}

func (m *MockQuery) Scan(dest ...interface{}) error <span class="cov8" title="1">{
        m.callCount++
        if m.callCount &gt; m.maxCalls </span><span class="cov8" title="1">{
                // On success, populate the dest args
                for i, arg := range m.scanArgs </span><span class="cov8" title="1">{
                        if i &lt; len(dest) </span><span class="cov8" title="1">{
                                reflect.ValueOf(dest[i]).Elem().Set(reflect.ValueOf(arg))
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return m.scanErr</span>
}

func (m *MockQuery) Iter() *gocql.Iter <span class="cov0" title="0">{
        // Not testing iterators in this example, but you could create a mock iterator too
        return &amp;gocql.Iter{}
}</span>

func (m *MockQuery) WithContext(ctx context.Context) *gocql.Query <span class="cov0" title="0">{
        m.ctx = ctx
        // The return value needs to be a *gocql.Query, so we return a dummy one.
        // Our mock methods will be called through the MockSession's setup.
        return &amp;gocql.Query{}
}</span>

func (m *MockQuery) Idempotent(idem bool) *gocql.Query <span class="cov0" title="0">{
        m.isIdempotent = idem
        return &amp;gocql.Query{}
}</span>

// Context returns the query's context
func (m *MockQuery) Context() context.Context <span class="cov0" title="0">{
        if m.ctx != nil </span><span class="cov0" title="0">{
                return m.ctx
        }</span>
        <span class="cov0" title="0">return context.Background()</span>
}

// --- Mock Session ---

// MockSession implements the database.Sessioner interface for testing.
type MockSession struct {
        // The Query method will return this query, allowing us to control its behavior.
        mockQuery *MockQuery
}

// Query returns our controllable MockQuery.
func (m *MockSession) Query(stmt string, values ...interface{}) *gocql.Query <span class="cov8" title="1">{
        // Create a minimal gocql.Query that won't cause nil pointer issues
        // We'll use a dummy query that has the minimum required structure
        dummyQuery := &amp;gocql.Query{}

        // Store our mock query for later access
        m.mockQuery = &amp;MockQuery{}

        // Return the dummy query - the actual mocking will happen in the test setup
        return dummyQuery
}</span>

func (m *MockSession) Close() {<span class="cov0" title="0">
        // Clean up if needed
}</span>

// GetMockQuery returns the mock query for assertions
func (m *MockSession) GetMockQuery() *MockQuery <span class="cov0" title="0">{
        return m.mockQuery
}</span>
</pre>
		
		<pre class="file" id="file228" style="display: none">package database

import (
        "context"

        "github.com/gocql/gocql"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// Queryx is a wrapper around gocql.Query that provides retry logic via the generic retry package.
type Queryx struct {
        query  *gocql.Query
        conn   *Connection
        isIdem bool
}

// NewQuery wraps a gocql.Query to provide retry functionality.
func (c *Connection) NewQuery(stmt string, values ...interface{}) *Queryx <span class="cov8" title="1">{
        return &amp;Queryx{
                query: c.session.Query(stmt, values...),
                conn:  c,
        }
}</span>

// Exec executes a query with retry logic.
// The query should be marked as Idempotent() for safe retries on CUD operations.
func (q *Queryx) Exec() error <span class="cov0" title="0">{
        // if !q.isIdem {
                // q.conn.logger.Warnf("Executing a non-idempotent query with retry logic. Ensure this is intended.")
        // }

        operation := func() error </span><span class="cov0" title="0">{
                return q.query.Exec()
        }</span>

        // Use default retry config if none is provided
        <span class="cov0" title="0">var cfg retry.RetryConfig
        if q.conn.config.RetryConfig != nil </span><span class="cov0" title="0">{
                cfg = *q.conn.config.RetryConfig
        }</span> else<span class="cov0" title="0"> {
                cfg = *retry.DefaultRetryConfig()
        }</span>
        <span class="cov0" title="0">cfg.ShouldRetry = gocqlShouldRetry

        return retry.RetryFunc(q.query.Context(), operation, &amp;cfg, q.conn.logger)</span>
}

// Scan executes a query and scans the result, with retry logic.
func (q *Queryx) Scan(dest ...interface{}) error <span class="cov0" title="0">{
        operation := func() error </span><span class="cov0" title="0">{
                return q.query.Scan(dest...)
        }</span>

        // Use default retry config if none is provided
        <span class="cov0" title="0">var cfg retry.RetryConfig
        if q.conn.config.RetryConfig != nil </span><span class="cov0" title="0">{
                cfg = *q.conn.config.RetryConfig
        }</span> else<span class="cov0" title="0"> {
                cfg = *retry.DefaultRetryConfig()
        }</span>
        <span class="cov0" title="0">cfg.ShouldRetry = gocqlShouldRetry

        _, err := retry.Retry(q.query.Context(), func() (struct{}, error) </span><span class="cov0" title="0">{
                return struct{}{}, operation()
        }</span>, &amp;cfg, q.conn.logger)

        <span class="cov0" title="0">return err</span>
}

// Iter returns an iterator for the query.
// Retries on iterators are handled internally by gocql's paging mechanism.
// No custom retry wrapper is needed here.
func (q *Queryx) Iter() *gocql.Iter <span class="cov0" title="0">{
        return q.query.Iter()
}</span>

// WithContext sets the context for the underlying gocql.Query.
// Note: The retry mechanism itself also uses context for timeouts/cancellation.
func (q *Queryx) WithContext(ctx context.Context) *Queryx <span class="cov0" title="0">{
        q.query.WithContext(ctx)
        return q
}</span>

// Idempotent marks the query as idempotent.
// This is critical for Exec() to be retried safely.
func (q *Queryx) Idempotent() *Queryx <span class="cov0" title="0">{
        q.query.Idempotent(true)
        q.isIdem = true
        return q
}</span>
</pre>
		
		<pre class="file" id="file229" style="display: none">package database

import (
        "errors"
        "net"
        "strings"

        "github.com/gocql/gocql"
)

// gocqlShouldRetry is the predicate that determines if a gocql error is transient and should be retried.
func gocqlShouldRetry(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Do NOT retry if the resource is simply not found. This is a final state.
        <span class="cov8" title="1">if errors.Is(err, gocql.ErrNotFound) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Do NOT retry on query validation errors (e.g., syntax error).
        // Check for invalid query error codes (8704 = Invalid query, 2000 = Syntax error)
        <span class="cov8" title="1">var reqErr gocql.RequestError
        if errors.As(err, &amp;reqErr) </span><span class="cov8" title="1">{
                code := reqErr.Code()
                // Error codes for invalid queries: 8704 (Invalid query), 2000 (Syntax error)
                if code == 8704 || code == 2000 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Use type assertions for specific, known-retryable gocql error types.
        // This is the most reliable method.
        <span class="cov8" title="1">switch err.(type) </span>{
        case *gocql.RequestErrWriteTimeout,
                *gocql.RequestErrReadTimeout,
                *gocql.RequestErrUnavailable,
                *gocql.RequestErrReadFailure,
                *gocql.RequestErrWriteFailure:<span class="cov8" title="1">
                return true</span>
        }

        // Check for generic network errors, which are often retryable.
        <span class="cov0" title="0">var netErr net.Error
        if errors.As(err, &amp;netErr) &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                return true
        }</span>

        // As a fallback, check for common error strings. This is more brittle but can
        // catch transient errors that don't conform to the types above.
        <span class="cov0" title="0">errMsg := strings.ToLower(err.Error())
        retryableMessages := []string{
                "no connections available",
                "connection reset by peer",
                "i/o timeout",
                "broken pipe",
                "connection timed out",
                "connection refused",
        }

        for _, msg := range retryableMessages </span><span class="cov0" title="0">{
                if strings.Contains(errMsg, msg) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file230" style="display: none">package config

import (
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/go-units"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/scripts"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
)

func DefaultConfig(lang string) ExecutorConfig <span class="cov8" title="1">{
        return ExecutorConfig{
                Docker:     DefaultDockerConfig(lang),
                Fees:       DefaultFeeConfig(),
                BasePool:   DefaultBasePoolConfig(),
                Cache:      DefaultCacheConfig(),
                Validation: DefaultValidationConfig(),
        }
}</span>

func DefaultDockerConfig(lang string) DockerConfig <span class="cov8" title="1">{
        var imageName string
        switch lang </span>{
        case "go":<span class="cov8" title="1">
                imageName = "golang:1.21-alpine"</span> // Use Alpine for faster startup
        case "py":<span class="cov8" title="1">
                imageName = "python:3.12-alpine"</span> // Use Alpine for faster startup
        case "js", "ts", "node":<span class="cov8" title="1">
                imageName = "node:22-alpine"</span> // Use Alpine for faster startup
        default:<span class="cov8" title="1">
                imageName = "golang:1.21-alpine"</span>
        }

        <span class="cov8" title="1">return DockerConfig{
                Image:          imageName,
                TimeoutSeconds: 300, // Reduced timeout
                AutoCleanup:    true,
                MemoryLimit:    "1024m",
                CPULimit:       1.0,
                NetworkMode:    "bridge",
                SecurityOpt:    []string{"no-new-privileges"},
                ReadOnlyRootFS: false,
                Environment: []string{
                        "GODEBUG=http2client=0",
                        "GOCACHE=/tmp/go-cache", // Enable Go module cache
                        "GOPROXY=direct",        // Faster dependency resolution
                },
                Binds: []string{
                        "/var/run/docker.sock:/var/run/docker.sock",
                        "/tmp/go-cache:/tmp/go-cache", // Persist Go cache
                },
        }</span>
}

// GetLanguageConfig returns language-specific configuration
func GetLanguageConfig(lang types.Language) LanguageConfig <span class="cov8" title="1">{
        switch lang </span>{
        case types.LanguageGo:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguageGo,
                        ImageName:   "golang:1.21-alpine",
                        SetupScript: scripts.GetGoSetupScript(),
                        RunCommand:  "go run code.go",
                        Extensions:  []string{".go"},
                }</span>
        case types.LanguagePy:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguagePy,
                        ImageName:   "python:3.12-alpine",
                        SetupScript: scripts.GetPythonSetupScript(),
                        RunCommand:  "python code.py",
                        Extensions:  []string{".py"},
                }</span>
        case types.LanguageJS:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguageJS,
                        ImageName:   "node:22-alpine",
                        SetupScript: scripts.GetJavaScriptSetupScript(),
                        RunCommand:  "node code.js",
                        Extensions:  []string{".js"},
                }</span>
        case types.LanguageTS:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguageTS,
                        ImageName:   "node:22-alpine",
                        SetupScript: scripts.GetTypeScriptSetupScript(),
                        RunCommand:  "node code.js",
                        Extensions:  []string{".ts"},
                }</span>
        case types.LanguageNode:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguageNode,
                        ImageName:   "node:22-alpine",
                        SetupScript: scripts.GetNodeSetupScript(),
                        RunCommand:  "node code.js",
                        Extensions:  []string{".js", ".mjs", ".cjs"},
                }</span>
        default:<span class="cov8" title="1">
                return LanguageConfig{
                        Language:    types.LanguageGo,
                        ImageName:   "golang:1.21-alpine",
                        SetupScript: scripts.GetGoSetupScript(),
                        RunCommand:  "go run code.go",
                        Extensions:  []string{".go"},
                }</span>
        }
}

// GetLanguagePoolConfig returns pool configuration for a specific language
func GetLanguagePoolConfig(lang types.Language) LanguagePoolConfig <span class="cov8" title="1">{
        baseConfig := DefaultBasePoolConfig()
        return LanguagePoolConfig{
                Language:       lang,
                BasePoolConfig: baseConfig,
                Config:         GetLanguageConfig(lang),
        }
}</span>

// GetSupportedLanguages returns all supported languages
func GetSupportedLanguages() []types.Language <span class="cov8" title="1">{
        return []types.Language{
                types.LanguageGo,
                types.LanguagePy,
                types.LanguageJS,
                types.LanguageTS,
                types.LanguageNode,
        }
}</span>

func DefaultFeeConfig() FeeConfig <span class="cov8" title="1">{
        return FeeConfig{
                PricePerTG:            0.0001,
                FixedCost:             1.0,
                TransactionSimulation: 1.0,
                OverheadCost:          0.1,
        }
}</span>

func DefaultBasePoolConfig() BasePoolConfig <span class="cov8" title="1">{
        return BasePoolConfig{
                MaxContainers:       5,
                MinContainers:       2,
                IdleTimeout:         30 * time.Minute,
                PreWarmCount:        3,
                MaxWaitTime:         60 * time.Second,
                CleanupInterval:     30 * time.Minute,
                HealthCheckInterval: 30 * time.Second,
        }
}</span>

func DefaultCacheConfig() CacheConfig <span class="cov8" title="1">{
        return CacheConfig{
                CacheDir:          "data/cache",
                MaxCacheSize:      100 * 1024 * 1024,   // 100MB
                CleanupInterval:   10 * time.Minute,
                EnableCompression: true,
                MaxFileSize:       1 * 1024 * 1024, // 1MB
        }
}</span>

func DefaultValidationConfig() ValidationConfig <span class="cov8" title="1">{
        return ValidationConfig{
                EnableCodeValidation: true,
                MaxFileSize:          1 * 1024 * 1024, // 1MB
                AllowedExtensions:    []string{".go", ".py", ".js", ".ts"},
                BlockedPatterns: []string{
                        "os.RemoveAll",
                        "exec.Command",
                        "syscall",
                        "runtime.GC",
                        "panic(",
                },
                TimeoutSeconds: 30,
        }
}</span>

// OptimizedConfig returns a configuration optimized for high-performance execution
func OptimizedConfig(lang string) ExecutorConfig <span class="cov8" title="1">{
        cfg := DefaultConfig(lang)

        // Optimize pool settings for high throughput
        cfg.BasePool.MaxContainers = 10
        cfg.BasePool.MinContainers = 5
        cfg.BasePool.PreWarmCount = 8
        cfg.BasePool.IdleTimeout = 5 * time.Minute

        // Optimize cache settings
        cfg.Cache.CacheDir = "data/cache"
        cfg.Cache.MaxCacheSize = 500 * 1024 * 1024 // 500MB

        // Optimize Docker settings
        cfg.Docker.MemoryLimit = "2048m"
        cfg.Docker.CPULimit = 2.0

        return cfg
}</span>

// DevelopmentConfig returns a configuration optimized for development
func DevelopmentConfig(lang string) ExecutorConfig <span class="cov8" title="1">{
        cfg := DefaultConfig(lang)

        // Reduce resource usage for development
        cfg.BasePool.MaxContainers = 2
        cfg.BasePool.MinContainers = 1
        cfg.BasePool.PreWarmCount = 1

        // Shorter timeouts for faster feedback
        cfg.BasePool.IdleTimeout = 2 * time.Minute

        return cfg
}</span>

func (c *DockerConfig) MemoryLimitBytes() uint64 <span class="cov8" title="1">{
        memoryLimit, err := units.RAMInBytes(c.MemoryLimit)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return uint64(memoryLimit)</span>
}

func (c *DockerConfig) ToContainerResources() container.Resources <span class="cov8" title="1">{
        return container.Resources{
                Memory:   int64(c.MemoryLimitBytes()),
                NanoCPUs: int64(c.CPULimit * 1e9),
        }
}</span>
</pre>
		
		<pre class="file" id="file231" style="display: none">package container

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type ContainerLifecycle struct {
        manager *Manager
        logger  logging.Logger
        config  config.DockerConfig
}

func NewContainerLifecycle(manager *Manager, logger logging.Logger) *ContainerLifecycle <span class="cov0" title="0">{
        return &amp;ContainerLifecycle{
                manager: manager,
                logger:  logger,
                config:  manager.config,
        }
}</span>

func (cl *ContainerLifecycle) CreateAndStart(ctx context.Context, config *types.ContainerConfig) (*types.ContainerInfo, error) <span class="cov0" title="0">{
        cl.logger.Infof("Creating container with image: %s", config.Image)

        // Create container
        containerID, err := cl.manager.CreateContainer(ctx, config.WorkingDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create container: %w", err)
        }</span>

        // Start container
        <span class="cov0" title="0">if err := cl.StartContainer(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                // Cleanup failed container
                err := cl.manager.CleanupContainer(ctx, containerID)
                if err != nil </span><span class="cov0" title="0">{
                        cl.logger.Errorf("Failed to cleanup container: %v", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to start container: %w", err)</span>
        }

        // Get container info
        <span class="cov0" title="0">info, err := cl.GetContainerInfo(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container info: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Infof("Container created and started: %s", containerID)
        return info, nil</span>
}

func (cl *ContainerLifecycle) StartContainer(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        cl.logger.Debugf("Starting container: %s", containerID)

        err := cl.manager.Cli.ContainerStart(ctx, containerID, container.StartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start container: %w", err)
        }</span>

        // Wait for container to be running
        <span class="cov0" title="0">if err := cl.waitForContainerRunning(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("container failed to start: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Container started successfully: %s", containerID)
        return nil</span>
}

func (cl *ContainerLifecycle) StopContainer(ctx context.Context, containerID string, timeout time.Duration) error <span class="cov0" title="0">{
        cl.logger.Debugf("Stopping container: %s", containerID)

        timeoutSeconds := int(timeout.Seconds())
        err := cl.manager.Cli.ContainerStop(ctx, containerID, container.StopOptions{Timeout: &amp;timeoutSeconds})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop container: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Container stopped successfully: %s", containerID)
        return nil</span>
}

func (cl *ContainerLifecycle) RestartContainer(ctx context.Context, containerID string, timeout time.Duration) error <span class="cov0" title="0">{
        cl.logger.Debugf("Restarting container: %s", containerID)

        timeoutSeconds := int(timeout.Seconds())
        err := cl.manager.Cli.ContainerRestart(ctx, containerID, container.StopOptions{Timeout: &amp;timeoutSeconds})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart container: %w", err)
        }</span>

        // Wait for container to be running
        <span class="cov0" title="0">if err := cl.waitForContainerRunning(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("container failed to restart: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Container restarted successfully: %s", containerID)
        return nil</span>
}

func (cl *ContainerLifecycle) RemoveContainer(ctx context.Context, containerID string, force bool) error <span class="cov0" title="0">{
        cl.logger.Debugf("Removing container: %s (force: %v)", containerID, force)

        err := cl.manager.Cli.ContainerRemove(ctx, containerID, container.RemoveOptions{Force: force})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove container: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Container removed successfully: %s", containerID)
        return nil</span>
}

func (cl *ContainerLifecycle) GetContainerInfo(ctx context.Context, containerID string) (*types.ContainerInfo, error) <span class="cov0" title="0">{
        info, err := cl.manager.GetContainerInfo(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container info: %w", err)
        }</span>

        // Convert to our types
        <span class="cov0" title="0">containerInfo := &amp;types.ContainerInfo{
                ID:      containerID,
                Created: time.Now(), // Use current time as fallback
                Config: &amp;types.ContainerConfig{
                        Image:          info.Config.Image,
                        WorkingDir:     info.Config.WorkingDir,
                        Environment:    info.Config.Env,
                        Binds:          info.HostConfig.Binds,
                        Resources:      info.HostConfig.Resources,
                        Privileged:     info.HostConfig.Privileged,
                        NetworkMode:    string(info.HostConfig.NetworkMode),
                        SecurityOpt:    info.HostConfig.SecurityOpt,
                        ReadOnlyRootFS: info.HostConfig.ReadonlyRootfs,
                },
        }

        return containerInfo, nil</span>
}

func (cl *ContainerLifecycle) GetContainerStats(ctx context.Context, containerID string) (*types.DockerResourceStats, error) <span class="cov0" title="0">{
        stats, err := cl.manager.Cli.ContainerStats(ctx, containerID, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container stats: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := stats.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        cl.logger.Errorf("Failed to close container stats body: %v", err)
                }</span>
        }()

        // Docker stats stream JSON objects; decode the first one
        <span class="cov0" title="0">var dockerStats container.StatsResponse
        dec := json.NewDecoder(stats.Body)
        if err := dec.Decode(&amp;dockerStats); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode container stats: %w", err)
        }</span>

        // Calculate CPU usage percent (see Docker's formula)
        <span class="cov0" title="0">var cpuPercent float64
        cpuDelta := float64(dockerStats.CPUStats.CPUUsage.TotalUsage - dockerStats.PreCPUStats.CPUUsage.TotalUsage)
        systemDelta := float64(dockerStats.CPUStats.SystemUsage - dockerStats.PreCPUStats.SystemUsage)
        if systemDelta &gt; 0.0 &amp;&amp; cpuDelta &gt; 0.0 </span><span class="cov0" title="0">{
                cpuPercent = (cpuDelta / systemDelta) * float64(len(dockerStats.CPUStats.CPUUsage.PercpuUsage)) * 100.0
        }</span>

        // Network stats (sum all interfaces)
        <span class="cov0" title="0">var rxBytes, txBytes uint64
        if dockerStats.Networks != nil </span><span class="cov0" title="0">{
                for _, v := range dockerStats.Networks </span><span class="cov0" title="0">{
                        rxBytes += v.RxBytes
                        txBytes += v.TxBytes
                }</span>
        }

        <span class="cov0" title="0">resourceStats := &amp;types.DockerResourceStats{
                MemoryUsage:   dockerStats.MemoryStats.Usage,
                CPUPercentage: cpuPercent,
                NetworkRx:     rxBytes,
                NetworkTx:     txBytes,
                BlockRead:     sumBlkioServiceBytes(dockerStats.BlkioStats.IoServiceBytesRecursive, "Read"),
                BlockWrite:    sumBlkioServiceBytes(dockerStats.BlkioStats.IoServiceBytesRecursive, "Write"),
                RxBytes:       rxBytes,
                TxBytes:       txBytes,
                ExecutionTime: time.Duration(dockerStats.Read.UnixNano()), // This is the stats timestamp; adjust as needed
        }

        return resourceStats, nil</span>
}

func (cl *ContainerLifecycle) IsContainerRunning(ctx context.Context, containerID string) (bool, error) <span class="cov0" title="0">{
        info, err := cl.manager.GetContainerInfo(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get container info: %w", err)
        }</span>

        <span class="cov0" title="0">return info.State.Running, nil</span>
}

func (cl *ContainerLifecycle) WaitForContainer(ctx context.Context, containerID string, condition container.WaitCondition) error <span class="cov0" title="0">{
        cl.logger.Debugf("Waiting for container: %s (condition: %s)", containerID, condition)

        statusCh, errCh := cl.manager.Cli.ContainerWait(ctx, containerID, condition)

        select </span>{
        case err := &lt;-errCh:<span class="cov0" title="0">
                return fmt.Errorf("container wait error: %w", err)</span>
        case status := &lt;-statusCh:<span class="cov0" title="0">
                if status.StatusCode != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("container exited with status %d", status.StatusCode)
                }</span>
                <span class="cov0" title="0">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("context cancelled while waiting for container: %w", ctx.Err())</span>
        }
}

func (cl *ContainerLifecycle) waitForContainerRunning(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        timeout := 30 * time.Second
        deadline := time.Now().Add(timeout)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                running, err := cl.IsContainerRunning(ctx, containerID)
                if err != nil </span><span class="cov0" title="0">{
                        cl.logger.Warnf("Failed to check container status: %v", err)
                        time.Sleep(100 * time.Millisecond)
                        continue</span>
                }

                <span class="cov0" title="0">if running </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("container failed to start within %v", timeout)</span>
}

func (cl *ContainerLifecycle) HealthCheck(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        cl.logger.Debugf("Performing health check on container: %s", containerID)

        // Check if container is running
        running, err := cl.IsContainerRunning(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !running </span><span class="cov0" title="0">{
                return fmt.Errorf("container is not running")
        }</span>

        // Get container stats to check resource usage
        <span class="cov0" title="0">stats, err := cl.GetContainerStats(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get container stats: %w", err)
        }</span>

        // Check memory usage
        <span class="cov0" title="0">memoryLimit := cl.config.MemoryLimitBytes()
        if stats.MemoryUsage &gt; uint64(0.9*float64(memoryLimit)) </span><span class="cov0" title="0">{
                cl.logger.Warnf("Container %s memory usage is high: %d/%d bytes",
                        containerID, stats.MemoryUsage, memoryLimit)
        }</span>

        // Check CPU usage
        <span class="cov0" title="0">if stats.CPUPercentage &gt; 90.0 </span><span class="cov0" title="0">{
                cl.logger.Warnf("Container %s CPU usage is high: %.2f%%",
                        containerID, stats.CPUPercentage)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Health check passed for container: %s", containerID)
        return nil</span>
}

func (cl *ContainerLifecycle) CleanupContainer(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        cl.logger.Debugf("Cleaning up container: %s", containerID)

        // Stop container if running
        running, err := cl.IsContainerRunning(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                cl.logger.Warnf("Failed to check if container is running: %v", err)
        }</span> else<span class="cov0" title="0"> if running </span><span class="cov0" title="0">{
                if err := cl.StopContainer(ctx, containerID, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                        cl.logger.Warnf("Failed to stop container: %v", err)
                }</span>
        }

        // Remove container
        <span class="cov0" title="0">if err := cl.RemoveContainer(ctx, containerID, true); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove container: %w", err)
        }</span>

        <span class="cov0" title="0">cl.logger.Debugf("Container cleanup completed: %s", containerID)
        return nil</span>
}

// Helper to sum block I/O stats for a given op ("Read" or "Write")
func sumBlkioServiceBytes(entries []container.BlkioStatEntry, op string) uint64 <span class="cov0" title="0">{
        var sum uint64
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.Op == op </span><span class="cov0" title="0">{
                        sum += entry.Value
                }</span>
        }
        <span class="cov0" title="0">return sum</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">package container

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/image"
        "github.com/docker/docker/client"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Manager struct {
        Cli        *client.Client
        config     config.DockerConfig
        logger     logging.Logger
        pools      map[types.Language]*ContainerPool
        lifecycle  *ContainerLifecycle
        mutex      sync.RWMutex
        initialized bool
}

func NewManager(cli *client.Client, cfg config.ExecutorConfig, logger logging.Logger) (*Manager, error) <span class="cov0" title="0">{
        manager := &amp;Manager{
                Cli:        cli,
                config:     cfg.Docker,
                logger:     logger,
                pools:      make(map[types.Language]*ContainerPool),
        }

        // Create lifecycle manager
        manager.lifecycle = NewContainerLifecycle(manager, logger)

        return manager, nil
}</span>

func (m *Manager) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        m.logger.Info("Initializing Docker manager")

        // Pull the base image
        if err := m.PullImage(ctx, m.config.Image); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull base image: %w", err)
        }</span>

        <span class="cov0" title="0">m.logger.Info("Docker manager initialized successfully")
        return nil</span>
}

// InitializeLanguagePools initializes language-specific container pools
func (m *Manager) InitializeLanguagePools(ctx context.Context, languages []types.Language) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("docker manager already initialized")
        }</span>

        <span class="cov0" title="0">m.logger.Info("Initializing language-specific container pools")

        for _, lang := range languages </span><span class="cov0" title="0">{
                poolConfig := config.GetLanguagePoolConfig(lang)
                pool := NewContainerPool(poolConfig, m, m.logger)

                if err := pool.Initialize(ctx); err != nil </span><span class="cov0" title="0">{
                        m.logger.Warnf("Failed to initialize pool for language %s: %v", lang, err)
                        continue</span>
                }

                <span class="cov0" title="0">m.pools[lang] = pool
                m.logger.Infof("Initialized pool for language: %s", lang)</span>
        }

        <span class="cov0" title="0">m.initialized = true
        m.logger.Infof("Language-specific container pools initialized with %d pools", len(m.pools))
        return nil</span>
}

// GetContainer returns a container for the specified language
func (m *Manager) GetContainer(ctx context.Context, language types.Language) (*types.PooledContainer, error) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if !m.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("docker manager not initialized")
        }</span>

        <span class="cov0" title="0">pool, exists := m.pools[language]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no pool available for language: %s", language)
        }</span>

        <span class="cov0" title="0">return pool.GetContainer(ctx)</span>
}

// ReturnContainer returns a container to its language-specific pool
func (m *Manager) ReturnContainer(container *types.PooledContainer) error <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if !m.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("docker manager not initialized")
        }</span>

        <span class="cov0" title="0">pool, exists := m.pools[container.Language]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no pool available for language: %s", container.Language)
        }</span>

        <span class="cov0" title="0">return pool.ReturnContainer(container)</span>
}

// GetPoolStats returns statistics for all language pools
func (m *Manager) GetPoolStats() map[types.Language]*types.PoolStats <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        stats := make(map[types.Language]*types.PoolStats)
        for lang, pool := range m.pools </span><span class="cov0" title="0">{
                stats[lang] = pool.GetStats()
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// GetLanguageStats returns statistics for a specific language pool
func (m *Manager) GetLanguageStats(language types.Language) (*types.PoolStats, bool) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        pool, exists := m.pools[language]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return pool.GetStats(), true</span>
}

// GetSupportedLanguages returns all languages with active pools
func (m *Manager) GetSupportedLanguages() []types.Language <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        languages := make([]types.Language, 0, len(m.pools))
        for lang := range m.pools </span><span class="cov0" title="0">{
                languages = append(languages, lang)
        }</span>

        <span class="cov0" title="0">return languages</span>
}

// IsLanguageSupported checks if a language is supported
func (m *Manager) IsLanguageSupported(language types.Language) bool <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        _, exists := m.pools[language]
        return exists
}</span>

// ExecuteInContainerWithLanguage executes code in a container using language-specific setup
func (m *Manager) ExecuteInContainer(ctx context.Context, containerID string, filePath string, language types.Language) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        m.logger.Infof("Executing file %s in container %s with language %s", filePath, containerID, language)

        // Verify container is running before execution
        inspect, err := m.Cli.ContainerInspect(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inspect container before execution: %w", err)
        }</span>
        <span class="cov0" title="0">m.logger.Debugf("Container %s state: %s, running: %v", containerID, inspect.State.Status, inspect.State.Running)

        if !inspect.State.Running </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container %s is not running (status: %s)", containerID, inspect.State.Status)
        }</span>

        // Replace the code file in the container
        <span class="cov0" title="0">if err := m.replaceCodeFile(ctx, containerID, filePath, language); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to replace code file: %w", err)
        }</span>
        <span class="cov0" title="0">m.logger.Debugf("File copy completed for container %s", containerID)

        // Execute the code
        m.logger.Debugf("Starting code execution in container %s", containerID)
        result, err := m.executeCode(ctx, containerID, language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute code: %w", err)
        }</span>
        <span class="cov0" title="0">m.logger.Debugf("Code execution completed for container %s", containerID)

        return result, nil</span>
}

func (m *Manager) PullImage(ctx context.Context, imageName string) error <span class="cov0" title="0">{
        // m.logger.Infof("Pulling Docker image: %s", imageName)

        // Check if image already exists locally
        images, err := m.Cli.ImageList(ctx, image.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Warnf("Failed to list images: %v", err)
        }</span> else<span class="cov0" title="0"> {
                for _, img := range images </span><span class="cov0" title="0">{
                        for _, tag := range img.RepoTags </span><span class="cov0" title="0">{
                                if tag == imageName || tag == imageName+":latest" </span><span class="cov0" title="0">{
                                        m.logger.Debugf("Image %s already exists locally, skipping pull", imageName)
                                        return nil
                                }</span>
                        }
                }
        }

        // Image doesn't exist locally, pull it
        <span class="cov0" title="0">reader, err := m.Cli.ImagePull(ctx, imageName, image.PullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("Failed to pull image: %v", err)
                return fmt.Errorf("failed to pull image: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := reader.Close()
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Errorf("Failed to close image pull reader: %v", err)
                }</span>
        }()

        // Read the output to ensure the pull completes
        <span class="cov0" title="0">buf := new(bytes.Buffer)
        if _, err := io.Copy(buf, reader); err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("Error reading image pull response: %v", err)
                return fmt.Errorf("error reading image pull response: %w", err)
        }</span>

        // Log the last few lines of the pull output for debugging
        <span class="cov0" title="0">pullOutput := buf.String()
        lines := strings.Split(pullOutput, "\n")
        if len(lines) &gt; 5 </span><span class="cov0" title="0">{
                lines = lines[len(lines)-5:]
        }</span>
        <span class="cov0" title="0">for _, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{
                        m.logger.Debugf("Pull output: %s", line)
                }</span>
        }

        <span class="cov0" title="0">m.logger.Infof("Successfully pulled image: %s", imageName)
        return nil</span>
}

func (m *Manager) CleanupImages(ctx context.Context) error <span class="cov0" title="0">{
        images, err := m.Cli.ImageList(ctx, image.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("failed to list images: %v", err)
                return fmt.Errorf("failed to list images: %w", err)
        }</span>

        <span class="cov0" title="0">for _, dockerImage := range images </span><span class="cov0" title="0">{
                _, err := m.Cli.ImageRemove(ctx, dockerImage.ID, image.RemoveOptions{Force: true})
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Errorf("failed to remove image: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) CreateContainer(ctx context.Context, codePath string) (string, error) <span class="cov0" title="0">{
        absPath, err := filepath.Abs(codePath)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("failed to get absolute path: %v", err)
                return "", fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        <span class="cov0" title="0">m.logger.Debugf("Creating container with code directory: %s", absPath)

        // List directory contents for debugging
        // if entries, err := os.ReadDir(absPath); err == nil {
        //         m.logger.Debugf("Directory contents of %s:", absPath)
        //         for _, entry := range entries {
        //                 m.logger.Debugf("  - %s (dir: %v)", entry.Name(), entry.IsDir())
        //                 if info, err := os.Stat(filepath.Join(absPath, entry.Name())); err == nil {
        //                         m.logger.Debugf("    - permissions: %v", info.Mode())
        //                 }
        //         }
        // }

        // For Docker-in-Docker, make sure the mount path is absolute and exists on the host
        hostMountPath := absPath
        if !filepath.IsAbs(hostMountPath) </span><span class="cov0" title="0">{
                hostMountPath, _ = filepath.Abs(hostMountPath)
        }</span>

        // m.logger.Debugf("Using host mount path: %s", hostMountPath)

        // Create a simple keep-alive command that keeps the container running
        // We'll execute the actual code later via exec
        <span class="cov0" title="0">keepAliveCommand := `tail -f /dev/null`

        config := &amp;container.Config{
                Image:      m.config.Image,
                Cmd:        []string{"sh", "-c", keepAliveCommand},
                Tty:        true, // Don't allocate TTY for keep-alive
                WorkingDir: "/code",
        }

        hostConfig := &amp;container.HostConfig{
                Binds: []string{
                        fmt.Sprintf("%s:/code:rw", hostMountPath),
                        "/var/run/docker.sock:/var/run/docker.sock", // Ensure Docker socket is mounted
                },
                Resources: container.Resources{
                        Memory:   int64(m.config.MemoryLimitBytes()),
                        NanoCPUs: int64(m.config.CPULimit * 1e9),
                },
                Privileged: true, // Add privileged mode for Docker-in-Docker
        }

        // m.logger.Debugf("Creating container with bind mount: %s:/code", hostMountPath)

        resp, err := m.Cli.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("failed to create container: %v", err)
                return "", fmt.Errorf("failed to create container: %w", err)
        }</span>

        <span class="cov0" title="0">containerID := resp.ID
        m.logger.Infof("Container created with ID: %s", containerID)

        // Start the container
        // m.logger.Infof("Starting container: %s", containerID)
        err = m.Cli.ContainerStart(ctx, containerID, container.StartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("failed to start container: %v", err)
                // Try to cleanup the created container
                if cleanupErr := m.Cli.ContainerRemove(ctx, containerID, container.RemoveOptions{Force: true}); cleanupErr != nil </span><span class="cov0" title="0">{
                        m.logger.Warnf("Failed to cleanup container after start failure: %v", cleanupErr)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to start container: %w", err)</span>
        }

        // Wait for container to be running
        <span class="cov0" title="0">maxRetries := 10
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                inspect, err := m.Cli.ContainerInspect(ctx, containerID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to inspect container after start: %w", err)
                }</span>

                <span class="cov0" title="0">if inspect.State.Running </span><span class="cov0" title="0">{
                        m.logger.Infof("Container %s is running", containerID)
                        return containerID, nil
                }</span>

                <span class="cov0" title="0">m.logger.Debugf("Container %s not running yet (attempt %d/%d), status: %s", containerID, i+1, maxRetries, inspect.State.Status)
                time.Sleep(500 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("container %s failed to start properly", containerID)</span>
}

func (m *Manager) CleanupContainer(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        if !m.config.AutoCleanup </span><span class="cov0" title="0">{
                m.logger.Infof("auto cleanup is disabled, skipping container cleanup")
                return nil
        }</span>

        <span class="cov0" title="0">return m.Cli.ContainerRemove(ctx, containerID, container.RemoveOptions{Force: true})</span>
}

func (m *Manager) GetContainerInfo(ctx context.Context, containerID string) (container.InspectResponse, error) <span class="cov0" title="0">{
        info, err := m.Cli.ContainerInspect(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Errorf("failed to get container info: %v", err)
                return container.InspectResponse{}, fmt.Errorf("failed to get container info: %w", err)
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

func (m *Manager) replaceCodeFile(ctx context.Context, containerID string, filePath string, language types.Language) error <span class="cov0" title="0">{
        // First, copy the file to the container
        if err := m.copyFileToContainer(ctx, containerID, filePath, language); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file to container: %w", err)
        }</span>

        // For Go language, run go mod tidy after replacing the file
        <span class="cov0" title="0">if language == types.LanguageGo </span><span class="cov0" title="0">{
                if err := m.runGoModTidy(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run go mod tidy: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) runGoModTidy(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        m.logger.Debugf("Running go mod tidy in container %s", containerID)

        execConfig := &amp;container.ExecOptions{
                Cmd:          []string{"sh", "-c", "cd /code &amp;&amp; go mod tidy -e"},
                AttachStdout: true,
                AttachStderr: true,
        }

        execResp, err := m.Cli.ContainerExecCreate(ctx, containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create go mod tidy exec: %w", err)
        }</span>

        <span class="cov0" title="0">execAttachResp, err := m.Cli.ContainerExecAttach(ctx, execResp.ID, container.ExecAttachOptions{
                Detach: false,
                Tty:    false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to go mod tidy exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execAttachResp.Close()

        // Execute the go mod tidy command
        if err := m.Cli.ContainerExecStart(ctx, execResp.ID, container.ExecStartOptions{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start go mod tidy exec: %w", err)
        }</span>

        // Wait for go mod tidy to complete
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := m.Cli.ContainerExecInspect(ctx, execResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect go mod tidy exec: %w", err)
                }</span>
                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("go mod tidy failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">m.logger.Debugf("Go mod tidy completed successfully in container %s", containerID)
        return nil</span>
}

func (m *Manager) copyFileToContainer(ctx context.Context, containerID string, filePath string, language types.Language) error <span class="cov0" title="0">{
        // m.logger.Debugf("Copying file %s to container %s", filePath, containerID)

        // Read the file content
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>
        // m.logger.Debugf("Read %d bytes from file %s", len(content), filePath)

        // First, ensure the /code directory exists and check container state
        <span class="cov0" title="0">setupCmd := []string{"sh", "-c", "mkdir -p /code &amp;&amp; ls -la /code &amp;&amp; pwd &amp;&amp; whoami"}
        // m.logger.Debugf("Setup command for container %s: %v", containerID, setupCmd)

        setupExecConfig := &amp;container.ExecOptions{
                Cmd:          setupCmd,
                AttachStdout: true,
                AttachStderr: true,
        }

        // m.logger.Debugf("Creating setup exec for container %s", containerID)
        setupExecResp, err := m.Cli.ContainerExecCreate(ctx, containerID, *setupExecConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create setup exec: %w", err)
        }</span>

        // Execute the setup command
        <span class="cov0" title="0">err = m.Cli.ContainerExecStart(ctx, setupExecResp.ID, container.ExecStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start setup exec: %w", err)
        }</span>

        // Wait for setup completion
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := m.Cli.ContainerExecInspect(ctx, setupExecResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect setup exec: %w", err)
                }</span>

                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        // m.logger.Debugf("Setup exec completed with exit code %d", inspectResp.ExitCode)
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("setup failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        // Now copy the file using a simpler approach
        // Escape the content properly for shell
        <span class="cov0" title="0">escapedContent := strings.ReplaceAll(string(content), "'", "'\"'\"'")

        // Determine the target filename based on language
        var targetFile string
        switch language </span>{
        case types.LanguageGo:<span class="cov0" title="0">
                targetFile = "/code/code.go"</span>
        case types.LanguagePy:<span class="cov0" title="0">
                targetFile = "/code/code.py"</span>
        case types.LanguageJS, types.LanguageNode:<span class="cov0" title="0">
                targetFile = "/code/code.js"</span>
        case types.LanguageTS:<span class="cov0" title="0">
                targetFile = "/code/code.ts"</span>
        default:<span class="cov0" title="0">
                targetFile = "/code/code.go"</span>
        }

        <span class="cov0" title="0">copyCmd := []string{"sh", "-c", fmt.Sprintf("echo '%s' &gt; %s", escapedContent, targetFile)}
        // m.logger.Debugf("Copy command for container %s: %v", containerID, copyCmd)

        execConfig := &amp;container.ExecOptions{
                Cmd:          copyCmd,
                AttachStdout: true,
                AttachStderr: true,
        }

        // m.logger.Debugf("Creating exec for container %s", containerID)
        execResp, err := m.Cli.ContainerExecCreate(ctx, containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create exec: %w", err)
        }</span>
        // m.logger.Debugf("Created exec %s for container %s", execResp.ID, containerID)

        // Execute the copy command
        // m.logger.Debugf("Starting exec %s for container %s", execResp.ID, containerID)
        <span class="cov0" title="0">err = m.Cli.ContainerExecStart(ctx, execResp.ID, container.ExecStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start exec: %w", err)
        }</span>
        // m.logger.Debugf("Started exec %s for container %s", execResp.ID, containerID)

        // Wait for completion
        // m.logger.Debugf("Waiting for exec %s to complete", execResp.ID)
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := m.Cli.ContainerExecInspect(ctx, execResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect exec: %w", err)
                }</span>

                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        // m.logger.Debugf("Exec %s completed with exit code %d", execResp.ID, inspectResp.ExitCode)
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("file copy failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        // Verify the file was copied
        <span class="cov0" title="0">verifyCmd := []string{"sh", "-c", fmt.Sprintf("ls -la %s &amp;&amp; wc -l %s", targetFile, targetFile)}
        // m.logger.Debugf("Verify command for container %s: %v", containerID, verifyCmd)

        verifyExecConfig := &amp;container.ExecOptions{
                Cmd:          verifyCmd,
                AttachStdout: true,
                AttachStderr: true,
        }

        verifyExecResp, err := m.Cli.ContainerExecCreate(ctx, containerID, *verifyExecConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create verify exec: %w", err)
        }</span>

        <span class="cov0" title="0">err = m.Cli.ContainerExecStart(ctx, verifyExecResp.ID, container.ExecStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start verify exec: %w", err)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := m.Cli.ContainerExecInspect(ctx, verifyExecResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect verify exec: %w", err)
                }</span>

                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        // m.logger.Debugf("Verify exec completed with exit code %d", inspectResp.ExitCode)
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("file verification failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        // m.logger.Debugf("File copy completed successfully for container %s", containerID)
        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) executeCode(ctx context.Context, containerID string, language types.Language) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        result := &amp;types.ExecutionResult{}
        var executionStartTime time.Time
        var executionEndTime time.Time
        var codeExecutionTime time.Duration
        executionStarted := false
        var outputBuffer bytes.Buffer

        // Get language-specific setup script
        langConfig := config.GetLanguageConfig(language)
        execCmd := []string{"sh", "-c", langConfig.SetupScript}

        execConfig := &amp;container.ExecOptions{
                Cmd:          execCmd,
                AttachStdout: true,
                AttachStderr: true,
        }

        execResp, err := m.Cli.ContainerExecCreate(ctx, containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exec: %w", err)
        }</span>

        <span class="cov0" title="0">execAttachResp, err := m.Cli.ContainerExecAttach(ctx, execResp.ID, container.ExecAttachOptions{
                Detach: false,
                Tty:    true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to attach to exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execAttachResp.Close()
        scanner := bufio.NewScanner(execAttachResp.Reader)

        // Execute the command
        err = m.Cli.ContainerExecStart(ctx, execResp.ID, container.ExecStartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start exec: %w", err)
        }</span>

        <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                // m.logger.Debugf("Container Log: %s\n", line)

                if strings.Contains(line, "START_EXECUTION") </span><span class="cov0" title="0">{
                        executionStartTime = time.Now().UTC()
                        executionStarted = true
                }</span> else<span class="cov0" title="0"> if strings.Contains(line, "END_EXECUTION") &amp;&amp; executionStarted </span><span class="cov0" title="0">{
                        executionEndTime = time.Now().UTC()
                        codeExecutionTime = executionEndTime.Sub(executionStartTime)
                        // m.logger.Debugf("Code execution completed in: %v\n", codeExecutionTime)
                        break</span>
                } else<span class="cov0" title="0"> if executionStarted </span><span class="cov0" title="0">{
                        outputBuffer.WriteString(line)
                        // m.logger.Debugf("Container Log: %s\n", line)
                }</span>
        }

        // Wait for exec to finish (in case END_EXECUTION is not printed)
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := m.Cli.ContainerExecInspect(ctx, execResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to inspect exec: %w", err)
                }</span>
                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        if !executionStarted || codeExecutionTime == 0 </span><span class="cov0" title="0">{
                                codeExecutionTime = time.Since(executionStartTime)
                                m.logger.Debugf("Warning: Could not determine precise code execution time, using container execution time instead")
                        }</span>
                        <span class="cov0" title="0">result.Success = inspectResp.ExitCode == 0
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                result.Error = fmt.Errorf("execution failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">result.Output = outputBuffer.String()
        result.Stats.ExecutionTime = codeExecutionTime
        return result, nil</span>
}

func (m *Manager) Close() error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Close all language pools
        for lang, pool := range m.pools </span><span class="cov0" title="0">{
                if err := pool.Close(); err != nil </span><span class="cov0" title="0">{
                        m.logger.Warnf("Failed to close pool for language %s: %v", lang, err)
                }</span>
        }

        <span class="cov0" title="0">m.logger.Info("Docker manager closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">package container

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/image"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/scripts"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type ContainerPool struct {
        language      types.Language
        containers    map[string]*types.PooledContainer
        mutex         sync.RWMutex
        config        config.LanguagePoolConfig
        logger        logging.Logger
        manager       *Manager
        cleanupTicker *time.Ticker
        stopCleanup   chan struct{}
        stats         *types.PoolStats
        statsMutex    sync.RWMutex
        waitQueue     chan struct{}
}

func NewContainerPool(cfg config.LanguagePoolConfig, manager *Manager, logger logging.Logger) *ContainerPool <span class="cov0" title="0">{
        pool := &amp;ContainerPool{
                language:    cfg.Language,
                containers:  make(map[string]*types.PooledContainer),
                config:      cfg,
                logger:      logger,
                manager:     manager,
                stopCleanup: make(chan struct{}),
                waitQueue:   make(chan struct{}, cfg.MaxContainers),
                stats: &amp;types.PoolStats{
                        Language:          cfg.Language,
                        TotalContainers:   0,
                        ReadyContainers:   0,
                        BusyContainers:    0,
                        ErrorContainers:   0,
                        UtilizationRate:   0.0,
                        AverageWaitTime:   0,
                        MaxWaitTime:       0,
                        ContainerLifetime: 0,
                        CreatedCount:      0,
                        DestroyedCount:    0,
                        LastCleanup:       time.Now(),
                },
        }

        // Start cleanup routine
        pool.startCleanupRoutine()

        // Start health check routine
        pool.startHealthCheckRoutine()

        return pool
}</span>

func (p *ContainerPool) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        // p.logger.Infof("Initializing %s language pool with %d pre-warmed containers", p.language, p.config.PreWarmCount)

        // Pull the language-specific image
        if err := p.pullImage(ctx, p.config.Config.ImageName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to pull image for language %s: %w", p.language, err)
        }</span>

        // Pre-warm containers in parallel for faster initialization
        <span class="cov0" title="0">containerChan := make(chan *types.PooledContainer, p.config.PreWarmCount)
        errorChan := make(chan error, p.config.PreWarmCount)

        // Start parallel container creation
        for i := 0; i &lt; p.config.PreWarmCount; i++ </span><span class="cov0" title="0">{
                go func(index int) </span><span class="cov0" title="0">{
                        container, err := p.createPreparedContainer(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                p.logger.Warnf("Failed to create pre-warmed container %d for language %s: %v", index, p.language, err)
                                errorChan &lt;- err
                                return
                        }</span>
                        <span class="cov0" title="0">containerChan &lt;- container</span>
                }(i)
        }

        // Collect results
        <span class="cov0" title="0">successCount := 0
        for i := 0; i &lt; p.config.PreWarmCount; i++ </span><span class="cov0" title="0">{
                select </span>{
                case container := &lt;-containerChan:<span class="cov0" title="0">
                        successCount++
                        p.logger.Debugf("Successfully created pre-warmed container %d: %s", successCount, container.ID)</span>
                case err := &lt;-errorChan:<span class="cov0" title="0">
                        p.logger.Warnf("Container creation failed: %v", err)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("context cancelled during container initialization: %w", ctx.Err())</span>
                }
        }

        <span class="cov0" title="0">p.logger.Infof("%s language pool initialized with %d containers", p.language, successCount)
        return nil</span>
}

func (p *ContainerPool) GetContainer(ctx context.Context) (*types.PooledContainer, error) <span class="cov0" title="0">{
        // Try to get a ready container
        p.mutex.Lock()
        for _, container := range p.containers </span><span class="cov0" title="0">{
                // p.logger.Debugf("Checking container %s: status=%s, ready=%v", container.ID, container.Status, container.IsReady)

                if container.Status == types.ContainerStatusReady &amp;&amp; container.IsReady </span><span class="cov0" title="0">{
                        // p.logger.Debugf("Found ready container %s, verifying it's running", container.ID)

                        // Verify container is actually running before returning it
                        inspect, err := p.manager.Cli.ContainerInspect(ctx, container.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                p.logger.Warnf("Container %s health check failed during get: %v", container.ID, err)
                                container.Status = types.ContainerStatusError
                                container.Error = err
                                continue</span>
                        }

                        // p.logger.Debugf("Container %s inspect result: status=%s, running=%v", container.ID, inspect.State.Status, inspect.State.Running)

                        <span class="cov0" title="0">if !inspect.State.Running </span><span class="cov0" title="0">{
                                p.logger.Warnf("Container %s is not running, marking as error", container.ID)
                                container.Status = types.ContainerStatusError
                                container.IsReady = false
                                continue</span>
                        }

                        <span class="cov0" title="0">p.logger.Debugf("Container %s verified as running, returning it", container.ID)
                        container.Status = types.ContainerStatusRunning
                        container.LastUsed = time.Now()
                        p.updateStats()
                        p.mutex.Unlock()
                        return container, nil</span>
                }
        }
        <span class="cov0" title="0">p.mutex.Unlock()

        // No ready containers available, try to create a new one
        if p.getTotalContainerCount() &lt; p.config.MaxContainers </span><span class="cov0" title="0">{
                container, err := p.createPreparedContainer(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create container for language %s: %w", p.language, err)
                }</span>
                <span class="cov0" title="0">container.Status = types.ContainerStatusRunning
                container.LastUsed = time.Now()
                return container, nil</span>
        }

        // Wait for a container to become available
        <span class="cov0" title="0">select </span>{
        case &lt;-p.waitQueue:<span class="cov0" title="0">
                // Try again after waiting
                return p.GetContainer(ctx)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("timeout waiting for container: %w", ctx.Err())</span>
        case &lt;-time.After(p.config.MaxWaitTime):<span class="cov0" title="0">
                return nil, fmt.Errorf("timeout waiting for container in language pool %s", p.language)</span>
        }
}

func (p *ContainerPool) ReturnContainer(container *types.PooledContainer) error <span class="cov0" title="0">{
        p.logger.Debugf("Returning container %s to %s language pool", container.ID, p.language)

        p.mutex.Lock()
        defer p.mutex.Unlock()

        if pooledContainer, exists := p.containers[container.ID]; exists </span><span class="cov0" title="0">{
                p.logger.Debugf("Found container %s in pool, resetting it", container.ID)

                // Reset container for reuse
                if err := p.resetContainer(container.ID); err != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Failed to reset container %s: %v", container.ID, err)
                        // Mark as error and remove from pool
                        pooledContainer.Status = types.ContainerStatusError
                        pooledContainer.Error = err
                        pooledContainer.IsReady = false
                        p.updateStats()

                        // Try to cleanup the failed container
                        if cleanupErr := p.manager.CleanupContainer(context.Background(), container.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                                p.logger.Warnf("Failed to cleanup failed container %s: %v", container.ID, cleanupErr)
                        }</span> else<span class="cov0" title="0"> {
                                delete(p.containers, container.ID)
                        }</span>

                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">p.logger.Debugf("Container %s reset successfully, marking as ready", container.ID)
                pooledContainer.Status = types.ContainerStatusReady
                pooledContainer.IsReady = true
                pooledContainer.Error = nil // Clear any previous errors
                p.updateStats()

                // Signal that a container is available
                select </span>{
                case p.waitQueue &lt;- struct{}{}:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel is full, no one is waiting
                }

                <span class="cov0" title="0">p.logger.Debugf("Returned container %s to %s language pool", container.ID, p.language)</span>
        } else<span class="cov0" title="0"> {
                p.logger.Warnf("Container %s not found in %s language pool", container.ID, p.language)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *ContainerPool) createPreparedContainer(ctx context.Context) (*types.PooledContainer, error) <span class="cov0" title="0">{
        // Create a temporary directory for the container
        tmpDir, err := p.createTempDirectory()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp directory: %w", err)
        }</span>

        // Create container using the language-specific configuration
        <span class="cov0" title="0">containerID, err := p.createContainer(ctx, tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create container: %w", err)
        }</span>

        // Initialize the container with /code folder and basic setup
        <span class="cov0" title="0">if err := p.initializeContainer(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                // Cleanup container if initialization fails
                if cleanupErr := p.manager.CleanupContainer(ctx, containerID); cleanupErr != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Failed to cleanup container %s after initialization failure: %v", containerID, cleanupErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to initialize container: %w", err)</span>
        }

        // Create pooled container
        <span class="cov0" title="0">pooledContainer := &amp;types.PooledContainer{
                ID:         containerID,
                Status:     types.ContainerStatusReady,
                LastUsed:   time.Now(),
                IsReady:    true,
                WorkingDir: tmpDir,
                ImageName:  p.config.Config.ImageName,
                Language:   p.language,
                CreatedAt:  time.Now(),
        }

        p.mutex.Lock()
        p.containers[containerID] = pooledContainer
        p.stats.CreatedCount++
        p.updateStats()
        p.mutex.Unlock()

        p.logger.Infof("Created prepared container for language %s: %s", p.language, containerID)
        return pooledContainer, nil</span>
}

func (p *ContainerPool) createTempDirectory() (string, error) <span class="cov0" title="0">{
        tmpDir := fmt.Sprintf("/tmp/docker-container-%s-%d", p.language, time.Now().UnixNano())
        if err := os.MkdirAll(tmpDir, 0777); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov0" title="0">return tmpDir, nil</span>
}

// initializeContainer sets up the container with /code folder and basic initialization
func (p *ContainerPool) initializeContainer(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        p.logger.Debugf("Initializing container %s with /code folder setup", containerID)

        // Create /code directory and initialize basic files
        initScript := scripts.GetInitializationScript(p.language)

        execConfig := &amp;container.ExecOptions{
                Cmd:          []string{"sh", "-c", initScript},
                AttachStdout: true,
                AttachStderr: true,
        }

        execResp, err := p.manager.Cli.ContainerExecCreate(ctx, containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create initialization exec: %w", err)
        }</span>

        <span class="cov0" title="0">execAttachResp, err := p.manager.Cli.ContainerExecAttach(ctx, execResp.ID, container.ExecAttachOptions{
                Detach: false,
                Tty:    false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to initialization exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execAttachResp.Close()

        // Execute the initialization command
        if err := p.manager.Cli.ContainerExecStart(ctx, execResp.ID, container.ExecStartOptions{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start initialization exec: %w", err)
        }</span>

        // Wait for initialization to complete
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := p.manager.Cli.ContainerExecInspect(ctx, execResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect initialization exec: %w", err)
                }</span>
                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("container initialization failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">p.logger.Debugf("Container %s initialized successfully", containerID)

        // Verify container is ready by running a quick test
        if err := p.verifyContainerReady(ctx, containerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("container verification failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// verifyContainerReady runs a quick test to ensure the container is fully ready
func (p *ContainerPool) verifyContainerReady(ctx context.Context, containerID string) error <span class="cov0" title="0">{
        p.logger.Debugf("Verifying container %s is ready", containerID)

        // Run a simple test command based on language
        var testCmd string
        switch p.language </span>{
        case types.LanguageGo:<span class="cov0" title="0">
                testCmd = "cd /code &amp;&amp; go version"</span>
        case types.LanguagePy:<span class="cov0" title="0">
                testCmd = "cd /code &amp;&amp; python --version"</span>
        case types.LanguageJS, types.LanguageNode:<span class="cov0" title="0">
                testCmd = "cd /code &amp;&amp; node --version"</span>
        case types.LanguageTS:<span class="cov0" title="0">
                testCmd = "cd /code &amp;&amp; tsc --version"</span>
        default:<span class="cov0" title="0">
                testCmd = "cd /code &amp;&amp; echo 'ready'"</span>
        }

        <span class="cov0" title="0">execConfig := &amp;container.ExecOptions{
                Cmd:          []string{"sh", "-c", testCmd},
                AttachStdout: true,
                AttachStderr: true,
        }

        execResp, err := p.manager.Cli.ContainerExecCreate(ctx, containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create verification exec: %w", err)
        }</span>

        <span class="cov0" title="0">execAttachResp, err := p.manager.Cli.ContainerExecAttach(ctx, execResp.ID, container.ExecAttachOptions{
                Detach: false,
                Tty:    false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to verification exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execAttachResp.Close()

        // Execute the verification command
        if err := p.manager.Cli.ContainerExecStart(ctx, execResp.ID, container.ExecStartOptions{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start verification exec: %w", err)
        }</span>

        // Wait for verification to complete with timeout
        <span class="cov0" title="0">timeout := time.After(10 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timeout:<span class="cov0" title="0">
                        return fmt.Errorf("container verification timed out")</span>
                default:<span class="cov0" title="0">
                        inspectResp, err := p.manager.Cli.ContainerExecInspect(ctx, execResp.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to inspect verification exec: %w", err)
                        }</span>
                        <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                                if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("container verification failed with exit code: %d", inspectResp.ExitCode)
                                }</span>
                                <span class="cov0" title="0">p.logger.Debugf("Container %s verified as ready", containerID)
                                return nil</span>
                        }
                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                }
        }
}

func (p *ContainerPool) pullImage(ctx context.Context, imageName string) error <span class="cov0" title="0">{
        // Check if image already exists locally
        images, err := p.manager.Cli.ImageList(ctx, image.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Warnf("Failed to list images: %v", err)
        }</span> else<span class="cov0" title="0"> {
                for _, img := range images </span><span class="cov0" title="0">{
                        for _, tag := range img.RepoTags </span><span class="cov0" title="0">{
                                if tag == imageName || tag == imageName+":latest" </span><span class="cov0" title="0">{
                                        p.logger.Debugf("Image %s already exists locally, skipping pull", imageName)
                                        return nil
                                }</span>
                        }
                }
        }

        // Image doesn't exist locally, pull it
        <span class="cov0" title="0">reader, err := p.manager.Cli.ImagePull(ctx, imageName, image.PullOptions{})
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Errorf("Failed to pull image: %v", err)
                return fmt.Errorf("failed to pull image: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := reader.Close()
                if err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close image pull reader: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">p.logger.Infof("Successfully pulled image: %s", imageName)
        return nil</span>
}

func (p *ContainerPool) createContainer(ctx context.Context, codePath string) (string, error) <span class="cov0" title="0">{
        absPath, err := filepath.Abs(codePath)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Errorf("failed to get absolute path: %v", err)
                return "", fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Debugf("Creating container with code directory: %s", absPath)

        // For Docker-in-Docker, make sure the mount path is absolute and exists on the host
        hostMountPath := absPath
        if !filepath.IsAbs(hostMountPath) </span><span class="cov0" title="0">{
                hostMountPath, _ = filepath.Abs(hostMountPath)
        }</span>

        // Create a simple keep-alive command that keeps the container running
        <span class="cov0" title="0">keepAliveCommand := `tail -f /dev/null`

        config := &amp;container.Config{
                Image:      p.config.Config.ImageName,
                Cmd:        []string{"sh", "-c", keepAliveCommand},
                Tty:        true,
                WorkingDir: "/code",
        }

        hostConfig := &amp;container.HostConfig{
                Binds: []string{
                        fmt.Sprintf("%s:/code:rw", hostMountPath),
                        "/var/run/docker.sock:/var/run/docker.sock",
                },
                Resources: container.Resources{
                        Memory:   1024 * 1024 * 1024, // 1GB default
                        NanoCPUs: 1e9,                // 1 CPU default
                },
                Privileged: true,
        }

        resp, err := p.manager.Cli.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Errorf("failed to create container: %v", err)
                return "", fmt.Errorf("failed to create container: %w", err)
        }</span>

        <span class="cov0" title="0">containerID := resp.ID
        p.logger.Infof("Container created with ID: %s", containerID)

        // Start the container
        err = p.manager.Cli.ContainerStart(ctx, containerID, container.StartOptions{})
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Errorf("failed to start container: %v", err)
                // Try to cleanup the created container
                if cleanupErr := p.manager.Cli.ContainerRemove(ctx, containerID, container.RemoveOptions{Force: true}); cleanupErr != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Failed to cleanup container after start failure: %v", cleanupErr)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to start container: %w", err)</span>
        }

        // Wait for container to be running
        <span class="cov0" title="0">maxRetries := 10
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                inspect, err := p.manager.Cli.ContainerInspect(ctx, containerID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to inspect container after start: %w", err)
                }</span>

                <span class="cov0" title="0">if inspect.State.Running </span><span class="cov0" title="0">{
                        p.logger.Infof("Container %s is running", containerID)
                        return containerID, nil
                }</span>

                <span class="cov0" title="0">p.logger.Debugf("Container %s not running yet (attempt %d/%d), status: %s", containerID, i+1, maxRetries, inspect.State.Status)
                time.Sleep(500 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("container %s failed to start properly", containerID)</span>
}

func (p *ContainerPool) resetContainer(containerID string) error <span class="cov0" title="0">{
        p.logger.Debugf("Resetting container %s", containerID)

        // Instead of full restart, just clean up the code files
        resetScript := p.getResetScript()

        execConfig := &amp;container.ExecOptions{
                Cmd:          []string{"sh", "-c", resetScript},
                AttachStdout: true,
                AttachStderr: true,
        }

        execResp, err := p.manager.Cli.ContainerExecCreate(context.Background(), containerID, *execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create reset exec: %w", err)
        }</span>

        <span class="cov0" title="0">execAttachResp, err := p.manager.Cli.ContainerExecAttach(context.Background(), execResp.ID, container.ExecAttachOptions{
                Detach: false,
                Tty:    false,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to attach to reset exec: %w", err)
        }</span>
        <span class="cov0" title="0">defer execAttachResp.Close()

        // Execute the reset command
        if err := p.manager.Cli.ContainerExecStart(context.Background(), execResp.ID, container.ExecStartOptions{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start reset exec: %w", err)
        }</span>

        // Wait for reset to complete
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                inspectResp, err := p.manager.Cli.ContainerExecInspect(context.Background(), execResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inspect reset exec: %w", err)
                }</span>
                <span class="cov0" title="0">if !inspectResp.Running </span><span class="cov0" title="0">{
                        if inspectResp.ExitCode != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("container reset failed with exit code: %d", inspectResp.ExitCode)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">p.logger.Debugf("Container %s reset successfully", containerID)
        return nil</span>
}

// getResetScript returns the script to reset a container
func (p *ContainerPool) getResetScript() string <span class="cov0" title="0">{
        switch p.language </span>{
        case types.LanguageGo:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
cd /code
rm -f code.go
echo 'package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}' &gt; code.go
echo "Container reset successfully"
`</span>
        case types.LanguagePy:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
cd /code
rm -f code.py
echo 'print("Hello, World!")' &gt; code.py
echo "Container reset successfully"
`</span>
        case types.LanguageJS, types.LanguageNode:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
cd /code
rm -f code.js
echo 'console.log("Hello, World!");' &gt; code.js
echo "Container reset successfully"
`</span>
        case types.LanguageTS:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
cd /code
rm -f code.ts
echo 'console.log("Hello, World!");' &gt; code.ts
echo "Container reset successfully"
`</span>
        default:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
cd /code
echo "Container reset successfully"
`</span>
        }
}

func (p *ContainerPool) startCleanupRoutine() <span class="cov0" title="0">{
        p.cleanupTicker = time.NewTicker(p.config.CleanupInterval)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-p.cleanupTicker.C:<span class="cov0" title="0">
                                p.cleanup()</span>
                        case &lt;-p.stopCleanup:<span class="cov0" title="0">
                                p.cleanupTicker.Stop()
                                return</span>
                        }
                }
        }()
}

func (p *ContainerPool) startHealthCheckRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(p.config.HealthCheckInterval)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                p.healthCheck()</span>
                        case &lt;-p.stopCleanup:<span class="cov0" title="0">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (p *ContainerPool) cleanup() <span class="cov0" title="0">{
        p.mutex.Lock()
        defer p.mutex.Unlock()

        now := time.Now()
        containersToRemove := make([]string, 0)

        // Find containers that have been idle too long
        for id, container := range p.containers </span><span class="cov0" title="0">{
                if container.Status == types.ContainerStatusReady &amp;&amp;
                        now.Sub(container.LastUsed) &gt; p.config.IdleTimeout </span><span class="cov0" title="0">{
                        containersToRemove = append(containersToRemove, id)
                }</span>
        }

        // Remove idle containers (but keep minimum number)
        <span class="cov0" title="0">readyCount := p.getReadyContainerCount()
        for _, id := range containersToRemove </span><span class="cov0" title="0">{
                if readyCount &lt;= p.config.MinContainers </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if err := p.manager.CleanupContainer(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Failed to cleanup container %s: %v", id, err)
                        continue</span>
                }

                <span class="cov0" title="0">delete(p.containers, id)
                readyCount--
                p.stats.DestroyedCount++</span>
        }

        <span class="cov0" title="0">if len(containersToRemove) &gt; 0 </span><span class="cov0" title="0">{
                p.logger.Infof("Cleaned up %d idle containers from %s language pool", len(containersToRemove), p.language)
        }</span>

        <span class="cov0" title="0">p.stats.LastCleanup = now
        p.updateStats()</span>
}

func (p *ContainerPool) healthCheck() <span class="cov0" title="0">{
        p.mutex.Lock()
        defer p.mutex.Unlock()

        for id, container := range p.containers </span><span class="cov0" title="0">{
                // Check if container is still running
                inspect, err := p.manager.Cli.ContainerInspect(context.Background(), id)
                if err != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Container %s health check failed: %v", id, err)
                        container.Status = types.ContainerStatusError
                        container.Error = err
                        continue</span>
                }

                <span class="cov0" title="0">if !inspect.State.Running </span><span class="cov0" title="0">{
                        container.Status = types.ContainerStatusStopped
                        container.IsReady = false
                }</span>
        }

        <span class="cov0" title="0">p.updateStats()</span>
}

func (p *ContainerPool) getTotalContainerCount() int <span class="cov0" title="0">{
        return len(p.containers)
}</span>

func (p *ContainerPool) getReadyContainerCount() int <span class="cov0" title="0">{
        count := 0
        for _, container := range p.containers </span><span class="cov0" title="0">{
                if container.Status == types.ContainerStatusReady &amp;&amp; container.IsReady </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

func (p *ContainerPool) updateStats() <span class="cov0" title="0">{
        readyCount := 0
        busyCount := 0
        errorCount := 0

        for _, container := range p.containers </span><span class="cov0" title="0">{
                switch container.Status </span>{
                case types.ContainerStatusReady:<span class="cov0" title="0">
                        readyCount++</span>
                case types.ContainerStatusRunning:<span class="cov0" title="0">
                        busyCount++</span>
                case types.ContainerStatusError:<span class="cov0" title="0">
                        errorCount++</span>
                }
        }

        <span class="cov0" title="0">p.statsMutex.Lock()
        p.stats.ReadyContainers = readyCount
        p.stats.BusyContainers = busyCount
        p.stats.ErrorContainers = errorCount
        p.stats.TotalContainers = len(p.containers)

        if p.stats.TotalContainers &gt; 0 </span><span class="cov0" title="0">{
                p.stats.UtilizationRate = float64(busyCount) / float64(p.stats.TotalContainers)
        }</span>
        <span class="cov0" title="0">p.statsMutex.Unlock()</span>
}

func (p *ContainerPool) GetStats() *types.PoolStats <span class="cov0" title="0">{
        p.statsMutex.RLock()
        defer p.statsMutex.RUnlock()

        // Create a copy to avoid race conditions
        stats := *p.stats
        return &amp;stats
}</span>

func (p *ContainerPool) GetLanguage() types.Language <span class="cov0" title="0">{
        return p.language
}</span>

func (p *ContainerPool) Close() error <span class="cov0" title="0">{
        p.mutex.Lock()
        defer p.mutex.Unlock()

        // Stop cleanup routine
        if p.cleanupTicker != nil </span><span class="cov0" title="0">{
                close(p.stopCleanup)
        }</span>

        // Cleanup all containers
        <span class="cov0" title="0">for id := range p.containers </span><span class="cov0" title="0">{
                if err := p.manager.CleanupContainer(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                        p.logger.Warnf("Failed to cleanup container %s: %v", id, err)
                }</span>
        }

        <span class="cov0" title="0">p.containers = make(map[string]*types.PooledContainer)
        p.logger.Infof("Closed %s language pool", p.language)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file234" style="display: none">package docker

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/execution"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
)

// DockerManager is the main entry point for the Docker package
// It provides a unified interface for all Docker operations
type DockerManager struct {
        executor    *execution.CodeExecutor
        config      config.ExecutorConfig
        logger      logging.Logger
        mutex       sync.RWMutex
        initialized bool
        closed      bool
}

// NewDockerManager creates a new Docker manager with the specified configuration
func NewDockerManager(cfg config.ExecutorConfig, logger logging.Logger) (*DockerManager, error) <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>

        <span class="cov0" title="0">dm := &amp;DockerManager{
                config: cfg,
                logger: logger,
        }

        return dm, nil</span>
}

// Initialize sets up the Docker manager and all its components
func (dm *DockerManager) Initialize(ctx context.Context, languages []types.Language) error <span class="cov0" title="0">{
        dm.mutex.Lock()
        defer dm.mutex.Unlock()

        if dm.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("docker manager already initialized")
        }</span>

        <span class="cov0" title="0">dm.logger.Info("Initializing Docker manager")

        httpClient, err := httppkg.NewHTTPClient(httppkg.DefaultHTTPRetryConfig(), dm.logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        // Create the code executor
        <span class="cov0" title="0">executor, err := execution.NewCodeExecutor(ctx, dm.config, httpClient, dm.logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create code executor: %w", err)
        }</span>

        // Initialize language-specific container pools
        <span class="cov0" title="0">if err := executor.InitializeLanguagePools(ctx, languages); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize language pools: %w", err)
        }</span>

        <span class="cov0" title="0">dm.executor = executor
        dm.initialized = true

        dm.logger.Infof("Docker manager initialized successfully with %d language pools", len(languages))
        return nil</span>
}

// Execute runs code from the specified URL with the given number of attestations
func (dm *DockerManager) Execute(ctx context.Context, fileURL string, noOfAttesters int) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        dm.mutex.RLock()
        if !dm.initialized </span><span class="cov0" title="0">{
                dm.mutex.RUnlock()
                return nil, fmt.Errorf("docker manager not initialized")
        }</span>
        <span class="cov0" title="0">if dm.closed </span><span class="cov0" title="0">{
                dm.mutex.RUnlock()
                return nil, fmt.Errorf("docker manager is closed")
        }</span>
        <span class="cov0" title="0">dm.mutex.RUnlock()

        dm.logger.Infof("Executing code from URL: %s with %d attestations", fileURL, noOfAttesters)

        result, err := dm.executor.Execute(ctx, fileURL, noOfAttesters)
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Errorf("Execution failed: %v", err)
                return nil, fmt.Errorf("execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">dm.logger.Infof("Execution completed successfully")
        return result, nil</span>
}

// GetHealthStatus returns the current health status of the Docker manager
func (dm *DockerManager) GetHealthStatus() *execution.HealthStatus <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return &amp;execution.HealthStatus{
                        Status:    "unavailable",
                        Score:     0.0,
                        LastCheck: time.Now(),
                        Alerts:    []execution.Alert{},
                        Metrics:   &amp;types.PerformanceMetrics{},
                }
        }</span>

        <span class="cov0" title="0">return dm.executor.GetHealthStatus()</span>
}

// GetStats returns performance metrics for the Docker manager
func (dm *DockerManager) GetStats() *types.PerformanceMetrics <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return &amp;types.PerformanceMetrics{}
        }</span>

        <span class="cov0" title="0">return dm.executor.GetStats()</span>
}

// GetPoolStats returns statistics for all language pools
func (dm *DockerManager) GetAllPoolStats() map[types.Language]*types.PoolStats <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return make(map[types.Language]*types.PoolStats)
        }</span>

        <span class="cov0" title="0">return dm.executor.GetPoolStats()</span>
}

// GetLanguageStats returns statistics for a specific language pool
func (dm *DockerManager) GetPoolStats(language types.Language) *types.PoolStats <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stats := dm.executor.GetPoolStats()
        if stats == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return stats[language]</span>
}

// GetLanguageStats returns statistics for a specific language pool
func (dm *DockerManager) GetLanguageStats(language types.Language) (*types.PoolStats, bool) <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">stats := dm.executor.GetPoolStats()
        if stats == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">poolStats, exists := stats[language]
        return poolStats, exists</span>
}

// GetSupportedLanguages returns all languages with active pools
func (dm *DockerManager) GetSupportedLanguages() []types.Language <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return []types.Language{}
        }</span>

        <span class="cov0" title="0">return dm.executor.GetSupportedLanguages()</span>
}

// IsLanguageSupported checks if a language is supported
func (dm *DockerManager) IsLanguageSupported(language types.Language) bool <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return dm.executor.IsLanguageSupported(language)</span>
}

// GetActiveExecutions returns all currently active executions
func (dm *DockerManager) GetActiveExecutions() []*types.ExecutionContext <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return []*types.ExecutionContext{}
        }</span>

        <span class="cov0" title="0">return dm.executor.GetActiveExecutions()</span>
}

// GetExecutionByID returns a specific execution by its ID
func (dm *DockerManager) GetExecutionByID(executionID string) (*types.ExecutionContext, bool) <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return dm.executor.GetExecutionByID(executionID)</span>
}

// CancelExecution cancels a running execution
func (dm *DockerManager) CancelExecution(executionID string) error <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("docker manager not initialized")
        }</span>
        <span class="cov0" title="0">if dm.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("docker manager is closed")
        }</span>

        <span class="cov0" title="0">return dm.executor.CancelExecution(executionID)</span>
}

// GetAlerts returns alerts from the monitoring system
func (dm *DockerManager) GetAlerts(severity string, limit int) []execution.Alert <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return []execution.Alert{}
        }</span>

        <span class="cov0" title="0">return dm.executor.GetAlerts(severity, limit)</span>
}

// ClearAlerts clears all alerts from the monitoring system
func (dm *DockerManager) ClearAlerts() <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()

        if !dm.initialized || dm.closed </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">dm.executor.ClearAlerts()</span>
}

// IsInitialized returns whether the Docker manager is initialized
func (dm *DockerManager) IsInitialized() bool <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()
        return dm.initialized
}</span>

// IsClosed returns whether the Docker manager is closed
func (dm *DockerManager) IsClosed() bool <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()
        return dm.closed
}</span>

// GetConfig returns a copy of the current configuration
func (dm *DockerManager) GetConfig() config.ExecutorConfig <span class="cov0" title="0">{
        dm.mutex.RLock()
        defer dm.mutex.RUnlock()
        return dm.config
}</span>

// UpdateConfig updates the configuration (requires reinitialization)
func (dm *DockerManager) UpdateConfig(newConfig config.ExecutorConfig) error <span class="cov0" title="0">{
        dm.mutex.Lock()
        defer dm.mutex.Unlock()

        if dm.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot update config while initialized, close manager first")
        }</span>

        <span class="cov0" title="0">dm.config = newConfig
        dm.logger.Info("Configuration updated")
        return nil</span>
}

// Close shuts down the Docker manager and cleans up resources
func (dm *DockerManager) Close() error <span class="cov0" title="0">{
        dm.mutex.Lock()
        defer dm.mutex.Unlock()

        if dm.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dm.logger.Info("Closing Docker manager")

        if dm.executor != nil </span><span class="cov0" title="0">{
                if err := dm.executor.Close(); err != nil </span><span class="cov0" title="0">{
                        dm.logger.Warnf("Failed to close executor: %v", err)
                }</span>
        }

        <span class="cov0" title="0">dm.closed = true
        dm.logger.Info("Docker manager closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file235" style="display: none">package execution

import (
        "context"
        "fmt"

        "github.com/docker/docker/client"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/container"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/file"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type CodeExecutor struct {
        pipeline *ExecutionPipeline
        monitor  *ExecutionMonitor
        config   config.ExecutorConfig
        logger   logging.Logger
}

func NewCodeExecutor(ctx context.Context, cfg config.ExecutorConfig, httpClient *httppkg.HTTPClient, logger logging.Logger) (*CodeExecutor, error) <span class="cov0" title="0">{
        // Create Docker client with API version compatibility
        cli, err := client.NewClientWithOpts(
                client.FromEnv,
                client.WithVersion("1.44"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create docker client: %w", err)
        }</span>

        // Create file manager
        <span class="cov0" title="0">fileMgr, err := file.NewFileManager(cfg, httpClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file manager: %w", err)
        }</span>

        // Create container manager
        <span class="cov0" title="0">containerMgr, err := container.NewManager(cli, cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create container manager: %w", err)
        }</span>

        // Initialize container manager
        <span class="cov0" title="0">if err := containerMgr.Initialize(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize container manager: %w", err)
        }</span>

        // Create execution pipeline
        <span class="cov0" title="0">pipeline := NewExecutionPipeline(cfg, fileMgr, containerMgr, logger)

        // Create execution monitor
        monitor := NewExecutionMonitor(pipeline, cfg, logger)

        return &amp;CodeExecutor{
                pipeline: pipeline,
                monitor:  monitor,
                config:   cfg,
                logger:   logger,
        }, nil</span>
}

func (e *CodeExecutor) Execute(ctx context.Context, fileURL string, noOfAttesters int) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        e.logger.Infof("Executing code from URL: %s with %d attestations", fileURL, noOfAttesters)

        // Execute through pipeline
        result, err := e.pipeline.Execute(ctx, fileURL, noOfAttesters)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Errorf("Execution failed: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">e.logger.Infof("Execution completed successfully")
        return result, nil</span>
}

func (e *CodeExecutor) GetHealthStatus() *HealthStatus <span class="cov0" title="0">{
        return e.monitor.GetHealthStatus()
}</span>

func (e *CodeExecutor) GetStats() *types.PerformanceMetrics <span class="cov0" title="0">{
        return e.pipeline.GetStats()
}</span>

func (e *CodeExecutor) GetPoolStats() map[types.Language]*types.PoolStats <span class="cov0" title="0">{
        return e.pipeline.containerMgr.GetPoolStats()
}</span>

// InitializeLanguagePools initializes language-specific container pools
func (e *CodeExecutor) InitializeLanguagePools(ctx context.Context, languages []types.Language) error <span class="cov0" title="0">{
        return e.pipeline.containerMgr.InitializeLanguagePools(ctx, languages)
}</span>

// GetSupportedLanguages returns all languages with active pools
func (e *CodeExecutor) GetSupportedLanguages() []types.Language <span class="cov0" title="0">{
        return e.pipeline.containerMgr.GetSupportedLanguages()
}</span>

// IsLanguageSupported checks if a language is supported
func (e *CodeExecutor) IsLanguageSupported(language types.Language) bool <span class="cov0" title="0">{
        return e.pipeline.containerMgr.IsLanguageSupported(language)
}</span>

func (e *CodeExecutor) GetActiveExecutions() []*types.ExecutionContext <span class="cov0" title="0">{
        return e.monitor.GetActiveExecutions()
}</span>

func (e *CodeExecutor) GetExecutionByID(executionID string) (*types.ExecutionContext, bool) <span class="cov0" title="0">{
        return e.monitor.GetExecutionByID(executionID)
}</span>

func (e *CodeExecutor) CancelExecution(executionID string) error <span class="cov0" title="0">{
        return e.monitor.CancelExecution(executionID)
}</span>

func (e *CodeExecutor) GetAlerts(severity string, limit int) []Alert <span class="cov0" title="0">{
        return e.monitor.GetAlerts(severity, limit)
}</span>

func (e *CodeExecutor) ClearAlerts() <span class="cov0" title="0">{
        e.monitor.ClearAlerts()
}</span>

func (e *CodeExecutor) Close() error <span class="cov0" title="0">{
        e.logger.Info("Closing code executor")

        // Close monitor
        if e.monitor != nil </span><span class="cov0" title="0">{
                if err := e.monitor.Close(); err != nil </span><span class="cov0" title="0">{
                        e.logger.Warnf("Failed to close monitor: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if e.pipeline.fileManager != nil </span><span class="cov0" title="0">{
                if err := e.pipeline.fileManager.Close(); err != nil </span><span class="cov0" title="0">{
                        e.logger.Warnf("Failed to close file manager: %v", err)
                }</span>
        }

        <span class="cov0" title="0">if e.pipeline.containerMgr != nil </span><span class="cov0" title="0">{
                if err := e.pipeline.containerMgr.Close(); err != nil </span><span class="cov0" title="0">{
                        e.logger.Warnf("Failed to close container manager: %v", err)
                }</span>
        }

        <span class="cov0" title="0">e.logger.Info("Code executor closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file236" style="display: none">package execution

import (
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type Alert struct {
        Type      string    `json:"type"`
        Message   string    `json:"message"`
        Severity  string    `json:"severity"`
        Timestamp time.Time `json:"timestamp"`
}

type HealthStatus struct {
        Status    string                    `json:"status"`
        Score     float64                   `json:"score"`
        LastCheck time.Time                 `json:"last_check"`
        Alerts    []Alert                   `json:"alerts"`
        Metrics   *types.PerformanceMetrics `json:"metrics"`
}

type ExecutionMonitor struct {
        pipeline         *ExecutionPipeline
        config           config.ExecutorConfig
        logger           logging.Logger
        mutex            sync.RWMutex
        alerts           []Alert
        metrics          *types.PerformanceMetrics
        monitoringTicker *time.Ticker
        stopMonitoring   chan struct{}
}

func NewExecutionMonitor(pipeline *ExecutionPipeline, cfg config.ExecutorConfig, logger logging.Logger) *ExecutionMonitor <span class="cov0" title="0">{
        monitor := &amp;ExecutionMonitor{
                pipeline: pipeline,
                config:   cfg,
                logger:   logger,
                alerts:   make([]Alert, 0),
                metrics: &amp;types.PerformanceMetrics{
                        TotalExecutions:      0,
                        SuccessfulExecutions: 0,
                        FailedExecutions:     0,
                        AverageExecutionTime: 0,
                        MinExecutionTime:     0,
                        MaxExecutionTime:     0,
                        TotalCost:            0.0,
                        AverageCost:          0.0,
                        LastExecution:        time.Time{},
                },
                stopMonitoring: make(chan struct{}),
        }

        // Start monitoring routine
        monitor.startMonitoring()

        return monitor
}</span>

func (em *ExecutionMonitor) startMonitoring() <span class="cov0" title="0">{
        // Use a default interval since Monitoring config doesn't exist
        interval := 30 * time.Second
        em.monitoringTicker = time.NewTicker(interval)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-em.monitoringTicker.C:<span class="cov0" title="0">
                                em.performHealthCheck()</span>
                        case &lt;-em.stopMonitoring:<span class="cov0" title="0">
                                em.monitoringTicker.Stop()
                                return</span>
                        }
                }
        }()
}

func (em *ExecutionMonitor) performHealthCheck() <span class="cov0" title="0">{
        em.logger.Debugf("Performing health check")

        // Check active executions
        activeExecutions := em.pipeline.GetActiveExecutions()

        // Check for stuck executions (default max time: 5 minutes)
        maxExecutionTime := 5 * time.Minute
        for _, exec := range activeExecutions </span><span class="cov0" title="0">{
                duration := time.Since(exec.StartedAt)
                if duration &gt; maxExecutionTime </span><span class="cov0" title="0">{
                        em.createAlert("execution_timeout", fmt.Sprintf("Execution %s has exceeded max time: %v", exec.TraceID, duration), "warning")
                }</span>
        }

        // Check pipeline statistics
        <span class="cov0" title="0">stats := em.pipeline.GetStats()

        // Check success rate (default min: 80%)
        minSuccessRate := 0.8
        if stats.TotalExecutions &gt; 0 </span><span class="cov0" title="0">{
                successRate := float64(stats.SuccessfulExecutions) / float64(stats.TotalExecutions)
                if successRate &lt; minSuccessRate </span><span class="cov0" title="0">{
                        em.createAlert("low_success_rate", fmt.Sprintf("Success rate is low: %.2f%%", successRate*100), "error")
                }</span>
        }

        // Check average execution time (default max: 2 minutes)
        <span class="cov0" title="0">maxAverageTime := 2 * time.Minute
        if stats.AverageExecutionTime &gt; maxAverageTime </span><span class="cov0" title="0">{
                em.createAlert("high_execution_time", fmt.Sprintf("Average execution time is high: %v", stats.AverageExecutionTime), "warning")
        }</span>

        // Update metrics
        <span class="cov0" title="0">em.updateMetrics(stats)</span>
}

func (em *ExecutionMonitor) createAlert(alertType, message, severity string) <span class="cov0" title="0">{
        alert := Alert{
                Type:      alertType,
                Message:   message,
                Severity:  severity,
                Timestamp: time.Now(),
        }

        em.mutex.Lock()
        em.alerts = append(em.alerts, alert)

        // Keep only recent alerts (max 100)
        maxAlerts := 100
        if len(em.alerts) &gt; maxAlerts </span><span class="cov0" title="0">{
                em.alerts = em.alerts[len(em.alerts)-maxAlerts:]
        }</span>
        <span class="cov0" title="0">em.mutex.Unlock()

        em.logger.Warnf("Alert: %s - %s", alertType, message)</span>
}

func (em *ExecutionMonitor) updateMetrics(stats *types.PerformanceMetrics) <span class="cov0" title="0">{
        em.mutex.Lock()
        defer em.mutex.Unlock()

        em.metrics = stats
}</span>

func (em *ExecutionMonitor) GetHealthStatus() *HealthStatus <span class="cov0" title="0">{
        em.mutex.RLock()
        defer em.mutex.RUnlock()

        // Calculate overall health score
        healthScore := 100.0

        // Reduce score based on alerts
        criticalAlerts := 0
        warningAlerts := 0

        for _, alert := range em.alerts </span><span class="cov0" title="0">{
                if time.Since(alert.Timestamp) &lt; time.Hour </span><span class="cov0" title="0">{ // Only consider recent alerts
                        switch alert.Severity </span>{
                        case "error":<span class="cov0" title="0">
                                criticalAlerts++</span>
                        case "warning":<span class="cov0" title="0">
                                warningAlerts++</span>
                        }
                }
        }

        <span class="cov0" title="0">healthScore -= float64(criticalAlerts) * 20 // Each critical alert reduces score by 20
        healthScore -= float64(warningAlerts) * 5   // Each warning alert reduces score by 5

        if healthScore &lt; 0 </span><span class="cov0" title="0">{
                healthScore = 0
        }</span>

        <span class="cov0" title="0">status := "healthy"
        if healthScore &lt; 50 </span><span class="cov0" title="0">{
                status = "critical"
        }</span> else<span class="cov0" title="0"> if healthScore &lt; 80 </span><span class="cov0" title="0">{
                status = "warning"
        }</span>

        <span class="cov0" title="0">return &amp;HealthStatus{
                Status:    status,
                Score:     healthScore,
                LastCheck: time.Now(),
                Alerts:    em.getRecentAlerts(),
                Metrics:   em.metrics,
        }</span>
}

func (em *ExecutionMonitor) getRecentAlerts() []Alert <span class="cov0" title="0">{
        recentAlerts := make([]Alert, 0)
        cutoff := time.Now().Add(-time.Hour) // Last hour

        for _, alert := range em.alerts </span><span class="cov0" title="0">{
                if alert.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        recentAlerts = append(recentAlerts, alert)
                }</span>
        }

        <span class="cov0" title="0">return recentAlerts</span>
}

func (em *ExecutionMonitor) GetAlerts(severity string, limit int) []Alert <span class="cov0" title="0">{
        em.mutex.RLock()
        defer em.mutex.RUnlock()

        filteredAlerts := make([]Alert, 0)

        for _, alert := range em.alerts </span><span class="cov0" title="0">{
                if severity == "" || alert.Severity == severity </span><span class="cov0" title="0">{
                        filteredAlerts = append(filteredAlerts, alert)
                }</span>
        }

        // Sort by timestamp (newest first)
        <span class="cov0" title="0">for i := 0; i &lt; len(filteredAlerts)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(filteredAlerts); j++ </span><span class="cov0" title="0">{
                        if filteredAlerts[i].Timestamp.Before(filteredAlerts[j].Timestamp) </span><span class="cov0" title="0">{
                                filteredAlerts[i], filteredAlerts[j] = filteredAlerts[j], filteredAlerts[i]
                        }</span>
                }
        }

        // Apply limit
        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(filteredAlerts) &gt; limit </span><span class="cov0" title="0">{
                filteredAlerts = filteredAlerts[:limit]
        }</span>

        <span class="cov0" title="0">return filteredAlerts</span>
}

func (em *ExecutionMonitor) ClearAlerts() <span class="cov0" title="0">{
        em.mutex.Lock()
        defer em.mutex.Unlock()

        em.alerts = make([]Alert, 0)
        em.logger.Info("All alerts cleared")
}</span>

func (em *ExecutionMonitor) GetMetrics() *types.PerformanceMetrics <span class="cov0" title="0">{
        em.mutex.RLock()
        defer em.mutex.RUnlock()

        // Create a copy to avoid race conditions
        metrics := *em.metrics
        return &amp;metrics
}</span>

func (em *ExecutionMonitor) GetActiveExecutions() []*types.ExecutionContext <span class="cov0" title="0">{
        return em.pipeline.GetActiveExecutions()
}</span>

func (em *ExecutionMonitor) GetExecutionByID(executionID string) (*types.ExecutionContext, bool) <span class="cov0" title="0">{
        return em.pipeline.GetExecutionByID(executionID)
}</span>

func (em *ExecutionMonitor) CancelExecution(executionID string) error <span class="cov0" title="0">{
        return em.pipeline.CancelExecution(executionID)
}</span>

func (em *ExecutionMonitor) Close() error <span class="cov0" title="0">{
        em.logger.Info("Closing execution monitor")

        if em.monitoringTicker != nil </span><span class="cov0" title="0">{
                close(em.stopMonitoring)
        }</span>

        <span class="cov0" title="0">em.logger.Info("Execution monitor closed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file237" style="display: none">package execution

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/container"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/file"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type ExecutionPipeline struct {
        fileManager      *file.FileManager
        containerMgr     *container.Manager
        config           config.ExecutorConfig
        logger           logging.Logger
        mutex            sync.RWMutex
        activeExecutions map[string]*types.ExecutionContext
        stats            *types.PerformanceMetrics
}

func NewExecutionPipeline(cfg config.ExecutorConfig, fileMgr *file.FileManager, containerMgr *container.Manager, logger logging.Logger) *ExecutionPipeline <span class="cov0" title="0">{
        return &amp;ExecutionPipeline{
                fileManager:      fileMgr,
                containerMgr:     containerMgr,
                config:           cfg,
                logger:           logger,
                activeExecutions: make(map[string]*types.ExecutionContext),
                stats: &amp;types.PerformanceMetrics{
                        TotalExecutions:      0,
                        SuccessfulExecutions: 0,
                        FailedExecutions:     0,
                        AverageExecutionTime: 0,
                        MinExecutionTime:     0,
                        MaxExecutionTime:     0,
                        TotalCost:            0.0,
                        AverageCost:          0.0,
                        LastExecution:        time.Time{},
                },
        }
}</span>

func (ep *ExecutionPipeline) Execute(ctx context.Context, fileURL string, noOfAttesters int) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        executionID := generateExecutionID()

        ep.logger.Infof("Starting execution %s for file: %s", executionID, fileURL)

        // Create execution context
        execCtx := &amp;types.ExecutionContext{
                FileURL:       fileURL,
                NoOfAttesters: noOfAttesters,
                TraceID:       executionID,
                StartedAt:     startTime,
                Metadata:      make(map[string]string),
        }

        // Track execution
        ep.mutex.Lock()
        ep.activeExecutions[executionID] = execCtx
        ep.mutex.Unlock()

        defer func() </span><span class="cov0" title="0">{
                // Remove from active executions
                ep.mutex.Lock()
                delete(ep.activeExecutions, executionID)
                ep.mutex.Unlock()

                // Update statistics
                duration := time.Since(startTime)
                ep.updateStats(true, duration, 0.0)
        }</span>()

        // Execute pipeline stages
        <span class="cov0" title="0">result, err := ep.executeStages(ctx, execCtx)
        if err != nil </span><span class="cov0" title="0">{
                execCtx.CompletedAt = time.Now()
                ep.updateStats(false, time.Since(startTime), 0.0)
                return nil, fmt.Errorf("execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">execCtx.CompletedAt = time.Now()
        duration := time.Since(startTime)

        ep.logger.Infof("Execution %s completed successfully in %v", executionID, duration)
        return result, nil</span>
}

func (ep *ExecutionPipeline) executeStages(ctx context.Context, execCtx *types.ExecutionContext) (*types.ExecutionResult, error) <span class="cov0" title="0">{
        // Stage 1: Download and Validate
        ep.logger.Debugf("Stage 1: Downloading and validating file")
        fileCtx, err := ep.fileManager.GetOrDownload(ctx, execCtx.FileURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download file: %w", err)
        }</span>

        // Check validation results
        <span class="cov0" title="0">if fileCtx.Metadata["validation_errors"] != "" </span><span class="cov0" title="0">{
                return &amp;types.ExecutionResult{
                        Success: false,
                        Output:  "",
                        Error:   fmt.Errorf("file validation failed: %s", fileCtx.Metadata["validation_errors"]),
                }, nil
        }</span>

        // Stage 2: Get Container
        <span class="cov0" title="0">ep.logger.Debugf("Stage 2: Getting container from pool")

        // Determine language from file extension
        filePath := fileCtx.Metadata["file_path"]
        if filePath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file path not found in execution context")
        }</span>

        <span class="cov0" title="0">language := types.GetLanguageFromFile(filePath)
        ep.logger.Debugf("Detected language: %s for file: %s", language, filePath)

        container, err := ep.containerMgr.GetContainer(ctx, language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get container: %w", err)
        }</span>

        <span class="cov0" title="0">ep.logger.Debugf("Got container %s from %s pool", container.ID, container.Language)

        // Return container to pool asynchronously
        defer func() </span><span class="cov0" title="0">{
                go func(containerID string, container *types.PooledContainer) </span><span class="cov0" title="0">{
                        ep.logger.Debugf("Returning container %s to pool (async)", containerID)
                        if err := ep.containerMgr.ReturnContainer(container); err != nil </span><span class="cov0" title="0">{
                                ep.logger.Warnf("Failed to return container to pool: %v", err)
                        }</span>
                }(container.ID, container)
        }()

        // Stage 3: Execute Code
        <span class="cov0" title="0">ep.logger.Debugf("Stage 3: Executing code in container %s", container.ID)
        result, err := ep.containerMgr.ExecuteInContainer(ctx, container.ID, filePath, container.Language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute code: %w", err)
        }</span>

        // Stage 4: Process Results
        <span class="cov0" title="0">ep.logger.Debugf("Stage 4: Processing results")
        finalResult := ep.processResults(result, execCtx)

        // Stage 5: Cleanup
        // ep.logger.Debugf("Stage 5: Cleaning up")
        // if err := ep.cleanupExecution(execCtx); err != nil {
        //         ep.logger.Warnf("Failed to cleanup execution: %v", err)
        // }

        return finalResult, nil</span>
}

func (ep *ExecutionPipeline) processResults(result *types.ExecutionResult, execCtx *types.ExecutionContext) *types.ExecutionResult <span class="cov0" title="0">{
        // Add execution metadata
        execCtx.Metadata["execution_time"] = result.Stats.ExecutionTime.String()
        execCtx.Metadata["static_complexity"] = fmt.Sprintf("%.6f", result.Stats.StaticComplexity)
        execCtx.Metadata["dynamic_complexity"] = fmt.Sprintf("%.6f", result.Stats.DynamicComplexity)

        // Calculate fees
        fees := ep.calculateFees(execCtx)
        execCtx.Metadata["fees"] = fmt.Sprintf("%.6f", fees)
        result.Stats.TotalCost = fees

        return result
}</span>

func (ep *ExecutionPipeline) calculateFees(execCtx *types.ExecutionContext) float64 <span class="cov0" title="0">{
        // Basic fee calculation
        duration := time.Since(execCtx.StartedAt)
        baseFee := ep.config.Fees.FixedCost
        timeFee := duration.Seconds() * ep.config.Fees.PricePerTG

        // Add complexity factor if available
        complexityFee := 0.0
        if _, ok := execCtx.Metadata["complexity"]; ok </span><span class="cov0" title="0">{
                // Parse complexity and apply factor
                // This is a simplified calculation
                complexityFee = 0.1 // Placeholder
        }</span>

        <span class="cov0" title="0">return baseFee + timeFee + complexityFee</span>
}

// func (ep *ExecutionPipeline) cleanupExecution(execCtx *types.ExecutionContext) error {
//         // Cleanup any temporary files
//         // In this implementation, the file manager handles cleanup
//         return nil
// }

func (ep *ExecutionPipeline) GetActiveExecutions() []*types.ExecutionContext <span class="cov0" title="0">{
        ep.mutex.RLock()
        defer ep.mutex.RUnlock()

        executions := make([]*types.ExecutionContext, 0, len(ep.activeExecutions))
        for _, exec := range ep.activeExecutions </span><span class="cov0" title="0">{
                executions = append(executions, exec)
        }</span>

        <span class="cov0" title="0">return executions</span>
}

func (ep *ExecutionPipeline) GetExecutionByID(executionID string) (*types.ExecutionContext, bool) <span class="cov0" title="0">{
        ep.mutex.RLock()
        defer ep.mutex.RUnlock()

        exec, exists := ep.activeExecutions[executionID]
        return exec, exists
}</span>

func (ep *ExecutionPipeline) CancelExecution(executionID string) error <span class="cov0" title="0">{
        ep.mutex.Lock()
        defer ep.mutex.Unlock()

        exec, exists := ep.activeExecutions[executionID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("execution not found: %s", executionID)
        }</span>

        <span class="cov0" title="0">exec.CompletedAt = time.Now()

        ep.logger.Infof("Execution %s cancelled", executionID)
        return nil</span>
}

func (ep *ExecutionPipeline) GetStats() *types.PerformanceMetrics <span class="cov0" title="0">{
        ep.mutex.RLock()
        defer ep.mutex.RUnlock()

        // Create a copy to avoid race conditions
        stats := *ep.stats
        return &amp;stats
}</span>

func (ep *ExecutionPipeline) updateStats(success bool, duration time.Duration, complexity float64) <span class="cov0" title="0">{
        ep.mutex.Lock()
        defer ep.mutex.Unlock()

        ep.stats.TotalExecutions++
        ep.stats.LastExecution = time.Now()

        if success </span><span class="cov0" title="0">{
                ep.stats.SuccessfulExecutions++
        }</span> else<span class="cov0" title="0"> {
                ep.stats.FailedExecutions++
        }</span>

        // Update execution time statistics
        <span class="cov0" title="0">if ep.stats.MinExecutionTime == 0 || duration &lt; ep.stats.MinExecutionTime </span><span class="cov0" title="0">{
                ep.stats.MinExecutionTime = duration
        }</span>
        <span class="cov0" title="0">if duration &gt; ep.stats.MaxExecutionTime </span><span class="cov0" title="0">{
                ep.stats.MaxExecutionTime = duration
        }</span>

        // Calculate average execution time - only if we have successful executions
        <span class="cov0" title="0">if ep.stats.SuccessfulExecutions &gt; 0 </span><span class="cov0" title="0">{
                if ep.stats.SuccessfulExecutions == 1 </span><span class="cov0" title="0">{
                        // First successful execution
                        ep.stats.AverageExecutionTime = duration
                }</span> else<span class="cov0" title="0"> {
                        // Calculate running average
                        totalDuration := ep.stats.AverageExecutionTime * time.Duration(ep.stats.SuccessfulExecutions-1)
                        totalDuration += duration
                        ep.stats.AverageExecutionTime = totalDuration / time.Duration(ep.stats.SuccessfulExecutions)
                }</span>
        }

        // Update cost statistics
        <span class="cov0" title="0">cost := ep.calculateCost(duration, complexity)
        ep.stats.TotalCost += cost

        // Calculate average cost - only if we have successful executions
        if ep.stats.SuccessfulExecutions &gt; 0 </span><span class="cov0" title="0">{
                ep.stats.AverageCost = ep.stats.TotalCost / float64(ep.stats.SuccessfulExecutions)
        }</span>
}

func (ep *ExecutionPipeline) calculateCost(duration time.Duration, complexity float64) float64 <span class="cov0" title="0">{
        // Basic cost calculation based on execution time and complexity
        timeCost := duration.Seconds() * ep.config.Fees.PricePerTG
        complexityCost := complexity * ep.config.Fees.PricePerTG
        return timeCost + complexityCost + ep.config.Fees.FixedCost
}</span>

func generateExecutionID() string <span class="cov0" title="0">{
        return fmt.Sprintf("exec_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file238" style="display: none">package file

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type cachedFile struct {
        Path         string    `json:"path"`
        Hash         string    `json:"hash"`
        LastAccessed time.Time `json:"last_accessed"`
        Size         int64     `json:"size"`
        CreatedAt    time.Time `json:"created_at"`
}

type fileCache struct {
        cacheDir      string
        fileCache     map[string]*cachedFile
        mutex         sync.RWMutex
        config        config.CacheConfig
        logger        logging.Logger
        cleanupTicker *time.Ticker
        stopCleanup   chan struct{}
        stats         *types.CacheStats
        statsMutex    sync.RWMutex
}

func newFileCache(cfg config.CacheConfig, logger logging.Logger) (*fileCache, error) <span class="cov0" title="0">{
        // Use configured cache directory or fallback to persistent location
        cacheDir := cfg.CacheDir
        if cacheDir == "" </span><span class="cov0" title="0">{
                cacheDir = "/var/lib/triggerx/cache"
        }</span>

        // Ensure the cache directory exists with proper permissions
        <span class="cov0" title="0">if err := os.MkdirAll(cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cache directory %s: %w", cacheDir, err)
        }</span>

        <span class="cov0" title="0">cache := &amp;fileCache{
                cacheDir:    cacheDir,
                fileCache:   make(map[string]*cachedFile),
                config:      cfg,
                logger:      logger,
                stopCleanup: make(chan struct{}),
                stats: &amp;types.CacheStats{
                        HitCount:      0,
                        MissCount:     0,
                        HitRate:       0.0,
                        Size:          0,
                        MaxSize:       cfg.MaxCacheSize,
                        ItemCount:     0,
                        EvictionCount: 0,
                        LastCleanup:   time.Now(),
                },
        }

        // cache.startCleanupRoutine()

        if err := cache.loadExistingFiles(); err != nil </span><span class="cov0" title="0">{
                logger.Warnf("Failed to load existing cached files: %v", err)
        }</span>

        <span class="cov0" title="0">return cache, nil</span>
}

// GetOrDownload checks if the file is in the cache by key (CID or URL). If not, it calls downloadFunc to get the content and stores it.
func (c *fileCache) getOrDownloadFile(key string, downloadFunc func() ([]byte, error)) (string, error) <span class="cov0" title="0">{
        c.mutex.RLock()
        if cachedFile, exists := c.fileCache[key]; exists </span><span class="cov0" title="0">{
                c.mutex.RUnlock()
                return c.accessCachedFile(cachedFile)
        }</span>
        <span class="cov0" title="0">c.mutex.RUnlock()

        // Cache miss - need to download and store the file
        c.statsMutex.Lock()
        c.stats.MissCount++
        c.updateHitRate()
        c.statsMutex.Unlock()

        content, err := downloadFunc()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return c.storeFile(key, content)</span>
}

func (c *fileCache) accessCachedFile(cachedFile *cachedFile) (string, error) <span class="cov0" title="0">{
        // Check if file still exists on disk
        if _, err := os.Stat(cachedFile.Path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // File was deleted, remove from cache
                c.mutex.Lock()
                delete(c.fileCache, cachedFile.Hash)
                c.stats.ItemCount--
                c.stats.Size -= cachedFile.Size
                c.mutex.Unlock()

                // Save updated metadata
                if saveErr := c.saveMetadata(); saveErr != nil </span><span class="cov0" title="0">{
                        c.logger.Warnf("Failed to save cache metadata after removal: %v", saveErr)
                }</span>

                <span class="cov0" title="0">return "", fmt.Errorf("cached file not found on disk: %s", cachedFile.Path)</span>
        }

        <span class="cov0" title="0">cachedFile.LastAccessed = time.Now()

        // Save metadata to persist access time
        if err := c.saveMetadata(); err != nil </span><span class="cov0" title="0">{
                c.logger.Warnf("Failed to save cache metadata after access: %v", err)
        }</span>

        <span class="cov0" title="0">return cachedFile.Path, nil</span>
}

// storeFile now uses the key (CID or URL) as the filename (with .go extension)
func (c *fileCache) storeFile(key string, content []byte) (string, error) <span class="cov0" title="0">{
        if err := c.ensureSpace(int64(len(content))); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to ensure cache space: %w", err)
        }</span>

        // Sanitize key for filename (replace / and :)
        <span class="cov0" title="0">filename := strings.ReplaceAll(strings.ReplaceAll(key, "/", "_"), ":", "_") + ".go"
        filePath := filepath.Join(c.cacheDir, filename)

        if err := os.WriteFile(filePath, content, 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write cached file: %w", err)
        }</span>

        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">cachedFile := &amp;cachedFile{
                Path:         filePath,
                Hash:         key,
                LastAccessed: time.Now(),
                Size:         fileInfo.Size(),
                CreatedAt:    time.Now(),
        }

        c.mutex.Lock()
        c.fileCache[key] = cachedFile
        c.stats.ItemCount++
        c.stats.Size += fileInfo.Size()
        c.mutex.Unlock()

        // Save metadata to persist cache information
        if err := c.saveMetadata(); err != nil </span><span class="cov0" title="0">{
                c.logger.Warnf("Failed to save cache metadata: %v", err)
        }</span>

        <span class="cov0" title="0">c.logger.Infof("Stored file in cache (size: %d bytes)", fileInfo.Size())
        return filePath, nil</span>
}

func (c *fileCache) ensureSpace(requiredSize int64) error <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        // If we have enough space, no need to evict
        if c.stats.Size+requiredSize &lt;= c.config.MaxCacheSize </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Need to evict files
        <span class="cov0" title="0">evictionSize := c.stats.Size + requiredSize - c.config.MaxCacheSize

        // Sort files by last accessed time (oldest first)
        type fileEntry struct {
                hash string
                file *cachedFile
        }

        var files []fileEntry
        for hash, file := range c.fileCache </span><span class="cov0" title="0">{
                files = append(files, fileEntry{hash: hash, file: file})
        }</span>

        // Sort by last accessed time (oldest first)
        <span class="cov0" title="0">for i := 0; i &lt; len(files)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(files); j++ </span><span class="cov0" title="0">{
                        if files[i].file.LastAccessed.After(files[j].file.LastAccessed) </span><span class="cov0" title="0">{
                                files[i], files[j] = files[j], files[i]
                        }</span>
                }
        }

        // Evict files until we have enough space
        <span class="cov0" title="0">evictedSize := int64(0)
        for _, entry := range files </span><span class="cov0" title="0">{
                if evictedSize &gt;= evictionSize </span><span class="cov0" title="0">{
                        break</span>
                }

                // Remove file from disk
                <span class="cov0" title="0">if err := os.Remove(entry.file.Path); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warnf("Failed to remove cached file: %v", err)
                        continue</span>
                }

                // Remove from cache
                <span class="cov0" title="0">delete(c.fileCache, entry.hash)
                evictedSize += entry.file.Size
                c.stats.EvictionCount++
                c.stats.ItemCount--
                c.stats.Size -= entry.file.Size

                c.logger.Debugf("Evicted cached file: %s (size: %d bytes)", entry.hash, entry.file.Size)</span>
        }

        <span class="cov0" title="0">c.logger.Infof("Evicted %d bytes (%d files) from cache", evictedSize, c.stats.EvictionCount)

        // Save updated metadata after eviction
        if err := c.saveMetadata(); err != nil </span><span class="cov0" title="0">{
                c.logger.Warnf("Failed to save cache metadata after eviction: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *fileCache) loadExistingFiles() error <span class="cov0" title="0">{
        // Load metadata file if it exists
        metadataPath := filepath.Join(c.cacheDir, "cache_metadata.json")
        if _, err := os.Stat(metadataPath); err == nil </span><span class="cov0" title="0">{
                if err := c.loadMetadata(metadataPath); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warnf("Failed to load cache metadata: %v", err)
                }</span>
        }

        // Also scan directory for any files not in metadata
        <span class="cov0" title="0">entries, err := os.ReadDir(c.cacheDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() || filepath.Ext(entry.Name()) != ".go" || entry.Name() == "cache_metadata.json" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract hash from filename
                <span class="cov0" title="0">key := strings.TrimSuffix(entry.Name(), ".go")
                filePath := filepath.Join(c.cacheDir, entry.Name())

                // Skip if already loaded from metadata
                if _, exists := c.fileCache[key]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warnf("Failed to stat cached file %s: %v", filePath, err)
                        continue</span>
                }

                <span class="cov0" title="0">cachedFile := &amp;cachedFile{
                        Path:         filePath,
                        Hash:         key,
                        LastAccessed: fileInfo.ModTime(),
                        Size:         fileInfo.Size(),
                        CreatedAt:    fileInfo.ModTime(),
                }

                c.fileCache[key] = cachedFile
                c.stats.ItemCount++
                c.stats.Size += fileInfo.Size()</span>
        }

        <span class="cov0" title="0">c.logger.Infof("Loaded %d existing cached files", len(c.fileCache))
        return nil</span>
}

func (c *fileCache) loadMetadata(metadataPath string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var metadata map[string]*cachedFile
        if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for key, cachedFile := range metadata </span><span class="cov0" title="0">{
                // Verify file still exists
                if _, err := os.Stat(cachedFile.Path); err == nil </span><span class="cov0" title="0">{
                        c.fileCache[key] = cachedFile
                        c.stats.ItemCount++
                        c.stats.Size += cachedFile.Size
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *fileCache) saveMetadata() error <span class="cov0" title="0">{
        metadataPath := filepath.Join(c.cacheDir, "cache_metadata.json")
        data, err := json.MarshalIndent(c.fileCache, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(metadataPath, data, 0644)</span>
}

func (c *fileCache) updateHitRate() <span class="cov0" title="0">{
        total := c.stats.HitCount + c.stats.MissCount
        if total &gt; 0 </span><span class="cov0" title="0">{
                c.stats.HitRate = float64(c.stats.HitCount) / float64(total)
        }</span>
}

func (c *fileCache) getCacheStats() *types.CacheStats <span class="cov0" title="0">{
        c.statsMutex.RLock()
        defer c.statsMutex.RUnlock()

        // Create a copy to avoid race conditions
        stats := *c.stats
        return &amp;stats
}</span>

func (c *fileCache) close() error <span class="cov0" title="0">{
        if c.cleanupTicker != nil </span><span class="cov0" title="0">{
                close(c.stopCleanup)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">package file

import (
        "fmt"
        "io"
        "net/http"
        "os"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type downloader struct {
        client    *httppkg.HTTPClient
        cache     *fileCache
        validator *codeValidator
        logger    logging.Logger
}

type downloadResult struct {
        FilePath   string
        Content    []byte
        Hash       string
        Size       int64
        IsCached   bool
        Validation *types.ValidationResult
}

func newDownloader(cfg config.CacheConfig, validationCfg config.ValidationConfig, httpClient *httppkg.HTTPClient, logger logging.Logger) (*downloader, error) <span class="cov0" title="0">{
        cache, err := newFileCache(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file cache: %w", err)
        }</span>

        <span class="cov0" title="0">validator := newCodeValidator(validationCfg, logger)

        return &amp;downloader{
                client:    httpClient,
                cache:     cache,
                validator: validator,
                logger:    logger,
        }, nil</span>
}

func (d *downloader) downloadFile(key string, url string) (*downloadResult, error) <span class="cov0" title="0">{
        // Get file from cache or download it
        var isCached bool
        filePath, err := d.cache.getOrDownloadFile(key, func() ([]byte, error) </span><span class="cov0" title="0">{
                return d.downloadContent(url)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download or store file in cache: %w", err)
        }</span>
        <span class="cov0" title="0">isCached = true
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read downloaded file: %w", err)
        }</span>
        <span class="cov0" title="0">d.logger.Infof("File downloaded and stored in cache: %s", key)

        // Validate content (either fresh or from cache)
        validation, err := d.validator.validateFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate content: %w", err)
        }</span>

        <span class="cov0" title="0">if !validation.IsValid </span><span class="cov0" title="0">{
                d.logger.Warnf("File validation failed: %v", validation.Errors)
                return &amp;downloadResult{
                        Content:    content,
                        Validation: validation,
                }, nil
        }</span>

        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;downloadResult{
                FilePath:   filePath,
                Content:    content,
                Hash:       key,
                Size:       fileInfo.Size(),
                IsCached:   isCached,
                Validation: validation,
        }, nil</span>
}

func (d *downloader) downloadContent(url string) ([]byte, error) <span class="cov0" title="0">{
        resp, err := d.client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        d.logger.Error("Error closing response body", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">d.logger.Debugf("Downloaded %d bytes", len(content))
        return content, nil</span>
}

func (d *downloader) close() error <span class="cov0" title="0">{
        if d.cache != nil </span><span class="cov0" title="0">{
                return d.cache.close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file240" style="display: none">package file

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
)

type FileManager struct {
        downloader *downloader
        config     config.ExecutorConfig
        logger     logging.Logger
        mutex      sync.RWMutex
        stats      *types.PerformanceMetrics
}

func NewFileManager(cfg config.ExecutorConfig, httpClient *httppkg.HTTPClient, logger logging.Logger) (*FileManager, error) <span class="cov0" title="0">{
        downloader, err := newDownloader(cfg.Cache, cfg.Validation, httpClient, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create downloader: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;FileManager{
                downloader: downloader,
                config:     cfg,
                logger:     logger,
                stats: &amp;types.PerformanceMetrics{
                        TotalExecutions:      0,
                        SuccessfulExecutions: 0,
                        FailedExecutions:     0,
                        AverageExecutionTime: 0,
                        MinExecutionTime:     0,
                        MaxExecutionTime:     0,
                        TotalCost:            0.0,
                        AverageCost:          0.0,
                        LastExecution:        time.Time{},
                },
        }, nil</span>
}

func (fm *FileManager) GetOrDownload(ctx context.Context, fileURL string) (*types.ExecutionContext, error) <span class="cov0" title="0">{
        startTime := time.Now()
        fm.logger.Debugf("Processing file: %s", fileURL)

        // Download and validate file
        result, err := fm.downloader.downloadFile(fileURL, fileURL)
        if err != nil </span><span class="cov0" title="0">{
                fm.updateStats(false, time.Since(startTime), 0.0)
                return nil, fmt.Errorf("failed to download file: %w", err)
        }</span>

        // Check validation results
        <span class="cov0" title="0">if !result.Validation.IsValid </span><span class="cov0" title="0">{
                fm.logger.Warnf("File validation failed: %v", result.Validation.Errors)
                fm.updateStats(false, time.Since(startTime), 0.0)
                return &amp;types.ExecutionContext{
                        FileURL:   fileURL,
                        StartedAt: startTime,
                        Metadata: map[string]string{
                                "validation_errors": fmt.Sprintf("%v", result.Validation.Errors),
                                "is_cached":         fmt.Sprintf("%v", result.IsCached),
                        },
                }, nil
        }</span>

        // Create execution context
        <span class="cov0" title="0">execCtx := &amp;types.ExecutionContext{
                FileURL:   fileURL,
                StartedAt: startTime,
                Metadata: map[string]string{
                        "file_path":  result.FilePath,
                        "file_hash":  result.Hash,
                        "file_size":  fmt.Sprintf("%d", result.Size),
                        "is_cached":  fmt.Sprintf("%v", result.IsCached),
                        "complexity": fmt.Sprintf("%.2f", result.Validation.Complexity),
                        "warnings":   fmt.Sprintf("%v", result.Validation.Warnings),
                },
        }

        // Update statistics
        fm.updateStats(true, time.Since(startTime), result.Validation.Complexity)

        fm.logger.Debugf("File processed successfully (cached: %v, size: %d bytes)", result.IsCached, result.Size)

        return execCtx, nil</span>
}

func (fm *FileManager) GetPerformanceStats() *types.PerformanceMetrics <span class="cov0" title="0">{
        fm.mutex.RLock()
        defer fm.mutex.RUnlock()

        // Create a copy to avoid race conditions
        stats := *fm.stats
        return &amp;stats
}</span>

func (fm *FileManager) GetCacheStats() *types.CacheStats <span class="cov0" title="0">{
        return fm.downloader.cache.getCacheStats()
}</span>

func (fm *FileManager) updateStats(success bool, duration time.Duration, complexity float64) <span class="cov0" title="0">{
        fm.mutex.Lock()
        defer fm.mutex.Unlock()

        fm.stats.TotalExecutions++
        fm.stats.LastExecution = time.Now()

        if success </span><span class="cov0" title="0">{
                fm.stats.SuccessfulExecutions++
        }</span> else<span class="cov0" title="0"> {
                fm.stats.FailedExecutions++
        }</span>

        // Update execution time statistics
        <span class="cov0" title="0">if fm.stats.MinExecutionTime == 0 || duration &lt; fm.stats.MinExecutionTime </span><span class="cov0" title="0">{
                fm.stats.MinExecutionTime = duration
        }</span>
        <span class="cov0" title="0">if duration &gt; fm.stats.MaxExecutionTime </span><span class="cov0" title="0">{
                fm.stats.MaxExecutionTime = duration
        }</span>

        // Calculate average execution time
        <span class="cov0" title="0">if fm.stats.SuccessfulExecutions &gt; 0 </span><span class="cov0" title="0">{
                totalDuration := fm.stats.AverageExecutionTime * time.Duration(fm.stats.SuccessfulExecutions-1)
                totalDuration += duration
                fm.stats.AverageExecutionTime = totalDuration / time.Duration(fm.stats.SuccessfulExecutions)
        }</span> else<span class="cov0" title="0"> {
                fm.stats.AverageExecutionTime = duration
        }</span>

        // Update cost statistics (basic calculation)
        <span class="cov0" title="0">cost := fm.calculateCost(duration, complexity)
        fm.stats.TotalCost += cost
        if fm.stats.SuccessfulExecutions &gt; 0 </span><span class="cov0" title="0">{
                fm.stats.AverageCost = fm.stats.TotalCost / float64(fm.stats.SuccessfulExecutions)
        }</span> else<span class="cov0" title="0"> {
                fm.stats.AverageCost = cost
        }</span>
}

func (fm *FileManager) calculateCost(duration time.Duration, complexity float64) float64 <span class="cov0" title="0">{
        // Basic cost calculation based on execution time and complexity
        timeCost := duration.Seconds() * fm.config.Fees.PricePerTG
        complexityCost := complexity * fm.config.Fees.PricePerTG
        return timeCost + complexityCost + fm.config.Fees.FixedCost
}</span>

func (fm *FileManager) Close() error <span class="cov0" title="0">{
        var errors []error

        if fm.downloader != nil </span><span class="cov0" title="0">{
                if err := fm.downloader.close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close downloader: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors during cleanup: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file241" style="display: none">package file

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/trigg3rX/triggerx-backend/pkg/docker/config"
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

type codeValidator struct {
        config config.ValidationConfig
        logger logging.Logger
}

func newCodeValidator(cfg config.ValidationConfig, logger logging.Logger) *codeValidator <span class="cov0" title="0">{
        return &amp;codeValidator{
                config: cfg,
                logger: logger,
        }
}</span>

// validateFile validates a file by checking its size, extension, and content (meant to be when writing file to cache)
func (v *codeValidator) validateFile(filePath string) (*types.ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;types.ValidationResult{
                IsValid:    true,
                Errors:     make([]string, 0),
                Warnings:   make([]string, 0),
                Complexity: 0.0,
        }

        // Check file size
        if err := v.validateFileSize(filePath, result); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        // Check file extension
        <span class="cov0" title="0">if err := v.validateFileExtension(filePath, result); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        // Read and validate file content
        <span class="cov0" title="0">if err := v.validateFileContent(filePath, result); err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        // Calculate complexity
        <span class="cov0" title="0">result.Complexity = v.calculateComplexity(filePath)

        return result, nil</span>
}

func (v *codeValidator) validateFileContent(filePath string, result *types.ValidationResult) error <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath) // Read the entire file into memory
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file for validation: %w", err)
        }</span>

    // Delegate the actual pattern matching to the function that handles byte slices
        <span class="cov0" title="0">v.validateContentPatterns(content, result)

        return nil</span>
}

func (v *codeValidator) validateFileSize(filePath string, result *types.ValidationResult) error <span class="cov0" title="0">{
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() &gt; v.config.MaxFileSize </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, fmt.Sprintf("file size exceeds limit: %d bytes", fileInfo.Size()))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (v *codeValidator) validateFileExtension(filePath string, result *types.ValidationResult) error <span class="cov0" title="0">{
        ext := filepath.Ext(filePath)

        // Check if extension is allowed
        allowed := false
        for _, allowedExt := range v.config.AllowedExtensions </span><span class="cov0" title="0">{
                if ext == allowedExt </span><span class="cov0" title="0">{
                        allowed = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Errors = append(result.Errors, fmt.Sprintf("file extension not allowed: %s", ext))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (v *codeValidator) validateContentPatterns(content []byte, result *types.ValidationResult) <span class="cov0" title="0">{
        contentStr := string(content)
        lines := strings.Split(contentStr, "\n")

        for lineNumber, line := range lines </span><span class="cov0" title="0">{
                lineNumber++ // Convert to 1-based indexing

                // Check for dangerous patterns
                for _, pattern := range v.config.BlockedPatterns </span><span class="cov0" title="0">{
                        if strings.Contains(line, pattern) </span><span class="cov0" title="0">{
                                result.IsValid = false
                                result.Errors = append(result.Errors,
                                        fmt.Sprintf("dangerous pattern found at line %d: %s", lineNumber, pattern))
                        }</span>
                }

                // Check for suspicious patterns (warnings)
                <span class="cov0" title="0">v.checkSuspiciousPatterns(line, lineNumber, result)</span>
        }
}

func (v *codeValidator) checkSuspiciousPatterns(line string, lineNumber int, result *types.ValidationResult) <span class="cov0" title="0">{
        suspiciousPatterns := []string{
                "http://",
                "ftp://",
                "file://",
                "os.Open",
                "ioutil.ReadFile",
                "os.ReadFile",
                "exec.",
                "syscall.",
                "runtime.",
                "unsafe.",
                "reflect.",
                "cgo.",
        }

        for _, pattern := range suspiciousPatterns </span><span class="cov0" title="0">{
                if strings.Contains(line, pattern) </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings,
                                fmt.Sprintf("suspicious pattern at line %d: %s", lineNumber, pattern))
                }</span>
        }
}

func (v *codeValidator) calculateComplexity(filePath string) float64 <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Warnf("Failed to open file for complexity calculation: %v", err)
                return 0.0
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        v.logger.Errorf("Failed to close file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Warnf("Failed to get file info for complexity calculation: %v", err)
                return 0.0
        }</span>

        // Read file content for complexity calculation
        <span class="cov0" title="0">content := make([]byte, fileInfo.Size())
        _, err = file.Read(content)
        if err != nil </span><span class="cov0" title="0">{
                v.logger.Warnf("Failed to read file for complexity calculation: %v", err)
                return 0.0
        }</span>

        <span class="cov0" title="0">return v.calculateContentComplexity(content)</span>
}

func (v *codeValidator) calculateContentComplexity(content []byte) float64 <span class="cov0" title="0">{
        contentStr := string(content)

        // Basic complexity calculation based on:
        // 1. File size (in KB)
        // 2. Number of lines
        // 3. Number of functions
        // 4. Number of imports
        // 5. Number of loops and conditionals

        sizeKB := float64(len(content)) / 1024.0
        lines := strings.Split(contentStr, "\n")
        numLines := float64(len(lines))

        // Count functions (basic pattern matching)
        functionCount := float64(strings.Count(contentStr, "func "))

        // Count imports
        importCount := float64(strings.Count(contentStr, "import "))

        // Count loops and conditionals
        loopCount := float64(strings.Count(contentStr, "for ") + strings.Count(contentStr, "range "))
        conditionalCount := float64(strings.Count(contentStr, "if ") + strings.Count(contentStr, "switch "))

        // Calculate complexity score
        complexity := sizeKB*0.1 + // Size factor
                numLines*0.01 + // Line count factor
                functionCount*0.5 + // Function factor
                importCount*0.2 + // Import factor
                (loopCount+conditionalCount)*0.3 // Control flow factor

        return complexity
}</span>
</pre>
		
		<pre class="file" id="file242" style="display: none">package scripts

import (
        "github.com/trigg3rX/triggerx-backend/pkg/docker/types"
)


// getInitializationScript returns the script to initialize a container
func GetInitializationScript(language types.Language) string <span class="cov0" title="0">{
        switch language </span>{
        case types.LanguageGo:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
mkdir -p /code
cd /code
echo 'package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}' &gt; code.go
go mod init code
go mod download
echo "Container initialized successfully"
`</span>
        case types.LanguagePy:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
mkdir -p /code
cd /code
echo 'print("Hello, World!")' &gt; code.py
echo "Container initialized successfully"
`</span>
        case types.LanguageJS, types.LanguageNode:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
mkdir -p /code
cd /code
echo 'console.log("Hello, World!");' &gt; code.js
echo "Container initialized successfully"
`</span>
        case types.LanguageTS:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
mkdir -p /code
cd /code
npm install -g typescript
echo 'console.log("Hello, World!");' &gt; code.ts
echo "Container initialized successfully"
`</span>
        default:<span class="cov0" title="0">
                return `#!/bin/sh
set -e
mkdir -p /code
cd /code
echo "Container initialized successfully"
`</span>
        }
}

func GetGoSetupScript() string <span class="cov0" title="0">{
        return `#!/bin/sh
set -e
cd /code

# One-time warm-up of Go build cache (if not already done)
if [ ! -f /code/.warm ]; then
    # Create a minimal Go program to warm up the compiler
    echo 'package main; func main(){}' &gt; warm.go
    
    # Build with optimized flags to populate cache
    GOFLAGS='-buildvcs=false -trimpath' go build -o /tmp/warm warm.go
    
    # Clean up warm-up artifacts
    rm warm.go /tmp/warm
    touch /code/.warm
fi

echo "START_EXECUTION"
# Run with optimized flags
GOFLAGS='-buildvcs=false -trimpath' go run code.go 2&gt;&amp;1 || {
    echo "Error executing Go program. Exit code: $?"
    exit 1
}
echo "END_EXECUTION"
`
}</span>

func GetPythonSetupScript() string <span class="cov0" title="0">{
        return `#!/bin/sh
set -e
cd /code

# One-time warm-up of Python bytecode cache
if [ ! -f /code/.warm ]; then
    # Create a minimal Python program to warm up common imports
    cat &gt; warm.py &lt;&lt; 'EOF'
import json
import os
import sys
import time
import datetime
import requests
import web3
EOF
    
    # Pre-compile to bytecode
    python -m py_compile warm.py
    # Run once to warm up imports
    python -c "import warm"
    rm warm.py warm.pyc
    touch /code/.warm
fi

echo "START_EXECUTION"
# Run with bytecode compilation enabled (default)
python -B code.py 2&gt;&amp;1 || {
    echo "Error executing Python program. Exit code: $?"
    exit 1
}
echo "END_EXECUTION"
`
}</span>

func GetJavaScriptSetupScript() string <span class="cov0" title="0">{
        return `#!/bin/sh
set -e
cd /code

# One-time warm-up of V8 engine and common modules
if [ ! -f /code/.warm ]; then
    # Create a minimal JS program to warm up common modules
    cat &gt; warm.js &lt;&lt; 'EOF'
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const crypto = require('crypto');
const { Web3 } = require('web3');
const { ethers } = require('ethers');
EOF
    
    # Run once to warm up V8 and modules
    NODE_OPTIONS='--no-warnings' node warm.js || true
    rm warm.js
    touch /code/.warm
fi

echo "START_EXECUTION"
# Run with optimized Node options
NODE_OPTIONS='--no-warnings --max-old-space-size=256' node code.js 2&gt;&amp;1 || {
    echo "Error executing JavaScript program. Exit code: $?"
    exit 1
}
echo "END_EXECUTION"
`
}</span>

func GetTypeScriptSetupScript() string <span class="cov0" title="0">{
        return `#!/bin/sh
set -e
cd /code

# One-time warm-up of TypeScript compiler and V8 engine
if [ ! -f /code/.warm ]; then
    # Create a minimal TS program to warm up compiler
    cat &gt; warm.ts &lt;&lt; 'EOF'
import * as fs from 'fs';
import * as path from 'path';
import * as http from 'http';
import * as https from 'https';
import * as crypto from 'crypto';
import { Web3 } from 'web3';
import { ethers } from 'ethers';

interface WarmupTest {
    id: number;
    name: string;
}

const test: WarmupTest = { id: 1, name: "test" };
console.log(test);
EOF
    
    # Create tsconfig for faster compilation
    cat &gt; tsconfig.json &lt;&lt; 'EOF'
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "outDir": "./dist",
        "incremental": true
    }
}
EOF
    
    # Warm up TypeScript compiler and V8
    NODE_OPTIONS='--no-warnings' tsc warm.ts &amp;&amp; node warm.js || true
    rm warm.ts warm.js tsconfig.json
    touch /code/.warm
fi

echo "START_EXECUTION"
# Run with optimized options
NODE_OPTIONS='--no-warnings --max-old-space-size=256' tsc code.ts --incremental &amp;&amp; node code.js 2&gt;&amp;1 || {
    echo "Error executing TypeScript program. Exit code: $?"
    exit 1
}
echo "END_EXECUTION"
`
}</span>

func GetNodeSetupScript() string <span class="cov0" title="0">{
        return `#!/bin/sh
set -e
cd /code

# One-time warm-up of V8 engine and common modules
if [ ! -f /code/.warm ]; then
    # Create a minimal Node program to warm up common modules
    cat &gt; warm.js &lt;&lt; 'EOF'
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const crypto = require('crypto');
const { Web3 } = require('web3');
const { ethers } = require('ethers');
EOF
    
    # Run once to warm up V8 and modules
    NODE_OPTIONS='--no-warnings' node warm.js || true
    rm warm.js
    touch /code/.warm
fi

echo "START_EXECUTION"
# Run with optimized Node options
NODE_OPTIONS='--no-warnings --max-old-space-size=256' node code.js 2&gt;&amp;1 || {
    echo "Error executing Node.js program. Exit code: $?"
    exit 1
}
echo "END_EXECUTION"
`
}</pre>
		
		<pre class="file" id="file243" style="display: none">package types

import (
        "path/filepath"
        "strings"
        "time"

        "github.com/docker/docker/api/types/container"
)

type Language string
const (
        LanguageGo   Language = "go"
        LanguagePy   Language = "py"
        LanguageJS   Language = "js"
        LanguageTS   Language = "ts"
        LanguageNode Language = "node"
)

type ContainerStatus string
const (
        ContainerStatusPending ContainerStatus = "pending"
        ContainerStatusRunning ContainerStatus = "running"
        ContainerStatusStopped ContainerStatus = "stopped"
        ContainerStatusReady   ContainerStatus = "ready"
        ContainerStatusError   ContainerStatus = "error"
)

type PooledContainer struct {
        ID         string          `json:"id"`
        Status     ContainerStatus `json:"status"`
        LastUsed   time.Time       `json:"last_used"`
        IsReady    bool            `json:"is_ready"`
        WorkingDir string          `json:"working_dir"`
        ImageName  string          `json:"image_name"`
        Language   Language        `json:"language"`
        CreatedAt  time.Time       `json:"created_at"`
        Error      error           `json:"error,omitempty"`
}

// GetLanguageFromFile returns the language based on file extension
func GetLanguageFromFile(filePath string) Language <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filePath))
        switch ext </span>{
        case ".go":<span class="cov8" title="1">
                return LanguageGo</span>
        case ".py":<span class="cov8" title="1">
                return LanguagePy</span>
        case ".js":<span class="cov8" title="1">
                return LanguageJS</span>
        case ".ts":<span class="cov8" title="1">
                return LanguageTS</span>
        case ".mjs", ".cjs":<span class="cov8" title="1">
                return LanguageNode</span>
        default:<span class="cov8" title="1">
                return LanguageGo</span> // Default to Go
        }
}

// GetLanguageFromExtension returns the language based on file extension string
func GetLanguageFromExtension(extension string) Language <span class="cov8" title="1">{
        ext := strings.ToLower(extension)
        if !strings.HasPrefix(ext, ".") </span><span class="cov8" title="1">{
                ext = "." + ext
        }</span>
        <span class="cov8" title="1">return GetLanguageFromFile("dummy" + ext)</span>
}

type ContainerConfig struct {
        Image          string              `json:"image"`
        WorkingDir     string              `json:"working_dir"`
        Environment    []string            `json:"environment"`
        Binds          []string            `json:"binds"`
        Resources      container.Resources `json:"resources"`
        Privileged     bool                `json:"privileged"`
        NetworkMode    string              `json:"network_mode"`
        SecurityOpt    []string            `json:"security_opt"`
        ReadOnlyRootFS bool                `json:"read_only_root_fs"`
}

type ContainerInfo struct {
        ID      string               `json:"id"`
        Config  *ContainerConfig     `json:"config"`
        Stats   *DockerResourceStats `json:"stats,omitempty"`
        Created time.Time            `json:"created"`
}
</pre>
		
		<pre class="file" id="file244" style="display: none">package env

import (
        "os"
        "strconv"
        "time"
)

// Helper functions
func GetEnvString(key, defaultValue string) string <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func GetEnvBool(key string, defaultValue bool) bool <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                boolValue, err := strconv.ParseBool(value)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultValue
                }</span>
                <span class="cov8" title="1">return boolValue</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func GetEnvInt(key string, defaultValue int) int <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                intValue, err := strconv.Atoi(value)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultValue
                }</span>
                <span class="cov8" title="1">return intValue</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

func GetEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(value)
                if err != nil </span><span class="cov8" title="1">{
                        return defaultValue
                }</span>
                <span class="cov8" title="1">return duration</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file245" style="display: none">package env

import (
        "regexp"
        "strings"
        
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/crypto"
)

func IsEmpty(value string) bool <span class="cov8" title="1">{
        return value == ""
}</span>

// Email Address
func IsValidEmail(email string) bool <span class="cov8" title="1">{
        // Improved regex: allows TLDs with more than 2 chars and supports subdomains and hyphens
        emailPattern := `^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`
        matched, _ := regexp.MatchString(emailPattern, email)
        return matched
}</span>

// Ethereum Address
func IsValidEthAddress(address string) bool <span class="cov8" title="1">{
        matched, _ := regexp.MatchString("^0x[0-9a-fA-F]{40}$", address)
        return matched
}</span>

// ECDSA Private Key
func IsValidPrivateKey(privateKey string) bool <span class="cov8" title="1">{
        matched, _ := regexp.MatchString("^[0-9a-fA-F]{64}$", privateKey)
        return matched
}</span>

func IsValidEthKeyPair(privateKey string, publicAddress string) bool <span class="cov8" title="1">{
        if !IsValidEthAddress(publicAddress) || !IsValidPrivateKey(privateKey) </span><span class="cov8" title="1">{
                return false
        }</span> else<span class="cov8" title="1"> if crypto.PubkeyToAddress(crypto.ToECDSAUnsafe(common.FromHex(privateKey)).PublicKey).Hex() != publicAddress </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func IsValidIPAddress(ipAddress string) bool <span class="cov8" title="1">{
        if ipAddress == "localhost" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">ipPattern := `^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$`
        matched, _ := regexp.MatchString(ipPattern, ipAddress)
        return matched</span>
}

// Port number
func IsValidPort(port string) bool <span class="cov8" title="1">{
        matched, _ := regexp.MatchString("^(102[4-9]|10[3-9][0-9]|1[1-9][0-9]{2}|[2-9][0-9]{3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$", port)
        return matched
}</span>

// URL
func IsValidURL(url string) bool <span class="cov8" title="1">{
        if url == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(url, "http://") &amp;&amp; !strings.HasPrefix(url, "https://") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">urlWithoutProtocol := strings.TrimPrefix(strings.TrimPrefix(url, "http://"), "https://")
        parts := strings.Split(urlWithoutProtocol, ":")

        if len(parts) == 1 </span><span class="cov8" title="1">{
                if IsValidIPAddress(parts[0]) </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">domainPattern := `^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$`
                matched, _ := regexp.MatchString(domainPattern, parts[0])
                return matched</span>
        }

        <span class="cov8" title="1">if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !IsValidIPAddress(parts[0]) </span><span class="cov8" title="1">{
                domainPattern := `^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$`
                matched, _ := regexp.MatchString(domainPattern, parts[0])
                if !matched </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">if !IsValidPort(parts[1]) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Othentic Peer ID
func IsValidPeerID(peerID string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(peerID, "12D3") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return len(peerID) == len("12D3KooWBNFG1QjuF3UKAKvqhdXcxh9iBmj88cM5eU2EK5Pa91KB")</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">package http

import (
        "bytes"
        "fmt"
        "io"
        "net"
        "net/http"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// HTTPRetryConfig holds configuration for HTTP retry operations
type HTTPRetryConfig struct {
        RetryConfig     *retry.RetryConfig
        Timeout         time.Duration
        IdleConnTimeout time.Duration
        MaxResponseSize int64 // Maximum response size to read for error messages
}

// DefaultHTTPRetryConfig returns default configuration for HTTP retry operations
func DefaultHTTPRetryConfig() *HTTPRetryConfig <span class="cov8" title="1">{
        return &amp;HTTPRetryConfig{
                RetryConfig:     retry.DefaultRetryConfig(),
                Timeout:         10 * time.Second,
                IdleConnTimeout: 30 * time.Second,
                MaxResponseSize: 4096, // 4KB default max for error messages
        }
}</span>

// Validate checks the HTTP configuration for reasonable values
func (c *HTTPRetryConfig) Validate() error <span class="cov8" title="1">{
        if c.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("timeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.IdleConnTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("idleConnTimeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.MaxResponseSize &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("maxResponseSize must be &gt;= 0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// HTTPError represents an HTTP-specific error with status code
type HTTPError struct {
        StatusCode int
        Message    string
}

func (e *HTTPError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}</span>

// HTTPClient is a wrapper around http.Client that includes retry logic
type HTTPClient struct {
        client     *http.Client
        HTTPConfig *HTTPRetryConfig
        logger     logging.Logger
}

// NewHTTPClient creates a new HTTP client with retry capabilities
func NewHTTPClient(httpConfig *HTTPRetryConfig, logger logging.Logger) (*HTTPClient, error) <span class="cov8" title="1">{
        if httpConfig == nil </span><span class="cov8" title="1">{
                httpConfig = DefaultHTTPRetryConfig()
        }</span>

        <span class="cov8" title="1">if err := httpConfig.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid HTTP retry config: %w", err)
        }</span>

        <span class="cov8" title="1">client := &amp;http.Client{
                Timeout: httpConfig.Timeout,
                Transport: &amp;http.Transport{
                        IdleConnTimeout:   httpConfig.IdleConnTimeout,
                        DisableKeepAlives: false,
                        DialContext: (&amp;net.Dialer{
                                Timeout:   httpConfig.Timeout / 2,
                                KeepAlive: httpConfig.IdleConnTimeout,
                        }).DialContext,
                        TLSHandshakeTimeout:   httpConfig.Timeout / 2,
                        ResponseHeaderTimeout: httpConfig.Timeout / 2,
                        ExpectContinueTimeout: httpConfig.Timeout / 3,
                },
        }

        return &amp;HTTPClient{
                client:     client,
                HTTPConfig: httpConfig,
                logger:     logger,
        }, nil</span>
}

// DoWithRetry performs an HTTP request with retry logic using the retry package.
// The caller is responsible for closing the response body.
func (c *HTTPClient) DoWithRetry(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        // Prepare request body for retries
        var getBody func() (io.ReadCloser, error)
        if req.GetBody != nil </span><span class="cov8" title="1">{
                getBody = req.GetBody
        }</span> else<span class="cov8" title="1"> if req.Body != nil </span><span class="cov8" title="1">{
                // Fallback for requests without GetBody
                bodyBytes, err := io.ReadAll(req.Body)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error reading request body: %w", err)
                }</span>
                <span class="cov8" title="1">if err := req.Body.Close(); err != nil </span><span class="cov8" title="1">{
                        c.logger.Warnf("Failed to close request body: %v", err)
                }</span>
                <span class="cov8" title="1">req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                getBody = func() (io.ReadCloser, error) </span><span class="cov8" title="1">{
                        return io.NopCloser(bytes.NewBuffer(bodyBytes)), nil
                }</span>
        }

        // Create operation function for retry package
        <span class="cov8" title="1">operation := func() (*http.Response, error) </span><span class="cov8" title="1">{
                // Clone the request for each attempt
                reqClone := req.Clone(req.Context())
                if getBody != nil </span><span class="cov8" title="1">{
                        body, err := getBody()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get request body: %w", err)
                        }</span>
                        <span class="cov8" title="1">reqClone.Body = body</span>
                }

                <span class="cov8" title="1">resp, err := c.client.Do(reqClone)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("http request failed: %w", err)
                }</span>

                // Check if response status code indicates retryable error
                <span class="cov8" title="1">if c.shouldRetryResponse(resp.StatusCode) </span><span class="cov8" title="1">{
                        // Read and close body for retryable responses
                        bodyBytes, _ := io.ReadAll(io.LimitReader(resp.Body, c.HTTPConfig.MaxResponseSize))
                        _ = resp.Body.Close()

                        bodyPreview := fmt.Sprintf(", body preview: %q", truncate(string(bodyBytes), 200))
                        return nil, &amp;HTTPError{
                                StatusCode: resp.StatusCode,
                                Message:    fmt.Sprintf("retryable status code%s", bodyPreview),
                        }
                }</span>

                <span class="cov8" title="1">return resp, nil</span>
        }

        // Use retry package to execute the operation
        <span class="cov8" title="1">return retry.Retry(req.Context(), operation, c.HTTPConfig.RetryConfig, c.logger)</span>
}

// Get performs a GET request with retry logic
func (c *HTTPClient) Get(url string) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GET request: %w", err)
        }</span>
        <span class="cov8" title="1">return c.DoWithRetry(req)</span>
}

// Post performs a POST request with retry logic
func (c *HTTPClient) Post(url, contentType string, body io.Reader) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("POST", url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create POST request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", contentType)
        return c.DoWithRetry(req)</span>
}

// Put performs a PUT request with retry logic
func (c *HTTPClient) Put(url, contentType string, body io.Reader) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("PUT", url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create PUT request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", contentType)
        return c.DoWithRetry(req)</span>
}

// Delete performs a DELETE request with retry logic
func (c *HTTPClient) Delete(url string) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create DELETE request: %w", err)
        }</span>
        <span class="cov8" title="1">return c.DoWithRetry(req)</span>
}

// truncate shortens a string to maxLen, adding "..." if truncated
func truncate(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

// shouldRetryResponse checks if the status code should be retried based on default logic and custom retry function
func (c *HTTPClient) shouldRetryResponse(statusCode int) bool <span class="cov8" title="1">{
        // Create a mock error to test with custom retry function
        mockErr := &amp;HTTPError{
                StatusCode: statusCode,
                Message:    "mock error for retry check",
        }

        // If custom retry function is set, use it
        if c.HTTPConfig.RetryConfig.ShouldRetry != nil </span><span class="cov8" title="1">{
                return c.HTTPConfig.RetryConfig.ShouldRetry(mockErr)
        }</span>

        // Default logic: retry on server errors (5xx) and some specific client errors
        <span class="cov8" title="1">return statusCode &gt;= 500 || statusCode == 429</span> // 429 is rate limit
}

// Close closes idle connections
func (c *HTTPClient) Close() <span class="cov8" title="1">{
        c.client.CloseIdleConnections()
}</span>

// GetTimeout returns the configured timeout
func (c *HTTPClient) GetTimeout() time.Duration <span class="cov8" title="1">{
        return c.HTTPConfig.Timeout
}</span>

// GetIdleConnTimeout returns the configured idle connection timeout
func (c *HTTPClient) GetIdleConnTimeout() time.Duration <span class="cov8" title="1">{
        return c.HTTPConfig.IdleConnTimeout
}</span>

// GetClient returns the underlying http.Client for use with other libraries
func (c *HTTPClient) GetClient() *http.Client <span class="cov0" title="0">{
        return c.client
}</span>
</pre>
		
		<pre class="file" id="file247" style="display: none">package http

import (
        "bytes"
        "io"
        "net/http"
        "time"

        "github.com/stretchr/testify/mock"
)

// MockHTTPClient is a mock implementation of the HTTPClient interface
type MockHTTPClient struct {
        mock.Mock
}

// DoWithRetry mocks the DoWithRetry method
func (m *MockHTTPClient) DoWithRetry(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        args := m.Called(req)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Get mocks the Get method
func (m *MockHTTPClient) Get(url string) (*http.Response, error) <span class="cov8" title="1">{
        args := m.Called(url)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Post mocks the Post method
func (m *MockHTTPClient) Post(url, contentType string, body io.Reader) (*http.Response, error) <span class="cov8" title="1">{
        args := m.Called(url, contentType, body)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Put mocks the Put method
func (m *MockHTTPClient) Put(url, contentType string, body io.Reader) (*http.Response, error) <span class="cov8" title="1">{
        args := m.Called(url, contentType, body)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Delete mocks the Delete method
func (m *MockHTTPClient) Delete(url string) (*http.Response, error) <span class="cov8" title="1">{
        args := m.Called(url)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Close mocks the Close method
func (m *MockHTTPClient) Close() <span class="cov8" title="1">{
        m.Called()
}</span>

// GetTimeout mocks the GetTimeout method
func (m *MockHTTPClient) GetTimeout() time.Duration <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).(time.Duration)
}</span>

// GetIdleConnTimeout mocks the GetIdleConnTimeout method
func (m *MockHTTPClient) GetIdleConnTimeout() time.Duration <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).(time.Duration)
}</span>

// GetClient mocks the GetClient method
func (m *MockHTTPClient) GetClient() *http.Client <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Client)</span>
}

// Test helper functions for creating mock responses
type MockResponseBuilder struct {
        statusCode int
        body       string
        headers    map[string]string
}

// NewMockResponseBuilder creates a new mock response builder
func NewMockResponseBuilder() *MockResponseBuilder <span class="cov8" title="1">{
        return &amp;MockResponseBuilder{
                statusCode: http.StatusOK,
                headers:    make(map[string]string),
        }
}</span>

// WithStatusCode sets the status code for the mock response
func (b *MockResponseBuilder) WithStatusCode(statusCode int) *MockResponseBuilder <span class="cov8" title="1">{
        b.statusCode = statusCode
        return b
}</span>

// WithBody sets the response body for the mock response
func (b *MockResponseBuilder) WithBody(body string) *MockResponseBuilder <span class="cov8" title="1">{
        b.body = body
        return b
}</span>

// WithHeader adds a header to the mock response
func (b *MockResponseBuilder) WithHeader(key, value string) *MockResponseBuilder <span class="cov8" title="1">{
        b.headers[key] = value
        return b
}</span>

// Build creates the final mock response
func (b *MockResponseBuilder) Build() *http.Response <span class="cov8" title="1">{
        body := b.body
        if body == "" </span><span class="cov8" title="1">{
                body = "{}"
        }</span>

        <span class="cov8" title="1">headers := make(http.Header)
        for key, value := range b.headers </span><span class="cov8" title="1">{
                headers.Add(key, value)
        }</span>

        <span class="cov8" title="1">return &amp;http.Response{
                StatusCode: b.statusCode,
                Body:       io.NopCloser(bytes.NewBufferString(body)),
                Header:     headers,
        }</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">package ipfs

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "time"

        httppkg "github.com/trigg3rX/triggerx-backend/pkg/http"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// Client interface defines the methods for IPFS operations
type IPFSClient interface {
        // Upload uploads data to IPFS and returns the CID
        Upload(filename string, data []byte) (string, error)

        // Fetch retrieves content from IPFS by CID
        Fetch(cid string) (types.IPFSData, error)

        // Delete deletes a file from IPFS by CID
        Delete(cid string) error

        // ListFiles lists all files from Pinata v3 API
        ListFiles() ([]PinataFile, error)

        // Close closes the client and cleans up resources
        Close() error
}

// Pinata v3 API structures
type PinataFile struct {
        ID        string            `json:"id"`
        Name      string            `json:"name"`
        CID       string            `json:"cid"`
        Size      int64             `json:"size"`
        MimeType  string            `json:"mime_type"`
        GroupID   string            `json:"group_id,omitempty"`
        Keyvalues map[string]string `json:"keyvalues,omitempty"`
        CreatedAt time.Time         `json:"created_at"`
}

type PinataListResponse struct {
        Data struct {
                Files         []PinataFile `json:"files"`
                NextPageToken string       `json:"next_page_token,omitempty"`
        } `json:"data"`
}

type PinataDeleteResponse struct {
        Data interface{} `json:"data"`
}

// client implements the Client interface
type ipfsClient struct {
        config     *Config
        logger     logging.Logger
        httpClient httppkg.HTTPClientInterface
}

// NewClient creates a new IPFS client with the given configuration
func NewClient(config *Config, logger logging.Logger) (IPFSClient, error) <span class="cov8" title="1">{
        if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpClient, err := httppkg.NewHTTPClient(httppkg.DefaultHTTPRetryConfig(), logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ipfsClient{
                config:     config,
                logger:     logger,
                httpClient: httpClient,
        }, nil</span>
}

// Upload uploads data to IPFS using Pinata and returns the CID
func (c *ipfsClient) Upload(filename string, data []byte) (string, error) <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("filename cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("data cannot be empty")
        }</span>

        <span class="cov8" title="1">body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)

        // Add the "network" field and set it to "public" to ensure content is publicly accessible
        if err := writer.WriteField("network", "public"); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write network field: %v", err)
        }</span>

        // Add the file
        <span class="cov8" title="1">part, err := writer.CreateFormFile("file", filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create form file: %v", err)
        }</span>

        <span class="cov8" title="1">if _, err := part.Write(data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write data to form: %v", err)
        }</span>

        <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close writer: %v", err)
        }</span>

        // Create request
        <span class="cov8" title="1">req, err := http.NewRequest("POST", c.config.PinataBaseURL, body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.config.PinataJWT)
        req.Header.Set("Content-Type", writer.FormDataContentType())

        // Send request
        resp, err := c.httpClient.DoWithRetry(req)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to send request: %v", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Failed to close response body", "error", err)
                }</span>
        }()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return "", fmt.Errorf("http error: status code %d", resp.StatusCode)
        }</span>

        // Read response
        <span class="cov8" title="1">respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %v", err)
        }</span>

        // Parse response
        <span class="cov8" title="1">var ipfsResponse struct {
                Data struct {
                        CID string `json:"cid"`
                } `json:"data"`
        }

        if err := json.Unmarshal(respBody, &amp;ipfsResponse); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to unmarshal IPFS response: %v", err)
        }</span>

        <span class="cov8" title="1">cid := ipfsResponse.Data.CID
        if cid == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("received empty CID from IPFS")
        }</span>

        <span class="cov8" title="1">c.logger.Info("Successfully uploaded to IPFS", "filename", filename, "cid", cid)
        return cid, nil</span>
}

// Fetch retrieves content from IPFS by CID
func (c *ipfsClient) Fetch(cid string) (types.IPFSData, error) <span class="cov8" title="1">{
        if cid == "" </span><span class="cov8" title="1">{
                return types.IPFSData{}, fmt.Errorf("CID cannot be empty")
        }</span>

        <span class="cov8" title="1">ipfsURL := "https://" + c.config.PinataHost + "/ipfs/" + cid

        resp, err := c.httpClient.Get(ipfsURL)
        if err != nil </span><span class="cov8" title="1">{
                return types.IPFSData{}, fmt.Errorf("failed to fetch IPFS content: %v", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("Failed to close response body", "error", err)
                }</span>
        }()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return types.IPFSData{}, fmt.Errorf("http error: status code %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return types.IPFSData{}, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov8" title="1">var ipfsData types.IPFSData
        if err := json.Unmarshal(body, &amp;ipfsData); err != nil </span><span class="cov8" title="1">{
                return types.IPFSData{}, fmt.Errorf("failed to unmarshal IPFS data: %v", err)
        }</span>

        <span class="cov8" title="1">return ipfsData, nil</span>
}

// Delete file by ID using Pinata v3 API
func (c *ipfsClient) Delete(cid string) error <span class="cov8" title="1">{
        if cid == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("CID cannot be empty")
        }</span>

        // Find file ID by CID
        <span class="cov8" title="1">network := c.config.PinataHost // Use configurable network from config
        url := fmt.Sprintf("https://api.pinata.cloud/v3/files/%s?cid=%s&amp;limit=1", network, cid)

        resp, err := c.httpClient.Get(url)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to search for CID %s: %w", cid, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov8" title="1">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                c.logger.Debugf("failed to close response body: %v", err)
                        }</span>
                }
        }()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to search for CID %s: status %d, body: %s",
                        cid, resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var listResp PinataListResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;listResp); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to decode search response for CID %s: %w", cid, err)
        }</span>

        <span class="cov8" title="1">if len(listResp.Data.Files) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no file found with CID %s", cid)
        }</span>

        <span class="cov8" title="1">url = fmt.Sprintf("https://api.pinata.cloud/v3/files/%s/%s", network, listResp.Data.Files[0].ID)

        resp, err = c.httpClient.Delete(url)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete file %s: %w", listResp.Data.Files[0].ID, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if resp != nil &amp;&amp; resp.Body != nil </span><span class="cov8" title="1">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                c.logger.Debugf("failed to close response body: %v", err)
                        }</span>
                }
        }()

        <span class="cov8" title="1">body, _ := io.ReadAll(resp.Body)

        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusAccepted </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to delete file %s: status %d, body: %s",
                        listResp.Data.Files[0].ID, resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var deleteResp PinataDeleteResponse
        if err := json.Unmarshal(body, &amp;deleteResp); err != nil </span><span class="cov0" title="0">{
                // If we can't parse the response but got a success status, that's still OK
                c.logger.Debugf("Could not parse delete response for file %s, but status was %d", listResp.Data.Files[0].ID, resp.StatusCode)
        }</span>

        <span class="cov8" title="1">c.logger.Infof("Successfully deleted file %s from Pinata", listResp.Data.Files[0].ID)
        return nil</span>
}

// List all files from Pinata v3 API
func (c *ipfsClient) ListFiles() ([]PinataFile, error) <span class="cov8" title="1">{
        network := c.config.PinataHost // Use configurable network from config
        url := fmt.Sprintf("https://api.pinata.cloud/v3/files/%s?limit=1000", network)

        var allFiles []PinataFile
        nextPageToken := ""

        for </span><span class="cov8" title="1">{
                requestURL := url
                if nextPageToken != "" </span><span class="cov8" title="1">{
                        requestURL = fmt.Sprintf("%s&amp;pageToken=%s", url, nextPageToken)
                }</span>

                <span class="cov8" title="1">resp, err := c.httpClient.Get(requestURL)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to list files: %w", err)
                }</span>

                <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                        body, _ := io.ReadAll(resp.Body)
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                c.logger.Debugf("failed to close response body: %v", err)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to list files: status %d, body: %s",
                                resp.StatusCode, string(body))</span>
                }

                <span class="cov8" title="1">var listResp PinataListResponse
                if err := json.NewDecoder(resp.Body).Decode(&amp;listResp); err != nil </span><span class="cov8" title="1">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                c.logger.Debugf("failed to close response body: %v", err)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to decode list response: %w", err)</span>
                }
                <span class="cov8" title="1">if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Debugf("failed to close response body: %v", err)
                }</span>

                <span class="cov8" title="1">allFiles = append(allFiles, listResp.Data.Files...)

                // Check if there are more pages
                if listResp.Data.NextPageToken == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">nextPageToken = listResp.Data.NextPageToken</span>
        }

        <span class="cov8" title="1">return allFiles, nil</span>
}

// Close closes the client and cleans up resources
func (c *ipfsClient) Close() error <span class="cov8" title="1">{
        // Close the HTTP client if needed
        c.httpClient.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file249" style="display: none">package ipfs

import (
        "fmt"
        "strings"
)

type Config struct {
        PinataHost    string
        PinataJWT     string
        PinataBaseURL string
}

func NewConfig(pinataHost string, pinataJWT string) *Config <span class="cov8" title="1">{
        return &amp;Config{
                PinataHost:    pinataHost,
                PinataJWT:     pinataJWT,
                PinataBaseURL: "https://uploads.pinata.cloud/v3/files",
        }
}</span>

func (c *Config) Validate() error <span class="cov8" title="1">{
        if strings.TrimSpace(c.PinataHost) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("PinataHost is required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(c.PinataJWT) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("PinataJWT is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file250" style="display: none">package logging

import (
        "os"
        "path/filepath"
)

var (
        BaseDataDir = getBaseDataDir()
        LogsDir     = "logs"
)

type ProcessName string

const (
        AggregatorProcess         ProcessName = "aggregator"
        DatabaseProcess           ProcessName = "dbserver"
        KeeperProcess             ProcessName = "keeper"
        RegistrarProcess          ProcessName = "registrar"
        HealthProcess             ProcessName = "health"
        TaskDispatcherProcess     ProcessName = "taskdispatcher"
        TaskMonitorProcess        ProcessName = "taskmonitor"
        TimeSchedulerProcess      ProcessName = "schedulers-time"
        ConditionSchedulerProcess ProcessName = "schedulers-condition"
        TestProcess               ProcessName = "test"
)

type LoggerConfig struct {
        ProcessName   ProcessName
        IsDevelopment bool
}

const (
        colorReset   = "\x1b[0m"
        colorRed     = "\x1b[31m"
        colorGreen   = "\x1b[32m"
        colorYellow  = "\x1b[33m"
        colorBlue    = "\x1b[34m"
        colorMagenta = "\x1b[35m"
        colorWhite   = "\x1b[37m"
)

func getBaseDataDir() string <span class="cov8" title="1">{
        if dataDir := os.Getenv("TRIGGERX_DATA_DIR"); dataDir != "" </span><span class="cov8" title="1">{
                return dataDir
        }</span>

        <span class="cov8" title="1">currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "data"
        }</span>
        
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if _, err := os.Stat(filepath.Join(currentDir, "go.mod")); err == nil </span><span class="cov8" title="1">{
                        return filepath.Join(currentDir, "data")
                }</span>
                
                <span class="cov8" title="1">parent := filepath.Dir(currentDir)
                if parent == currentDir </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">currentDir = parent</span>
        }
        <span class="cov8" title="1">return "data"</span>
}
</pre>
		
		<pre class="file" id="file251" style="display: none">package logging

import (
        "github.com/stretchr/testify/mock"
)

// MockLogger is a mock implementation of the Logger interface
type MockLogger struct {
        mock.Mock
}

// Debug mocks the Debug method
func (m *MockLogger) Debug(msg string, keysAndValues ...interface{}) <span class="cov8" title="1">{
        m.Called(msg, keysAndValues)
}</span>

// Info mocks the Info method
func (m *MockLogger) Info(msg string, keysAndValues ...interface{}) <span class="cov8" title="1">{
        m.Called(msg, keysAndValues)
}</span>

// Warn mocks the Warn method
func (m *MockLogger) Warn(msg string, keysAndValues ...interface{}) <span class="cov8" title="1">{
        m.Called(msg, keysAndValues)
}</span>

// Error mocks the Error method
func (m *MockLogger) Error(msg string, keysAndValues ...interface{}) <span class="cov8" title="1">{
        m.Called(msg, keysAndValues)
}</span>

// Fatal mocks the Fatal method
func (m *MockLogger) Fatal(msg string, keysAndValues ...interface{}) <span class="cov8" title="1">{
        m.Called(msg, keysAndValues)
}</span>

// Debugf mocks the Debugf method
func (m *MockLogger) Debugf(template string, args ...interface{}) <span class="cov8" title="1">{
        m.Called(template, args)
}</span>

// Infof mocks the Infof method
func (m *MockLogger) Infof(template string, args ...interface{}) <span class="cov8" title="1">{
        m.Called(template, args)
}</span>

// Warnf mocks the Warnf method
func (m *MockLogger) Warnf(template string, args ...interface{}) <span class="cov8" title="1">{
        m.Called(template, args)
}</span>

// Errorf mocks the Errorf method
func (m *MockLogger) Errorf(template string, args ...interface{}) <span class="cov8" title="1">{
        m.Called(template, args)
}</span>

// Fatalf mocks the Fatalf method
func (m *MockLogger) Fatalf(template string, args ...interface{}) <span class="cov8" title="1">{
        m.Called(template, args)
}</span>

// With mocks the With method
func (m *MockLogger) With(tags ...any) Logger <span class="cov8" title="1">{
        args := m.Called(tags)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov8" title="1">return args.Get(0).(Logger)</span>
}

// MockLoggerFactory is a factory for creating mock loggers
// This can be used to inject mock loggers into components under test
type MockLoggerFactory struct {
        mock.Mock
}

// NewMockLogger creates a new mock logger instance
func (f *MockLoggerFactory) NewMockLogger() *MockLogger <span class="cov8" title="1">{
        return &amp;MockLogger{}
}</span>

// CreateLogger mocks the logger creation process
func (f *MockLoggerFactory) CreateLogger(config LoggerConfig) (Logger, error) <span class="cov8" title="1">{
        args := f.Called(config)
        return args.Get(0).(Logger), args.Error(1)
}</span>

// MockSequentialRotator is a mock implementation of the SequentialRotator
// This can be used to test components that depend on log rotation
type MockSequentialRotator struct {
        mock.Mock
}

// Write mocks the Write method
func (m *MockSequentialRotator) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        args := m.Called(p)
        return args.Int(0), args.Error(1)
}</span>

// Close mocks the Close method
func (m *MockSequentialRotator) Close() error <span class="cov8" title="1">{
        args := m.Called()
        return args.Error(0)
}</span>

// MockLoggerConfig is a mock configuration for testing
type MockLoggerConfig struct {
        ProcessName   ProcessName
        IsDevelopment bool
}

// NewMockLoggerConfig creates a new mock logger config
func NewMockLoggerConfig() MockLoggerConfig <span class="cov8" title="1">{
        return MockLoggerConfig{
                ProcessName:   TestProcess,
                IsDevelopment: true,
        }
}</span>

// Test utilities for common mock setups

// NewNoOpLogger creates a logger that does nothing (useful for tests that don't care about logging)
func NewNoOpLogger() Logger <span class="cov8" title="1">{
        return &amp;NoOpLogger{}
}</span>

// NoOpLogger is a logger implementation that does nothing
// Useful for tests where logging is not important
type NoOpLogger struct{}

func (n *NoOpLogger) Debug(msg string, keysAndValues ...interface{}) {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Info(msg string, keysAndValues ...interface{})  {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Warn(msg string, keysAndValues ...interface{})  {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Error(msg string, keysAndValues ...interface{}) {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Fatal(msg string, keysAndValues ...interface{}) {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Debugf(template string, args ...interface{})    {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Infof(template string, args ...interface{})     {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Warnf(template string, args ...interface{})     {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Errorf(template string, args ...interface{})    {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) Fatalf(template string, args ...interface{})    {<span class="cov8" title="1">}</span>
func (n *NoOpLogger) With(tags ...interface{}) Logger                <span class="cov8" title="1">{ return n }</span>

// NewTestLogger creates a logger suitable for testing
// It uses a mock rotator to avoid file system dependencies
func NewTestLogger() (Logger, error) <span class="cov8" title="1">{
        config := LoggerConfig{
                ProcessName:   TestProcess,
                IsDevelopment: true,
        }
        return NewZapLogger(config)
}</span>

// NewTestLoggerWithConfig creates a test logger with custom configuration
func NewTestLoggerWithConfig(config LoggerConfig) (Logger, error) <span class="cov8" title="1">{
        return NewZapLogger(config)
}</span>

// MockLoggerBuilder provides a fluent interface for building mock loggers
type MockLoggerBuilder struct {
        logger *MockLogger
}

// NewMockLoggerBuilder creates a new mock logger builder
func NewMockLoggerBuilder() *MockLoggerBuilder <span class="cov8" title="1">{
        return &amp;MockLoggerBuilder{
                logger: &amp;MockLogger{},
        }
}</span>

// ExpectDebug sets up an expectation for a Debug call
func (b *MockLoggerBuilder) ExpectDebug(msg string, keysAndValues ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Debug", msg, keysAndValues).Return(nil)
        return b
}</span>

// ExpectInfo sets up an expectation for an Info call
func (b *MockLoggerBuilder) ExpectInfo(msg string, keysAndValues ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Info", msg, keysAndValues).Return(nil)
        return b
}</span>

// ExpectWarn sets up an expectation for a Warn call
func (b *MockLoggerBuilder) ExpectWarn(msg string, keysAndValues ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Warn", msg, keysAndValues).Return(nil)
        return b
}</span>

// ExpectError sets up an expectation for an Error call
func (b *MockLoggerBuilder) ExpectError(msg string, keysAndValues ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Error", msg, keysAndValues).Return(nil)
        return b
}</span>

// ExpectFatal sets up an expectation for a Fatal call
func (b *MockLoggerBuilder) ExpectFatal(msg string, keysAndValues ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Fatal", msg, keysAndValues).Return(nil)
        return b
}</span>

// ExpectDebugf sets up an expectation for a Debugf call
func (b *MockLoggerBuilder) ExpectDebugf(template string, args ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Debugf", template, args).Return(nil)
        return b
}</span>

// ExpectInfof sets up an expectation for an Infof call
func (b *MockLoggerBuilder) ExpectInfof(template string, args ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Infof", template, args).Return(nil)
        return b
}</span>

// ExpectWarnf sets up an expectation for a Warnf call
func (b *MockLoggerBuilder) ExpectWarnf(template string, args ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Warnf", template, args).Return(nil)
        return b
}</span>

// ExpectErrorf sets up an expectation for an Errorf call
func (b *MockLoggerBuilder) ExpectErrorf(template string, args ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Errorf", template, args).Return(nil)
        return b
}</span>

// ExpectFatalf sets up an expectation for a Fatalf call
func (b *MockLoggerBuilder) ExpectFatalf(template string, args ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("Fatalf", template, args).Return(nil)
        return b
}</span>

// ExpectWith sets up an expectation for a With call
func (b *MockLoggerBuilder) ExpectWith(tags ...interface{}) *MockLoggerBuilder <span class="cov8" title="1">{
        b.logger.On("With", tags).Return(b.logger)
        return b
}</span>

// Build returns the configured mock logger
func (b *MockLoggerBuilder) Build() *MockLogger <span class="cov8" title="1">{
        return b.logger
}</span>

// AssertExpectations asserts that all expected calls were made
func (b *MockLoggerBuilder) AssertExpectations(t mock.TestingT) bool <span class="cov0" title="0">{
        return b.logger.AssertExpectations(t)
}</span>

// AssertNumberOfCalls asserts the number of calls to a specific method
func (b *MockLoggerBuilder) AssertNumberOfCalls(t mock.TestingT, methodName string, expectedCalls int) bool <span class="cov8" title="1">{
        return b.logger.AssertNumberOfCalls(t, methodName, expectedCalls)
}</span>
</pre>
		
		<pre class="file" id="file252" style="display: none">package logging

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"
)

// SequentialRotator implements a log rotator with sequential numbering
type SequentialRotator struct {
        filename   string
        maxSize    int64 // bytes
        maxAge     int   // days
        maxBackups int   // number of old log files to keep
        compress   bool
        mu         sync.Mutex
        file       *os.File
        size       int64
}

// NewSequentialRotator creates a new sequential rotator
func NewSequentialRotator(filename string, maxSizeMB, maxAge, maxBackups int, compress bool) *SequentialRotator <span class="cov8" title="1">{
        return &amp;SequentialRotator{
                filename:   filename,
                maxSize:    int64(maxSizeMB) * 1024 * 1024, // Convert MB to bytes
                maxAge:     maxAge,
                maxBackups: maxBackups,
                compress:   compress,
        }
}</span>

// Write implements io.Writer
func (r *SequentialRotator) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Open file if not already open
        if r.file == nil </span><span class="cov8" title="1">{
                if err := r.openFile(); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        // Check if rotation is needed
        <span class="cov8" title="1">if r.size+int64(len(p)) &gt; r.maxSize </span><span class="cov8" title="1">{
                if err := r.rotate(); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Write to file
        <span class="cov8" title="1">n, err = r.file.Write(p)
        r.size += int64(n)
        return n, err</span>
}

// Close closes the current log file
func (r *SequentialRotator) Close() error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.file != nil </span><span class="cov8" title="1">{
                err := r.file.Close()
                r.file = nil
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// openFile opens the log file for writing
func (r *SequentialRotator) openFile() error <span class="cov8" title="1">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(r.filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get current file size if it exists
        <span class="cov8" title="1">info, err := os.Stat(r.filename)
        if err == nil </span><span class="cov8" title="1">{
                r.size = info.Size()
        }</span> else<span class="cov8" title="1"> {
                r.size = 0
        }</span>

        // Open file for appending
        <span class="cov8" title="1">file, err := os.OpenFile(r.filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r.file = file
        return nil</span>
}

// rotate rotates the current log file
func (r *SequentialRotator) rotate() error <span class="cov8" title="1">{
        // Close current file
        if r.file != nil </span><span class="cov8" title="1">{
                if err := r.file.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">r.file = nil</span>
        }

        // Get the next sequence number
        <span class="cov8" title="1">nextSeq := r.getNextSequenceNumber()

        // Generate new filename with sequence number
        base := strings.TrimSuffix(r.filename, ".log")
        rotatedName := fmt.Sprintf("%s.%d.log", base, nextSeq)

        // Rename current file to rotated name
        if err := os.Rename(r.filename, rotatedName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clean up old files
        <span class="cov8" title="1">r.cleanupOldFiles()

        // Open new file
        r.size = 0
        return r.openFile()</span>
}

// getNextSequenceNumber finds the next available sequence number
func (r *SequentialRotator) getNextSequenceNumber() int <span class="cov8" title="1">{
        dir := filepath.Dir(r.filename)
        base := strings.TrimSuffix(filepath.Base(r.filename), ".log")

        // Get all rotated files
        files, err := filepath.Glob(filepath.Join(dir, base+".*.log"))
        if err != nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov8" title="1">maxSeq := 0
        for _, file := range files </span><span class="cov8" title="1">{
                baseName := filepath.Base(file)
                // Extract sequence number from filename like "2025-07-01.1.log"
                parts := strings.Split(baseName, ".")
                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                        if seq, err := strconv.Atoi(parts[len(parts)-2]); err == nil </span><span class="cov8" title="1">{
                                if seq &gt; maxSeq </span><span class="cov8" title="1">{
                                        maxSeq = seq
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return maxSeq + 1</span>
}

// cleanupOldFiles removes old log files based on maxBackups and maxAge
func (r *SequentialRotator) cleanupOldFiles() <span class="cov8" title="1">{
        dir := filepath.Dir(r.filename)
        base := strings.TrimSuffix(filepath.Base(r.filename), ".log")

        // Get all rotated files
        files, err := filepath.Glob(filepath.Join(dir, base+".*.log"))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Sort files by modification time (newest first)
        <span class="cov8" title="1">type fileInfo struct {
                path    string
                modTime time.Time
                seq     int
        }

        var fileInfos []fileInfo
        for _, file := range files </span><span class="cov8" title="1">{
                info, err := os.Stat(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">baseName := filepath.Base(file)
                parts := strings.Split(baseName, ".")
                seq := 0
                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                        if s, err := strconv.Atoi(parts[len(parts)-2]); err == nil </span><span class="cov8" title="1">{
                                seq = s
                        }</span>
                }

                <span class="cov8" title="1">fileInfos = append(fileInfos, fileInfo{
                        path:    file,
                        modTime: info.ModTime(),
                        seq:     seq,
                })</span>
        }

        // Sort by sequence number (descending)
        <span class="cov8" title="1">sort.Slice(fileInfos, func(i, j int) bool </span><span class="cov8" title="1">{
                return fileInfos[i].seq &gt; fileInfos[j].seq
        }</span>)

        // Remove files that exceed maxBackups
        <span class="cov8" title="1">if r.maxBackups &gt; 0 &amp;&amp; len(fileInfos) &gt; r.maxBackups </span><span class="cov8" title="1">{
                for i := r.maxBackups; i &lt; len(fileInfos); i++ </span><span class="cov8" title="1">{
                        err := os.Remove(fileInfos[i].path)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("Failed to remove log file: ", err)
                        }</span>
                }
                <span class="cov8" title="1">fileInfos = fileInfos[:r.maxBackups]</span>
        }

        // Remove files older than maxAge
        <span class="cov8" title="1">if r.maxAge &gt; 0 </span><span class="cov8" title="1">{
                cutoff := time.Now().AddDate(0, 0, -r.maxAge)
                for _, fi := range fileInfos </span><span class="cov8" title="1">{
                        if fi.modTime.Before(cutoff) </span><span class="cov8" title="1">{
                                err := os.Remove(fi.path)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println("Failed to remove log file: ", err)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file253" style="display: none">package logging

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type zapLogger struct {
        sugarLogger *zap.SugaredLogger
}

func NewZapLogger(config LoggerConfig) (*zapLogger, error) <span class="cov8" title="1">{
        fileName := fmt.Sprintf("%s.log", time.Now().Format("2006-01-02"))
        fullPath := filepath.Join(BaseDataDir, LogsDir, string(config.ProcessName), fileName)

        // File writer with sequential rotation and no colors
        rotator := NewSequentialRotator(
                fullPath,
                50,    // MaxSize in MB
                30,    // MaxAge in days
                1000,  // MaxBackups (number of old files to keep)
                false, // Compress (disabled for now for Loki compatibility)
        )
        fileWriter := zapcore.AddSync(rotator)

        // Console output (with colors)
        consoleWriter := zapcore.AddSync(os.Stdout)

        // Create cores
        fileCore := zapcore.NewCore(
                plainFileEncoder(),
                fileWriter,
                zapcore.DebugLevel,
        )
        consoleCore := zapcore.NewCore(
                coloredConsoleEncoder(),
                consoleWriter,
                getLogLevel(config.IsDevelopment),
        )

        // Combine cores
        core := zapcore.NewTee(fileCore, consoleCore)

        // Build the logger
        logger := zap.New(
                core,
                zap.AddCaller(),
                zap.AddCallerSkip(1),
        )

        return &amp;zapLogger{
                sugarLogger: logger.Sugar(),
        }, nil
}</span>

func getLogLevel(isDevelopment bool) zapcore.Level <span class="cov8" title="1">{
        if isDevelopment </span><span class="cov8" title="1">{
                return zapcore.DebugLevel
        }</span>
        <span class="cov8" title="1">return zapcore.InfoLevel</span>
}

// Custom console encoder with colors
func coloredConsoleEncoder() zapcore.Encoder <span class="cov8" title="1">{
        config := zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.StringDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
                EncodeLevel:    customColorLevelEncoder,
                // TODO: Add short file name, lowest priority, for aesthetics
        }
        return zapcore.NewConsoleEncoder(config)
}</span>

// Plain JSON encoder for files (no colors)
func plainFileEncoder() zapcore.Encoder <span class="cov8" title="1">{
        config := zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.StringDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
        }
        return zapcore.NewJSONEncoder(config)
}</span>

// Custom color encoder (stdout only)
func customColorLevelEncoder(level zapcore.Level, enc zapcore.PrimitiveArrayEncoder) <span class="cov8" title="1">{
        var color string
        var levelStr string
        switch level </span>{
        case zapcore.DebugLevel:<span class="cov8" title="1">
                color = colorBlue
                levelStr = "DBG"</span>
        case zapcore.InfoLevel:<span class="cov8" title="1">
                color = colorGreen
                levelStr = "INF"</span>
        case zapcore.WarnLevel:<span class="cov8" title="1">
                color = colorYellow
                levelStr = "WRN"</span>
        case zapcore.ErrorLevel:<span class="cov8" title="1">
                color = colorRed
                levelStr = "ERR"</span>
        case zapcore.FatalLevel:<span class="cov8" title="1">
                color = colorMagenta
                levelStr = "FTL"</span>
        default:<span class="cov8" title="1">
                color = colorWhite
                levelStr = "???"</span>
        }

        // Format: [COLOR][LEVEL][RESET] (e.g., "\x1b[32mINF\x1b[0m")
        <span class="cov8" title="1">enc.AppendString(fmt.Sprintf("%s%-3s%s", color, levelStr, colorReset))</span>
}

// Implement the Logger interface methods
func (z *zapLogger) Debug(msg string, keysAndValues ...any) <span class="cov8" title="1">{
        z.sugarLogger.Debugw(msg, keysAndValues...)
}</span>

func (z *zapLogger) Info(msg string, keysAndValues ...any) <span class="cov8" title="1">{
        z.sugarLogger.Infow(msg, keysAndValues...)
}</span>

func (z *zapLogger) Warn(msg string, keysAndValues ...any) <span class="cov8" title="1">{
        z.sugarLogger.Warnw(msg, keysAndValues...)
}</span>

func (z *zapLogger) Error(msg string, keysAndValues ...any) <span class="cov8" title="1">{
        z.sugarLogger.Errorw(msg, keysAndValues...)
}</span>

func (z *zapLogger) Fatal(msg string, keysAndValues ...any) <span class="cov0" title="0">{
        z.sugarLogger.Fatalw(msg, keysAndValues...)
}</span>

func (z *zapLogger) Debugf(template string, args ...interface{}) <span class="cov8" title="1">{
        z.sugarLogger.Debugf(template, args...)
}</span>

func (z *zapLogger) Infof(template string, args ...interface{}) <span class="cov8" title="1">{
        z.sugarLogger.Infof(template, args...)
}</span>

func (z *zapLogger) Warnf(template string, args ...interface{}) <span class="cov8" title="1">{
        z.sugarLogger.Warnf(template, args...)
}</span>

func (z *zapLogger) Errorf(template string, args ...interface{}) <span class="cov8" title="1">{
        z.sugarLogger.Errorf(template, args...)
}</span>

func (z *zapLogger) Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        z.sugarLogger.Fatalf(template, args...)
}</span>

func (z *zapLogger) With(tags ...any) Logger <span class="cov8" title="1">{
        return &amp;zapLogger{
                sugarLogger: z.sugarLogger.With(tags...),
        }
}</span>
</pre>
		
		<pre class="file" id="file254" style="display: none">package parser

import (
        "fmt"
        "time"
        // "github.com/robfig/cron/v3"
)

// CalculateNextExecutionTime calculates the next execution timestamp based on the schedule type
func CalculateNextExecutionTime(currentExecutionTime time.Time, scheduleType string, timeInterval int64, cronExpression string, specificSchedule string) (time.Time, error) <span class="cov8" title="1">{
        switch scheduleType </span>{
        case "interval":<span class="cov8" title="1">
                if timeInterval &lt;= 0 </span><span class="cov8" title="1">{
                        return time.Time{}, fmt.Errorf("invalid time interval")
                }</span>
                <span class="cov8" title="1">return currentExecutionTime.Add(time.Duration(timeInterval) * time.Second), nil</span>

        case "cron":<span class="cov8" title="1">
                if cronExpression == "" </span><span class="cov8" title="1">{
                        return time.Time{}, fmt.Errorf("cron expression is required for cron schedule type")
                }</span>
                // parser := cron.NewParser(cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)
                // schedule, err := parser.Parse(cronExpression)
                // if err != nil {
                //         return time.Time{}, fmt.Errorf("invalid cron expression: %v", err)
                // }
                // return schedule.Next(currentExecutionTime), nil

                // TODO: Implement cron expression parsing, current logic is flawed
                <span class="cov8" title="1">return time.Time{}, fmt.Errorf("cron expression parsing not implemented yet")</span>

        case "specific":<span class="cov8" title="1">
                // For specific schedules like "1st day of month" or "every Sunday 2 PM"
                // This is a simplified version - you might want to implement more complex parsing
                if specificSchedule == "" </span><span class="cov8" title="1">{
                        return time.Time{}, fmt.Errorf("specific schedule is required for specific schedule type")
                }</span>
                // TODO: Implement specific schedule parsing
                // For now, return an error
                <span class="cov8" title="1">return time.Time{}, fmt.Errorf("specific schedule parsing not implemented yet")</span>

        default:<span class="cov8" title="1">
                return time.Time{}, fmt.Errorf("unknown schedule type: %s", scheduleType)</span>
        }
}

// for parsing time expressions to UTC timestamp
</pre>
		
		<pre class="file" id="file255" style="display: none">package proof

import (
        "crypto/sha256"
        "crypto/tls"
        "crypto/x509"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/types"
)

// TLSProofConfig holds configuration for TLS proof generation
type TLSProofConfig struct {
        TargetHost string        // Host to establish TLS connection with
        TargetPort string        // Port to connect to (default: "443")
        Timeout    time.Duration // Connection timeout (default: 10s)
        VerifyPeer bool          // Whether to verify peer certificates (default: true)
        ServerName string        // Server name for SNI (optional, defaults to TargetHost)
}

// DefaultTLSProofConfig returns a default configuration for TLS proof generation
func DefaultTLSProofConfig(host string) *TLSProofConfig <span class="cov8" title="1">{
        return &amp;TLSProofConfig{
                TargetHost: host,
                TargetPort: "443",
                Timeout:    10 * time.Second,
                VerifyPeer: true,
                ServerName: host,
        }
}</span>

// GenerateProofWithTLSConnection generates a proof using a real TLS connection
func GenerateProofWithTLSConnection(ipfsData types.IPFSData, config *TLSProofConfig) (types.ProofData, error) <span class="cov8" title="1">{
        connState, err := EstablishTLSConnection(config)
        if err != nil </span><span class="cov8" title="1">{
                return types.ProofData{}, fmt.Errorf("failed to establish TLS connection: %w", err)
        }</span>

        <span class="cov8" title="1">return GenerateProof(ipfsData, connState)</span>
}

// EstablishTLSConnection creates a real TLS connection and returns the connection state
func EstablishTLSConnection(config *TLSProofConfig) (*tls.ConnectionState, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, errors.New("TLS proof config cannot be nil")
        }</span>

        <span class="cov8" title="1">if config.TargetHost == "" </span><span class="cov8" title="1">{
                return nil, errors.New("target host cannot be empty")
        }</span>

        <span class="cov8" title="1">if config.TargetPort == "" </span><span class="cov8" title="1">{
                config.TargetPort = "443"
        }</span>

        <span class="cov8" title="1">if config.Timeout == 0 </span><span class="cov8" title="1">{
                config.Timeout = 10 * time.Second
        }</span>

        <span class="cov8" title="1">if config.ServerName == "" </span><span class="cov8" title="1">{
                config.ServerName = config.TargetHost
        }</span>

        // Configure TLS
        <span class="cov8" title="1">tlsConfig := &amp;tls.Config{
                ServerName:         config.ServerName,
                InsecureSkipVerify: !config.VerifyPeer,
        }

        // Establish connection with timeout
        dialer := &amp;net.Dialer{
                Timeout: config.Timeout,
        }

        address := net.JoinHostPort(config.TargetHost, config.TargetPort)
        conn, err := tls.DialWithDialer(dialer, "tcp", address, tlsConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to establish TLS connection to %s: %w", address, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to close connection: %v\n", err)
                }</span>
        }()

        // Get connection state
        <span class="cov8" title="1">connState := conn.ConnectionState()

        // Verify we have certificates
        if len(connState.PeerCertificates) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no peer certificates found in TLS connection")
        }</span>

        <span class="cov8" title="1">return &amp;connState, nil</span>
}

// GenerateProof takes the action execution data and generates a proof by:
// 1. Creating a hash of the action data (tx hash, gas used, status etc)
// 2. Adding a timestamp when the proof was generated
// 3. Including TLS certificate information for verification
// This provides cryptographic proof that the action was executed
func GenerateProof(ipfsData types.IPFSData, connState *tls.ConnectionState) (types.ProofData, error) <span class="cov8" title="1">{
        // Validate inputs
        if connState == nil </span><span class="cov8" title="1">{
                return types.ProofData{}, errors.New("TLS connection state cannot be nil")
        }</span>

        <span class="cov8" title="1">if len(connState.PeerCertificates) == 0 </span><span class="cov8" title="1">{
                return types.ProofData{}, errors.New("no TLS certificates found in connection state")
        }</span>

        // Stringify the ipfs data, after converting all the strings to lowercase
        <span class="cov8" title="1">dataStr, err := StringifyIPFSData(ipfsData)
        if err != nil </span><span class="cov0" title="0">{
                return types.ProofData{}, fmt.Errorf("failed to stringify IPFS data: %w", err)
        }</span>

        // Validate and process the first certificate
        <span class="cov8" title="1">cert := connState.PeerCertificates[0]
        if cert == nil </span><span class="cov8" title="1">{
                return types.ProofData{}, errors.New("first peer certificate is nil")
        }</span>

        // Verify certificate validity
        <span class="cov8" title="1">if err := validateCertificate(cert); err != nil </span><span class="cov8" title="1">{
                return types.ProofData{}, fmt.Errorf("certificate validation failed: %w", err)
        }</span>

        // Hash the certificate
        <span class="cov8" title="1">certHash := sha256.Sum256(cert.Raw)
        certHashStr := hex.EncodeToString(certHash[:])

        // Generate proof hash from the data
        proofHash := sha256.Sum256([]byte(dataStr))
        proofHashStr := hex.EncodeToString(proofHash[:])

        // Create enhanced proof with additional TLS information
        proofData := types.ProofData{
                TaskID:               ipfsData.TaskData.TaskID[0],
                ProofOfTask:          proofHashStr,
                CertificateHash:      certHashStr,
                CertificateTimestamp: time.Now().UTC(),
        }

        return proofData, nil</span>
}

// validateCertificate performs basic validation on the certificate
func validateCertificate(cert *x509.Certificate) error <span class="cov8" title="1">{
        if cert == nil </span><span class="cov8" title="1">{
                return errors.New("certificate is nil")
        }</span>

        // Check if certificate is expired
        <span class="cov8" title="1">now := time.Now()
        if now.Before(cert.NotBefore) </span><span class="cov8" title="1">{
                return fmt.Errorf("certificate is not yet valid (valid from: %v)", cert.NotBefore)
        }</span>

        <span class="cov8" title="1">if now.After(cert.NotAfter) </span><span class="cov8" title="1">{
                return fmt.Errorf("certificate has expired (expired on: %v)", cert.NotAfter)
        }</span>

        // Check if certificate has required fields
        <span class="cov8" title="1">if len(cert.Raw) == 0 </span><span class="cov8" title="1">{
                return errors.New("certificate raw data is empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func StringifyIPFSData(ipfsData types.IPFSData) (string, error) <span class="cov8" title="1">{
        ipfsDataMap := make(map[string]interface{})
        ipfsDataMap["task_data"] = ipfsData.TaskData
        ipfsDataMap["action_data"] = ipfsData.ActionData
        ipfsDataMap["proof_data"] = ipfsData.ProofData
        ipfsDataMap["performer_signature"] = ipfsData.PerformerSignature

        convertToLower(ipfsDataMap)

        ipfsDataBytes, err := json.Marshal(ipfsDataMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal IPFS data: %w", err)
        }</span>
        <span class="cov8" title="1">return string(ipfsDataBytes), nil</span>
}

func convertToLower(data map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                if s, ok := v.(string); ok </span><span class="cov8" title="1">{
                        data[k] = strings.ToLower(s)
                }</span> else<span class="cov8" title="1"> if m, ok := v.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        convertToLower(m)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file256" style="display: none">package retry

import (
        "context"
        "crypto/rand"
        "encoding/binary"
        "errors"
        "fmt"
        "math"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// Config holds the configuration for retry operations
type RetryConfig struct {
        MaxRetries      int              // Maximum number of retry attempts
        InitialDelay    time.Duration    // Initial delay between retries
        MaxDelay        time.Duration    // Maximum delay between retries
        BackoffFactor   float64          // Multiplier for exponential backoff
        JitterFactor    float64          // Factor for adding jitter to delays (% of delay)
        LogRetryAttempt bool             // Whether to log retry attempts
        ShouldRetry     func(error) bool // Custom function to determine if error should be retried
}

// DefaultConfig returns a default configuration for retry operations
func DefaultRetryConfig() *RetryConfig <span class="cov8" title="1">{
        return &amp;RetryConfig{
                MaxRetries:      5,
                InitialDelay:    time.Second,
                MaxDelay:        30 * time.Second,
                BackoffFactor:   2.0,
                JitterFactor:    0.2,
                LogRetryAttempt: true,
                ShouldRetry:     nil,
        }
}</span>

// validate checks the configuration for reasonable values
func (c *RetryConfig) Validate() error <span class="cov8" title="1">{
        if c.MaxRetries &lt; 0 </span><span class="cov8" title="1">{
                return errors.New("MaxRetries must be &gt;= 0")
        }</span>
        <span class="cov8" title="1">if c.InitialDelay &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("InitialDelay must be positive")
        }</span>
        <span class="cov8" title="1">if c.MaxDelay &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("MaxDelay must be positive")
        }</span>
        <span class="cov8" title="1">if c.BackoffFactor &lt; 1.0 </span><span class="cov8" title="1">{
                return errors.New("BackoffFactor must be &gt;= 1.0")
        }</span>
        <span class="cov8" title="1">if c.JitterFactor &lt; 0 || c.JitterFactor &gt; 1.0 </span><span class="cov8" title="1">{
                return errors.New("JitterFactor must be between 0.0 and 1.0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SecureFloat64 returns a secure random float64 in [0.0,1.0)
func SecureFloat64() float64 <span class="cov8" title="1">{
        var b [8]byte
        _, err := rand.Read(b[:])
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to a less random source if crypto/rand fails
                return math.Mod(float64(time.Now().UnixNano()), 1000) / 1000.0
        }</span>
        <span class="cov8" title="1">return float64(binary.BigEndian.Uint64(b[:])) / (1 &lt;&lt; 64)</span>
}

// CalculateDelayWithJitter calculates the sleep duration for the given base delay with jitter applied
func CalculateDelayWithJitter(baseDelay time.Duration, jitterFactor float64) time.Duration <span class="cov8" title="1">{
        sleepDuration := baseDelay
        if jitterFactor &gt; 0 </span><span class="cov8" title="1">{
                jitter := time.Duration(jitterFactor * float64(baseDelay) * SecureFloat64())
                sleepDuration += jitter
        }</span>
        <span class="cov8" title="1">return sleepDuration</span>
}

// CalculateNextDelay calculates the next delay value using exponential backoff
func CalculateNextDelay(currentDelay time.Duration, backoffFactor float64, maxDelay time.Duration) time.Duration <span class="cov8" title="1">{
        nextDelay := time.Duration(float64(currentDelay) * backoffFactor)
        if nextDelay &gt; maxDelay </span><span class="cov8" title="1">{
                nextDelay = maxDelay
        }</span>
        <span class="cov8" title="1">return nextDelay</span>
}

// Retry executes the given operation with exponential backoff and retry logic.
// Returns the result of the operation if successful, or an error if all attempts fail.
func Retry[T any](ctx context.Context, operation func() (T, error), retryConfig *RetryConfig, logger logging.Logger) (T, error) <span class="cov8" title="1">{
        var zero T
        var err error

        if retryConfig == nil </span><span class="cov8" title="1">{
                retryConfig = DefaultRetryConfig()
        }</span> else<span class="cov8" title="1"> if err := retryConfig.Validate(); err != nil </span><span class="cov8" title="1">{
                return zero, fmt.Errorf("invalid retry config: %w", err)
        }</span>

        <span class="cov8" title="1">delay := retryConfig.InitialDelay

        for attempt := 0; attempt &lt; retryConfig.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return zero, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">result, opErr := operation()
                if opErr == nil </span><span class="cov8" title="1">{
                        return result, nil
                }</span>
                <span class="cov8" title="1">err = opErr

                // Check if we should retry based on custom predicate
                if retryConfig.ShouldRetry != nil &amp;&amp; !retryConfig.ShouldRetry(err) </span><span class="cov8" title="1">{
                        return zero, err
                }</span>

                <span class="cov8" title="1">sleepDuration := CalculateDelayWithJitter(delay, retryConfig.JitterFactor)

                if retryConfig.LogRetryAttempt </span><span class="cov8" title="1">{
                        logger.Warnf("Attempt %d/%d failed: %v. Retrying in %v...", attempt+1, retryConfig.MaxRetries, err, sleepDuration)
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-time.After(sleepDuration):<span class="cov8" title="1">
                        // Calculate next delay
                        delay = CalculateNextDelay(delay, retryConfig.BackoffFactor, retryConfig.MaxDelay)</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return zero, ctx.Err()</span>
                }
        }

        <span class="cov8" title="1">return zero, fmt.Errorf("operation failed after %d attempts: %w", retryConfig.MaxRetries, err)</span>
}

// RetryFunc executes an operation that only returns an error, with exponential backoff.
// This is a convenience wrapper around Retry.
func RetryFunc(ctx context.Context, operation func() error, config *RetryConfig, logger logging.Logger) error <span class="cov8" title="1">{
        opWithValue := func() (struct{}, error) </span><span class="cov8" title="1">{
                return struct{}{}, operation()
        }</span>
        <span class="cov8" title="1">_, err := Retry(ctx, opWithValue, config, logger)
        return err</span>
}
</pre>
		
		<pre class="file" id="file257" style="display: none">package config

import (
        "os"
        "time"
)

// AuthConfig holds authentication configuration
type AuthConfig struct {
        // JWT Configuration
        JWTSecretKey     string        `json:"jwt_secret_key"`
        JWTExpiration    time.Duration `json:"jwt_expiration"`
        JWTRefreshExpiry time.Duration `json:"jwt_refresh_expiry"`

        // Token Configuration
        AccessTokenExpiry  time.Duration `json:"access_token_expiry"`
        RefreshTokenExpiry time.Duration `json:"refresh_token_expiry"`

        // Security Configuration
        EnableRateLimit bool          `json:"enable_rate_limit"`
        MaxRequests     int           `json:"max_requests"`
        WindowSize      time.Duration `json:"window_size"`

        // Service Configuration
        ServiceName string `json:"service_name"`
        Environment string `json:"environment"`
}

// NewAuthConfig creates a new authentication configuration with defaults
func NewAuthConfig() *AuthConfig <span class="cov0" title="0">{
        return &amp;AuthConfig{
                JWTSecretKey:       getEnvOrDefault("JWT_SECRET_KEY", "your-secret-key-change-in-production"),
                JWTExpiration:      getDurationEnvOrDefault("JWT_EXPIRATION", 24*time.Hour),
                JWTRefreshExpiry:   getDurationEnvOrDefault("JWT_REFRESH_EXPIRY", 7*24*time.Hour),
                AccessTokenExpiry:  getDurationEnvOrDefault("ACCESS_TOKEN_EXPIRY", 1*time.Hour),
                RefreshTokenExpiry: getDurationEnvOrDefault("REFRESH_TOKEN_EXPIRY", 7*24*time.Hour),
                EnableRateLimit:    getBoolEnvOrDefault("ENABLE_RATE_LIMIT", false),
                MaxRequests:        getIntEnvOrDefault("MAX_REQUESTS", 100),
                WindowSize:         getDurationEnvOrDefault("RATE_LIMIT_WINDOW", 1*time.Minute),
                ServiceName:        getEnvOrDefault("SERVICE_NAME", "triggerx-backend"),
                Environment:        getEnvOrDefault("ENVIRONMENT", "development"),
        }
}</span>

// GetJWTSecretKey returns the JWT secret key
func (c *AuthConfig) GetJWTSecretKey() string <span class="cov0" title="0">{
        return c.JWTSecretKey
}</span>

// GetJWTExpiration returns the JWT expiration duration
func (c *AuthConfig) GetJWTExpiration() time.Duration <span class="cov0" title="0">{
        return c.JWTExpiration
}</span>

// GetAccessTokenExpiry returns the access token expiry duration
func (c *AuthConfig) GetAccessTokenExpiry() time.Duration <span class="cov0" title="0">{
        return c.AccessTokenExpiry
}</span>

// GetRefreshTokenExpiry returns the refresh token expiry duration
func (c *AuthConfig) GetRefreshTokenExpiry() time.Duration <span class="cov0" title="0">{
        return c.RefreshTokenExpiry
}</span>

// IsRateLimitEnabled returns whether rate limiting is enabled
func (c *AuthConfig) IsRateLimitEnabled() bool <span class="cov0" title="0">{
        return c.EnableRateLimit
}</span>

// GetMaxRequests returns the maximum number of requests allowed
func (c *AuthConfig) GetMaxRequests() int <span class="cov0" title="0">{
        return c.MaxRequests
}</span>

// GetWindowSize returns the rate limit window size
func (c *AuthConfig) GetWindowSize() time.Duration <span class="cov0" title="0">{
        return c.WindowSize
}</span>

// IsDevelopment returns whether the environment is development
func (c *AuthConfig) IsDevelopment() bool <span class="cov0" title="0">{
        return c.Environment == "development"
}</span>

// IsProduction returns whether the environment is production
func (c *AuthConfig) IsProduction() bool <span class="cov0" title="0">{
        return c.Environment == "production"
}</span>

// Helper functions for environment variable handling
func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getDurationEnvOrDefault(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getBoolEnvOrDefault(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value == "true" || value == "1" || value == "yes"
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntEnvOrDefault(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return int(intValue)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file258" style="display: none">package jwt

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// Claims represents the JWT claims structure
type Claims struct {
        UserID      string            `json:"user_id"`
        Email       string            `json:"email"`
        Address     string            `json:"address"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        jwt.RegisteredClaims
}

// NewClaims creates a new JWT claims instance
func NewClaims(userID, email, address, role string, permissions []string) *Claims <span class="cov0" title="0">{
        now := time.Now()

        return &amp;Claims{
                UserID:      userID,
                Email:       email,
                Address:     address,
                Role:        role,
                Permissions: permissions,
                Metadata:    make(map[string]string),
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "triggerx-backend",
                        Subject:   userID,
                        Audience:  []string{"triggerx-backend"},
                        ExpiresAt: jwt.NewNumericDate(now.Add(24 * time.Hour)),
                        NotBefore: jwt.NewNumericDate(now),
                        IssuedAt:  jwt.NewNumericDate(now),
                        ID:        generateTokenID(),
                },
        }
}</span>

// NewAccessTokenClaims creates claims for access tokens
func NewAccessTokenClaims(userID, email, address, role string, permissions []string, expiry time.Duration) *Claims <span class="cov0" title="0">{
        now := time.Now()

        return &amp;Claims{
                UserID:      userID,
                Email:       email,
                Address:     address,
                Role:        role,
                Permissions: permissions,
                Metadata:    make(map[string]string),
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "triggerx-backend",
                        Subject:   userID,
                        Audience:  []string{"triggerx-backend"},
                        ExpiresAt: jwt.NewNumericDate(now.Add(expiry)),
                        NotBefore: jwt.NewNumericDate(now),
                        IssuedAt:  jwt.NewNumericDate(now),
                        ID:        generateTokenID(),
                },
        }
}</span>

// NewRefreshTokenClaims creates claims for refresh tokens
func NewRefreshTokenClaims(userID string, expiry time.Duration) *Claims <span class="cov0" title="0">{
        now := time.Now()

        return &amp;Claims{
                UserID:      userID,
                Email:       "",
                Address:     "",
                Role:        "",
                Permissions: []string{},
                Metadata:    make(map[string]string),
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "triggerx-backend",
                        Subject:   userID,
                        Audience:  []string{"triggerx-backend"},
                        ExpiresAt: jwt.NewNumericDate(now.Add(expiry)),
                        NotBefore: jwt.NewNumericDate(now),
                        IssuedAt:  jwt.NewNumericDate(now),
                        ID:        generateTokenID(),
                },
        }
}</span>

// AddMetadata adds metadata to the claims
func (c *Claims) AddMetadata(key, value string) <span class="cov0" title="0">{
        if c.Metadata == nil </span><span class="cov0" title="0">{
                c.Metadata = make(map[string]string)
        }</span>
        <span class="cov0" title="0">c.Metadata[key] = value</span>
}

// GetMetadata retrieves metadata from the claims
func (c *Claims) GetMetadata(key string) string <span class="cov0" title="0">{
        if c.Metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return c.Metadata[key]</span>
}

// HasPermission checks if the user has a specific permission
func (c *Claims) HasPermission(permission string) bool <span class="cov0" title="0">{
        for _, p := range c.Permissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasAnyPermission checks if the user has any of the specified permissions
func (c *Claims) HasAnyPermission(permissions ...string) bool <span class="cov0" title="0">{
        for _, required := range permissions </span><span class="cov0" title="0">{
                if c.HasPermission(required) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasAllPermissions checks if the user has all of the specified permissions
func (c *Claims) HasAllPermissions(permissions ...string) bool <span class="cov0" title="0">{
        for _, required := range permissions </span><span class="cov0" title="0">{
                if !c.HasPermission(required) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// IsExpired checks if the token is expired
func (c *Claims) IsExpired() bool <span class="cov0" title="0">{
        return time.Now().After(c.ExpiresAt.Time)
}</span>

// IsValid checks if the token is valid (not expired and has required fields)
func (c *Claims) IsValid() bool <span class="cov0" title="0">{
        return !c.IsExpired() &amp;&amp; c.UserID != "" &amp;&amp; c.Subject != ""
}</span>

// GetExpirationTime returns the expiration time
func (c *Claims) GetExpirationTime() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return c.ExpiresAt, nil
}</span>

// GetIssuedTime returns the issued time
func (c *Claims) GetIssuedTime() time.Time <span class="cov0" title="0">{
        return c.IssuedAt.Time
}</span>

// GetTimeUntilExpiry returns the time until the token expires
func (c *Claims) GetTimeUntilExpiry() time.Duration <span class="cov0" title="0">{
        return time.Until(c.ExpiresAt.Time)
}</span>

// IsRefreshToken checks if this is a refresh token
func (c *Claims) IsRefreshToken() bool <span class="cov0" title="0">{
        return c.Email == "" &amp;&amp; c.Address == "" &amp;&amp; c.Role == "" &amp;&amp; len(c.Permissions) == 0
}</span>

// IsAccessToken checks if this is an access token
func (c *Claims) IsAccessToken() bool <span class="cov0" title="0">{
        return !c.IsRefreshToken()
}</span>

// generateTokenID generates a unique token ID
func generateTokenID() string <span class="cov0" title="0">{
        return "token_" + time.Now().Format("20060102150405") + "_" + randomString(8)
}</span>

// randomString generates a random string of specified length
func randomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file259" style="display: none">package jwt

import (
        "context"
        "fmt"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/config"
)

// AuthInterceptor provides JWT authentication for gRPC requests
type AuthInterceptor struct {
        validator *Validator
        config    *config.AuthConfig
}

// NewAuthInterceptor creates a new JWT authentication interceptor
func NewAuthInterceptor(cfg *config.AuthConfig) *AuthInterceptor <span class="cov0" title="0">{
        return &amp;AuthInterceptor{
                validator: NewValidator(cfg),
                config:    cfg,
        }
}</span>

// UnaryServerInterceptor returns a gRPC unary server interceptor for JWT authentication
func (ai *AuthInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Skip authentication for certain methods (health checks, etc.)
                if ai.shouldSkipAuth(info.FullMethod) </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                // Extract and validate JWT token
                <span class="cov0" title="0">claims, err := ai.AuthenticateRequest(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "authentication failed: %v", err)
                }</span>

                // Add claims to context
                <span class="cov0" title="0">ctx = ai.addClaimsToContext(ctx, claims)

                // Continue with the request
                return handler(ctx, req)</span>
        }
}

// UnaryClientInterceptor returns a gRPC unary client interceptor for JWT authentication
func (ai *AuthInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                // Add JWT token to outgoing metadata if available
                ctx = ai.addTokenToContext(ctx)
                return invoker(ctx, method, req, reply, cc, opts...)
        }</span>
}

// AuthenticateRequest extracts and validates JWT token from gRPC metadata
func (ai *AuthInterceptor) AuthenticateRequest(ctx context.Context) (*Claims, error) <span class="cov0" title="0">{
        // Extract token from metadata
        token, err := ai.extractTokenFromMetadata(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract token: %w", err)
        }</span>

        // Validate token
        <span class="cov0" title="0">claims, err := ai.validator.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// extractTokenFromMetadata extracts JWT token from gRPC metadata
func (ai *AuthInterceptor) extractTokenFromMetadata(ctx context.Context) (string, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no metadata found")
        }</span>

        // Try to get token from Authorization header
        <span class="cov0" title="0">authHeaders := md.Get("authorization")
        if len(authHeaders) &gt; 0 </span><span class="cov0" title="0">{
                token := authHeaders[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // Try to get token from x-auth-token header
        <span class="cov0" title="0">authTokens := md.Get("x-auth-token")
        if len(authTokens) &gt; 0 </span><span class="cov0" title="0">{
                token := authTokens[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // Try to get token from x-jwt-token header
        <span class="cov0" title="0">jwtTokens := md.Get("x-jwt-token")
        if len(jwtTokens) &gt; 0 </span><span class="cov0" title="0">{
                token := jwtTokens[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no authentication token found in metadata")</span>
}

// addClaimsToContext adds JWT claims to the context
func (ai *AuthInterceptor) addClaimsToContext(ctx context.Context, claims *Claims) context.Context <span class="cov0" title="0">{
        // Add claims to context using a custom key
        return context.WithValue(ctx, rpc.JWTClaimsKey, claims)
}</span>

// addTokenToContext adds JWT token to outgoing metadata
func (ai *AuthInterceptor) addTokenToContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        // This would typically get the token from the current context or session
        // For now, we'll return the context as-is
        return ctx
}</span>

// shouldSkipAuth determines if authentication should be skipped for a method
func (ai *AuthInterceptor) shouldSkipAuth(method string) bool <span class="cov0" title="0">{
        // Skip authentication for health checks and other public methods
        skipMethods := []string{
                "/grpc.health.v1.Health/Check",
                "/grpc.health.v1.Health/Watch",
                "/grpc.reflection.v1alpha.ServerReflection/ServerReflectionInfo",
                "/triggerx.backend.AuthService/Login",
                "/triggerx.backend.AuthService/Register",
                "/triggerx.backend.AuthService/RefreshToken",
        }

        for _, skipMethod := range skipMethods </span><span class="cov0" title="0">{
                if method == skipMethod </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetClaimsFromContext extracts JWT claims from context
func (ai *AuthInterceptor) GetClaimsFromContext(ctx context.Context) (*Claims, bool) <span class="cov0" title="0">{
        claims, ok := ctx.Value(rpc.JWTClaimsKey).(*Claims)
        return claims, ok
}</span>

// RequirePermission creates an interceptor that requires specific permissions
func (ai *AuthInterceptor) RequirePermission(permissions ...string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Get claims from context
                claims, ok := ai.GetClaimsFromContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "no authentication claims found")
                }</span>

                // Check permissions
                <span class="cov0" title="0">if !claims.HasAllPermissions(permissions...) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.PermissionDenied, "insufficient permissions: required %v", permissions)
                }</span>

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// RequireRole creates an interceptor that requires a specific role
func (ai *AuthInterceptor) RequireRole(role string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Get claims from context
                claims, ok := ai.GetClaimsFromContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "no authentication claims found")
                }</span>

                // Check role
                <span class="cov0" title="0">if claims.Role != role </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.PermissionDenied, "insufficient role: required %s, got %s", role, claims.Role)
                }</span>

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// OptionalAuth creates an interceptor that optionally authenticates requests
func (ai *AuthInterceptor) OptionalAuth() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Try to authenticate, but don't fail if no token is provided
                claims, err := ai.AuthenticateRequest(ctx)
                if err == nil </span><span class="cov0" title="0">{
                        // Authentication successful, add claims to context
                        ctx = ai.addClaimsToContext(ctx, claims)
                }</span>
                // If authentication fails, continue without claims

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// GenerateToken generates a new JWT token for a user
func (ai *AuthInterceptor) GenerateToken(userID, email, address, role string, permissions []string) (string, error) <span class="cov0" title="0">{
        return ai.validator.GenerateAccessToken(userID, email, address, role, permissions)
}</span>

// GenerateRefreshToken generates a refresh token for a user
func (ai *AuthInterceptor) GenerateRefreshToken(userID string) (string, error) <span class="cov0" title="0">{
        return ai.validator.GenerateRefreshToken(userID)
}</span>

// ValidateToken validates a JWT token
func (ai *AuthInterceptor) ValidateToken(token string) (*Claims, error) <span class="cov0" title="0">{
        return ai.validator.ValidateToken(token)
}</span>
</pre>
		
		<pre class="file" id="file260" style="display: none">package jwt

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/config"
)

// Validator handles JWT token validation and parsing
type Validator struct {
        config *config.AuthConfig
}

// NewValidator creates a new JWT validator
func NewValidator(cfg *config.AuthConfig) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                config: cfg,
        }
}</span>

// ValidateToken validates and parses a JWT token
func (v *Validator) ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        // Remove "Bearer " prefix if present
        tokenString = strings.TrimPrefix(tokenString, "Bearer ")

        // Parse the token
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(v.config.GetJWTSecretKey()), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        // Extract claims
        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        // Validate claims
        <span class="cov0" title="0">if err := v.validateClaims(claims); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// ValidateTokenFromContext validates a token from gRPC metadata
func (v *Validator) ValidateTokenFromContext(ctx context.Context) (*Claims, error) <span class="cov0" title="0">{
        // Extract token from metadata
        token, err := v.extractTokenFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return v.ValidateToken(token)</span>
}

// GenerateToken generates a new JWT token with the given claims
func (v *Validator) GenerateToken(claims *Claims) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(v.config.GetJWTSecretKey()))
}</span>

// GenerateAccessToken generates an access token for a user
func (v *Validator) GenerateAccessToken(userID, email, address, role string, permissions []string) (string, error) <span class="cov0" title="0">{
        claims := NewAccessTokenClaims(userID, email, address, role, permissions, v.config.GetAccessTokenExpiry())
        return v.GenerateToken(claims)
}</span>

// GenerateRefreshToken generates a refresh token for a user
func (v *Validator) GenerateRefreshToken(userID string) (string, error) <span class="cov0" title="0">{
        claims := NewRefreshTokenClaims(userID, v.config.GetRefreshTokenExpiry())
        return v.GenerateToken(claims)
}</span>

// RefreshToken refreshes an access token using a refresh token
func (v *Validator) RefreshToken(refreshTokenString string, userID, email, address, role string, permissions []string) (string, error) <span class="cov0" title="0">{
        // Validate the refresh token
        claims, err := v.ValidateToken(refreshTokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid refresh token: %w", err)
        }</span>

        // Check if it's actually a refresh token
        <span class="cov0" title="0">if !claims.IsRefreshToken() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("token is not a refresh token")
        }</span>

        // Check if the user ID matches
        <span class="cov0" title="0">if claims.UserID != userID </span><span class="cov0" title="0">{
                return "", fmt.Errorf("refresh token user ID mismatch")
        }</span>

        // Generate new access token
        <span class="cov0" title="0">return v.GenerateAccessToken(userID, email, address, role, permissions)</span>
}

// ValidateClaims validates the JWT claims
func (v *Validator) validateClaims(claims *Claims) error <span class="cov0" title="0">{
        // Check if token is expired
        if claims.IsExpired() </span><span class="cov0" title="0">{
                return fmt.Errorf("token is expired")
        }</span>

        // Check if token is not yet valid
        <span class="cov0" title="0">if time.Now().Before(claims.NotBefore.Time) </span><span class="cov0" title="0">{
                return fmt.Errorf("token is not yet valid")
        }</span>

        // Check required fields
        <span class="cov0" title="0">if claims.UserID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing user ID in token")
        }</span>

        <span class="cov0" title="0">if claims.Subject == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing subject in token")
        }</span>

        // Validate issuer
        <span class="cov0" title="0">if claims.Issuer != "triggerx-backend" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid token issuer")
        }</span>

        // Validate audience
        <span class="cov0" title="0">validAudience := false
        for _, audience := range claims.Audience </span><span class="cov0" title="0">{
                if audience == "triggerx-backend" </span><span class="cov0" title="0">{
                        validAudience = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !validAudience </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid token audience")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExtractTokenFromMetadata extracts token from gRPC metadata
func (v *Validator) extractTokenFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // This would be implemented based on your gRPC metadata structure
        // For now, we'll use a placeholder implementation
        return "", fmt.Errorf("extractTokenFromContext not implemented")
}</span>

// IsTokenExpired checks if a token is expired without full validation
func (v *Validator) IsTokenExpired(tokenString string) (bool, error) <span class="cov0" title="0">{
        // Parse token without validation to check expiration
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, &amp;Claims{})
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov0" title="0">return claims.IsExpired(), nil</span>
}

// GetTokenExpirationTime gets the expiration time of a token
func (v *Validator) GetTokenExpirationTime(tokenString string) (time.Time, error) <span class="cov0" title="0">{
        // Parse token without validation to get expiration
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, &amp;Claims{})
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov0" title="0">expTime, err := claims.GetExpirationTime()
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return expTime.Time, nil</span>
}

// ValidateTokenPermissions validates if a token has the required permissions
func (v *Validator) ValidateTokenPermissions(tokenString string, requiredPermissions ...string) error <span class="cov0" title="0">{
        claims, err := v.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !claims.HasAllPermissions(requiredPermissions...) </span><span class="cov0" title="0">{
                return fmt.Errorf("token does not have required permissions: %v", requiredPermissions)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateTokenRole validates if a token has the required role
func (v *Validator) ValidateTokenRole(tokenString string, requiredRole string) error <span class="cov0" title="0">{
        claims, err := v.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if claims.Role != requiredRole </span><span class="cov0" title="0">{
                return fmt.Errorf("token does not have required role: %s", requiredRole)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTokenClaims gets the claims from a token without validation
func (v *Validator) GetTokenClaims(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        // Parse token without validation
        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, &amp;Claims{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file261" style="display: none">package middleware

import (
        "context"
        "fmt"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/config"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc/auth/jwt"
)

// AuthMiddleware provides authentication middleware for gRPC services
type AuthMiddleware struct {
        jwtInterceptor *jwt.AuthInterceptor
        config         *config.AuthConfig
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(cfg *config.AuthConfig) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                jwtInterceptor: jwt.NewAuthInterceptor(cfg),
                config:         cfg,
        }
}</span>

// AuthenticateRequest authenticates a gRPC request
func (am *AuthMiddleware) AuthenticateRequest(ctx context.Context, method string) (*jwt.Claims, error) <span class="cov0" title="0">{
        // Skip authentication for certain methods
        if am.shouldSkipAuth(method) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Extract and validate JWT token
        <span class="cov0" title="0">claims, err := am.jwtInterceptor.AuthenticateRequest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication failed: %w", err)
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// RequireAuth creates an interceptor that requires authentication
func (am *AuthMiddleware) RequireAuth() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return am.jwtInterceptor.UnaryServerInterceptor()
}</span>

// RequirePermission creates an interceptor that requires specific permissions
func (am *AuthMiddleware) RequirePermission(permissions ...string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return am.jwtInterceptor.RequirePermission(permissions...)
}</span>

// RequireRole creates an interceptor that requires a specific role
func (am *AuthMiddleware) RequireRole(role string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return am.jwtInterceptor.RequireRole(role)
}</span>

// OptionalAuth creates an interceptor that optionally authenticates requests
func (am *AuthMiddleware) OptionalAuth() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return am.jwtInterceptor.OptionalAuth()
}</span>

// GetClaimsFromContext extracts JWT claims from context
func (am *AuthMiddleware) GetClaimsFromContext(ctx context.Context) (*jwt.Claims, bool) <span class="cov0" title="0">{
        return am.jwtInterceptor.GetClaimsFromContext(ctx)
}</span>

// GenerateToken generates a new JWT token for a user
func (am *AuthMiddleware) GenerateToken(userID, email, address, role string, permissions []string) (string, error) <span class="cov0" title="0">{
        return am.jwtInterceptor.GenerateToken(userID, email, address, role, permissions)
}</span>

// GenerateRefreshToken generates a refresh token for a user
func (am *AuthMiddleware) GenerateRefreshToken(userID string) (string, error) <span class="cov0" title="0">{
        return am.jwtInterceptor.GenerateRefreshToken(userID)
}</span>

// ValidateToken validates a JWT token
func (am *AuthMiddleware) ValidateToken(token string) (*jwt.Claims, error) <span class="cov0" title="0">{
        return am.jwtInterceptor.ValidateToken(token)
}</span>

// AddTokenToMetadata adds a JWT token to gRPC metadata
func (am *AuthMiddleware) AddTokenToMetadata(ctx context.Context, token string) context.Context <span class="cov0" title="0">{
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                md = metadata.New(nil)
        }</span>

        <span class="cov0" title="0">md.Set("authorization", "Bearer "+token)
        return metadata.NewOutgoingContext(ctx, md)</span>
}

// ExtractTokenFromMetadata extracts JWT token from gRPC metadata
func (am *AuthMiddleware) ExtractTokenFromMetadata(ctx context.Context) (string, error) <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no metadata found")
        }</span>

        // Try to get token from Authorization header
        <span class="cov0" title="0">authHeaders := md.Get("authorization")
        if len(authHeaders) &gt; 0 </span><span class="cov0" title="0">{
                token := authHeaders[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // Try to get token from x-auth-token header
        <span class="cov0" title="0">authTokens := md.Get("x-auth-token")
        if len(authTokens) &gt; 0 </span><span class="cov0" title="0">{
                token := authTokens[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        // Try to get token from x-jwt-token header
        <span class="cov0" title="0">jwtTokens := md.Get("x-jwt-token")
        if len(jwtTokens) &gt; 0 </span><span class="cov0" title="0">{
                token := jwtTokens[0]
                if token != "" </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no authentication token found in metadata")</span>
}

// shouldSkipAuth determines if authentication should be skipped for a method
func (am *AuthMiddleware) shouldSkipAuth(method string) bool <span class="cov0" title="0">{
        // Skip authentication for health checks and other public methods
        skipMethods := []string{
                "/grpc.health.v1.Health/Check",
                "/grpc.health.v1.Health/Watch",
                "/grpc.reflection.v1alpha.ServerReflection/ServerReflectionInfo",
                "/triggerx.backend.AuthService/Login",
                "/triggerx.backend.AuthService/Register",
                "/triggerx.backend.AuthService/RefreshToken",
                "/triggerx.backend.AuthService/ValidateToken",
        }

        for _, skipMethod := range skipMethods </span><span class="cov0" title="0">{
                if method == skipMethod </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// CreateAuthContext creates a context with authentication information
func (am *AuthMiddleware) CreateAuthContext(ctx context.Context, claims *jwt.Claims) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, rpc.JWTClaimsKey, claims)
}</span>

// IsAuthenticated checks if the context contains valid authentication claims
func (am *AuthMiddleware) IsAuthenticated(ctx context.Context) bool <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        return ok &amp;&amp; claims != nil &amp;&amp; claims.IsValid()
}</span>

// GetUserID extracts user ID from context
func (am *AuthMiddleware) GetUserID(ctx context.Context) (string, error) <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Unauthenticated, "no authentication claims found")
        }</span>
        <span class="cov0" title="0">return claims.UserID, nil</span>
}

// GetUserRole extracts user role from context
func (am *AuthMiddleware) GetUserRole(ctx context.Context) (string, error) <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Unauthenticated, "no authentication claims found")
        }</span>
        <span class="cov0" title="0">return claims.Role, nil</span>
}

// GetUserPermissions extracts user permissions from context
func (am *AuthMiddleware) GetUserPermissions(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "no authentication claims found")
        }</span>
        <span class="cov0" title="0">return claims.Permissions, nil</span>
}

// HasPermission checks if the user has a specific permission
func (am *AuthMiddleware) HasPermission(ctx context.Context, permission string) bool <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return claims.HasPermission(permission)</span>
}

// HasAnyPermission checks if the user has any of the specified permissions
func (am *AuthMiddleware) HasAnyPermission(ctx context.Context, permissions ...string) bool <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return claims.HasAnyPermission(permissions...)</span>
}

// HasAllPermissions checks if the user has all of the specified permissions
func (am *AuthMiddleware) HasAllPermissions(ctx context.Context, permissions ...string) bool <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return claims.HasAllPermissions(permissions...)</span>
}

// HasRole checks if the user has a specific role
func (am *AuthMiddleware) HasRole(ctx context.Context, role string) bool <span class="cov0" title="0">{
        claims, ok := am.GetClaimsFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return claims.Role == role</span>
}
</pre>
		
		<pre class="file" id="file262" style="display: none">package client

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/anypb"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcpkg "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        rpcproto "github.com/trigg3rX/triggerx-backend/pkg/rpc/proto"
)

// Client represents a gRPC client
type Client struct {
        config   Config
        logger   logging.Logger
        registry rpcpkg.ServiceRegistry
        pool     *ConnectionPool
}

// Config holds client configuration
type Config struct {
        ServiceName string
        Timeout     time.Duration
        MaxRetries  int
        RetryDelay  time.Duration
        PoolSize    int
        PoolTimeout time.Duration
}

// NewClient creates a new gRPC client
func NewClient(config Config, logger logging.Logger) *Client <span class="cov0" title="0">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxRetries == 0 </span><span class="cov0" title="0">{
                config.MaxRetries = 3
        }</span>
        <span class="cov0" title="0">if config.RetryDelay == 0 </span><span class="cov0" title="0">{
                config.RetryDelay = time.Second
        }</span>
        <span class="cov0" title="0">if config.PoolSize == 0 </span><span class="cov0" title="0">{
                config.PoolSize = 10
        }</span>
        <span class="cov0" title="0">if config.PoolTimeout == 0 </span><span class="cov0" title="0">{
                config.PoolTimeout = 5 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;Client{
                config: config,
                logger: logger,
                pool:   NewConnectionPool(config.PoolSize, config.PoolTimeout, logger),
        }</span>
}

// SetRegistry sets the service registry for discovery
func (c *Client) SetRegistry(registry rpcpkg.ServiceRegistry) <span class="cov0" title="0">{
        c.registry = registry
}</span>

// Call makes a gRPC call to the specified service and method
func (c *Client) Call(ctx context.Context, method string, request interface{}, response interface{}) error <span class="cov0" title="0">{
        retryCfg := DefaultRetryConfig()
        retryCfg.MaxRetries = c.config.MaxRetries
        if retryCfg.MaxRetries &lt;= 0 </span><span class="cov0" title="0">{
                retryCfg.MaxRetries = 3
        }</span>
        <span class="cov0" title="0">retryCfg.InitialDelay = c.config.RetryDelay
        if retryCfg.InitialDelay &lt;= 0 </span><span class="cov0" title="0">{
                retryCfg.InitialDelay = 500 * time.Millisecond
        }</span>
        <span class="cov0" title="0">retryCfg.MaxDelay = 5 * time.Second
        retryCfg.BackoffFactor = 2.0
        retryCfg.JitterFactor = 0.2

        err := RetryWithBackoff(ctx, func() error </span><span class="cov0" title="0">{
                // Get service info from registry or use direct connection
                var serviceInfo *rpcpkg.ServiceInfo
                var err error

                if c.registry != nil </span><span class="cov0" title="0">{
                        serviceInfo, err = c.getServiceFromRegistry(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get service from registry: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Use direct connection if no registry
                        serviceInfo = &amp;rpcpkg.ServiceInfo{
                                Address: c.config.ServiceName, // Assume it's a direct address
                        }
                }</span>

                // Get connection from pool
                <span class="cov0" title="0">conn, err := c.pool.GetConnection(ctx, serviceInfo.Address)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get connection: %w", err)
                }</span>

                // Make gRPC call
                <span class="cov0" title="0">callErr := c.makeGRPCCall(ctx, conn, method, request, response)
                // Return connection to pool (mark failed if callErr != nil)
                c.pool.ReturnConnection(conn, callErr != nil)

                return callErr</span>
        }, retryCfg, c.logger)

        <span class="cov0" title="0">return err</span>
}

// getServiceFromRegistry gets service info from registry
func (c *Client) getServiceFromRegistry(ctx context.Context) (*rpcpkg.ServiceInfo, error) <span class="cov0" title="0">{
        serviceInfo, err := c.registry.GetService(ctx, c.config.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if service is healthy
        <span class="cov0" title="0">if serviceInfo.Health.Status != "healthy" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s is not healthy: %s", c.config.ServiceName, serviceInfo.Health.Status)
        }</span>

        <span class="cov0" title="0">return serviceInfo, nil</span>
}

// makeGRPCCall makes the actual gRPC call
func (c *Client) makeGRPCCall(ctx context.Context, conn *grpc.ClientConn, method string, request interface{}, response interface{}) error <span class="cov0" title="0">{
        // Create call context with timeout
        callCtx, cancel := context.WithTimeout(ctx, c.config.Timeout)
        defer cancel()

        // Create gRPC client
        client := rpcproto.NewGenericServiceClient(conn)

        // Convert request to Any
        var payload *anypb.Any
        if request != nil </span><span class="cov0" title="0">{
                if protoMsg, ok := request.(proto.Message); ok </span><span class="cov0" title="0">{
                        var err error
                        payload, err = anypb.New(protoMsg)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to serialize request: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // For non-proto messages, serialize as JSON
                        jsonData, err := json.Marshal(request)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to serialize request as JSON: %w", err)
                        }</span>
                        <span class="cov0" title="0">payload = &amp;anypb.Any{
                                TypeUrl: "application/json",
                                Value:   jsonData,
                        }</span>
                }
        }

        // Create gRPC request
        <span class="cov0" title="0">grpcReq := &amp;rpcproto.RPCRequest{
                Method:  method,
                Payload: payload,
        }

        // Make the call
        grpcResp, err := client.Call(callCtx, grpcReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("gRPC call failed: %w", err)
        }</span>

        // Check for error in response
        <span class="cov0" title="0">if grpcResp.Error != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service error: %s", grpcResp.Error)
        }</span>

        // Convert response from Any
        <span class="cov0" title="0">if response != nil &amp;&amp; grpcResp.Result != nil </span><span class="cov0" title="0">{
                if protoMsg, ok := response.(proto.Message); ok </span><span class="cov0" title="0">{
                        if err := grpcResp.Result.UnmarshalTo(protoMsg); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to deserialize response: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // For non-proto messages, deserialize from JSON
                        if grpcResp.Result.TypeUrl == "application/json" </span><span class="cov0" title="0">{
                                if err := json.Unmarshal(grpcResp.Result.Value, response); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to deserialize response from JSON: %w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("unsupported response type: %s", grpcResp.Result.TypeUrl)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Close closes the client and connection pool
func (c *Client) Close() error <span class="cov0" title="0">{
        return c.pool.Close()
}</span>

// HealthCheck performs a health check on the service
func (c *Client) HealthCheck(ctx context.Context) (*rpcpkg.HealthStatus, error) <span class="cov0" title="0">{
        var health rpcpkg.HealthStatus
        err := c.Call(ctx, "HealthCheck", &amp;struct{}{}, &amp;health)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;health, nil</span>
}

// GetMethods returns available methods from the service
func (c *Client) GetMethods(ctx context.Context) ([]rpcpkg.RPCMethod, error) <span class="cov0" title="0">{
        var methods []rpcpkg.RPCMethod
        err := c.Call(ctx, "GetMethods", &amp;struct{}{}, &amp;methods)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return methods, nil</span>
}
</pre>
		
		<pre class="file" id="file263" style="display: none">package client

import (
        "context"
        "fmt"
        "sync"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
)

// ConnectionPool manages a pool of gRPC connections
type ConnectionPool struct {
        address string
        maxSize int
        timeout time.Duration
        logger  logging.Logger

        connections chan *grpc.ClientConn
        mu          sync.RWMutex
        closed      bool
}

// NewConnectionPool creates a new connection pool
func NewConnectionPool(maxSize int, timeout time.Duration, logger logging.Logger) *ConnectionPool <span class="cov0" title="0">{
        return &amp;ConnectionPool{
                maxSize:     maxSize,
                timeout:     timeout,
                logger:      logger,
                connections: make(chan *grpc.ClientConn, maxSize),
        }
}</span>

// GetConnection gets a connection from the pool
func (p *ConnectionPool) GetConnection(ctx context.Context, address string) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connection pool is closed")
        }</span>

        // Update address if needed
        <span class="cov0" title="0">if p.address == "" </span><span class="cov0" title="0">{
                p.address = address
        }</span>

        // Try to get existing connection
        <span class="cov0" title="0">select </span>{
        case conn := &lt;-p.connections:<span class="cov0" title="0">
                // Test connection health
                if p.isConnectionHealthy(conn) </span><span class="cov0" title="0">{
                        return conn, nil
                }</span>
                // Connection is unhealthy, close it and create new one
                <span class="cov0" title="0">if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close connection: %v", err)
                }</span>
        default:<span class="cov0" title="0">
                // No connection available, create new one if under limit
                if len(p.connections) &lt; p.maxSize </span><span class="cov0" title="0">{
                        return p.createConnection(address)
                }</span>
        }

        // Wait for available connection
        <span class="cov0" title="0">select </span>{
        case conn := &lt;-p.connections:<span class="cov0" title="0">
                return conn, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("timeout waiting for connection: %w", ctx.Err())</span>
        }
}

// ReturnConnection returns a connection to the pool
func (p *ConnectionPool) ReturnConnection(conn *grpc.ClientConn, failed bool) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close connection: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if failed </span><span class="cov0" title="0">{
                // Connection failed, close it
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close connection: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Return connection to pool
        <span class="cov0" title="0">select </span>{
        case p.connections &lt;- conn:<span class="cov0" title="0"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full, close connection
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close connection: %v", err)
                }</span>
        }
}

// createConnection creates a new gRPC connection
func (p *ConnectionPool) createConnection(address string) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial gRPC server: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Debug("Created new gRPC connection", "address", address)
        return conn, nil</span>
}

// isConnectionHealthy checks if a connection is healthy
func (p *ConnectionPool) isConnectionHealthy(conn *grpc.ClientConn) bool <span class="cov0" title="0">{
        // Simple health check - check connection state
        state := conn.GetState()
        return state.String() == "READY"
}</span>

// Close closes the connection pool
func (p *ConnectionPool) Close() error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">p.closed = true
        close(p.connections)

        // Close all connections
        for conn := range p.connections </span><span class="cov0" title="0">{
                if err := conn.Close(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Errorf("Failed to close connection: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file264" style="display: none">package client

import (
        "context"
        "time"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
)

// RetryConfig holds retry configuration
type RetryConfig struct {
        MaxRetries     int
        InitialDelay   time.Duration
        MaxDelay       time.Duration
        BackoffFactor  float64
        JitterFactor   float64
        RetryableCodes []codes.Code
}

// DefaultRetryConfig returns default retry configuration for gRPC client
func DefaultRetryConfig() *RetryConfig <span class="cov0" title="0">{
        return &amp;RetryConfig{
                MaxRetries:    3,
                InitialDelay:  time.Second,
                MaxDelay:      10 * time.Second,
                BackoffFactor: 2.0,
                JitterFactor:  0.1,
                RetryableCodes: []codes.Code{
                        codes.Unavailable,
                        codes.DeadlineExceeded,
                        codes.ResourceExhausted,
                        codes.Aborted,
                        codes.Internal,
                },
        }
}</span>

// RetryWithBackoff retries a function with exponential backoff using the retry package
func RetryWithBackoff(ctx context.Context, fn func() error, config *RetryConfig, logger logging.Logger) error <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultRetryConfig()
        }</span>

        // Convert to the retry package config
        <span class="cov0" title="0">retryConfig := &amp;retry.RetryConfig{
                MaxRetries:      config.MaxRetries,
                InitialDelay:    config.InitialDelay,
                MaxDelay:        config.MaxDelay,
                BackoffFactor:   config.BackoffFactor,
                JitterFactor:    config.JitterFactor,
                LogRetryAttempt: true,
                ShouldRetry: func(err error) bool </span><span class="cov0" title="0">{
                        return isRetryableError(err, config.RetryableCodes)
                }</span>,
        }

        // Use the retry package
        <span class="cov0" title="0">return retry.RetryFunc(ctx, fn, retryConfig, logger)</span>
}

// isRetryableError checks if an error is retryable
func isRetryableError(err error, retryableCodes []codes.Code) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's a gRPC status error
        <span class="cov0" title="0">if st, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                for _, code := range retryableCodes </span><span class="cov0" title="0">{
                        if st.Code() == code </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // Check for connection errors
        <span class="cov0" title="0">if st, ok := status.FromError(err); ok &amp;&amp; st.Code() == codes.Canceled </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">package discovery

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/trigg3rX/triggerx-backend/pkg/client/redis"
        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/rpc"
)

// RedisRegistry implements the ServiceRegistry interface using Redis as the backend
type RedisRegistry struct {
        client     *redis.Client
        logger     logging.Logger
        config     RedisRegistryConfig
        watchers   map[string][]chan rpc.ServiceInfo
        watcherMu  sync.RWMutex
        stopChan   chan struct{}
        processMap map[string]logging.ProcessName
}

// RedisRegistryConfig holds configuration for the Redis registry
type RedisRegistryConfig struct {
        // Redis configuration
        RedisConfig redis.RedisConfig
        // Registry-specific settings
        KeyPrefix       string
        TTL             time.Duration
        RefreshInterval time.Duration
        WatchBufferSize int
        MaxRetries      int
        RetryDelay      time.Duration
}

// DefaultRedisRegistryConfig returns default configuration for Redis registry
func DefaultRedisRegistryConfig() RedisRegistryConfig <span class="cov0" title="0">{
        return RedisRegistryConfig{
                RedisConfig: redis.RedisConfig{
                        UpstashConfig: redis.UpstashConfig{
                                URL:   "", // Must be set by caller
                                Token: "", // Must be set by caller
                        },
                        ConnectionSettings: redis.ConnectionSettings{
                                PoolSize:     10,
                                MinIdleConns: 2,
                                MaxRetries:   3,
                                DialTimeout:  5 * time.Second,
                                ReadTimeout:  3 * time.Second,
                                WriteTimeout: 3 * time.Second,
                                PoolTimeout:  4 * time.Second,
                        },
                },
                KeyPrefix:       "triggerx:registry:",
                TTL:             30 * time.Second,
                RefreshInterval: 15 * time.Second,
                WatchBufferSize: 100,
                MaxRetries:      3,
                RetryDelay:      1 * time.Second,
        }
}</span>

// NewRedisRegistry creates a new Redis-based service registry
func NewRedisRegistry(logger logging.Logger, config RedisRegistryConfig) (*RedisRegistry, error) <span class="cov0" title="0">{
        if config.RedisConfig.UpstashConfig.URL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis URL is required")
        }</span>

        <span class="cov0" title="0">client, err := redis.NewRedisClient(logger, config.RedisConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Redis client: %w", err)
        }</span>

        <span class="cov0" title="0">registry := &amp;RedisRegistry{
                client:   client,
                logger:   logger,
                config:   config,
                watchers: make(map[string][]chan rpc.ServiceInfo),
                stopChan: make(chan struct{}),
                processMap: map[string]logging.ProcessName{
                        "aggregator":           logging.AggregatorProcess,
                        "dbserver":             logging.DatabaseProcess,
                        "keeper":               logging.KeeperProcess,
                        "registrar":            logging.RegistrarProcess,
                        "health":               logging.HealthProcess,
                        "taskdispatcher":       logging.TaskDispatcherProcess,
                        "taskmonitor":          logging.TaskMonitorProcess,
                        "schedulers-time":      logging.TimeSchedulerProcess,
                        "schedulers-condition": logging.ConditionSchedulerProcess,
                        "test":                 logging.TestProcess,
                },
        }

        // Start the background refresh goroutine
        go registry.refreshLoop()

        logger.Infof("Redis registry initialized with prefix: %s", config.KeyPrefix)
        return registry, nil</span>
}

// Register registers a service in the Redis registry
func (r *RedisRegistry) Register(ctx context.Context, info rpc.ServiceInfo) error <span class="cov0" title="0">{
        key := r.serviceKey(info.Name)

        // Update the last seen timestamp
        info.LastSeen = time.Now()

        // Marshal the service info to JSON
        data, err := json.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal service info: %w", err)
        }</span>

        // Store in Redis with TTL
        <span class="cov0" title="0">err = r.client.Set(ctx, key, string(data), r.config.TTL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register service in Redis: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Infof("Registered service: %s at %s:%d", info.Name, info.Address, info.Port)

        // Notify watchers
        r.notifyWatchers(info.Name, info)

        return nil</span>
}

// Deregister removes a service from the Redis registry
func (r *RedisRegistry) Deregister(ctx context.Context, name string) error <span class="cov0" title="0">{
        key := r.serviceKey(name)

        err := r.client.Del(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deregister service from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Infof("Deregistered service: %s", name)

        // Notify watchers with empty service info to indicate deregistration
        r.notifyWatchers(name, rpc.ServiceInfo{Name: name})

        return nil</span>
}

// GetService retrieves a specific service from the registry
func (r *RedisRegistry) GetService(ctx context.Context, name string) (*rpc.ServiceInfo, error) <span class="cov0" title="0">{
        key := r.serviceKey(name)

        value, exists, err := r.client.GetWithExists(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get service from Redis: %w", err)
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service not found: %s", name)
        }</span>

        <span class="cov0" title="0">var info rpc.ServiceInfo
        err = json.Unmarshal([]byte(value), &amp;info)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal service info: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;info, nil</span>
}

// ListServices retrieves all registered services
func (r *RedisRegistry) ListServices(ctx context.Context) ([]rpc.ServiceInfo, error) <span class="cov0" title="0">{
        pattern := r.config.KeyPrefix + "*"

        // Use SCAN to get all keys matching the pattern
        var services []rpc.ServiceInfo
        var cursor uint64

        for </span><span class="cov0" title="0">{
                // Note: This is a simplified implementation. In production, you might want to use
                // Redis SCAN command directly for better performance with large datasets
                keys, err := r.scanKeys(ctx, pattern, cursor, 100)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan Redis keys: %w", err)
                }</span>

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        value, exists, err := r.client.GetWithExists(ctx, key)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Warnf("Failed to get value for key %s: %v", key, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var info rpc.ServiceInfo
                        err = json.Unmarshal([]byte(value), &amp;info)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Warnf("Failed to unmarshal service info for key %s: %v", key, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">services = append(services, info)</span>
                }

                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return services, nil</span>
}

// Watch watches for changes to a specific service
func (r *RedisRegistry) Watch(ctx context.Context, name string) (&lt;-chan rpc.ServiceInfo, error) <span class="cov0" title="0">{
        r.watcherMu.Lock()
        defer r.watcherMu.Unlock()

        // Create a new channel for this watcher
        ch := make(chan rpc.ServiceInfo, r.config.WatchBufferSize)

        if r.watchers[name] == nil </span><span class="cov0" title="0">{
                r.watchers[name] = make([]chan rpc.ServiceInfo, 0)
        }</span>
        <span class="cov0" title="0">r.watchers[name] = append(r.watchers[name], ch)

        // Send initial state if service exists
        if info, err := r.GetService(ctx, name); err == nil </span><span class="cov0" title="0">{
                select </span>{
                case ch &lt;- *info:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        r.logger.Warnf("Failed to send initial state to watcher for service: %s", name)</span>
                }
        }

        <span class="cov0" title="0">r.logger.Infof("Started watching service: %s", name)
        return ch, nil</span>
}

// Close closes the registry and cleans up resources
func (r *RedisRegistry) Close() error <span class="cov0" title="0">{
        close(r.stopChan)

        // Close all watcher channels
        r.watcherMu.Lock()
        for serviceName, channels := range r.watchers </span><span class="cov0" title="0">{
                for _, ch := range channels </span><span class="cov0" title="0">{
                        close(ch)
                }</span>
                <span class="cov0" title="0">delete(r.watchers, serviceName)</span>
        }
        <span class="cov0" title="0">r.watcherMu.Unlock()

        // Close Redis client
        return r.client.Close()</span>
}

// GetProcessName returns the ProcessName for a given service name
func (r *RedisRegistry) GetProcessName(serviceName string) (logging.ProcessName, bool) <span class="cov0" title="0">{
        processName, exists := r.processMap[serviceName]
        return processName, exists
}</span>

// GetServiceHealth retrieves the health status of a service
func (r *RedisRegistry) GetServiceHealth(ctx context.Context, name string) (*rpc.HealthStatus, error) <span class="cov0" title="0">{
        info, err := r.GetService(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;info.Health, nil</span>
}

// UpdateServiceHealth updates the health status of a service
func (r *RedisRegistry) UpdateServiceHealth(ctx context.Context, name string, health rpc.HealthStatus) error <span class="cov0" title="0">{
        info, err := r.GetService(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">info.Health = health
        info.LastSeen = time.Now()

        return r.Register(ctx, *info)</span>
}

// serviceKey generates the Redis key for a service
func (r *RedisRegistry) serviceKey(name string) string <span class="cov0" title="0">{
        return r.config.KeyPrefix + name
}</span>

// notifyWatchers notifies all watchers of a service about changes
func (r *RedisRegistry) notifyWatchers(serviceName string, info rpc.ServiceInfo) <span class="cov0" title="0">{
        r.watcherMu.RLock()
        defer r.watcherMu.RUnlock()

        channels, exists := r.watchers[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, ch := range channels </span><span class="cov0" title="0">{
                select </span>{
                case ch &lt;- info:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        r.logger.Warnf("Failed to notify watcher for service: %s", serviceName)</span>
                }
        }
}

// refreshLoop runs in the background to refresh service registrations
func (r *RedisRegistry) refreshLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(r.config.RefreshInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        r.refreshServices()</span>
                case &lt;-r.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// refreshServices refreshes all service registrations to extend their TTL
func (r *RedisRegistry) refreshServices() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        services, err := r.ListServices(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Errorf("Failed to list services for refresh: %v", err)
                return
        }</span>

        <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{
                // Only refresh if the service is still healthy
                if service.Health.Status == "healthy" </span><span class="cov0" title="0">{
                        err := r.Register(ctx, service)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Warnf("Failed to refresh service %s: %v", service.Name, err)
                        }</span>
                }
        }
}

// scanKeys is a helper method to scan Redis keys (simplified implementation)
func (r *RedisRegistry) scanKeys(ctx context.Context, pattern string, cursor uint64, count int64) ([]string, error) <span class="cov0" title="0">{
        // This is a simplified implementation. In production, you would use the actual Redis SCAN command
        // For now, we'll return an empty slice as this would require direct Redis client access
        // The actual implementation would use r.client.Client().Scan(ctx, cursor, pattern, count)
        return []string{}, nil
}</span>

// HealthCheck performs a health check on the registry
func (r *RedisRegistry) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return r.client.Ping(ctx)
}</span>

// GetRegistryStats returns statistics about the registry
func (r *RedisRegistry) GetRegistryStats(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        services, err := r.ListServices(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_services": len(services),
                "services":       make(map[string]interface{}),
        }

        // Group services by health status
        healthCounts := make(map[string]int)
        for _, service := range services </span><span class="cov0" title="0">{
                healthCounts[service.Health.Status]++
                stats["services"].(map[string]interface{})[service.Name] = map[string]interface{}{
                        "address":   service.Address,
                        "port":      service.Port,
                        "health":    service.Health.Status,
                        "last_seen": service.LastSeen,
                }
        }</span>

        <span class="cov0" title="0">stats["health_counts"] = healthCounts
        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file266" style="display: none">package metrics

import (
        "sync"
        "time"
)

// InMemoryCollector is a simple thread-safe in-memory implementation of the Collector.
// Useful for development/testing or as a default no-op-ish collector.
type InMemoryCollector struct {
        mu sync.RWMutex

        requests map[string]int64
        errors   map[string]int64
        // We store basic aggregation for durations: count and total ns
        durationsCount map[string]int64
        durationsSumNs map[string]int64
}

// NewInMemoryCollector creates a new in-memory metrics collector.
func NewInMemoryCollector() *InMemoryCollector <span class="cov0" title="0">{
        return &amp;InMemoryCollector{
                requests:       make(map[string]int64),
                errors:         make(map[string]int64),
                durationsCount: make(map[string]int64),
                durationsSumNs: make(map[string]int64),
        }
}</span>

func (c *InMemoryCollector) IncRequestsTotal(service string, method string) <span class="cov0" title="0">{
        key := service + "." + method
        c.mu.Lock()
        c.requests[key]++
        c.mu.Unlock()
}</span>

func (c *InMemoryCollector) IncErrorsTotal(service string, method string) <span class="cov0" title="0">{
        key := service + "." + method
        c.mu.Lock()
        c.errors[key]++
        c.mu.Unlock()
}</span>

func (c *InMemoryCollector) ObserveRequestDuration(service string, method string, duration time.Duration) <span class="cov0" title="0">{
        key := service + "." + method
        c.mu.Lock()
        c.durationsCount[key]++
        c.durationsSumNs[key] += duration.Nanoseconds()
        c.mu.Unlock()
}</span>

// Snapshot returns a copy of current counters for external inspection.
func (c *InMemoryCollector) Snapshot() (requests map[string]int64, errors map[string]int64, durationsCount map[string]int64, durationsSumNs map[string]int64) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        req := make(map[string]int64, len(c.requests))
        err := make(map[string]int64, len(c.errors))
        dcnt := make(map[string]int64, len(c.durationsCount))
        dsum := make(map[string]int64, len(c.durationsSumNs))
        for k, v := range c.requests </span><span class="cov0" title="0">{
                req[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range c.errors </span><span class="cov0" title="0">{
                err[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range c.durationsCount </span><span class="cov0" title="0">{
                dcnt[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range c.durationsSumNs </span><span class="cov0" title="0">{
                dsum[k] = v
        }</span>
        <span class="cov0" title="0">return req, err, dcnt, dsum</span>
}
</pre>
		
		<pre class="file" id="file267" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        v6.31.1
// source: pkg/rpc/proto/service.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        anypb "google.golang.org/protobuf/types/known/anypb"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ServiceInfo represents information about an RPC service
type ServiceInfo struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
        Address       string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
        Port          int32                  `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        LastSeen      *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
        Health        *HealthStatus          `protobuf:"bytes,7,opt,name=health,proto3" json:"health,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ServiceInfo) Reset() <span class="cov0" title="0">{
        *x = ServiceInfo{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ServiceInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ServiceInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ServiceInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ServiceInfo.ProtoReflect.Descriptor instead.
func (*ServiceInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ServiceInfo) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ServiceInfo) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ServiceInfo) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ServiceInfo) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ServiceInfo) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ServiceInfo) GetLastSeen() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastSeen
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ServiceInfo) GetHealth() *HealthStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Health
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// HealthStatus represents the health status of a service
type HealthStatus struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"` // "healthy", "unhealthy", "degraded"
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Details       map[string]string      `protobuf:"bytes,4,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthStatus) Reset() <span class="cov0" title="0">{
        *x = HealthStatus{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthStatus) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthStatus) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthStatus.ProtoReflect.Descriptor instead.
func (*HealthStatus) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *HealthStatus) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthStatus) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HealthStatus) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *HealthStatus) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RPCMethod represents an RPC method definition
type RPCMethod struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Description   string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        RequestType   string                 `protobuf:"bytes,3,opt,name=request_type,json=requestType,proto3" json:"request_type,omitempty"`
        ResponseType  string                 `protobuf:"bytes,4,opt,name=response_type,json=responseType,proto3" json:"response_type,omitempty"`
        TimeoutNanos  int64                  `protobuf:"varint,5,opt,name=timeout_nanos,json=timeoutNanos,proto3" json:"timeout_nanos,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RPCMethod) Reset() <span class="cov0" title="0">{
        *x = RPCMethod{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RPCMethod) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RPCMethod) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RPCMethod) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RPCMethod.ProtoReflect.Descriptor instead.
func (*RPCMethod) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RPCMethod) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCMethod) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCMethod) GetRequestType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequestType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCMethod) GetResponseType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ResponseType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCMethod) GetTimeoutNanos() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeoutNanos
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// RPCRequest represents a generic RPC request
type RPCRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Method        string                 `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
        Payload       *anypb.Any             `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RPCRequest) Reset() <span class="cov0" title="0">{
        *x = RPCRequest{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RPCRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RPCRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RPCRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RPCRequest.ProtoReflect.Descriptor instead.
func (*RPCRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *RPCRequest) GetMethod() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Method
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCRequest) GetPayload() *anypb.Any <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RPCRequest) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RPCResponse represents a generic RPC response
type RPCResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Result        *anypb.Any             `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
        Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RPCResponse) Reset() <span class="cov0" title="0">{
        *x = RPCResponse{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RPCResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RPCResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RPCResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RPCResponse.ProtoReflect.Descriptor instead.
func (*RPCResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *RPCResponse) GetResult() *anypb.Any <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RPCResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RPCResponse) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// HealthCheckRequest represents a health check request
type HealthCheckRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Service       string                 `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckRequest) Reset() <span class="cov0" title="0">{
        *x = HealthCheckRequest{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthCheckRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheckRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *HealthCheckRequest) GetService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Service
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// HealthCheckResponse represents a health check response
type HealthCheckResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        *HealthStatus          `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckResponse) Reset() <span class="cov0" title="0">{
        *x = HealthCheckResponse{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HealthCheckResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheckResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *HealthCheckResponse) GetStatus() *HealthStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetMethodsResponse returns available RPC methods
type GetMethodsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Methods       []*RPCMethod           `protobuf:"bytes,1,rep,name=methods,proto3" json:"methods,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMethodsResponse) Reset() <span class="cov0" title="0">{
        *x = GetMethodsResponse{}
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMethodsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMethodsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMethodsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pkg_rpc_proto_service_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMethodsResponse.ProtoReflect.Descriptor instead.
func (*GetMethodsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pkg_rpc_proto_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetMethodsResponse) GetMethods() []*RPCMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Methods
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pkg_rpc_proto_service_proto protoreflect.FileDescriptor

const file_pkg_rpc_proto_service_proto_rawDesc = "" +
        "\n" +
        "\x1bpkg/rpc/proto/service.proto\x12\x03rpc\x1a\x19google/protobuf/any.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xc6\x02\n" +
        "\vServiceInfo\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
        "\aversion\x18\x02 \x01(\tR\aversion\x12\x18\n" +
        "\aaddress\x18\x03 \x01(\tR\aaddress\x12\x12\n" +
        "\x04port\x18\x04 \x01(\x05R\x04port\x12:\n" +
        "\bmetadata\x18\x05 \x03(\v2\x1e.rpc.ServiceInfo.MetadataEntryR\bmetadata\x127\n" +
        "\tlast_seen\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen\x12)\n" +
        "\x06health\x18\a \x01(\v2\x11.rpc.HealthStatusR\x06health\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf0\x01\n" +
        "\fHealthStatus\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\x128\n" +
        "\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x128\n" +
        "\adetails\x18\x04 \x03(\v2\x1e.rpc.HealthStatus.DetailsEntryR\adetails\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xae\x01\n" +
        "\tRPCMethod\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x02 \x01(\tR\vdescription\x12!\n" +
        "\frequest_type\x18\x03 \x01(\tR\vrequestType\x12#\n" +
        "\rresponse_type\x18\x04 \x01(\tR\fresponseType\x12#\n" +
        "\rtimeout_nanos\x18\x05 \x01(\x03R\ftimeoutNanos\"\xcc\x01\n" +
        "\n" +
        "RPCRequest\x12\x16\n" +
        "\x06method\x18\x01 \x01(\tR\x06method\x12.\n" +
        "\apayload\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\apayload\x129\n" +
        "\bmetadata\x18\x03 \x03(\v2\x1d.rpc.RPCRequest.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xca\x01\n" +
        "\vRPCResponse\x12,\n" +
        "\x06result\x18\x01 \x01(\v2\x14.google.protobuf.AnyR\x06result\x12\x14\n" +
        "\x05error\x18\x02 \x01(\tR\x05error\x12:\n" +
        "\bmetadata\x18\x03 \x03(\v2\x1e.rpc.RPCResponse.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\".\n" +
        "\x12HealthCheckRequest\x12\x18\n" +
        "\aservice\x18\x01 \x01(\tR\aservice\"@\n" +
        "\x13HealthCheckResponse\x12)\n" +
        "\x06status\x18\x01 \x01(\v2\x11.rpc.HealthStatusR\x06status\"&gt;\n" +
        "\x12GetMethodsResponse\x12(\n" +
        "\amethods\x18\x01 \x03(\v2\x0e.rpc.RPCMethodR\amethods2\xbc\x01\n" +
        "\x0eGenericService\x12)\n" +
        "\x04Call\x12\x0f.rpc.RPCRequest\x1a\x10.rpc.RPCResponse\x12@\n" +
        "\vHealthCheck\x12\x17.rpc.HealthCheckRequest\x1a\x18.rpc.HealthCheckResponse\x12=\n" +
        "\n" +
        "GetMethods\x12\x16.google.protobuf.Empty\x1a\x17.rpc.GetMethodsResponseB4Z2github.com/trigg3rX/triggerx-backend/pkg/rpc/protob\x06proto3"

var (
        file_pkg_rpc_proto_service_proto_rawDescOnce sync.Once
        file_pkg_rpc_proto_service_proto_rawDescData []byte
)

func file_pkg_rpc_proto_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pkg_rpc_proto_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pkg_rpc_proto_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pkg_rpc_proto_service_proto_rawDesc), len(file_pkg_rpc_proto_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_pkg_rpc_proto_service_proto_rawDescData</span>
}

var file_pkg_rpc_proto_service_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_pkg_rpc_proto_service_proto_goTypes = []any{
        (*ServiceInfo)(nil),           // 0: rpc.ServiceInfo
        (*HealthStatus)(nil),          // 1: rpc.HealthStatus
        (*RPCMethod)(nil),             // 2: rpc.RPCMethod
        (*RPCRequest)(nil),            // 3: rpc.RPCRequest
        (*RPCResponse)(nil),           // 4: rpc.RPCResponse
        (*HealthCheckRequest)(nil),    // 5: rpc.HealthCheckRequest
        (*HealthCheckResponse)(nil),   // 6: rpc.HealthCheckResponse
        (*GetMethodsResponse)(nil),    // 7: rpc.GetMethodsResponse
        nil,                           // 8: rpc.ServiceInfo.MetadataEntry
        nil,                           // 9: rpc.HealthStatus.DetailsEntry
        nil,                           // 10: rpc.RPCRequest.MetadataEntry
        nil,                           // 11: rpc.RPCResponse.MetadataEntry
        (*timestamppb.Timestamp)(nil), // 12: google.protobuf.Timestamp
        (*anypb.Any)(nil),             // 13: google.protobuf.Any
        (*emptypb.Empty)(nil),         // 14: google.protobuf.Empty
}
var file_pkg_rpc_proto_service_proto_depIdxs = []int32{
        8,  // 0: rpc.ServiceInfo.metadata:type_name -&gt; rpc.ServiceInfo.MetadataEntry
        12, // 1: rpc.ServiceInfo.last_seen:type_name -&gt; google.protobuf.Timestamp
        1,  // 2: rpc.ServiceInfo.health:type_name -&gt; rpc.HealthStatus
        12, // 3: rpc.HealthStatus.timestamp:type_name -&gt; google.protobuf.Timestamp
        9,  // 4: rpc.HealthStatus.details:type_name -&gt; rpc.HealthStatus.DetailsEntry
        13, // 5: rpc.RPCRequest.payload:type_name -&gt; google.protobuf.Any
        10, // 6: rpc.RPCRequest.metadata:type_name -&gt; rpc.RPCRequest.MetadataEntry
        13, // 7: rpc.RPCResponse.result:type_name -&gt; google.protobuf.Any
        11, // 8: rpc.RPCResponse.metadata:type_name -&gt; rpc.RPCResponse.MetadataEntry
        1,  // 9: rpc.HealthCheckResponse.status:type_name -&gt; rpc.HealthStatus
        2,  // 10: rpc.GetMethodsResponse.methods:type_name -&gt; rpc.RPCMethod
        3,  // 11: rpc.GenericService.Call:input_type -&gt; rpc.RPCRequest
        5,  // 12: rpc.GenericService.HealthCheck:input_type -&gt; rpc.HealthCheckRequest
        14, // 13: rpc.GenericService.GetMethods:input_type -&gt; google.protobuf.Empty
        4,  // 14: rpc.GenericService.Call:output_type -&gt; rpc.RPCResponse
        6,  // 15: rpc.GenericService.HealthCheck:output_type -&gt; rpc.HealthCheckResponse
        7,  // 16: rpc.GenericService.GetMethods:output_type -&gt; rpc.GetMethodsResponse
        14, // [14:17] is the sub-list for method output_type
        11, // [11:14] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_pkg_rpc_proto_service_proto_init() }</span>
func file_pkg_rpc_proto_service_proto_init() <span class="cov0" title="0">{
        if File_pkg_rpc_proto_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_pkg_rpc_proto_service_proto_rawDesc), len(file_pkg_rpc_proto_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   12,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_pkg_rpc_proto_service_proto_goTypes,
                DependencyIndexes: file_pkg_rpc_proto_service_proto_depIdxs,
                MessageInfos:      file_pkg_rpc_proto_service_proto_msgTypes,
        }.Build()
        File_pkg_rpc_proto_service_proto = out.File
        file_pkg_rpc_proto_service_proto_goTypes = nil
        file_pkg_rpc_proto_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file268" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.31.1
// source: pkg/rpc/proto/service.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        GenericService_Call_FullMethodName        = "/rpc.GenericService/Call"
        GenericService_HealthCheck_FullMethodName = "/rpc.GenericService/HealthCheck"
        GenericService_GetMethods_FullMethodName  = "/rpc.GenericService/GetMethods"
)

// GenericServiceClient is the client API for GenericService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GenericService provides a generic RPC interface
type GenericServiceClient interface {
        // Call handles generic RPC calls
        Call(ctx context.Context, in *RPCRequest, opts ...grpc.CallOption) (*RPCResponse, error)
        // HealthCheck performs a health check
        HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
        // GetMethods returns available methods
        GetMethods(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetMethodsResponse, error)
}

type genericServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewGenericServiceClient(cc grpc.ClientConnInterface) GenericServiceClient <span class="cov0" title="0">{
        return &amp;genericServiceClient{cc}
}</span>

func (c *genericServiceClient) Call(ctx context.Context, in *RPCRequest, opts ...grpc.CallOption) (*RPCResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RPCResponse)
        err := c.cc.Invoke(ctx, GenericService_Call_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *genericServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(HealthCheckResponse)
        err := c.cc.Invoke(ctx, GenericService_HealthCheck_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *genericServiceClient) GetMethods(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetMethodsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetMethodsResponse)
        err := c.cc.Invoke(ctx, GenericService_GetMethods_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GenericServiceServer is the server API for GenericService service.
// All implementations must embed UnimplementedGenericServiceServer
// for forward compatibility.
//
// GenericService provides a generic RPC interface
type GenericServiceServer interface {
        // Call handles generic RPC calls
        Call(context.Context, *RPCRequest) (*RPCResponse, error)
        // HealthCheck performs a health check
        HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
        // GetMethods returns available methods
        GetMethods(context.Context, *emptypb.Empty) (*GetMethodsResponse, error)
        mustEmbedUnimplementedGenericServiceServer()
}

// UnimplementedGenericServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGenericServiceServer struct{}

func (UnimplementedGenericServiceServer) Call(context.Context, *RPCRequest) (*RPCResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Call not implemented")
}</span>
func (UnimplementedGenericServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}</span>
func (UnimplementedGenericServiceServer) GetMethods(context.Context, *emptypb.Empty) (*GetMethodsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMethods not implemented")
}</span>
func (UnimplementedGenericServiceServer) mustEmbedUnimplementedGenericServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedGenericServiceServer) testEmbeddedByValue()                        {<span class="cov0" title="0">}</span>

// UnsafeGenericServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GenericServiceServer will
// result in compilation errors.
type UnsafeGenericServiceServer interface {
        mustEmbedUnimplementedGenericServiceServer()
}

func RegisterGenericServiceServer(s grpc.ServiceRegistrar, srv GenericServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedGenericServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;GenericService_ServiceDesc, srv)</span>
}

func _GenericService_Call_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RPCRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).Call(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GenericService_Call_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).Call(ctx, req.(*RPCRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GenericService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(HealthCheckRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).HealthCheck(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GenericService_HealthCheck_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GenericService_GetMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(emptypb.Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).GetMethods(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GenericService_GetMethods_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GenericServiceServer).GetMethods(ctx, req.(*emptypb.Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// GenericService_ServiceDesc is the grpc.ServiceDesc for GenericService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GenericService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "rpc.GenericService",
        HandlerType: (*GenericServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Call",
                        Handler:    _GenericService_Call_Handler,
                },
                {
                        MethodName: "HealthCheck",
                        Handler:    _GenericService_HealthCheck_Handler,
                },
                {
                        MethodName: "GetMethods",
                        Handler:    _GenericService_GetMethods_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "pkg/rpc/proto/service.proto",
}
</pre>
		
		<pre class="file" id="file269" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"

        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/anypb"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcpkg "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        rpcproto "github.com/trigg3rX/triggerx-backend/pkg/rpc/proto"
)

// GenericService implements the proto.GenericServiceServer interface
type GenericService struct {
        rpcproto.UnimplementedGenericServiceServer
        serviceName string
        handler     rpcpkg.RPCHandler
        logger      logging.Logger
}

// NewGenericService creates a new GenericService
func NewGenericService(serviceName string, handler rpcpkg.RPCHandler, logger logging.Logger) *GenericService <span class="cov0" title="0">{
        return &amp;GenericService{
                serviceName: serviceName,
                handler:     handler,
                logger:      logger,
        }
}</span>

// Call handles generic RPC calls
func (s *GenericService) Call(ctx context.Context, req *rpcproto.RPCRequest) (*rpcproto.RPCResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("gRPC call received",
                "service", s.serviceName,
                "method", req.Method)

        // Extract request payload
        var request interface{}
        if req.Payload != nil </span><span class="cov0" title="0">{
                if req.Payload.TypeUrl == "application/json" </span><span class="cov0" title="0">{
                        // Deserialize JSON payload
                        var jsonData map[string]interface{}
                        if err := json.Unmarshal(req.Payload.Value, &amp;jsonData); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to deserialize JSON payload",
                                        "service", s.serviceName,
                                        "method", req.Method,
                                        "error", err)
                                return &amp;rpcproto.RPCResponse{
                                        Error: fmt.Sprintf("failed to deserialize JSON payload: %v", err),
                                }, nil
                        }</span>
                        <span class="cov0" title="0">request = jsonData</span>
                } else<span class="cov0" title="0"> {
                        // For protobuf messages, pass as-is
                        request = req.Payload
                }</span>
        }

        // Call the handler
        <span class="cov0" title="0">result, err := s.handler.Handle(ctx, req.Method, request)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("gRPC call failed",
                        "service", s.serviceName,
                        "method", req.Method,
                        "error", err)

                return &amp;rpcproto.RPCResponse{
                        Error: err.Error(),
                }, nil
        }</span>

        // Convert result to Any
        <span class="cov0" title="0">var resultAny *anypb.Any
        if result != nil </span><span class="cov0" title="0">{
                if protoMsg, ok := result.(proto.Message); ok </span><span class="cov0" title="0">{
                        var err error
                        resultAny, err = anypb.New(protoMsg)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to convert result to Any",
                                        "service", s.serviceName,
                                        "method", req.Method,
                                        "error", err)
                                return &amp;rpcproto.RPCResponse{
                                        Error: fmt.Sprintf("failed to serialize result: %v", err),
                                }, nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        // For non-proto messages, serialize as JSON
                        jsonData, err := json.Marshal(result)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Failed to serialize result as JSON",
                                        "service", s.serviceName,
                                        "method", req.Method,
                                        "error", err)
                                return &amp;rpcproto.RPCResponse{
                                        Error: fmt.Sprintf("failed to serialize result as JSON: %v", err),
                                }, nil
                        }</span>
                        <span class="cov0" title="0">resultAny = &amp;anypb.Any{
                                TypeUrl: "application/json",
                                Value:   jsonData,
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Debug("gRPC call completed",
                "service", s.serviceName,
                "method", req.Method)

        return &amp;rpcproto.RPCResponse{
                Result: resultAny,
        }, nil</span>
}

// HealthCheck performs a health check
func (s *GenericService) HealthCheck(ctx context.Context, req *rpcproto.HealthCheckRequest) (*rpcproto.HealthCheckResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("Health check requested",
                "service", s.serviceName)

        // Create a simple health status
        healthStatus := &amp;rpcproto.HealthStatus{
                Status:  "healthy",
                Message: fmt.Sprintf("Service %s is healthy", s.serviceName),
        }

        return &amp;rpcproto.HealthCheckResponse{
                Status: healthStatus,
        }, nil
}</span>

// GetMethods returns available methods
func (s *GenericService) GetMethods(ctx context.Context, _ *emptypb.Empty) (*rpcproto.GetMethodsResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("Get methods requested",
                "service", s.serviceName)

        methods := s.handler.GetMethods()
        protoMethods := make([]*rpcproto.RPCMethod, len(methods))

        for i, method := range methods </span><span class="cov0" title="0">{
                protoMethods[i] = &amp;rpcproto.RPCMethod{
                        Name:         method.Name,
                        Description:  method.Description,
                        RequestType:  fmt.Sprintf("%T", method.RequestType),
                        ResponseType: fmt.Sprintf("%T", method.ResponseType),
                        TimeoutNanos: int64(method.Timeout),
                }
        }</span>

        <span class="cov0" title="0">return &amp;rpcproto.GetMethodsResponse{
                Methods: protoMethods,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file270" style="display: none">package server

import (
        "context"
        "fmt"
        "time"

        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        rpcproto "github.com/trigg3rX/triggerx-backend/pkg/rpc/proto"
)

// HealthService implements a simple health check service
type HealthService struct {
        rpcproto.UnimplementedGenericServiceServer
        logger      logging.Logger
        serviceName string
        startTime   time.Time
}

// NewHealthService creates a new health service
func NewHealthService(serviceName string, logger logging.Logger) *HealthService <span class="cov0" title="0">{
        return &amp;HealthService{
                logger:      logger,
                serviceName: serviceName,
                startTime:   time.Now(),
        }
}</span>

// HealthCheck performs a health check
func (s *HealthService) HealthCheck(ctx context.Context, req *rpcproto.HealthCheckRequest) (*rpcproto.HealthCheckResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("Health check requested",
                "service", s.serviceName,
                "requested_service", req.Service)

        // Create health status
        healthStatus := &amp;rpcproto.HealthStatus{
                Status:    "healthy",
                Message:   fmt.Sprintf("Service %s is healthy", s.serviceName),
                Timestamp: timestamppb.Now(),
                Details: map[string]string{
                        "uptime":     time.Since(s.startTime).String(),
                        "start_time": s.startTime.Format(time.RFC3339),
                },
        }

        return &amp;rpcproto.HealthCheckResponse{
                Status: healthStatus,
        }, nil
}</span>

// GetMethods returns available methods
func (s *HealthService) GetMethods(ctx context.Context, _ *emptypb.Empty) (*rpcproto.GetMethodsResponse, error) <span class="cov0" title="0">{
        s.logger.Debug("Get methods requested",
                "service", s.serviceName)

        methods := []*rpcproto.RPCMethod{
                {
                        Name:        "HealthCheck",
                        Description: "Perform a health check on the service",
                },
        }

        return &amp;rpcproto.GetMethodsResponse{
                Methods: methods,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file271" style="display: none">package server

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        metricspkg "github.com/trigg3rX/triggerx-backend/pkg/rpc/metrics"
)

// LoggingInterceptor provides request/response logging for gRPC
func LoggingInterceptor(logger logging.Logger) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()

                logger.Debug("gRPC request started",
                        "method", info.FullMethod,
                        "request", req)

                response, err := handler(ctx, req)

                duration := time.Since(start)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("gRPC request failed",
                                "method", info.FullMethod,
                                "duration", duration,
                                "error", err)
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("gRPC request completed",
                                "method", info.FullMethod,
                                "duration", duration,
                                "response", response)
                }</span>

                <span class="cov0" title="0">return response, err</span>
        }
}

// MetricsInterceptor provides metrics collection for gRPC
func MetricsInterceptor(collector metricspkg.Collector, serviceName string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                if collector == nil </span><span class="cov0" title="0">{
                        // No-op if no collector configured
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">start := time.Now()
                collector.IncRequestsTotal(serviceName, info.FullMethod)

                response, err := handler(ctx, req)

                duration := time.Since(start)
                collector.ObserveRequestDuration(serviceName, info.FullMethod, duration)
                if err != nil </span><span class="cov0" title="0">{
                        collector.IncErrorsTotal(serviceName, info.FullMethod)
                }</span>

                <span class="cov0" title="0">return response, err</span>
        }
}

// AuthInterceptor provides authentication for gRPC
func AuthInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // TODO: Add JWT authentication logic here
                // For now, just pass through
                return handler(ctx, req)
        }</span>
}

// RecoveryInterceptor provides panic recovery for gRPC
func RecoveryInterceptor(logger logging.Logger) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("gRPC panic recovered",
                                        "method", info.FullMethod,
                                        "panic", r)
                                err = status.Errorf(codes.Internal, "internal server error")
                        }</span>
                }()
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// TimeoutInterceptor provides request timeout for gRPC
func TimeoutInterceptor(timeout time.Duration) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(ctx, timeout)
                defer cancel()
                return handler(ctx, req)
        }</span>
}

// RateLimitInterceptor provides rate limiting for gRPC
func RateLimitInterceptor() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // TODO: Add rate limiting logic here
                // For now, just pass through
                return handler(ctx, req)
        }</span>
}
</pre>
		
		<pre class="file" id="file272" style="display: none">package server

import (
        "context"
        "fmt"
        "net"
        "sync"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        "github.com/trigg3rX/triggerx-backend/pkg/logging"
        "github.com/trigg3rX/triggerx-backend/pkg/retry"
        rpcpkg "github.com/trigg3rX/triggerx-backend/pkg/rpc"
        rpcproto "github.com/trigg3rX/triggerx-backend/pkg/rpc/proto"
)

// Server represents a gRPC server
type Server struct {
        config       Config
        logger       logging.Logger
        handlers     map[string]rpcpkg.RPCHandler
        interceptors []grpc.UnaryServerInterceptor
        registry     rpcpkg.ServiceRegistry

        // Server state
        grpcServer *grpc.Server
        listener   net.Listener
        isRunning  bool
        mu         sync.RWMutex

        // Service info
        serviceInfo rpcpkg.ServiceInfo
}

// Config holds server configuration
type Config struct {
        Name        string
        Version     string
        Address     string
        Port        int
        Timeout     time.Duration
        MaxRequests int
        Metadata    map[string]string
}

// NewServer creates a new gRPC server
func NewServer(config Config, logger logging.Logger) *Server <span class="cov0" title="0">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxRequests == 0 </span><span class="cov0" title="0">{
                config.MaxRequests = 1000
        }</span>

        <span class="cov0" title="0">return &amp;Server{
                config:   config,
                logger:   logger,
                handlers: make(map[string]rpcpkg.RPCHandler),
                serviceInfo: rpcpkg.ServiceInfo{
                        Name:     config.Name,
                        Version:  config.Version,
                        Address:  config.Address,
                        Port:     config.Port,
                        Metadata: config.Metadata,
                },
        }</span>
}

// RegisterHandler registers an RPC handler for a service
func (s *Server) RegisterHandler(serviceName string, handler rpcpkg.RPCHandler) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.handlers[serviceName] = handler
}</span>

// AddInterceptor adds a gRPC interceptor to the server
func (s *Server) AddInterceptor(interceptor grpc.UnaryServerInterceptor) <span class="cov0" title="0">{
        s.interceptors = append(s.interceptors, interceptor)
}</span>

// SetRegistry sets the service registry
func (s *Server) SetRegistry(registry rpcpkg.ServiceRegistry) <span class="cov0" title="0">{
        s.registry = registry
}</span>

// Start starts the gRPC server
func (s *Server) Start(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("server is already running")
        }</span>

        // Create gRPC server with interceptors
        <span class="cov0" title="0">s.grpcServer = grpc.NewServer(
                grpc.UnaryInterceptor(s.chainUnaryInterceptors()),
                grpc.MaxConcurrentStreams(uint32(s.config.MaxRequests)),
        )

        // Register handlers
        for serviceName, handler := range s.handlers </span><span class="cov0" title="0">{
                genericService := NewGenericService(serviceName, handler, s.logger)
                rpcproto.RegisterGenericServiceServer(s.grpcServer, genericService)
                s.logger.Info("Registered gRPC handler", "service", serviceName)
        }</span>

        // Enable reflection for debugging
        <span class="cov0" title="0">reflection.Register(s.grpcServer)

        // Create listener
        listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", s.config.Address, s.config.Port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create listener: %w", err)
        }</span>
        <span class="cov0" title="0">s.listener = listener

        // Update service info
        s.serviceInfo.Address = listener.Addr().String()
        s.serviceInfo.LastSeen = time.Now()

        // Register with service registry if available (with retry)
        if s.registry != nil </span><span class="cov0" title="0">{
                retryCfg := retry.DefaultRetryConfig()
                retryCfg.MaxRetries = 5
                retryCfg.InitialDelay = 500 * time.Millisecond
                retryCfg.MaxDelay = 5 * time.Second
                retryCfg.BackoffFactor = 2.0
                retryCfg.JitterFactor = 0.2
                retryCfg.LogRetryAttempt = true
                retryCfg.ShouldRetry = func(err error) bool </span><span class="cov0" title="0">{ return err != nil }</span>

                <span class="cov0" title="0">if err := retry.RetryFunc(ctx, func() error </span><span class="cov0" title="0">{
                        return s.registry.Register(ctx, s.serviceInfo)
                }</span>, retryCfg, s.logger); err != nil <span class="cov0" title="0">{
                        s.logger.Warn("Failed to register with service registry after retries", "error", err)
                }</span>
        }

        // Start server
        <span class="cov0" title="0">s.isRunning = true
        s.logger.Info("Starting gRPC server",
                "address", s.listener.Addr().String(),
                "services", len(s.handlers))

        go func() </span><span class="cov0" title="0">{
                if err := s.grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("gRPC server error", "error", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.isRunning </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.logger.Info("Stopping gRPC server")

        // Deregister from service registry (with retry)
        if s.registry != nil </span><span class="cov0" title="0">{
                retryCfg := retry.DefaultRetryConfig()
                retryCfg.MaxRetries = 3
                retryCfg.InitialDelay = 300 * time.Millisecond
                retryCfg.MaxDelay = 3 * time.Second
                retryCfg.BackoffFactor = 2.0
                retryCfg.JitterFactor = 0.2
                retryCfg.LogRetryAttempt = false
                retryCfg.ShouldRetry = func(err error) bool </span><span class="cov0" title="0">{ return err != nil }</span>

                <span class="cov0" title="0">if err := retry.RetryFunc(ctx, func() error </span><span class="cov0" title="0">{
                        return s.registry.Deregister(ctx, s.config.Name)
                }</span>, retryCfg, s.logger); err != nil <span class="cov0" title="0">{
                        s.logger.Warn("Failed to deregister from service registry after retries", "error", err)
                }</span>
        }

        // Stop gRPC server
        <span class="cov0" title="0">if s.grpcServer != nil </span><span class="cov0" title="0">{
                // Graceful shutdown
                s.grpcServer.GracefulStop()
        }</span>

        <span class="cov0" title="0">s.isRunning = false
        s.logger.Info("gRPC server stopped")
        return nil</span>
}

// chainUnaryInterceptors chains all unary interceptors
func (s *Server) chainUnaryInterceptors() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Apply interceptors in order
                for i := len(s.interceptors) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        handler = s.wrapUnaryHandler(s.interceptors[i], handler)
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// wrapUnaryHandler wraps a unary handler with an interceptor
func (s *Server) wrapUnaryHandler(interceptor grpc.UnaryServerInterceptor, handler grpc.UnaryHandler) grpc.UnaryHandler <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return interceptor(ctx, req, &amp;grpc.UnaryServerInfo{}, handler)
        }</span>
}

// GetServiceInfo returns the service information
func (s *Server) GetServiceInfo() rpcpkg.ServiceInfo <span class="cov0" title="0">{
        return s.serviceInfo
}</span>

// IsRunning returns whether the server is running
func (s *Server) IsRunning() bool <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.isRunning
}</span>
</pre>
		
		<pre class="file" id="file273" style="display: none">package tracing

import (
        "context"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// TraceInterceptor provides OpenTelemetry tracing for gRPC requests
func TraceInterceptor(serviceName string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                // Extract trace context from incoming metadata
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        md = metadata.New(nil)
                }</span>

                // Extract trace context using OpenTelemetry propagator
                <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
                ctx = propagator.Extract(ctx, MetadataTextMapCarrier(md))

                // Start a new span for this gRPC request
                tracer := otel.Tracer(serviceName)
                ctx, span := tracer.Start(ctx, info.FullMethod,
                        trace.WithSpanKind(trace.SpanKindServer),
                        trace.WithAttributes(
                                attribute.String("grpc.method", info.FullMethod),
                                attribute.String("grpc.service", serviceName),
                        ),
                )
                defer span.End()

                // Add request metadata as span attributes
                if len(md.Get("user-agent")) &gt; 0 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("grpc.user_agent", md.Get("user-agent")[0]))
                }</span>
                <span class="cov0" title="0">if len(md.Get("content-type")) &gt; 0 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("grpc.content_type", md.Get("content-type")[0]))
                }</span>

                // Process the request
                <span class="cov0" title="0">startTime := time.Now()
                resp, err := handler(ctx, req)
                duration := time.Since(startTime)

                // Set span attributes based on response
                span.SetAttributes(
                        attribute.Int64("grpc.duration_ms", duration.Milliseconds()),
                )

                // Handle errors
                if err != nil </span><span class="cov0" title="0">{
                        st, _ := status.FromError(err)
                        span.SetStatus(codes.Error, err.Error())
                        span.SetAttributes(
                                attribute.Int("grpc.status_code", int(st.Code())),
                                attribute.String("grpc.status_message", st.Message()),
                        )
                }</span> else<span class="cov0" title="0"> {
                        span.SetStatus(codes.Ok, "")
                        span.SetAttributes(attribute.Int("grpc.status_code", int(codes.Ok)))
                }</span>

                <span class="cov0" title="0">return resp, err</span>
        }
}

// TraceClientInterceptor provides OpenTelemetry tracing for gRPC client requests
func TraceClientInterceptor(serviceName string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                // Start a new span for this gRPC client request
                tracer := otel.Tracer(serviceName)
                ctx, span := tracer.Start(ctx, method,
                        trace.WithSpanKind(trace.SpanKindClient),
                        trace.WithAttributes(
                                attribute.String("grpc.method", method),
                                attribute.String("grpc.service", serviceName),
                                attribute.String("grpc.target", cc.Target()),
                        ),
                )
                defer span.End()

                // Inject trace context into outgoing metadata
                md, ok := metadata.FromOutgoingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        md = metadata.New(nil)
                }</span>

                <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
                propagator.Inject(ctx, MetadataTextMapCarrier(md))

                // Create new context with metadata
                ctx = metadata.NewOutgoingContext(ctx, md)

                // Make the gRPC call
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                duration := time.Since(startTime)

                // Set span attributes based on response
                span.SetAttributes(
                        attribute.Int64("grpc.duration_ms", duration.Milliseconds()),
                )

                // Handle errors
                if err != nil </span><span class="cov0" title="0">{
                        st, _ := status.FromError(err)
                        span.SetStatus(codes.Error, err.Error())
                        span.SetAttributes(
                                attribute.Int("grpc.status_code", int(st.Code())),
                                attribute.String("grpc.status_message", st.Message()),
                        )
                }</span> else<span class="cov0" title="0"> {
                        span.SetStatus(codes.Ok, "")
                        span.SetAttributes(attribute.Int("grpc.status_code", int(codes.Ok)))
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

// MetadataTextMapCarrier implements the OpenTelemetry TextMapCarrier interface for gRPC metadata
type MetadataTextMapCarrier metadata.MD

// Get retrieves a value from the metadata
func (m MetadataTextMapCarrier) Get(key string) string <span class="cov0" title="0">{
        values := metadata.MD(m).Get(key)
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return values[0]</span>
}

// Set sets a value in the metadata
func (m MetadataTextMapCarrier) Set(key, value string) <span class="cov0" title="0">{
        metadata.MD(m).Set(key, value)
}</span>

// Keys returns all keys in the metadata
func (m MetadataTextMapCarrier) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m))
        for k := range metadata.MD(m) </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// WithTraceContext adds trace context to gRPC metadata
func WithTraceContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                md = metadata.New(nil)
        }</span>

        <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
        propagator.Inject(ctx, MetadataTextMapCarrier(md))

        return metadata.NewOutgoingContext(ctx, md)</span>
}

// ExtractTraceContext extracts trace context from gRPC metadata
func ExtractTraceContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return ctx
        }</span>

        <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
        return propagator.Extract(ctx, MetadataTextMapCarrier(md))</span>
}
</pre>
		
		<pre class="file" id="file274" style="display: none">package tracing

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc/metadata"
)

// TraceContext represents trace context information
type TraceContext struct {
        TraceID    string            `json:"trace_id"`
        SpanID     string            `json:"span_id"`
        Attributes map[string]string `json:"attributes,omitempty"`
}

// GetTraceContext extracts trace context from the current context
func GetTraceContext(ctx context.Context) *TraceContext <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        spanContext := span.SpanContext()

        if !spanContext.HasTraceID() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">attrs := make(map[string]string)
        span.SetAttributes(
                attribute.String("trace.id", spanContext.TraceID().String()),
                attribute.String("span.id", spanContext.SpanID().String()),
        )

        return &amp;TraceContext{
                TraceID:    spanContext.TraceID().String(),
                SpanID:     spanContext.SpanID().String(),
                Attributes: attrs,
        }</span>
}

// SetTraceContext sets trace context in the current context
func SetTraceContext(ctx context.Context, traceCtx *TraceContext) context.Context <span class="cov0" title="0">{
        if traceCtx == nil </span><span class="cov0" title="0">{
                return ctx
        }</span>

        // Create a new span with the provided trace context
        <span class="cov0" title="0">tracer := otel.Tracer("triggerx-backend")
        ctx, span := tracer.Start(ctx, "trace-context",
                trace.WithAttributes(
                        attribute.String("trace.id", traceCtx.TraceID),
                        attribute.String("span.id", traceCtx.SpanID),
                ),
        )
        defer span.End()

        // Add custom attributes
        for key, value := range traceCtx.Attributes </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String(key, value))
        }</span>

        <span class="cov0" title="0">return ctx</span>
}

// InjectTraceContext injects trace context into gRPC metadata
func InjectTraceContext(ctx context.Context) (context.Context, error) <span class="cov0" title="0">{
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                md = metadata.New(nil)
        }</span>

        // Get the current trace context
        <span class="cov0" title="0">traceCtx := GetTraceContext(ctx)
        if traceCtx != nil </span><span class="cov0" title="0">{
                md.Set("x-trace-id", traceCtx.TraceID)
                md.Set("x-span-id", traceCtx.SpanID)
        }</span>

        // Use OpenTelemetry propagator to inject trace context
        <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
        propagator.Inject(ctx, MetadataTextMapCarrier(md))

        return metadata.NewOutgoingContext(ctx, md), nil</span>
}

// ExtractTraceContextFromMetadata extracts trace context from gRPC metadata
func ExtractTraceContextFromMetadata(ctx context.Context) context.Context <span class="cov0" title="0">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return ctx
        }</span>

        // Extract trace context from metadata
        <span class="cov0" title="0">traceID := ""
        spanID := ""

        if values := md.Get("x-trace-id"); len(values) &gt; 0 </span><span class="cov0" title="0">{
                traceID = values[0]
        }</span>
        <span class="cov0" title="0">if values := md.Get("x-span-id"); len(values) &gt; 0 </span><span class="cov0" title="0">{
                spanID = values[0]
        }</span>

        // Use OpenTelemetry propagator to extract trace context
        <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
        ctx = propagator.Extract(ctx, MetadataTextMapCarrier(md))

        // If we have trace context, create a new span
        if traceID != "" </span><span class="cov0" title="0">{
                tracer := otel.Tracer("triggerx-backend")
                newCtx, span := tracer.Start(ctx, "extracted-trace",
                        trace.WithAttributes(
                                attribute.String("trace.id", traceID),
                                attribute.String("span.id", spanID),
                        ),
                )
                defer span.End()
                return newCtx
        }</span>

        <span class="cov0" title="0">return ctx</span>
}

// CreateChildSpan creates a child span from the current context
func CreateChildSpan(ctx context.Context, operationName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        tracer := otel.Tracer("triggerx-backend")
        ctx, span := tracer.Start(ctx, operationName,
                trace.WithAttributes(attributes...),
        )
        return ctx, span
}</span>

// AddSpanEvent adds an event to the current span
func AddSpanEvent(ctx context.Context, name string, attributes ...attribute.KeyValue) <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        span.AddEvent(name, trace.WithAttributes(attributes...))
}</span>

// SetSpanAttributes sets attributes on the current span
func SetSpanAttributes(ctx context.Context, attributes ...attribute.KeyValue) <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        span.SetAttributes(attributes...)
}</span>

// RecordSpanError records an error on the current span
func RecordSpanError(ctx context.Context, err error, attributes ...attribute.KeyValue) <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        span.RecordError(err, trace.WithAttributes(attributes...))
        span.SetStatus(codes.Error, err.Error())
}</span>

// GetTraceIDFromContext extracts trace ID from context
func GetTraceIDFromContext(ctx context.Context) string <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        spanContext := span.SpanContext()
        if spanContext.HasTraceID() </span><span class="cov0" title="0">{
                return spanContext.TraceID().String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetSpanIDFromContext extracts span ID from context
func GetSpanIDFromContext(ctx context.Context) string <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        spanContext := span.SpanContext()
        if spanContext.HasSpanID() </span><span class="cov0" title="0">{
                return spanContext.SpanID().String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IsSampled checks if the current span is sampled
func IsSampled(ctx context.Context) bool <span class="cov0" title="0">{
        span := trace.SpanFromContext(ctx)
        spanContext := span.SpanContext()
        return spanContext.TraceFlags().IsSampled()
}</span>

// FormatTraceContext formats trace context for logging
func FormatTraceContext(ctx context.Context) string <span class="cov0" title="0">{
        traceID := GetTraceIDFromContext(ctx)
        spanID := GetSpanIDFromContext(ctx)

        if traceID == "" </span><span class="cov0" title="0">{
                return "no-trace"
        }</span>

        <span class="cov0" title="0">if spanID == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("trace_id=%s", traceID)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("trace_id=%s,span_id=%s", traceID, spanID)</span>
}

// CreateContextWithTrace creates a new context with trace information
func CreateContextWithTrace(parent context.Context, traceID, spanID string) context.Context <span class="cov0" title="0">{
        if traceID == "" </span><span class="cov0" title="0">{
                return parent
        }</span>

        <span class="cov0" title="0">tracer := otel.Tracer("triggerx-backend")
        ctx, span := tracer.Start(parent, "with-trace-context",
                trace.WithAttributes(
                        attribute.String("trace.id", traceID),
                        attribute.String("span.id", spanID),
                ),
        )
        defer span.End()

        return ctx</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
